<!DOCTYPE html>
<html lang="en">
    <head>
        <title>SuperSplat Viewer</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
        <base href="">
        <style>
            * {
                margin: 0;
                padding: 0;
                touch-action: none;
            }
            body {
                overflow: hidden;
                font-family: 'Arial', sans-serif;
                user-select: none;
                -webkit-user-select: none;
                -webkit-touch-callout: none;
            }
            .hidden {
                display: none !important;
            }
            #ui {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
            }
            #ui * {
                pointer-events: auto;
            }
            #infoPanel {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.3);
            }
            #infoPanel > #infoPanelContent {
                position: absolute;
                top: 40px;
                left: 50%;
                transform: translate(-50%, 0);
                min-height: 280px;
                min-width: 320px;
                padding: 8px;
                border-radius: 24px;
                color: black;
                background-color: #eeed;
                display: flex;
                flex-direction: column;
            }
            #infoPanel > #infoPanelContent > #header {
                font-size: 24px;
                font-weight: bold;
                padding-bottom: 16px;
                color: #444;
                display: none;
            }
            #infoPanel > #infoPanelContent > #tabs {
                display: flex;
                gap: 16px;
                background-color: #666;
                padding: 8px;
                border-radius: 22px;
            }
            #infoPanel > #infoPanelContent > #tabs > .tab {
                padding: 8px;
                border-radius: 16px;
                cursor: pointer;
                flex-grow: 1;
                text-align: center;
                font-weight: bold;
                font-size: 14px;
                color: #222;
                transition: background-color 250ms ease;
            }
            #infoPanel > #infoPanelContent > #tabs > .tab:hover {
                background-color: #eee;
            }
            #infoPanel > #infoPanelContent > #tabs > .tab.active {
                background-color: #eee;
            }
            #infoPanel > #infoPanelContent > #infoPanels {
                padding: 16px;
            }
            #infoPanel > #infoPanelContent .control-item {
                display: flex;
                justify-content: space-between;
                gap: 32px;
                line-height: 1.5;
            }
            #infoPanel > #infoPanelContent > #infoPanels h1 {
                font-size: 14px;
                font-weight: bold;
                padding: 0 0 6px 0;
            }
            #infoPanel > #infoPanelContent .control-item > .control-action {
                text-align: left;
                color: #333;
            }
            #infoPanel > #infoPanelContent .control-item > .control-key {
                text-align: right;
                color: #666;
            }
            #infoPanel > #infoPanelContent .control-spacer {
                border-bottom: 1px dashed #666;
                margin: 10px 0;
            }
            
            /* loadingWrap */
            
            #loadingWrap {
                position: fixed;
                bottom: 120px;
                left: 50%;
                transform: translate(-50%, 0);
                width: 380px;
            
                display: flex;
                flex-direction: column;
            
                padding: 16px;
            }
            #loadingWrap > #loadingText {
                font-size: 18px;
                color: white;
                text-align: center;
                text-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
            }
            #loadingWrap > #loadingBar {
                width: 100%;
                height: 10px;
                margin-top: 8px;
                border-radius: 4px;
                overflow: hidden;
            }
            
            /* controlsWrap */
            
            #controlsWrap {
                position: absolute;
                left: max(16px, env(safe-area-inset-left));
                right: max(16px, env(safe-area-inset-right));
                bottom: max(16px, env(safe-area-inset-bottom));
            
                display: flex;
                flex-direction: column;
            }
            
            #controlsWrap.faded-in {
                visibility: visible;
                opacity: 1;
                transition: opacity 0.5s ease-out;
            }
            #controlsWrap.faded-out {
                visibility: hidden;
                opacity: 0;
                transition: visibility 0s 0.5s, opacity 0.5s ease-out;
            }
            
            #controlsWrap > #timelineContainer {
                height: 30px;
                cursor: pointer;
            }
            #controlsWrap > #timelineContainer > #line {
                width: 100%;
                height: 50%;
                border-bottom: 1px solid #8888;
            }
            #controlsWrap > #timelineContainer > #handle {
                position: absolute;
                top: 15.5px;
                width: 10px;
                height: 10px;
                transform: translate(-50%, -50%);
                border: 1px solid black;
                border-radius: 50%;
                background-color: #fff8;
            }
            #controlsWrap > #timelineContainer > #time {
                position: absolute;
                top: 0;
                padding: 2px 4px;
                transform: translate(-50%, -100%);
                font-size: 12px;
                color: white;
                background-color: rgba(0, 0, 0, 0.5);
                border-radius: 4px;
            }
            #controlsWrap > #buttonContainer {
                display: flex;
                gap: 8px;
            }
            
            /* spacer */
            
            .spacer {
                flex-grow: 1;
            }
            
            /* settingsPanel */
            
            #settingsPanel {
                position: fixed;
                right: max(16px, env(safe-area-inset-right));
                bottom: calc(max(16px, env(safe-area-inset-bottom)) + 70px);
                padding: 10px;
                color: #eee;
                background-color: rgba(0, 0, 0, 0.3);
                border-radius: 8px;
            
                display: flex;
                flex-direction: column;
                align-items: flex-end;
                gap: 4px;
            
                font-size: 14px;
            }
            #settingsPanel > .settingsRow {
                display: flex;
                gap: 4px;
                width: 100%;
                
            }
            #settingsPanel > .settingsRow > .button {
                padding: 10px 0px;
                flex-grow: 1;
            }
            
            /* toggleWrap */
            
            .toggleWrap {
                position: relative;
                background-color: #dddd;
                border: 1px solid #888;
                border-radius: 8px;
                height: 40px;
                width: 120px;
            }
            .toggleWrap > .toggleHighlight {
                position: absolute;
                left: 0;
                width: 50%;
                height: 100%;
                background-color: #eee;
                border-radius: 8px;
                transition: left 0.1s ease-out;
            }
            .toggleWrap > .toggleHighlight.right {
                left: 60px;
            }
            .toggleWrap > button {
                position: absolute;
                width: 60px;
                height: 100%;
                border: 0;
                border-radius: 8px;
            
                cursor: pointer;
                font-size: 14px;
                letter-spacing: -0.25px;
            
                color: #222;
                background-color: transparent;
            
                appearance: none;
            }
            .toggleWrap > button:hover {
                color: black;
            }
            .toggleWrap > button.left {
                left: 0;
            }
            .toggleWrap > button.right {
                right: 0;
            }
            
            /* button */
            .button {
                width: 40px;
                height: 40px;
                padding: 0;
                margin: 0;
                color: #222;
                background-color: #dddd;
                border: 1px solid #888;
                border-radius: 8px;
                cursor: pointer;
            
                /* font-weight: bold; */
                font-size: 14px;
                letter-spacing: -0.25px;
            }
            .button:hover {
                background-color: #eee;
            }
            .button > svg {
                display: block;
                margin: auto;
            }
            #poster {
                display: none;
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-size: cover;
                background-position: center;
                background-repeat: no-repeat;
            }
            button {
                color: #222;
            }
            button:active {
                outline: none;
            }
            #joystickBase {
                position: absolute;
                width: 96px;
                height: 96px;
                transform: translate(-50%, -50%);
                border-radius: 50%;
                touch-action: none;
            
                background: radial-gradient(circle at center, #0000 50%, #000f 100%);
                background-color: #0002;
            }
            
            #joystickBase > #joystick {
                position: absolute;
                width: 48px;
                height: 48px;
                transform: translate(-50%, -50%);
                border-radius: 50%;
                touch-action: none;
            
                background-color: #fff8;
            }
        </style>
        <script type="module">
            const url = new URL(location.href);
            const settingsUrl = url.searchParams.has('settings') ? url.searchParams.get('settings') : './settings.json';
            const contentUrl = url.searchParams.has('content') ? url.searchParams.get('content') : './scene.compressed.ply';
            window.sse = {
                settings: {"camera":{"fov":50,"position":[-0.0007490462157875299,-5.904026031494141,0.8610763549804688],"target":[-0.00023445165101286492,-1.5044616828853081,0.26951710782937405],"startAnim":"animTrack","animTrack":"cameraAnim"},"background":{"color":[0.4,0.4,0.4]},"animTracks":[{"name":"cameraAnim","duration":6,"frameRate":30,"target":"camera","loopMode":"repeat","interpolation":"spline","keyframes":{"times":[0,36,60],"values":{"position":[-0.0033458059187978506,-3.915705442428589,0.45567870140075684,-0.0033458059187978506,-3.915705442428589,0.45567870140075684,-0.0033458059187978506,-3.915705442428589,0.45567870140075684],"target":[0,0.5,0,0,0.5,0,0,0.5,0]}}}]},
                contentUrl,
                contents: fetch("data:application/ply;base64,cGx5CmZvcm1hdCBiaW5hcnlfbGl0dGxlX2VuZGlhbiAxLjAKY29tbWVudCBHZW5lcmF0ZWQgYnkgU3VwZXJTcGxhdCAyLjYuMgplbGVtZW50IGNodW5rIDY0CnByb3BlcnR5IGZsb2F0IG1pbl94CnByb3BlcnR5IGZsb2F0IG1pbl95CnByb3BlcnR5IGZsb2F0IG1pbl96CnByb3BlcnR5IGZsb2F0IG1heF94CnByb3BlcnR5IGZsb2F0IG1heF95CnByb3BlcnR5IGZsb2F0IG1heF96CnByb3BlcnR5IGZsb2F0IG1pbl9zY2FsZV94CnByb3BlcnR5IGZsb2F0IG1pbl9zY2FsZV95CnByb3BlcnR5IGZsb2F0IG1pbl9zY2FsZV96CnByb3BlcnR5IGZsb2F0IG1heF9zY2FsZV94CnByb3BlcnR5IGZsb2F0IG1heF9zY2FsZV95CnByb3BlcnR5IGZsb2F0IG1heF9zY2FsZV96CnByb3BlcnR5IGZsb2F0IG1pbl9yCnByb3BlcnR5IGZsb2F0IG1pbl9nCnByb3BlcnR5IGZsb2F0IG1pbl9iCnByb3BlcnR5IGZsb2F0IG1heF9yCnByb3BlcnR5IGZsb2F0IG1heF9nCnByb3BlcnR5IGZsb2F0IG1heF9iCmVsZW1lbnQgdmVydGV4IDE2Mzg0CnByb3BlcnR5IHVpbnQgcGFja2VkX3Bvc2l0aW9uCnByb3BlcnR5IHVpbnQgcGFja2VkX3JvdGF0aW9uCnByb3BlcnR5IHVpbnQgcGFja2VkX3NjYWxlCnByb3BlcnR5IHVpbnQgcGFja2VkX2NvbG9yCmVuZF9oZWFkZXIK9c+4vs22lL78Jmu/rn4dvpVXJr1ffTa/cRQ4wXieQMEVzizBA2tawKEJU8AlnlbAP/O7vBpIybzZ4be73UQAQDEl8T/tkfs/BqZ3vhB9hb60WG6/+Z8Pvjjj+TxTRPS+cPtDwVZ9T8G4PDbBA2tawKEJU8AlnlbAqm8ovOOLj7zrcOa757H7P2uZ3D+fdNc/N2RivklfPr7umG+/aeNDvd0hqD32kQW/1LMpwSdpPMF6NUjBA2tawKEJU8AlnlbA7IpNvOSvs7x99dq7VmUHQMTg3z/SyvA/R+Dlvlsd/L3FjWS/1y5DvGi8FT71PeK9pIAtwRixLMH8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"),
                params: {}
            };
        </script>
        <script type="module">
            var TRACEID_GPU_TIMINGS = 'GpuTimings';
            
            var version = '2.7.3';
            var revision = '03a9f12';
            function extend(target, ex) {
            		for(var prop in ex){
            				var copy = ex[prop];
            				if (Array.isArray(copy)) {
            						target[prop] = extend([], copy);
            				} else if (copy && typeof copy === 'object') {
            						target[prop] = extend({}, copy);
            				} else {
            						target[prop] = copy;
            				}
            		}
            		return target;
            }
            
            var guid = {
            		create () {
            				return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c)=>{
            						var r = Math.random() * 16 | 0;
            						var v = c === 'x' ? r : r & 0x3 | 0x8;
            						return v.toString(16);
            				});
            		}
            };
            
            var path = {
            		delimiter: '/',
            		join () {
            				for(var _len = arguments.length, sections = new Array(_len), _key = 0; _key < _len; _key++){
            						sections[_key] = arguments[_key];
            				}
            				var result = sections[0];
            				for(var i = 0; i < sections.length - 1; i++){
            						var one = sections[i];
            						var two = sections[i + 1];
            						if (two[0] === path.delimiter) {
            								result = two;
            								continue;
            						}
            						if (one && two && one[one.length - 1] !== path.delimiter && two[0] !== path.delimiter) {
            								result += path.delimiter + two;
            						} else {
            								result += two;
            						}
            				}
            				return result;
            		},
            		normalize (pathname) {
            				var lead = pathname.startsWith(path.delimiter);
            				var trail = pathname.endsWith(path.delimiter);
            				var parts = pathname.split('/');
            				var result = '';
            				var cleaned = [];
            				for(var i = 0; i < parts.length; i++){
            						if (parts[i] === '') continue;
            						if (parts[i] === '.') continue;
            						if (parts[i] === '..' && cleaned.length > 0) {
            								cleaned = cleaned.slice(0, cleaned.length - 2);
            								continue;
            						}
            						if (i > 0) cleaned.push(path.delimiter);
            						cleaned.push(parts[i]);
            				}
            				result = cleaned.join('');
            				if (!lead && result[0] === path.delimiter) {
            						result = result.slice(1);
            				}
            				if (trail && result[result.length - 1] !== path.delimiter) {
            						result += path.delimiter;
            				}
            				return result;
            		},
            		split (pathname) {
            				var lastDelimiterIndex = pathname.lastIndexOf(path.delimiter);
            				if (lastDelimiterIndex !== -1) {
            						return [
            								pathname.substring(0, lastDelimiterIndex),
            								pathname.substring(lastDelimiterIndex + 1)
            						];
            				}
            				return [
            						'',
            						pathname
            				];
            		},
            		getBasename (pathname) {
            				return path.split(pathname)[1];
            		},
            		getDirectory (pathname) {
            				return path.split(pathname)[0];
            		},
            		getExtension (pathname) {
            				var ext = pathname.split('?')[0].split('.').pop();
            				if (ext !== pathname) {
            						return "." + ext;
            				}
            				return '';
            		},
            		isRelativePath (pathname) {
            				return pathname.charAt(0) !== '/' && pathname.match(/:\/\//) === null;
            		},
            		extractPath (pathname) {
            				var result = '';
            				var parts = pathname.split('/');
            				var i = 0;
            				if (parts.length > 1) {
            						if (path.isRelativePath(pathname)) {
            								if (parts[0] === '.') {
            										for(i = 0; i < parts.length - 1; ++i){
            												result += i === 0 ? parts[i] : "/" + parts[i];
            										}
            								} else if (parts[0] === '..') {
            										for(i = 0; i < parts.length - 1; ++i){
            												result += i === 0 ? parts[i] : "/" + parts[i];
            										}
            								} else {
            										result = '.';
            										for(i = 0; i < parts.length - 1; ++i){
            												result += "/" + parts[i];
            										}
            								}
            						} else {
            								for(i = 0; i < parts.length - 1; ++i){
            										result += i === 0 ? parts[i] : "/" + parts[i];
            								}
            						}
            				}
            				return result;
            		}
            };
            
            var detectPassiveEvents = ()=>{
            		var result = false;
            		try {
            				var opts = Object.defineProperty({}, 'passive', {
            						get: function get() {
            								result = true;
            								return false;
            						}
            				});
            				window.addEventListener('testpassive', null, opts);
            				window.removeEventListener('testpassive', null, opts);
            		} catch (e) {}
            		return result;
            };
            var ua = typeof navigator !== 'undefined' ? navigator.userAgent : '';
            var environment = typeof window !== 'undefined' ? 'browser' : typeof global !== 'undefined' ? 'node' : 'worker';
            var platformName = /android/i.test(ua) ? 'android' : /ip(?:[ao]d|hone)/i.test(ua) ? 'ios' : /windows/i.test(ua) ? 'windows' : /mac os/i.test(ua) ? 'osx' : /linux/i.test(ua) ? 'linux' : /cros/i.test(ua) ? 'cros' : null;
            var browserName = environment !== 'browser' ? null : /Chrome\/|Chromium\/|Edg.*\//.test(ua) ? 'chrome' : /Safari\//.test(ua) ? 'safari' : /Firefox\//.test(ua) ? 'firefox' : 'other';
            var touch = environment === 'browser' && ('ontouchstart' in window || 'maxTouchPoints' in navigator && navigator.maxTouchPoints > 0);
            var passiveEvents = detectPassiveEvents();
            var platform = {
            		name: platformName,
            		browser: environment === 'browser',
            		worker: environment === 'worker',
            		android: platformName === 'android',
            		touch: touch,
            		passiveEvents: passiveEvents,
            		browserName: browserName
            };
            
            var ASCII_LOWERCASE = 'abcdefghijklmnopqrstuvwxyz';
            var ASCII_UPPERCASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            var ASCII_LETTERS = ASCII_LOWERCASE + ASCII_UPPERCASE;
            var HIGH_SURROGATE_BEGIN = 0xD800;
            var HIGH_SURROGATE_END = 0xDBFF;
            var LOW_SURROGATE_BEGIN = 0xDC00;
            var LOW_SURROGATE_END = 0xDFFF;
            var ZERO_WIDTH_JOINER = 0x200D;
            var REGIONAL_INDICATOR_BEGIN = 0x1F1E6;
            var REGIONAL_INDICATOR_END = 0x1F1FF;
            var FITZPATRICK_MODIFIER_BEGIN = 0x1F3FB;
            var FITZPATRICK_MODIFIER_END = 0x1F3FF;
            var DIACRITICAL_MARKS_BEGIN = 0x20D0;
            var DIACRITICAL_MARKS_END = 0x20FF;
            var VARIATION_MODIFIER_BEGIN = 0xFE00;
            var VARIATION_MODIFIER_END = 0xFE0F;
            function getCodePointData(string, i) {
            		if (i === void 0) i = 0;
            		var size = string.length;
            		if (i < 0 || i >= size) {
            				return null;
            		}
            		var first = string.charCodeAt(i);
            		if (size > 1 && first >= HIGH_SURROGATE_BEGIN && first <= HIGH_SURROGATE_END) {
            				var second = string.charCodeAt(i + 1);
            				if (second >= LOW_SURROGATE_BEGIN && second <= LOW_SURROGATE_END) {
            						return {
            								code: (first - HIGH_SURROGATE_BEGIN) * 0x400 + second - LOW_SURROGATE_BEGIN + 0x10000,
            								long: true
            						};
            				}
            		}
            		return {
            				code: first,
            				long: false
            		};
            }
            function isCodeBetween(string, begin, end) {
            		if (!string) {
            				return false;
            		}
            		var codeData = getCodePointData(string);
            		if (codeData) {
            				var code = codeData.code;
            				return code >= begin && code <= end;
            		}
            		return false;
            }
            function numCharsToTakeForNextSymbol(string, index) {
            		if (index === string.length - 1) {
            				return 1;
            		}
            		if (isCodeBetween(string[index], HIGH_SURROGATE_BEGIN, HIGH_SURROGATE_END)) {
            				var first = string.substring(index, index + 2);
            				var second = string.substring(index + 2, index + 4);
            				if (isCodeBetween(second, FITZPATRICK_MODIFIER_BEGIN, FITZPATRICK_MODIFIER_END) || isCodeBetween(first, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END) && isCodeBetween(second, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END)) {
            						return 4;
            				}
            				if (isCodeBetween(second, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
            						return 3;
            				}
            				return 2;
            		}
            		if (isCodeBetween(string[index + 1], VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
            				return 2;
            		}
            		return 1;
            }
            var string = {
            		ASCII_LOWERCASE: ASCII_LOWERCASE,
            		ASCII_UPPERCASE: ASCII_UPPERCASE,
            		ASCII_LETTERS: ASCII_LETTERS,
            		format (s) {
            				for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
            						args[_key - 1] = arguments[_key];
            				}
            				for(var i = 0; i < args.length; i++){
            						s = s.replace("{" + i + "}", args[i]);
            				}
            				return s;
            		},
            		getCodePoint (string, i) {
            				var codePointData = getCodePointData(string, i);
            				return codePointData && codePointData.code;
            		},
            		getCodePoints (string) {
            				if (typeof string !== 'string') {
            						throw new TypeError('Not a string');
            				}
            				var i = 0;
            				var arr = [];
            				var codePoint;
            				while(!!(codePoint = getCodePointData(string, i))){
            						arr.push(codePoint.code);
            						i += codePoint.long ? 2 : 1;
            				}
            				return arr;
            		},
            		getSymbols (string) {
            				if (typeof string !== 'string') {
            						throw new TypeError('Not a string');
            				}
            				var index = 0;
            				var length = string.length;
            				var output = [];
            				var take = 0;
            				var ch;
            				while(index < length){
            						take += numCharsToTakeForNextSymbol(string, index + take);
            						ch = string[index + take];
            						if (isCodeBetween(ch, DIACRITICAL_MARKS_BEGIN, DIACRITICAL_MARKS_END)) {
            								ch = string[index + take++];
            						}
            						if (isCodeBetween(ch, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {
            								ch = string[index + take++];
            						}
            						if (ch && ch.charCodeAt(0) === ZERO_WIDTH_JOINER) {
            								ch = string[index + take++];
            								continue;
            						}
            						var char = string.substring(index, index + take);
            						output.push(char);
            						index += take;
            						take = 0;
            				}
            				return output;
            		},
            		fromCodePoint () {
            				var chars = [];
            				var current;
            				var codePoint;
            				var units;
            				for(var i = 0; i < arguments.length; ++i){
            						current = Number(arguments[i]);
            						codePoint = current - 0x10000;
            						units = current > 0xFFFF ? [
            								(codePoint >> 10) + 0xD800,
            								codePoint % 0x400 + 0xDC00
            						] : [
            								current
            						];
            						chars.push(String.fromCharCode.apply(null, units));
            				}
            				return chars.join('');
            		}
            };
            
            class EventHandle {
            		off() {
            				if (this._removed) return;
            				this.handler.offByHandle(this);
            		}
            		on(name, callback, scope) {
            				if (scope === void 0) scope = this;
            				return this.handler._addCallback(name, callback, scope, false);
            		}
            		once(name, callback, scope) {
            				if (scope === void 0) scope = this;
            				return this.handler._addCallback(name, callback, scope, true);
            		}
            		set removed(value) {
            				if (!value) return;
            				this._removed = true;
            		}
            		get removed() {
            				return this._removed;
            		}
            		constructor(handler, name, callback, scope, once = false){
            				this._removed = false;
            				this.handler = handler;
            				this.name = name;
            				this.callback = callback;
            				this.scope = scope;
            				this._once = once;
            		}
            }
            
            class EventHandler {
            		initEventHandler() {
            				this._callbacks = new Map();
            				this._callbackActive = new Map();
            		}
            		_addCallback(name, callback, scope, once) {
            				if (!this._callbacks.has(name)) {
            						this._callbacks.set(name, []);
            				}
            				if (this._callbackActive.has(name)) {
            						var callbackActive = this._callbackActive.get(name);
            						if (callbackActive && callbackActive === this._callbacks.get(name)) {
            								this._callbackActive.set(name, callbackActive.slice());
            						}
            				}
            				var evt = new EventHandle(this, name, callback, scope, once);
            				this._callbacks.get(name).push(evt);
            				return evt;
            		}
            		on(name, callback, scope) {
            				if (scope === void 0) scope = this;
            				return this._addCallback(name, callback, scope, false);
            		}
            		once(name, callback, scope) {
            				if (scope === void 0) scope = this;
            				return this._addCallback(name, callback, scope, true);
            		}
            		off(name, callback, scope) {
            				if (name) {
            						if (this._callbackActive.has(name) && this._callbackActive.get(name) === this._callbacks.get(name)) {
            								this._callbackActive.set(name, this._callbackActive.get(name).slice());
            						}
            				} else {
            						for (var [key, callbacks] of this._callbackActive){
            								if (!this._callbacks.has(key)) {
            										continue;
            								}
            								if (this._callbacks.get(key) !== callbacks) {
            										continue;
            								}
            								this._callbackActive.set(key, callbacks.slice());
            						}
            				}
            				if (!name) {
            						for (var callbacks1 of this._callbacks.values()){
            								for(var i = 0; i < callbacks1.length; i++){
            										callbacks1[i].removed = true;
            								}
            						}
            						this._callbacks.clear();
            				} else if (!callback) {
            						var callbacks2 = this._callbacks.get(name);
            						if (callbacks2) {
            								for(var i1 = 0; i1 < callbacks2.length; i1++){
            										callbacks2[i1].removed = true;
            								}
            								this._callbacks.delete(name);
            						}
            				} else {
            						var callbacks3 = this._callbacks.get(name);
            						if (!callbacks3) {
            								return this;
            						}
            						for(var i2 = 0; i2 < callbacks3.length; i2++){
            								if (callbacks3[i2].callback !== callback) {
            										continue;
            								}
            								if (scope && callbacks3[i2].scope !== scope) {
            										continue;
            								}
            								callbacks3[i2].removed = true;
            								callbacks3.splice(i2, 1);
            								i2--;
            						}
            						if (callbacks3.length === 0) {
            								this._callbacks.delete(name);
            						}
            				}
            				return this;
            		}
            		offByHandle(handle) {
            				var name = handle.name;
            				handle.removed = true;
            				if (this._callbackActive.has(name) && this._callbackActive.get(name) === this._callbacks.get(name)) {
            						this._callbackActive.set(name, this._callbackActive.get(name).slice());
            				}
            				var callbacks = this._callbacks.get(name);
            				if (!callbacks) {
            						return this;
            				}
            				var ind = callbacks.indexOf(handle);
            				if (ind !== -1) {
            						callbacks.splice(ind, 1);
            						if (callbacks.length === 0) {
            								this._callbacks.delete(name);
            						}
            				}
            				return this;
            		}
            		fire(name, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {
            				if (!name) {
            						return this;
            				}
            				var callbacksInitial = this._callbacks.get(name);
            				if (!callbacksInitial) {
            						return this;
            				}
            				var callbacks;
            				if (!this._callbackActive.has(name)) {
            						this._callbackActive.set(name, callbacksInitial);
            				} else if (this._callbackActive.get(name) !== callbacksInitial) {
            						callbacks = callbacksInitial.slice();
            				}
            				for(var i = 0; (callbacks || this._callbackActive.get(name)) && i < (callbacks || this._callbackActive.get(name)).length; i++){
            						var evt = (callbacks || this._callbackActive.get(name))[i];
            						if (!evt.callback) continue;
            						evt.callback.call(evt.scope, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
            						if (evt._once) {
            								var existingCallback = this._callbacks.get(name);
            								var ind = existingCallback ? existingCallback.indexOf(evt) : -1;
            								if (ind !== -1) {
            										if (this._callbackActive.get(name) === existingCallback) {
            												this._callbackActive.set(name, this._callbackActive.get(name).slice());
            										}
            										var callbacks1 = this._callbacks.get(name);
            										if (!callbacks1) continue;
            										callbacks1[ind].removed = true;
            										callbacks1.splice(ind, 1);
            										if (callbacks1.length === 0) {
            												this._callbacks.delete(name);
            										}
            								}
            						}
            				}
            				if (!callbacks) {
            						this._callbackActive.delete(name);
            				}
            				return this;
            		}
            		hasEvent(name) {
            				var _this__callbacks_get;
            				return !!((_this__callbacks_get = this._callbacks.get(name)) == null ? void 0 : _this__callbacks_get.length);
            		}
            		constructor(){
            				this._callbacks = new Map();
            				this._callbackActive = new Map();
            		}
            }
            
            class IndexedList {
            		push(key, item) {
            				if (this._index[key]) {
            						throw Error("Key already in index " + key);
            				}
            				var location = this._list.push(item) - 1;
            				this._index[key] = location;
            		}
            		has(key) {
            				return this._index[key] !== undefined;
            		}
            		get(key) {
            				var location = this._index[key];
            				if (location !== undefined) {
            						return this._list[location];
            				}
            				return null;
            		}
            		remove(key) {
            				var location = this._index[key];
            				if (location !== undefined) {
            						this._list.splice(location, 1);
            						delete this._index[key];
            						for(key in this._index){
            								var idx = this._index[key];
            								if (idx > location) {
            										this._index[key] = idx - 1;
            								}
            						}
            						return true;
            				}
            				return false;
            		}
            		list() {
            				return this._list;
            		}
            		clear() {
            				this._list.length = 0;
            				for(var prop in this._index){
            						delete this._index[prop];
            				}
            		}
            		constructor(){
            				this._list = [];
            				this._index = {};
            		}
            }
            
            var cachedResult = (func)=>{
            		var uninitToken = {};
            		var result = uninitToken;
            		return ()=>{
            				if (result === uninitToken) {
            						result = func();
            				}
            				return result;
            		};
            };
            class Impl {
            		static loadScript(url, callback) {
            				var s = document.createElement("script");
            				s.setAttribute('src', url);
            				s.onload = ()=>{
            						callback(null);
            				};
            				s.onerror = ()=>{
            						callback("Failed to load script='" + url + "'");
            				};
            				document.body.appendChild(s);
            		}
            		static loadWasm(moduleName, config, callback) {
            				var loadUrl = Impl.wasmSupported() && config.glueUrl && config.wasmUrl ? config.glueUrl : config.fallbackUrl;
            				if (loadUrl) {
            						Impl.loadScript(loadUrl, (err)=>{
            								if (err) {
            										callback(err, null);
            								} else {
            										var module = window[moduleName];
            										window[moduleName] = undefined;
            										module({
            												locateFile: ()=>config.wasmUrl,
            												onAbort: ()=>{
            														callback('wasm module aborted.');
            												}
            										}).then((instance)=>{
            												callback(null, instance);
            										});
            								}
            						});
            				} else {
            						callback('No supported wasm modules found.', null);
            				}
            		}
            		static getModule(name) {
            				if (!Impl.modules.hasOwnProperty(name)) {
            						Impl.modules[name] = {
            								config: null,
            								initializing: false,
            								instance: null,
            								callbacks: []
            						};
            				}
            				return Impl.modules[name];
            		}
            		static initialize(moduleName, module) {
            				if (module.initializing) {
            						return;
            				}
            				var config = module.config;
            				if (config.glueUrl || config.wasmUrl || config.fallbackUrl) {
            						module.initializing = true;
            						Impl.loadWasm(moduleName, config, (err, instance)=>{
            								if (err) {
            										if (config.errorHandler) {
            												config.errorHandler(err);
            										} else {
            												console.error("failed to initialize module=" + moduleName + " error=" + err);
            										}
            								} else {
            										module.instance = instance;
            										module.callbacks.forEach((callback)=>{
            												callback(instance);
            										});
            								}
            						});
            				}
            		}
            }
            Impl.modules = {};
            Impl.wasmSupported = cachedResult(()=>{
            		try {
            				if (typeof WebAssembly === 'object' && typeof WebAssembly.instantiate === 'function') {
            						var module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));
            						if (module instanceof WebAssembly.Module) {
            								return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;
            						}
            				}
            		} catch (e) {}
            		return false;
            });
            class WasmModule {
            		static setConfig(moduleName, config) {
            				var module = Impl.getModule(moduleName);
            				module.config = config;
            				if (module.callbacks.length > 0) {
            						Impl.initialize(moduleName, module);
            				}
            		}
            		static getConfig(moduleName) {
            				var _Impl_modules_moduleName, _Impl_modules;
            				return (_Impl_modules = Impl.modules) == null ? void 0 : (_Impl_modules_moduleName = _Impl_modules[moduleName]) == null ? void 0 : _Impl_modules_moduleName.config;
            		}
            		static getInstance(moduleName, callback) {
            				var module = Impl.getModule(moduleName);
            				if (module.instance) {
            						callback(module.instance);
            				} else {
            						module.callbacks.push(callback);
            						if (module.config) {
            								Impl.initialize(moduleName, module);
            						}
            				}
            		}
            }
            
            class ReadStream {
            		get remainingBytes() {
            				return this.dataView.byteLength - this.offset;
            		}
            		reset(offset) {
            				if (offset === void 0) offset = 0;
            				this.offset = offset;
            		}
            		skip(bytes) {
            				this.offset += bytes;
            		}
            		align(bytes) {
            				this.offset = this.offset + bytes - 1 & ~(bytes - 1);
            		}
            		_inc(amount) {
            				this.offset += amount;
            				return this.offset - amount;
            		}
            		readChar() {
            				return String.fromCharCode(this.dataView.getUint8(this.offset++));
            		}
            		readChars(numChars) {
            				var result = '';
            				for(var i = 0; i < numChars; ++i){
            						result += this.readChar();
            				}
            				return result;
            		}
            		readU8() {
            				return this.dataView.getUint8(this.offset++);
            		}
            		readU16() {
            				return this.dataView.getUint16(this._inc(2), true);
            		}
            		readU32() {
            				return this.dataView.getUint32(this._inc(4), true);
            		}
            		readU64() {
            				return this.readU32() + 2 ** 32 * this.readU32();
            		}
            		readU32be() {
            				return this.dataView.getUint32(this._inc(4), false);
            		}
            		readArray(result) {
            				for(var i = 0; i < result.length; ++i){
            						result[i] = this.readU8();
            				}
            		}
            		readLine() {
            				var view = this.dataView;
            				var result = '';
            				while(true){
            						if (this.offset >= view.byteLength) {
            								break;
            						}
            						var c = String.fromCharCode(this.readU8());
            						if (c === '\n') {
            								break;
            						}
            						result += c;
            				}
            				return result;
            		}
            		constructor(arraybuffer){
            				this.offset = 0;
            				this.arraybuffer = arraybuffer;
            				this.dataView = new DataView(arraybuffer);
            		}
            }
            
            class SortedLoopArray {
            		_binarySearch(item) {
            				var left = 0;
            				var right = this.items.length - 1;
            				var search = item[this._sortBy];
            				var middle;
            				var current;
            				while(left <= right){
            						middle = Math.floor((left + right) / 2);
            						current = this.items[middle][this._sortBy];
            						if (current <= search) {
            								left = middle + 1;
            						} else if (current > search) {
            								right = middle - 1;
            						}
            				}
            				return left;
            		}
            		_doSort(a, b) {
            				var sortBy = this._sortBy;
            				return a[sortBy] - b[sortBy];
            		}
            		insert(item) {
            				var index = this._binarySearch(item);
            				this.items.splice(index, 0, item);
            				this.length++;
            				if (this.loopIndex >= index) {
            						this.loopIndex++;
            				}
            		}
            		append(item) {
            				this.items.push(item);
            				this.length++;
            		}
            		remove(item) {
            				var idx = this.items.indexOf(item);
            				if (idx < 0) return;
            				this.items.splice(idx, 1);
            				this.length--;
            				if (this.loopIndex >= idx) {
            						this.loopIndex--;
            				}
            		}
            		sort() {
            				var current = this.loopIndex >= 0 ? this.items[this.loopIndex] : null;
            				this.items.sort(this._sortHandler);
            				if (current !== null) {
            						this.loopIndex = this.items.indexOf(current);
            				}
            		}
            		constructor(args){
            				this.items = [];
            				this.length = 0;
            				this.loopIndex = -1;
            				this._sortBy = args.sortBy;
            				this._sortHandler = this._doSort.bind(this);
            		}
            }
            
            class Tags extends EventHandler {
            		add() {
            				for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            						args[_key] = arguments[_key];
            				}
            				var changed = false;
            				var tags = this._processArguments(args, true);
            				if (!tags.length) {
            						return changed;
            				}
            				for(var i = 0; i < tags.length; i++){
            						if (this._index[tags[i]]) {
            								continue;
            						}
            						changed = true;
            						this._index[tags[i]] = true;
            						this._list.push(tags[i]);
            						this.fire('add', tags[i], this._parent);
            				}
            				if (changed) {
            						this.fire('change', this._parent);
            				}
            				return changed;
            		}
            		remove() {
            				for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            						args[_key] = arguments[_key];
            				}
            				var changed = false;
            				if (!this._list.length) {
            						return changed;
            				}
            				var tags = this._processArguments(args, true);
            				if (!tags.length) {
            						return changed;
            				}
            				for(var i = 0; i < tags.length; i++){
            						if (!this._index[tags[i]]) {
            								continue;
            						}
            						changed = true;
            						delete this._index[tags[i]];
            						this._list.splice(this._list.indexOf(tags[i]), 1);
            						this.fire('remove', tags[i], this._parent);
            				}
            				if (changed) {
            						this.fire('change', this._parent);
            				}
            				return changed;
            		}
            		clear() {
            				if (!this._list.length) {
            						return;
            				}
            				var tags = this._list.slice(0);
            				this._list = [];
            				this._index = {};
            				for(var i = 0; i < tags.length; i++){
            						this.fire('remove', tags[i], this._parent);
            				}
            				this.fire('change', this._parent);
            		}
            		has() {
            				for(var _len = arguments.length, query = new Array(_len), _key = 0; _key < _len; _key++){
            						query[_key] = arguments[_key];
            				}
            				if (!this._list.length) {
            						return false;
            				}
            				return this._has(this._processArguments(query));
            		}
            		_has(tags) {
            				if (!this._list.length || !tags.length) {
            						return false;
            				}
            				for(var i = 0; i < tags.length; i++){
            						if (tags[i].length === 1) {
            								if (this._index[tags[i][0]]) {
            										return true;
            								}
            						} else {
            								var multiple = true;
            								for(var t = 0; t < tags[i].length; t++){
            										if (this._index[tags[i][t]]) {
            												continue;
            										}
            										multiple = false;
            										break;
            								}
            								if (multiple) {
            										return true;
            								}
            						}
            				}
            				return false;
            		}
            		list() {
            				return this._list.slice(0);
            		}
            		_processArguments(args, flat) {
            				var tags = [];
            				var tmp = [];
            				if (!args || !args.length) {
            						return tags;
            				}
            				for(var i = 0; i < args.length; i++){
            						if (args[i] instanceof Array) {
            								if (!flat) {
            										tmp = [];
            								}
            								for(var t = 0; t < args[i].length; t++){
            										if (typeof args[i][t] !== 'string') {
            												continue;
            										}
            										if (flat) {
            												tags.push(args[i][t]);
            										} else {
            												tmp.push(args[i][t]);
            										}
            								}
            								if (!flat && tmp.length) {
            										tags.push(tmp);
            								}
            						} else if (typeof args[i] === 'string') {
            								if (flat) {
            										tags.push(args[i]);
            								} else {
            										tags.push([
            												args[i]
            										]);
            								}
            						}
            				}
            				return tags;
            		}
            		get size() {
            				return this._list.length;
            		}
            		constructor(parent){
            				super(), this._index = {}, this._list = [];
            				this._parent = parent;
            		}
            }
            Tags.EVENT_ADD = 'add';
            Tags.EVENT_REMOVE = 'remove';
            Tags.EVENT_CHANGE = 'change';
            
            var now = typeof window !== 'undefined' && window.performance && window.performance.now ? performance.now.bind(performance) : Date.now;
            
            var re = /^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
            class URI {
            		toString() {
            				var s = '';
            				if (this.scheme) {
            						s += "" + this.scheme + ":";
            				}
            				if (this.authority) {
            						s += "//" + this.authority;
            				}
            				s += this.path;
            				if (this.query) {
            						s += "?" + this.query;
            				}
            				if (this.fragment) {
            						s += "#" + this.fragment;
            				}
            				return s;
            		}
            		getQuery() {
            				var result = {};
            				if (this.query) {
            						var queryParams = decodeURIComponent(this.query).split('&');
            						for (var queryParam of queryParams){
            								var pair = queryParam.split('=');
            								result[pair[0]] = pair[1];
            						}
            				}
            				return result;
            		}
            		setQuery(params) {
            				var q = '';
            				for(var key in params){
            						if (params.hasOwnProperty(key)) {
            								if (q !== '') {
            										q += '&';
            								}
            								q += encodeURIComponent(key) + "=" + encodeURIComponent(params[key]);
            						}
            				}
            				this.query = q;
            		}
            		constructor(uri){
            				var result = uri.match(re);
            				this.scheme = result[2];
            				this.authority = result[4];
            				this.path = result[5];
            				this.query = result[7];
            				this.fragment = result[9];
            		}
            }
            
            class Tracing {
            		static set(channel, enabled) {
            		}
            		static get(channel) {
            				return Tracing._traceChannels.has(channel);
            		}
            }
            Tracing._traceChannels = new Set();
            Tracing.stack = false;
            
            var CURVE_LINEAR = 0;
            var CURVE_SMOOTHSTEP = 1;
            var CURVE_SPLINE = 4;
            var CURVE_STEP = 5;
            
            var math = {
            		DEG_TO_RAD: Math.PI / 180,
            		RAD_TO_DEG: 180 / Math.PI,
            		clamp (value, min, max) {
            				if (value >= max) return max;
            				if (value <= min) return min;
            				return value;
            		},
            		intToBytes24 (i) {
            				var r = i >> 16 & 0xff;
            				var g = i >> 8 & 0xff;
            				var b = i & 0xff;
            				return [
            						r,
            						g,
            						b
            				];
            		},
            		intToBytes32 (i) {
            				var r = i >> 24 & 0xff;
            				var g = i >> 16 & 0xff;
            				var b = i >> 8 & 0xff;
            				var a = i & 0xff;
            				return [
            						r,
            						g,
            						b,
            						a
            				];
            		},
            		bytesToInt24 (r, g, b) {
            				if (r.length) {
            						b = r[2];
            						g = r[1];
            						r = r[0];
            				}
            				return r << 16 | g << 8 | b;
            		},
            		bytesToInt32 (r, g, b, a) {
            				if (r.length) {
            						a = r[3];
            						b = r[2];
            						g = r[1];
            						r = r[0];
            				}
            				return (r << 24 | g << 16 | b << 8 | a) >>> 0;
            		},
            		lerp (a, b, alpha) {
            				return a + (b - a) * math.clamp(alpha, 0, 1);
            		},
            		lerpAngle (a, b, alpha) {
            				if (b - a > 180) {
            						b -= 360;
            				}
            				if (b - a < -180) {
            						b += 360;
            				}
            				return math.lerp(a, b, math.clamp(alpha, 0, 1));
            		},
            		powerOfTwo (x) {
            				return x !== 0 && !(x & x - 1);
            		},
            		nextPowerOfTwo (val) {
            				val--;
            				val |= val >> 1;
            				val |= val >> 2;
            				val |= val >> 4;
            				val |= val >> 8;
            				val |= val >> 16;
            				val++;
            				return val;
            		},
            		nearestPowerOfTwo (val) {
            				return Math.pow(2, Math.round(Math.log(val) / Math.log(2)));
            		},
            		random (min, max) {
            				var diff = max - min;
            				return Math.random() * diff + min;
            		},
            		smoothstep (min, max, x) {
            				if (x <= min) return 0;
            				if (x >= max) return 1;
            				x = (x - min) / (max - min);
            				return x * x * (3 - 2 * x);
            		},
            		smootherstep (min, max, x) {
            				if (x <= min) return 0;
            				if (x >= max) return 1;
            				x = (x - min) / (max - min);
            				return x * x * x * (x * (x * 6 - 15) + 10);
            		},
            		roundUp (numToRound, multiple) {
            				if (multiple === 0) {
            						return numToRound;
            				}
            				return Math.ceil(numToRound / multiple) * multiple;
            		},
            		between (num, a, b, inclusive) {
            				var min = Math.min(a, b);
            				var max = Math.max(a, b);
            				return inclusive ? num >= min && num <= max : num > min && num < max;
            		}
            };
            
            class Color {
            		clone() {
            				var cstr = this.constructor;
            				return new cstr(this.r, this.g, this.b, this.a);
            		}
            		copy(rhs) {
            				this.r = rhs.r;
            				this.g = rhs.g;
            				this.b = rhs.b;
            				this.a = rhs.a;
            				return this;
            		}
            		equals(rhs) {
            				return this.r === rhs.r && this.g === rhs.g && this.b === rhs.b && this.a === rhs.a;
            		}
            		set(r, g, b, a) {
            				if (a === void 0) a = 1;
            				this.r = r;
            				this.g = g;
            				this.b = b;
            				this.a = a;
            				return this;
            		}
            		lerp(lhs, rhs, alpha) {
            				this.r = lhs.r + alpha * (rhs.r - lhs.r);
            				this.g = lhs.g + alpha * (rhs.g - lhs.g);
            				this.b = lhs.b + alpha * (rhs.b - lhs.b);
            				this.a = lhs.a + alpha * (rhs.a - lhs.a);
            				return this;
            		}
            		linear(src) {
            				if (src === void 0) src = this;
            				this.r = Math.pow(src.r, 2.2);
            				this.g = Math.pow(src.g, 2.2);
            				this.b = Math.pow(src.b, 2.2);
            				this.a = src.a;
            				return this;
            		}
            		gamma(src) {
            				if (src === void 0) src = this;
            				this.r = Math.pow(src.r, 1 / 2.2);
            				this.g = Math.pow(src.g, 1 / 2.2);
            				this.b = Math.pow(src.b, 1 / 2.2);
            				this.a = src.a;
            				return this;
            		}
            		mulScalar(scalar) {
            				this.r *= scalar;
            				this.g *= scalar;
            				this.b *= scalar;
            				return this;
            		}
            		fromString(hex) {
            				var i = parseInt(hex.replace('#', '0x'), 16);
            				var bytes;
            				if (hex.length > 7) {
            						bytes = math.intToBytes32(i);
            				} else {
            						bytes = math.intToBytes24(i);
            						bytes[3] = 255;
            				}
            				this.set(bytes[0] / 255, bytes[1] / 255, bytes[2] / 255, bytes[3] / 255);
            				return this;
            		}
            		fromArray(arr, offset) {
            				if (offset === void 0) offset = 0;
            				var _arr_offset;
            				this.r = (_arr_offset = arr[offset]) != null ? _arr_offset : this.r;
            				var _arr_;
            				this.g = (_arr_ = arr[offset + 1]) != null ? _arr_ : this.g;
            				var _arr_1;
            				this.b = (_arr_1 = arr[offset + 2]) != null ? _arr_1 : this.b;
            				var _arr_2;
            				this.a = (_arr_2 = arr[offset + 3]) != null ? _arr_2 : this.a;
            				return this;
            		}
            		toString(alpha, asArray) {
            				var { r, g, b, a } = this;
            				if (asArray || r > 1 || g > 1 || b > 1) {
            						return r.toFixed(3) + ", " + g.toFixed(3) + ", " + b.toFixed(3) + ", " + a.toFixed(3);
            				}
            				var s = "#" + ((1 << 24) + (Math.round(r * 255) << 16) + (Math.round(g * 255) << 8) + Math.round(b * 255)).toString(16).slice(1);
            				if (alpha === true) {
            						var aa = Math.round(a * 255).toString(16);
            						if (this.a < 16 / 255) {
            								s += "0" + aa;
            						} else {
            								s += aa;
            						}
            				}
            				return s;
            		}
            		toArray(arr, offset, alpha) {
            				if (arr === void 0) arr = [];
            				if (offset === void 0) offset = 0;
            				if (alpha === void 0) alpha = true;
            				arr[offset] = this.r;
            				arr[offset + 1] = this.g;
            				arr[offset + 2] = this.b;
            				if (alpha) {
            						arr[offset + 3] = this.a;
            				}
            				return arr;
            		}
            		constructor(r = 0, g = 0, b = 0, a = 1){
            				var length = r.length;
            				if (length === 3 || length === 4) {
            						this.r = r[0];
            						this.g = r[1];
            						this.b = r[2];
            						var _r_;
            						this.a = (_r_ = r[3]) != null ? _r_ : 1;
            				} else {
            						this.r = r;
            						this.g = g;
            						this.b = b;
            						this.a = a;
            				}
            		}
            }
            Color.BLACK = Object.freeze(new Color(0, 0, 0, 1));
            Color.BLUE = Object.freeze(new Color(0, 0, 1, 1));
            Color.CYAN = Object.freeze(new Color(0, 1, 1, 1));
            Color.GRAY = Object.freeze(new Color(0.5, 0.5, 0.5, 1));
            Color.GREEN = Object.freeze(new Color(0, 1, 0, 1));
            Color.MAGENTA = Object.freeze(new Color(1, 0, 1, 1));
            Color.RED = Object.freeze(new Color(1, 0, 0, 1));
            Color.WHITE = Object.freeze(new Color(1, 1, 1, 1));
            Color.YELLOW = Object.freeze(new Color(1, 1, 0, 1));
            
            class CurveEvaluator {
            		evaluate(time, forceReset) {
            				if (forceReset === void 0) forceReset = false;
            				if (forceReset || time < this._left || time >= this._right) {
            						this._reset(time);
            				}
            				var result;
            				var type = this._curve.type;
            				if (type === CURVE_STEP) {
            						result = this._p0;
            				} else {
            						var t = this._recip === 0 ? 0 : (time - this._left) * this._recip;
            						if (type === CURVE_LINEAR) {
            								result = math.lerp(this._p0, this._p1, t);
            						} else if (type === CURVE_SMOOTHSTEP) {
            								result = math.lerp(this._p0, this._p1, t * t * (3 - 2 * t));
            						} else {
            								result = this._evaluateHermite(this._p0, this._p1, this._m0, this._m1, t);
            						}
            				}
            				return result;
            		}
            		_reset(time) {
            				var keys = this._curve.keys;
            				var len = keys.length;
            				if (!len) {
            						this._left = -Infinity;
            						this._right = Infinity;
            						this._recip = 0;
            						this._p0 = this._p1 = this._m0 = this._m1 = 0;
            				} else {
            						if (time < keys[0][0]) {
            								this._left = -Infinity;
            								this._right = keys[0][0];
            								this._recip = 0;
            								this._p0 = this._p1 = keys[0][1];
            								this._m0 = this._m1 = 0;
            						} else if (time >= keys[len - 1][0]) {
            								this._left = keys[len - 1][0];
            								this._right = Infinity;
            								this._recip = 0;
            								this._p0 = this._p1 = keys[len - 1][1];
            								this._m0 = this._m1 = 0;
            						} else {
            								var index = 0;
            								while(time >= keys[index + 1][0]){
            										index++;
            								}
            								this._left = keys[index][0];
            								this._right = keys[index + 1][0];
            								var diff = 1.0 / (this._right - this._left);
            								this._recip = isFinite(diff) ? diff : 0;
            								this._p0 = keys[index][1];
            								this._p1 = keys[index + 1][1];
            								if (this._curve.type === CURVE_SPLINE) {
            										this._calcTangents(keys, index);
            								}
            						}
            				}
            		}
            		_calcTangents(keys, index) {
            				var a;
            				var b = keys[index];
            				var c = keys[index + 1];
            				var d;
            				if (index === 0) {
            						a = [
            								keys[0][0] + (keys[0][0] - keys[1][0]),
            								keys[0][1] + (keys[0][1] - keys[1][1])
            						];
            				} else {
            						a = keys[index - 1];
            				}
            				if (index === keys.length - 2) {
            						d = [
            								keys[index + 1][0] + (keys[index + 1][0] - keys[index][0]),
            								keys[index + 1][1] + (keys[index + 1][1] - keys[index][1])
            						];
            				} else {
            						d = keys[index + 2];
            				}
            				if (this._curve.type === CURVE_SPLINE) {
            						var s1_ = 2 * (c[0] - b[0]) / (c[0] - a[0]);
            						var s2_ = 2 * (c[0] - b[0]) / (d[0] - b[0]);
            						this._m0 = this._curve.tension * (isFinite(s1_) ? s1_ : 0) * (c[1] - a[1]);
            						this._m1 = this._curve.tension * (isFinite(s2_) ? s2_ : 0) * (d[1] - b[1]);
            				} else {
            						var s1 = (c[0] - b[0]) / (b[0] - a[0]);
            						var s2 = (c[0] - b[0]) / (d[0] - c[0]);
            						var a_ = b[1] + (a[1] - b[1]) * (isFinite(s1) ? s1 : 0);
            						var d_ = c[1] + (d[1] - c[1]) * (isFinite(s2) ? s2 : 0);
            						var tension = this._curve.tension;
            						this._m0 = tension * (c[1] - a_);
            						this._m1 = tension * (d_ - b[1]);
            				}
            		}
            		_evaluateHermite(p0, p1, m0, m1, t) {
            				var t2 = t * t;
            				var twot = t + t;
            				var omt = 1 - t;
            				var omt2 = omt * omt;
            				return p0 * ((1 + twot) * omt2) + m0 * (t * omt2) + p1 * (t2 * (3 - twot)) + m1 * (t2 * (t - 1));
            		}
            		constructor(curve, time = 0){
            				this._left = -Infinity;
            				this._right = Infinity;
            				this._recip = 0;
            				this._p0 = 0;
            				this._p1 = 0;
            				this._m0 = 0;
            				this._m1 = 0;
            				this._curve = curve;
            				this._reset(time);
            		}
            }
            
            class Curve {
            		get length() {
            				return this.keys.length;
            		}
            		add(time, value) {
            				var keys = this.keys;
            				var len = keys.length;
            				var i = 0;
            				for(; i < len; i++){
            						if (keys[i][0] > time) {
            								break;
            						}
            				}
            				var key = [
            						time,
            						value
            				];
            				this.keys.splice(i, 0, key);
            				return key;
            		}
            		get(index) {
            				return this.keys[index];
            		}
            		sort() {
            				this.keys.sort((a, b)=>a[0] - b[0]);
            		}
            		value(time) {
            				return this._eval.evaluate(time, true);
            		}
            		closest(time) {
            				var keys = this.keys;
            				var length = keys.length;
            				var min = 2;
            				var result = null;
            				for(var i = 0; i < length; i++){
            						var diff = Math.abs(time - keys[i][0]);
            						if (min >= diff) {
            								min = diff;
            								result = keys[i];
            						} else {
            								break;
            						}
            				}
            				return result;
            		}
            		clone() {
            				var result = new this.constructor();
            				result.keys = this.keys.map((key)=>[
            								...key
            						]);
            				result.type = this.type;
            				result.tension = this.tension;
            				return result;
            		}
            		quantize(precision) {
            				precision = Math.max(precision, 2);
            				var values = new Float32Array(precision);
            				var step = 1.0 / (precision - 1);
            				values[0] = this._eval.evaluate(0, true);
            				for(var i = 1; i < precision; i++){
            						values[i] = this._eval.evaluate(step * i);
            				}
            				return values;
            		}
            		quantizeClamped(precision, min, max) {
            				var result = this.quantize(precision);
            				for(var i = 0; i < result.length; ++i){
            						result[i] = Math.min(max, Math.max(min, result[i]));
            				}
            				return result;
            		}
            		constructor(data){
            				this.keys = [];
            				this.type = CURVE_SMOOTHSTEP;
            				this.tension = 0.5;
            				this._eval = new CurveEvaluator(this);
            				if (data) {
            						for(var i = 0; i < data.length - 1; i += 2){
            								this.keys.push([
            										data[i],
            										data[i + 1]
            								]);
            						}
            				}
            				this.sort();
            		}
            }
            
            class CurveSet {
            		get length() {
            				return this.curves.length;
            		}
            		set type(value) {
            				this._type = value;
            				for(var i = 0; i < this.curves.length; i++){
            						this.curves[i].type = value;
            				}
            		}
            		get type() {
            				return this._type;
            		}
            		get(index) {
            				return this.curves[index];
            		}
            		value(time, result) {
            				if (result === void 0) result = [];
            				var length = this.curves.length;
            				result.length = length;
            				for(var i = 0; i < length; i++){
            						result[i] = this.curves[i].value(time);
            				}
            				return result;
            		}
            		clone() {
            				var result = new this.constructor();
            				result.curves = [];
            				for(var i = 0; i < this.curves.length; i++){
            						result.curves.push(this.curves[i].clone());
            				}
            				result._type = this._type;
            				return result;
            		}
            		quantize(precision) {
            				precision = Math.max(precision, 2);
            				var numCurves = this.curves.length;
            				var values = new Float32Array(precision * numCurves);
            				var step = 1.0 / (precision - 1);
            				for(var c = 0; c < numCurves; c++){
            						var ev = new CurveEvaluator(this.curves[c]);
            						for(var i = 0; i < precision; i++){
            								values[i * numCurves + c] = ev.evaluate(step * i);
            						}
            				}
            				return values;
            		}
            		quantizeClamped(precision, min, max) {
            				var result = this.quantize(precision);
            				for(var i = 0; i < result.length; ++i){
            						result[i] = Math.min(max, Math.max(min, result[i]));
            				}
            				return result;
            		}
            		constructor(...args){
            				this.curves = [];
            				this._type = CURVE_SMOOTHSTEP;
            				if (args.length > 1) {
            						for(var i = 0; i < args.length; i++){
            								this.curves.push(new Curve(args[i]));
            						}
            				} else if (args.length === 0) {
            						this.curves.push(new Curve());
            				} else {
            						var arg = args[0];
            						if (typeof arg === 'number') {
            								for(var i1 = 0; i1 < arg; i1++){
            										this.curves.push(new Curve());
            								}
            						} else {
            								for(var i2 = 0; i2 < arg.length; i2++){
            										this.curves.push(new Curve(arg[i2]));
            								}
            						}
            				}
            		}
            }
            
            var floatView = new Float32Array(1);
            var int32View = new Int32Array(floatView.buffer);
            class FloatPacking {
            		static float2Half(value) {
            				floatView[0] = value;
            				var x = int32View[0];
            				var bits = x >> 16 & 0x8000;
            				var m = x >> 12 & 0x07ff;
            				var e = x >> 23 & 0xff;
            				if (e < 103) {
            						return bits;
            				}
            				if (e > 142) {
            						bits |= 0x7c00;
            						bits |= (e === 255 ? 0 : 1) && x & 0x007fffff;
            						return bits;
            				}
            				if (e < 113) {
            						m |= 0x0800;
            						bits |= (m >> 114 - e) + (m >> 113 - e & 1);
            						return bits;
            				}
            				bits |= e - 112 << 10 | m >> 1;
            				bits += m & 1;
            				return bits;
            		}
            		static float2RGBA8(value, data) {
            				floatView[0] = value;
            				var intBits = int32View[0];
            				data.r = (intBits >> 24 & 0xFF) / 255.0;
            				data.g = (intBits >> 16 & 0xFF) / 255.0;
            				data.b = (intBits >> 8 & 0xFF) / 255.0;
            				data.a = (intBits & 0xFF) / 255.0;
            		}
            }
            
            class Vec3 {
            		add(rhs) {
            				this.x += rhs.x;
            				this.y += rhs.y;
            				this.z += rhs.z;
            				return this;
            		}
            		add2(lhs, rhs) {
            				this.x = lhs.x + rhs.x;
            				this.y = lhs.y + rhs.y;
            				this.z = lhs.z + rhs.z;
            				return this;
            		}
            		addScalar(scalar) {
            				this.x += scalar;
            				this.y += scalar;
            				this.z += scalar;
            				return this;
            		}
            		addScaled(rhs, scalar) {
            				this.x += rhs.x * scalar;
            				this.y += rhs.y * scalar;
            				this.z += rhs.z * scalar;
            				return this;
            		}
            		clone() {
            				var cstr = this.constructor;
            				return new cstr(this.x, this.y, this.z);
            		}
            		copy(rhs) {
            				this.x = rhs.x;
            				this.y = rhs.y;
            				this.z = rhs.z;
            				return this;
            		}
            		cross(lhs, rhs) {
            				var lx = lhs.x;
            				var ly = lhs.y;
            				var lz = lhs.z;
            				var rx = rhs.x;
            				var ry = rhs.y;
            				var rz = rhs.z;
            				this.x = ly * rz - ry * lz;
            				this.y = lz * rx - rz * lx;
            				this.z = lx * ry - rx * ly;
            				return this;
            		}
            		distance(rhs) {
            				var x = this.x - rhs.x;
            				var y = this.y - rhs.y;
            				var z = this.z - rhs.z;
            				return Math.sqrt(x * x + y * y + z * z);
            		}
            		div(rhs) {
            				this.x /= rhs.x;
            				this.y /= rhs.y;
            				this.z /= rhs.z;
            				return this;
            		}
            		div2(lhs, rhs) {
            				this.x = lhs.x / rhs.x;
            				this.y = lhs.y / rhs.y;
            				this.z = lhs.z / rhs.z;
            				return this;
            		}
            		divScalar(scalar) {
            				this.x /= scalar;
            				this.y /= scalar;
            				this.z /= scalar;
            				return this;
            		}
            		dot(rhs) {
            				return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
            		}
            		equals(rhs) {
            				return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z;
            		}
            		equalsApprox(rhs, epsilon) {
            				if (epsilon === void 0) epsilon = 1e-6;
            				return Math.abs(this.x - rhs.x) < epsilon && Math.abs(this.y - rhs.y) < epsilon && Math.abs(this.z - rhs.z) < epsilon;
            		}
            		length() {
            				return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            		}
            		lengthSq() {
            				return this.x * this.x + this.y * this.y + this.z * this.z;
            		}
            		lerp(lhs, rhs, alpha) {
            				this.x = lhs.x + alpha * (rhs.x - lhs.x);
            				this.y = lhs.y + alpha * (rhs.y - lhs.y);
            				this.z = lhs.z + alpha * (rhs.z - lhs.z);
            				return this;
            		}
            		mul(rhs) {
            				this.x *= rhs.x;
            				this.y *= rhs.y;
            				this.z *= rhs.z;
            				return this;
            		}
            		mul2(lhs, rhs) {
            				this.x = lhs.x * rhs.x;
            				this.y = lhs.y * rhs.y;
            				this.z = lhs.z * rhs.z;
            				return this;
            		}
            		mulScalar(scalar) {
            				this.x *= scalar;
            				this.y *= scalar;
            				this.z *= scalar;
            				return this;
            		}
            		normalize(src) {
            				if (src === void 0) src = this;
            				var lengthSq = src.x * src.x + src.y * src.y + src.z * src.z;
            				if (lengthSq > 0) {
            						var invLength = 1 / Math.sqrt(lengthSq);
            						this.x = src.x * invLength;
            						this.y = src.y * invLength;
            						this.z = src.z * invLength;
            				}
            				return this;
            		}
            		floor(src) {
            				if (src === void 0) src = this;
            				this.x = Math.floor(src.x);
            				this.y = Math.floor(src.y);
            				this.z = Math.floor(src.z);
            				return this;
            		}
            		ceil(src) {
            				if (src === void 0) src = this;
            				this.x = Math.ceil(src.x);
            				this.y = Math.ceil(src.y);
            				this.z = Math.ceil(src.z);
            				return this;
            		}
            		round(src) {
            				if (src === void 0) src = this;
            				this.x = Math.round(src.x);
            				this.y = Math.round(src.y);
            				this.z = Math.round(src.z);
            				return this;
            		}
            		min(rhs) {
            				if (rhs.x < this.x) this.x = rhs.x;
            				if (rhs.y < this.y) this.y = rhs.y;
            				if (rhs.z < this.z) this.z = rhs.z;
            				return this;
            		}
            		max(rhs) {
            				if (rhs.x > this.x) this.x = rhs.x;
            				if (rhs.y > this.y) this.y = rhs.y;
            				if (rhs.z > this.z) this.z = rhs.z;
            				return this;
            		}
            		project(rhs) {
            				var a_dot_b = this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;
            				var b_dot_b = rhs.x * rhs.x + rhs.y * rhs.y + rhs.z * rhs.z;
            				var s = a_dot_b / b_dot_b;
            				this.x = rhs.x * s;
            				this.y = rhs.y * s;
            				this.z = rhs.z * s;
            				return this;
            		}
            		set(x, y, z) {
            				this.x = x;
            				this.y = y;
            				this.z = z;
            				return this;
            		}
            		sub(rhs) {
            				this.x -= rhs.x;
            				this.y -= rhs.y;
            				this.z -= rhs.z;
            				return this;
            		}
            		sub2(lhs, rhs) {
            				this.x = lhs.x - rhs.x;
            				this.y = lhs.y - rhs.y;
            				this.z = lhs.z - rhs.z;
            				return this;
            		}
            		subScalar(scalar) {
            				this.x -= scalar;
            				this.y -= scalar;
            				this.z -= scalar;
            				return this;
            		}
            		fromArray(arr, offset) {
            				if (offset === void 0) offset = 0;
            				var _arr_offset;
            				this.x = (_arr_offset = arr[offset]) != null ? _arr_offset : this.x;
            				var _arr_;
            				this.y = (_arr_ = arr[offset + 1]) != null ? _arr_ : this.y;
            				var _arr_1;
            				this.z = (_arr_1 = arr[offset + 2]) != null ? _arr_1 : this.z;
            				return this;
            		}
            		toString() {
            				return "[" + this.x + ", " + this.y + ", " + this.z + "]";
            		}
            		toArray(arr, offset) {
            				if (arr === void 0) arr = [];
            				if (offset === void 0) offset = 0;
            				arr[offset] = this.x;
            				arr[offset + 1] = this.y;
            				arr[offset + 2] = this.z;
            				return arr;
            		}
            		constructor(x = 0, y = 0, z = 0){
            				if (x.length === 3) {
            						this.x = x[0];
            						this.y = x[1];
            						this.z = x[2];
            				} else {
            						this.x = x;
            						this.y = y;
            						this.z = z;
            				}
            		}
            }
            Vec3.ZERO = Object.freeze(new Vec3(0, 0, 0));
            Vec3.HALF = Object.freeze(new Vec3(0.5, 0.5, 0.5));
            Vec3.ONE = Object.freeze(new Vec3(1, 1, 1));
            Vec3.UP = Object.freeze(new Vec3(0, 1, 0));
            Vec3.DOWN = Object.freeze(new Vec3(0, -1, 0));
            Vec3.RIGHT = Object.freeze(new Vec3(1, 0, 0));
            Vec3.LEFT = Object.freeze(new Vec3(-1, 0, 0));
            Vec3.FORWARD = Object.freeze(new Vec3(0, 0, -1));
            Vec3.BACK = Object.freeze(new Vec3(0, 0, 1));
            
            class Mat3 {
            		clone() {
            				var cstr = this.constructor;
            				return new cstr().copy(this);
            		}
            		copy(rhs) {
            				var src = rhs.data;
            				var dst = this.data;
            				dst[0] = src[0];
            				dst[1] = src[1];
            				dst[2] = src[2];
            				dst[3] = src[3];
            				dst[4] = src[4];
            				dst[5] = src[5];
            				dst[6] = src[6];
            				dst[7] = src[7];
            				dst[8] = src[8];
            				return this;
            		}
            		set(src) {
            				var dst = this.data;
            				dst[0] = src[0];
            				dst[1] = src[1];
            				dst[2] = src[2];
            				dst[3] = src[3];
            				dst[4] = src[4];
            				dst[5] = src[5];
            				dst[6] = src[6];
            				dst[7] = src[7];
            				dst[8] = src[8];
            				return this;
            		}
            		getX(x) {
            				if (x === void 0) x = new Vec3();
            				return x.set(this.data[0], this.data[1], this.data[2]);
            		}
            		getY(y) {
            				if (y === void 0) y = new Vec3();
            				return y.set(this.data[3], this.data[4], this.data[5]);
            		}
            		getZ(z) {
            				if (z === void 0) z = new Vec3();
            				return z.set(this.data[6], this.data[7], this.data[8]);
            		}
            		equals(rhs) {
            				var l = this.data;
            				var r = rhs.data;
            				return l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8];
            		}
            		isIdentity() {
            				var m = this.data;
            				return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 1 && m[5] === 0 && m[6] === 0 && m[7] === 0 && m[8] === 1;
            		}
            		setIdentity() {
            				var m = this.data;
            				m[0] = 1;
            				m[1] = 0;
            				m[2] = 0;
            				m[3] = 0;
            				m[4] = 1;
            				m[5] = 0;
            				m[6] = 0;
            				m[7] = 0;
            				m[8] = 1;
            				return this;
            		}
            		toString() {
            				return "[" + this.data.join(', ') + "]";
            		}
            		transpose(src) {
            				if (src === void 0) src = this;
            				var s = src.data;
            				var t = this.data;
            				if (s === t) {
            						var tmp;
            						tmp = s[1];
            						t[1] = s[3];
            						t[3] = tmp;
            						tmp = s[2];
            						t[2] = s[6];
            						t[6] = tmp;
            						tmp = s[5];
            						t[5] = s[7];
            						t[7] = tmp;
            				} else {
            						t[0] = s[0];
            						t[1] = s[3];
            						t[2] = s[6];
            						t[3] = s[1];
            						t[4] = s[4];
            						t[5] = s[7];
            						t[6] = s[2];
            						t[7] = s[5];
            						t[8] = s[8];
            				}
            				return this;
            		}
            		setFromMat4(m) {
            				var src = m.data;
            				var dst = this.data;
            				dst[0] = src[0];
            				dst[1] = src[1];
            				dst[2] = src[2];
            				dst[3] = src[4];
            				dst[4] = src[5];
            				dst[5] = src[6];
            				dst[6] = src[8];
            				dst[7] = src[9];
            				dst[8] = src[10];
            				return this;
            		}
            		setFromQuat(r) {
            				var qx = r.x;
            				var qy = r.y;
            				var qz = r.z;
            				var qw = r.w;
            				var x2 = qx + qx;
            				var y2 = qy + qy;
            				var z2 = qz + qz;
            				var xx = qx * x2;
            				var xy = qx * y2;
            				var xz = qx * z2;
            				var yy = qy * y2;
            				var yz = qy * z2;
            				var zz = qz * z2;
            				var wx = qw * x2;
            				var wy = qw * y2;
            				var wz = qw * z2;
            				var m = this.data;
            				m[0] = 1 - (yy + zz);
            				m[1] = xy + wz;
            				m[2] = xz - wy;
            				m[3] = xy - wz;
            				m[4] = 1 - (xx + zz);
            				m[5] = yz + wx;
            				m[6] = xz + wy;
            				m[7] = yz - wx;
            				m[8] = 1 - (xx + yy);
            				return this;
            		}
            		invertMat4(src) {
            				var s = src.data;
            				var a0 = s[0];
            				var a1 = s[1];
            				var a2 = s[2];
            				var a4 = s[4];
            				var a5 = s[5];
            				var a6 = s[6];
            				var a8 = s[8];
            				var a9 = s[9];
            				var a10 = s[10];
            				var b11 = a10 * a5 - a6 * a9;
            				var b21 = -a10 * a1 + a2 * a9;
            				var b31 = a6 * a1 - a2 * a5;
            				var b12 = -a10 * a4 + a6 * a8;
            				var b22 = a10 * a0 - a2 * a8;
            				var b32 = -a6 * a0 + a2 * a4;
            				var b13 = a9 * a4 - a5 * a8;
            				var b23 = -a9 * a0 + a1 * a8;
            				var b33 = a5 * a0 - a1 * a4;
            				var det = a0 * b11 + a1 * b12 + a2 * b13;
            				if (det === 0) {
            						this.setIdentity();
            				} else {
            						var invDet = 1 / det;
            						var t = this.data;
            						t[0] = b11 * invDet;
            						t[1] = b21 * invDet;
            						t[2] = b31 * invDet;
            						t[3] = b12 * invDet;
            						t[4] = b22 * invDet;
            						t[5] = b32 * invDet;
            						t[6] = b13 * invDet;
            						t[7] = b23 * invDet;
            						t[8] = b33 * invDet;
            				}
            				return this;
            		}
            		transformVector(vec, res) {
            				if (res === void 0) res = new Vec3();
            				var m = this.data;
            				var { x, y, z } = vec;
            				res.x = x * m[0] + y * m[3] + z * m[6];
            				res.y = x * m[1] + y * m[4] + z * m[7];
            				res.z = x * m[2] + y * m[5] + z * m[8];
            				return res;
            		}
            		constructor(){
            				this.data = new Float32Array(9);
            				this.data[0] = this.data[4] = this.data[8] = 1;
            		}
            }
            Mat3.IDENTITY = Object.freeze(new Mat3());
            Mat3.ZERO = Object.freeze(new Mat3().set([
            		0,
            		0,
            		0,
            		0,
            		0,
            		0,
            		0,
            		0,
            		0
            ]));
            
            class Vec2 {
            		add(rhs) {
            				this.x += rhs.x;
            				this.y += rhs.y;
            				return this;
            		}
            		add2(lhs, rhs) {
            				this.x = lhs.x + rhs.x;
            				this.y = lhs.y + rhs.y;
            				return this;
            		}
            		addScalar(scalar) {
            				this.x += scalar;
            				this.y += scalar;
            				return this;
            		}
            		addScaled(rhs, scalar) {
            				this.x += rhs.x * scalar;
            				this.y += rhs.y * scalar;
            				return this;
            		}
            		clone() {
            				var cstr = this.constructor;
            				return new cstr(this.x, this.y);
            		}
            		copy(rhs) {
            				this.x = rhs.x;
            				this.y = rhs.y;
            				return this;
            		}
            		cross(rhs) {
            				return this.x * rhs.y - this.y * rhs.x;
            		}
            		distance(rhs) {
            				var x = this.x - rhs.x;
            				var y = this.y - rhs.y;
            				return Math.sqrt(x * x + y * y);
            		}
            		div(rhs) {
            				this.x /= rhs.x;
            				this.y /= rhs.y;
            				return this;
            		}
            		div2(lhs, rhs) {
            				this.x = lhs.x / rhs.x;
            				this.y = lhs.y / rhs.y;
            				return this;
            		}
            		divScalar(scalar) {
            				this.x /= scalar;
            				this.y /= scalar;
            				return this;
            		}
            		dot(rhs) {
            				return this.x * rhs.x + this.y * rhs.y;
            		}
            		equals(rhs) {
            				return this.x === rhs.x && this.y === rhs.y;
            		}
            		equalsApprox(rhs, epsilon) {
            				if (epsilon === void 0) epsilon = 1e-6;
            				return Math.abs(this.x - rhs.x) < epsilon && Math.abs(this.y - rhs.y) < epsilon;
            		}
            		length() {
            				return Math.sqrt(this.x * this.x + this.y * this.y);
            		}
            		lengthSq() {
            				return this.x * this.x + this.y * this.y;
            		}
            		lerp(lhs, rhs, alpha) {
            				this.x = lhs.x + alpha * (rhs.x - lhs.x);
            				this.y = lhs.y + alpha * (rhs.y - lhs.y);
            				return this;
            		}
            		mul(rhs) {
            				this.x *= rhs.x;
            				this.y *= rhs.y;
            				return this;
            		}
            		mul2(lhs, rhs) {
            				this.x = lhs.x * rhs.x;
            				this.y = lhs.y * rhs.y;
            				return this;
            		}
            		mulScalar(scalar) {
            				this.x *= scalar;
            				this.y *= scalar;
            				return this;
            		}
            		normalize(src) {
            				if (src === void 0) src = this;
            				var lengthSq = src.x * src.x + src.y * src.y;
            				if (lengthSq > 0) {
            						var invLength = 1 / Math.sqrt(lengthSq);
            						this.x = src.x * invLength;
            						this.y = src.y * invLength;
            				}
            				return this;
            		}
            		rotate(degrees) {
            				var angle = Math.atan2(this.x, this.y) + degrees * math.DEG_TO_RAD;
            				var len = Math.sqrt(this.x * this.x + this.y * this.y);
            				this.x = Math.sin(angle) * len;
            				this.y = Math.cos(angle) * len;
            				return this;
            		}
            		angle() {
            				return Math.atan2(this.x, this.y) * math.RAD_TO_DEG;
            		}
            		angleTo(rhs) {
            				return Math.atan2(this.x * rhs.y + this.y * rhs.x, this.x * rhs.x + this.y * rhs.y) * math.RAD_TO_DEG;
            		}
            		floor(src) {
            				if (src === void 0) src = this;
            				this.x = Math.floor(src.x);
            				this.y = Math.floor(src.y);
            				return this;
            		}
            		ceil(src) {
            				if (src === void 0) src = this;
            				this.x = Math.ceil(src.x);
            				this.y = Math.ceil(src.y);
            				return this;
            		}
            		round(src) {
            				if (src === void 0) src = this;
            				this.x = Math.round(src.x);
            				this.y = Math.round(src.y);
            				return this;
            		}
            		min(rhs) {
            				if (rhs.x < this.x) this.x = rhs.x;
            				if (rhs.y < this.y) this.y = rhs.y;
            				return this;
            		}
            		max(rhs) {
            				if (rhs.x > this.x) this.x = rhs.x;
            				if (rhs.y > this.y) this.y = rhs.y;
            				return this;
            		}
            		set(x, y) {
            				this.x = x;
            				this.y = y;
            				return this;
            		}
            		sub(rhs) {
            				this.x -= rhs.x;
            				this.y -= rhs.y;
            				return this;
            		}
            		sub2(lhs, rhs) {
            				this.x = lhs.x - rhs.x;
            				this.y = lhs.y - rhs.y;
            				return this;
            		}
            		subScalar(scalar) {
            				this.x -= scalar;
            				this.y -= scalar;
            				return this;
            		}
            		fromArray(arr, offset) {
            				if (offset === void 0) offset = 0;
            				var _arr_offset;
            				this.x = (_arr_offset = arr[offset]) != null ? _arr_offset : this.x;
            				var _arr_;
            				this.y = (_arr_ = arr[offset + 1]) != null ? _arr_ : this.y;
            				return this;
            		}
            		toString() {
            				return "[" + this.x + ", " + this.y + "]";
            		}
            		toArray(arr, offset) {
            				if (arr === void 0) arr = [];
            				if (offset === void 0) offset = 0;
            				arr[offset] = this.x;
            				arr[offset + 1] = this.y;
            				return arr;
            		}
            		static angleRad(lhs, rhs) {
            				return Math.atan2(lhs.x * rhs.y - lhs.y * rhs.x, lhs.x * rhs.x + lhs.y * rhs.y);
            		}
            		constructor(x = 0, y = 0){
            				if (x.length === 2) {
            						this.x = x[0];
            						this.y = x[1];
            				} else {
            						this.x = x;
            						this.y = y;
            				}
            		}
            }
            Vec2.ZERO = Object.freeze(new Vec2(0, 0));
            Vec2.HALF = Object.freeze(new Vec2(0.5, 0.5));
            Vec2.ONE = Object.freeze(new Vec2(1, 1));
            Vec2.UP = Object.freeze(new Vec2(0, 1));
            Vec2.DOWN = Object.freeze(new Vec2(0, -1));
            Vec2.RIGHT = Object.freeze(new Vec2(1, 0));
            Vec2.LEFT = Object.freeze(new Vec2(-1, 0));
            
            class Vec4 {
            		add(rhs) {
            				this.x += rhs.x;
            				this.y += rhs.y;
            				this.z += rhs.z;
            				this.w += rhs.w;
            				return this;
            		}
            		add2(lhs, rhs) {
            				this.x = lhs.x + rhs.x;
            				this.y = lhs.y + rhs.y;
            				this.z = lhs.z + rhs.z;
            				this.w = lhs.w + rhs.w;
            				return this;
            		}
            		addScalar(scalar) {
            				this.x += scalar;
            				this.y += scalar;
            				this.z += scalar;
            				this.w += scalar;
            				return this;
            		}
            		addScaled(rhs, scalar) {
            				this.x += rhs.x * scalar;
            				this.y += rhs.y * scalar;
            				this.z += rhs.z * scalar;
            				this.w += rhs.w * scalar;
            				return this;
            		}
            		clone() {
            				var cstr = this.constructor;
            				return new cstr(this.x, this.y, this.z, this.w);
            		}
            		copy(rhs) {
            				this.x = rhs.x;
            				this.y = rhs.y;
            				this.z = rhs.z;
            				this.w = rhs.w;
            				return this;
            		}
            		div(rhs) {
            				this.x /= rhs.x;
            				this.y /= rhs.y;
            				this.z /= rhs.z;
            				this.w /= rhs.w;
            				return this;
            		}
            		div2(lhs, rhs) {
            				this.x = lhs.x / rhs.x;
            				this.y = lhs.y / rhs.y;
            				this.z = lhs.z / rhs.z;
            				this.w = lhs.w / rhs.w;
            				return this;
            		}
            		divScalar(scalar) {
            				this.x /= scalar;
            				this.y /= scalar;
            				this.z /= scalar;
            				this.w /= scalar;
            				return this;
            		}
            		dot(rhs) {
            				return this.x * rhs.x + this.y * rhs.y + this.z * rhs.z + this.w * rhs.w;
            		}
            		equals(rhs) {
            				return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;
            		}
            		equalsApprox(rhs, epsilon) {
            				if (epsilon === void 0) epsilon = 1e-6;
            				return Math.abs(this.x - rhs.x) < epsilon && Math.abs(this.y - rhs.y) < epsilon && Math.abs(this.z - rhs.z) < epsilon && Math.abs(this.w - rhs.w) < epsilon;
            		}
            		length() {
            				return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            		}
            		lengthSq() {
            				return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            		}
            		lerp(lhs, rhs, alpha) {
            				this.x = lhs.x + alpha * (rhs.x - lhs.x);
            				this.y = lhs.y + alpha * (rhs.y - lhs.y);
            				this.z = lhs.z + alpha * (rhs.z - lhs.z);
            				this.w = lhs.w + alpha * (rhs.w - lhs.w);
            				return this;
            		}
            		mul(rhs) {
            				this.x *= rhs.x;
            				this.y *= rhs.y;
            				this.z *= rhs.z;
            				this.w *= rhs.w;
            				return this;
            		}
            		mul2(lhs, rhs) {
            				this.x = lhs.x * rhs.x;
            				this.y = lhs.y * rhs.y;
            				this.z = lhs.z * rhs.z;
            				this.w = lhs.w * rhs.w;
            				return this;
            		}
            		mulScalar(scalar) {
            				this.x *= scalar;
            				this.y *= scalar;
            				this.z *= scalar;
            				this.w *= scalar;
            				return this;
            		}
            		normalize(src) {
            				if (src === void 0) src = this;
            				var lengthSq = src.x * src.x + src.y * src.y + src.z * src.z + src.w * src.w;
            				if (lengthSq > 0) {
            						var invLength = 1 / Math.sqrt(lengthSq);
            						this.x = src.x * invLength;
            						this.y = src.y * invLength;
            						this.z = src.z * invLength;
            						this.w = src.w * invLength;
            				}
            				return this;
            		}
            		floor(src) {
            				if (src === void 0) src = this;
            				this.x = Math.floor(src.x);
            				this.y = Math.floor(src.y);
            				this.z = Math.floor(src.z);
            				this.w = Math.floor(src.w);
            				return this;
            		}
            		ceil(src) {
            				if (src === void 0) src = this;
            				this.x = Math.ceil(src.x);
            				this.y = Math.ceil(src.y);
            				this.z = Math.ceil(src.z);
            				this.w = Math.ceil(src.w);
            				return this;
            		}
            		round(src) {
            				if (src === void 0) src = this;
            				this.x = Math.round(src.x);
            				this.y = Math.round(src.y);
            				this.z = Math.round(src.z);
            				this.w = Math.round(src.w);
            				return this;
            		}
            		min(rhs) {
            				if (rhs.x < this.x) this.x = rhs.x;
            				if (rhs.y < this.y) this.y = rhs.y;
            				if (rhs.z < this.z) this.z = rhs.z;
            				if (rhs.w < this.w) this.w = rhs.w;
            				return this;
            		}
            		max(rhs) {
            				if (rhs.x > this.x) this.x = rhs.x;
            				if (rhs.y > this.y) this.y = rhs.y;
            				if (rhs.z > this.z) this.z = rhs.z;
            				if (rhs.w > this.w) this.w = rhs.w;
            				return this;
            		}
            		set(x, y, z, w) {
            				this.x = x;
            				this.y = y;
            				this.z = z;
            				this.w = w;
            				return this;
            		}
            		sub(rhs) {
            				this.x -= rhs.x;
            				this.y -= rhs.y;
            				this.z -= rhs.z;
            				this.w -= rhs.w;
            				return this;
            		}
            		sub2(lhs, rhs) {
            				this.x = lhs.x - rhs.x;
            				this.y = lhs.y - rhs.y;
            				this.z = lhs.z - rhs.z;
            				this.w = lhs.w - rhs.w;
            				return this;
            		}
            		subScalar(scalar) {
            				this.x -= scalar;
            				this.y -= scalar;
            				this.z -= scalar;
            				this.w -= scalar;
            				return this;
            		}
            		fromArray(arr, offset) {
            				if (offset === void 0) offset = 0;
            				var _arr_offset;
            				this.x = (_arr_offset = arr[offset]) != null ? _arr_offset : this.x;
            				var _arr_;
            				this.y = (_arr_ = arr[offset + 1]) != null ? _arr_ : this.y;
            				var _arr_1;
            				this.z = (_arr_1 = arr[offset + 2]) != null ? _arr_1 : this.z;
            				var _arr_2;
            				this.w = (_arr_2 = arr[offset + 3]) != null ? _arr_2 : this.w;
            				return this;
            		}
            		toString() {
            				return "[" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + "]";
            		}
            		toArray(arr, offset) {
            				if (arr === void 0) arr = [];
            				if (offset === void 0) offset = 0;
            				arr[offset] = this.x;
            				arr[offset + 1] = this.y;
            				arr[offset + 2] = this.z;
            				arr[offset + 3] = this.w;
            				return arr;
            		}
            		constructor(x = 0, y = 0, z = 0, w = 0){
            				if (x.length === 4) {
            						this.x = x[0];
            						this.y = x[1];
            						this.z = x[2];
            						this.w = x[3];
            				} else {
            						this.x = x;
            						this.y = y;
            						this.z = z;
            						this.w = w;
            				}
            		}
            }
            Vec4.ZERO = Object.freeze(new Vec4(0, 0, 0, 0));
            Vec4.HALF = Object.freeze(new Vec4(0.5, 0.5, 0.5, 0.5));
            Vec4.ONE = Object.freeze(new Vec4(1, 1, 1, 1));
            
            var _halfSize$1 = new Vec2();
            var x$1 = new Vec3();
            var y$1 = new Vec3();
            var z$1 = new Vec3();
            var scale = new Vec3();
            class Mat4 {
            		static _getPerspectiveHalfSize(halfSize, fov, aspect, znear, fovIsHorizontal) {
            				if (fovIsHorizontal) {
            						halfSize.x = znear * Math.tan(fov * Math.PI / 360);
            						halfSize.y = halfSize.x / aspect;
            				} else {
            						halfSize.y = znear * Math.tan(fov * Math.PI / 360);
            						halfSize.x = halfSize.y * aspect;
            				}
            		}
            		add2(lhs, rhs) {
            				var a = lhs.data, b = rhs.data, r = this.data;
            				r[0] = a[0] + b[0];
            				r[1] = a[1] + b[1];
            				r[2] = a[2] + b[2];
            				r[3] = a[3] + b[3];
            				r[4] = a[4] + b[4];
            				r[5] = a[5] + b[5];
            				r[6] = a[6] + b[6];
            				r[7] = a[7] + b[7];
            				r[8] = a[8] + b[8];
            				r[9] = a[9] + b[9];
            				r[10] = a[10] + b[10];
            				r[11] = a[11] + b[11];
            				r[12] = a[12] + b[12];
            				r[13] = a[13] + b[13];
            				r[14] = a[14] + b[14];
            				r[15] = a[15] + b[15];
            				return this;
            		}
            		add(rhs) {
            				return this.add2(this, rhs);
            		}
            		clone() {
            				var cstr = this.constructor;
            				return new cstr().copy(this);
            		}
            		copy(rhs) {
            				var src = rhs.data, dst = this.data;
            				dst[0] = src[0];
            				dst[1] = src[1];
            				dst[2] = src[2];
            				dst[3] = src[3];
            				dst[4] = src[4];
            				dst[5] = src[5];
            				dst[6] = src[6];
            				dst[7] = src[7];
            				dst[8] = src[8];
            				dst[9] = src[9];
            				dst[10] = src[10];
            				dst[11] = src[11];
            				dst[12] = src[12];
            				dst[13] = src[13];
            				dst[14] = src[14];
            				dst[15] = src[15];
            				return this;
            		}
            		equals(rhs) {
            				var l = this.data, r = rhs.data;
            				return l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8] && l[9] === r[9] && l[10] === r[10] && l[11] === r[11] && l[12] === r[12] && l[13] === r[13] && l[14] === r[14] && l[15] === r[15];
            		}
            		isIdentity() {
            				var m = this.data;
            				return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 0 && m[5] === 1 && m[6] === 0 && m[7] === 0 && m[8] === 0 && m[9] === 0 && m[10] === 1 && m[11] === 0 && m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1;
            		}
            		mul2(lhs, rhs) {
            				var a = lhs.data;
            				var b = rhs.data;
            				var r = this.data;
            				var a00 = a[0];
            				var a01 = a[1];
            				var a02 = a[2];
            				var a03 = a[3];
            				var a10 = a[4];
            				var a11 = a[5];
            				var a12 = a[6];
            				var a13 = a[7];
            				var a20 = a[8];
            				var a21 = a[9];
            				var a22 = a[10];
            				var a23 = a[11];
            				var a30 = a[12];
            				var a31 = a[13];
            				var a32 = a[14];
            				var a33 = a[15];
            				var b0, b1, b2, b3;
            				b0 = b[0];
            				b1 = b[1];
            				b2 = b[2];
            				b3 = b[3];
            				r[0] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
            				r[1] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
            				r[2] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
            				r[3] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
            				b0 = b[4];
            				b1 = b[5];
            				b2 = b[6];
            				b3 = b[7];
            				r[4] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
            				r[5] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
            				r[6] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
            				r[7] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
            				b0 = b[8];
            				b1 = b[9];
            				b2 = b[10];
            				b3 = b[11];
            				r[8] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
            				r[9] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
            				r[10] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
            				r[11] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
            				b0 = b[12];
            				b1 = b[13];
            				b2 = b[14];
            				b3 = b[15];
            				r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;
            				r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;
            				r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;
            				r[15] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;
            				return this;
            		}
            		mulAffine2(lhs, rhs) {
            				var a = lhs.data;
            				var b = rhs.data;
            				var r = this.data;
            				var a00 = a[0];
            				var a01 = a[1];
            				var a02 = a[2];
            				var a10 = a[4];
            				var a11 = a[5];
            				var a12 = a[6];
            				var a20 = a[8];
            				var a21 = a[9];
            				var a22 = a[10];
            				var a30 = a[12];
            				var a31 = a[13];
            				var a32 = a[14];
            				var b0, b1, b2;
            				b0 = b[0];
            				b1 = b[1];
            				b2 = b[2];
            				r[0] = a00 * b0 + a10 * b1 + a20 * b2;
            				r[1] = a01 * b0 + a11 * b1 + a21 * b2;
            				r[2] = a02 * b0 + a12 * b1 + a22 * b2;
            				r[3] = 0;
            				b0 = b[4];
            				b1 = b[5];
            				b2 = b[6];
            				r[4] = a00 * b0 + a10 * b1 + a20 * b2;
            				r[5] = a01 * b0 + a11 * b1 + a21 * b2;
            				r[6] = a02 * b0 + a12 * b1 + a22 * b2;
            				r[7] = 0;
            				b0 = b[8];
            				b1 = b[9];
            				b2 = b[10];
            				r[8] = a00 * b0 + a10 * b1 + a20 * b2;
            				r[9] = a01 * b0 + a11 * b1 + a21 * b2;
            				r[10] = a02 * b0 + a12 * b1 + a22 * b2;
            				r[11] = 0;
            				b0 = b[12];
            				b1 = b[13];
            				b2 = b[14];
            				r[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30;
            				r[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31;
            				r[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32;
            				r[15] = 1;
            				return this;
            		}
            		mul(rhs) {
            				return this.mul2(this, rhs);
            		}
            		transformPoint(vec, res) {
            				if (res === void 0) res = new Vec3();
            				var m = this.data;
            				var { x, y, z } = vec;
            				res.x = x * m[0] + y * m[4] + z * m[8] + m[12];
            				res.y = x * m[1] + y * m[5] + z * m[9] + m[13];
            				res.z = x * m[2] + y * m[6] + z * m[10] + m[14];
            				return res;
            		}
            		transformVector(vec, res) {
            				if (res === void 0) res = new Vec3();
            				var m = this.data;
            				var { x, y, z } = vec;
            				res.x = x * m[0] + y * m[4] + z * m[8];
            				res.y = x * m[1] + y * m[5] + z * m[9];
            				res.z = x * m[2] + y * m[6] + z * m[10];
            				return res;
            		}
            		transformVec4(vec, res) {
            				if (res === void 0) res = new Vec4();
            				var m = this.data;
            				var { x, y, z, w } = vec;
            				res.x = x * m[0] + y * m[4] + z * m[8] + w * m[12];
            				res.y = x * m[1] + y * m[5] + z * m[9] + w * m[13];
            				res.z = x * m[2] + y * m[6] + z * m[10] + w * m[14];
            				res.w = x * m[3] + y * m[7] + z * m[11] + w * m[15];
            				return res;
            		}
            		setLookAt(position, target, up) {
            				z$1.sub2(position, target).normalize();
            				y$1.copy(up).normalize();
            				x$1.cross(y$1, z$1).normalize();
            				y$1.cross(z$1, x$1);
            				var r = this.data;
            				r[0] = x$1.x;
            				r[1] = x$1.y;
            				r[2] = x$1.z;
            				r[3] = 0;
            				r[4] = y$1.x;
            				r[5] = y$1.y;
            				r[6] = y$1.z;
            				r[7] = 0;
            				r[8] = z$1.x;
            				r[9] = z$1.y;
            				r[10] = z$1.z;
            				r[11] = 0;
            				r[12] = position.x;
            				r[13] = position.y;
            				r[14] = position.z;
            				r[15] = 1;
            				return this;
            		}
            		setFrustum(left, right, bottom, top, znear, zfar) {
            				var temp1 = 2 * znear;
            				var temp2 = right - left;
            				var temp3 = top - bottom;
            				var temp4 = zfar - znear;
            				var r = this.data;
            				r[0] = temp1 / temp2;
            				r[1] = 0;
            				r[2] = 0;
            				r[3] = 0;
            				r[4] = 0;
            				r[5] = temp1 / temp3;
            				r[6] = 0;
            				r[7] = 0;
            				r[8] = (right + left) / temp2;
            				r[9] = (top + bottom) / temp3;
            				r[10] = (-zfar - znear) / temp4;
            				r[11] = -1;
            				r[12] = 0;
            				r[13] = 0;
            				r[14] = -temp1 * zfar / temp4;
            				r[15] = 0;
            				return this;
            		}
            		setPerspective(fov, aspect, znear, zfar, fovIsHorizontal) {
            				Mat4._getPerspectiveHalfSize(_halfSize$1, fov, aspect, znear, fovIsHorizontal);
            				return this.setFrustum(-_halfSize$1.x, _halfSize$1.x, -_halfSize$1.y, _halfSize$1.y, znear, zfar);
            		}
            		setOrtho(left, right, bottom, top, near, far) {
            				var r = this.data;
            				r[0] = 2 / (right - left);
            				r[1] = 0;
            				r[2] = 0;
            				r[3] = 0;
            				r[4] = 0;
            				r[5] = 2 / (top - bottom);
            				r[6] = 0;
            				r[7] = 0;
            				r[8] = 0;
            				r[9] = 0;
            				r[10] = -2 / (far - near);
            				r[11] = 0;
            				r[12] = -(right + left) / (right - left);
            				r[13] = -(top + bottom) / (top - bottom);
            				r[14] = -(far + near) / (far - near);
            				r[15] = 1;
            				return this;
            		}
            		setFromAxisAngle(axis, angle) {
            				angle *= math.DEG_TO_RAD;
            				var { x, y, z } = axis;
            				var c = Math.cos(angle);
            				var s = Math.sin(angle);
            				var t = 1 - c;
            				var tx = t * x;
            				var ty = t * y;
            				var m = this.data;
            				m[0] = tx * x + c;
            				m[1] = tx * y + s * z;
            				m[2] = tx * z - s * y;
            				m[3] = 0;
            				m[4] = tx * y - s * z;
            				m[5] = ty * y + c;
            				m[6] = ty * z + s * x;
            				m[7] = 0;
            				m[8] = tx * z + s * y;
            				m[9] = ty * z - x * s;
            				m[10] = t * z * z + c;
            				m[11] = 0;
            				m[12] = 0;
            				m[13] = 0;
            				m[14] = 0;
            				m[15] = 1;
            				return this;
            		}
            		setTranslate(x, y, z) {
            				var m = this.data;
            				m[0] = 1;
            				m[1] = 0;
            				m[2] = 0;
            				m[3] = 0;
            				m[4] = 0;
            				m[5] = 1;
            				m[6] = 0;
            				m[7] = 0;
            				m[8] = 0;
            				m[9] = 0;
            				m[10] = 1;
            				m[11] = 0;
            				m[12] = x;
            				m[13] = y;
            				m[14] = z;
            				m[15] = 1;
            				return this;
            		}
            		setScale(x, y, z) {
            				var m = this.data;
            				m[0] = x;
            				m[1] = 0;
            				m[2] = 0;
            				m[3] = 0;
            				m[4] = 0;
            				m[5] = y;
            				m[6] = 0;
            				m[7] = 0;
            				m[8] = 0;
            				m[9] = 0;
            				m[10] = z;
            				m[11] = 0;
            				m[12] = 0;
            				m[13] = 0;
            				m[14] = 0;
            				m[15] = 1;
            				return this;
            		}
            		setViewport(x, y, width, height) {
            				var m = this.data;
            				m[0] = width * 0.5;
            				m[1] = 0;
            				m[2] = 0;
            				m[3] = 0;
            				m[4] = 0;
            				m[5] = height * 0.5;
            				m[6] = 0;
            				m[7] = 0;
            				m[8] = 0;
            				m[9] = 0;
            				m[10] = 0.5;
            				m[11] = 0;
            				m[12] = x + width * 0.5;
            				m[13] = y + height * 0.5;
            				m[14] = 0.5;
            				m[15] = 1;
            				return this;
            		}
            		setReflection(normal, distance) {
            				var a = normal.x;
            				var b = normal.y;
            				var c = normal.z;
            				var data = this.data;
            				data[0] = 1.0 - 2 * a * a;
            				data[1] = -2 * a * b;
            				data[2] = -2 * a * c;
            				data[3] = 0;
            				data[4] = -2 * a * b;
            				data[5] = 1.0 - 2 * b * b;
            				data[6] = -2 * b * c;
            				data[7] = 0;
            				data[8] = -2 * a * c;
            				data[9] = -2 * b * c;
            				data[10] = 1.0 - 2 * c * c;
            				data[11] = 0;
            				data[12] = -2 * a * distance;
            				data[13] = -2 * b * distance;
            				data[14] = -2 * c * distance;
            				data[15] = 1;
            				return this;
            		}
            		invert(src) {
            				if (src === void 0) src = this;
            				var s = src.data;
            				var a00 = s[0];
            				var a01 = s[1];
            				var a02 = s[2];
            				var a03 = s[3];
            				var a10 = s[4];
            				var a11 = s[5];
            				var a12 = s[6];
            				var a13 = s[7];
            				var a20 = s[8];
            				var a21 = s[9];
            				var a22 = s[10];
            				var a23 = s[11];
            				var a30 = s[12];
            				var a31 = s[13];
            				var a32 = s[14];
            				var a33 = s[15];
            				var b00 = a00 * a11 - a01 * a10;
            				var b01 = a00 * a12 - a02 * a10;
            				var b02 = a00 * a13 - a03 * a10;
            				var b03 = a01 * a12 - a02 * a11;
            				var b04 = a01 * a13 - a03 * a11;
            				var b05 = a02 * a13 - a03 * a12;
            				var b06 = a20 * a31 - a21 * a30;
            				var b07 = a20 * a32 - a22 * a30;
            				var b08 = a20 * a33 - a23 * a30;
            				var b09 = a21 * a32 - a22 * a31;
            				var b10 = a21 * a33 - a23 * a31;
            				var b11 = a22 * a33 - a23 * a32;
            				var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
            				if (det === 0) {
            						this.setIdentity();
            				} else {
            						var invDet = 1 / det;
            						var t = this.data;
            						t[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
            						t[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
            						t[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
            						t[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
            						t[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
            						t[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
            						t[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
            						t[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
            						t[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
            						t[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
            						t[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
            						t[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
            						t[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
            						t[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
            						t[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
            						t[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;
            				}
            				return this;
            		}
            		set(src) {
            				var dst = this.data;
            				dst[0] = src[0];
            				dst[1] = src[1];
            				dst[2] = src[2];
            				dst[3] = src[3];
            				dst[4] = src[4];
            				dst[5] = src[5];
            				dst[6] = src[6];
            				dst[7] = src[7];
            				dst[8] = src[8];
            				dst[9] = src[9];
            				dst[10] = src[10];
            				dst[11] = src[11];
            				dst[12] = src[12];
            				dst[13] = src[13];
            				dst[14] = src[14];
            				dst[15] = src[15];
            				return this;
            		}
            		setIdentity() {
            				var m = this.data;
            				m[0] = 1;
            				m[1] = 0;
            				m[2] = 0;
            				m[3] = 0;
            				m[4] = 0;
            				m[5] = 1;
            				m[6] = 0;
            				m[7] = 0;
            				m[8] = 0;
            				m[9] = 0;
            				m[10] = 1;
            				m[11] = 0;
            				m[12] = 0;
            				m[13] = 0;
            				m[14] = 0;
            				m[15] = 1;
            				return this;
            		}
            		setTRS(t, r, s) {
            				var qx = r.x;
            				var qy = r.y;
            				var qz = r.z;
            				var qw = r.w;
            				var sx = s.x;
            				var sy = s.y;
            				var sz = s.z;
            				var x2 = qx + qx;
            				var y2 = qy + qy;
            				var z2 = qz + qz;
            				var xx = qx * x2;
            				var xy = qx * y2;
            				var xz = qx * z2;
            				var yy = qy * y2;
            				var yz = qy * z2;
            				var zz = qz * z2;
            				var wx = qw * x2;
            				var wy = qw * y2;
            				var wz = qw * z2;
            				var m = this.data;
            				m[0] = (1 - (yy + zz)) * sx;
            				m[1] = (xy + wz) * sx;
            				m[2] = (xz - wy) * sx;
            				m[3] = 0;
            				m[4] = (xy - wz) * sy;
            				m[5] = (1 - (xx + zz)) * sy;
            				m[6] = (yz + wx) * sy;
            				m[7] = 0;
            				m[8] = (xz + wy) * sz;
            				m[9] = (yz - wx) * sz;
            				m[10] = (1 - (xx + yy)) * sz;
            				m[11] = 0;
            				m[12] = t.x;
            				m[13] = t.y;
            				m[14] = t.z;
            				m[15] = 1;
            				return this;
            		}
            		transpose(src) {
            				if (src === void 0) src = this;
            				var s = src.data;
            				var t = this.data;
            				if (s === t) {
            						var tmp;
            						tmp = s[1];
            						t[1] = s[4];
            						t[4] = tmp;
            						tmp = s[2];
            						t[2] = s[8];
            						t[8] = tmp;
            						tmp = s[3];
            						t[3] = s[12];
            						t[12] = tmp;
            						tmp = s[6];
            						t[6] = s[9];
            						t[9] = tmp;
            						tmp = s[7];
            						t[7] = s[13];
            						t[13] = tmp;
            						tmp = s[11];
            						t[11] = s[14];
            						t[14] = tmp;
            				} else {
            						t[0] = s[0];
            						t[1] = s[4];
            						t[2] = s[8];
            						t[3] = s[12];
            						t[4] = s[1];
            						t[5] = s[5];
            						t[6] = s[9];
            						t[7] = s[13];
            						t[8] = s[2];
            						t[9] = s[6];
            						t[10] = s[10];
            						t[11] = s[14];
            						t[12] = s[3];
            						t[13] = s[7];
            						t[14] = s[11];
            						t[15] = s[15];
            				}
            				return this;
            		}
            		getTranslation(t) {
            				if (t === void 0) t = new Vec3();
            				return t.set(this.data[12], this.data[13], this.data[14]);
            		}
            		getX(x) {
            				if (x === void 0) x = new Vec3();
            				return x.set(this.data[0], this.data[1], this.data[2]);
            		}
            		getY(y) {
            				if (y === void 0) y = new Vec3();
            				return y.set(this.data[4], this.data[5], this.data[6]);
            		}
            		getZ(z) {
            				if (z === void 0) z = new Vec3();
            				return z.set(this.data[8], this.data[9], this.data[10]);
            		}
            		getScale(scale) {
            				if (scale === void 0) scale = new Vec3();
            				this.getX(x$1);
            				this.getY(y$1);
            				this.getZ(z$1);
            				scale.set(x$1.length(), y$1.length(), z$1.length());
            				return scale;
            		}
            		get scaleSign() {
            				this.getX(x$1);
            				this.getY(y$1);
            				this.getZ(z$1);
            				x$1.cross(x$1, y$1);
            				return x$1.dot(z$1) < 0 ? -1 : 1;
            		}
            		setFromEulerAngles(ex, ey, ez) {
            				ex *= math.DEG_TO_RAD;
            				ey *= math.DEG_TO_RAD;
            				ez *= math.DEG_TO_RAD;
            				var s1 = Math.sin(-ex);
            				var c1 = Math.cos(-ex);
            				var s2 = Math.sin(-ey);
            				var c2 = Math.cos(-ey);
            				var s3 = Math.sin(-ez);
            				var c3 = Math.cos(-ez);
            				var m = this.data;
            				m[0] = c2 * c3;
            				m[1] = -c2 * s3;
            				m[2] = s2;
            				m[3] = 0;
            				m[4] = c1 * s3 + c3 * s1 * s2;
            				m[5] = c1 * c3 - s1 * s2 * s3;
            				m[6] = -c2 * s1;
            				m[7] = 0;
            				m[8] = s1 * s3 - c1 * c3 * s2;
            				m[9] = c3 * s1 + c1 * s2 * s3;
            				m[10] = c1 * c2;
            				m[11] = 0;
            				m[12] = 0;
            				m[13] = 0;
            				m[14] = 0;
            				m[15] = 1;
            				return this;
            		}
            		getEulerAngles(eulers) {
            				if (eulers === void 0) eulers = new Vec3();
            				this.getScale(scale);
            				var sx = scale.x;
            				var sy = scale.y;
            				var sz = scale.z;
            				if (sx === 0 || sy === 0 || sz === 0) {
            						return eulers.set(0, 0, 0);
            				}
            				var m = this.data;
            				var y = Math.asin(-m[2] / sx);
            				var halfPi = Math.PI * 0.5;
            				var x, z;
            				if (y < halfPi) {
            						if (y > -halfPi) {
            								x = Math.atan2(m[6] / sy, m[10] / sz);
            								z = Math.atan2(m[1] / sx, m[0] / sx);
            						} else {
            								z = 0;
            								x = -Math.atan2(m[4] / sy, m[5] / sy);
            						}
            				} else {
            						z = 0;
            						x = Math.atan2(m[4] / sy, m[5] / sy);
            				}
            				return eulers.set(x, y, z).mulScalar(math.RAD_TO_DEG);
            		}
            		toString() {
            				return "[" + this.data.join(', ') + "]";
            		}
            		constructor(){
            				this.data = new Float32Array(16);
            				this.data[0] = this.data[5] = this.data[10] = this.data[15] = 1;
            		}
            }
            Mat4.IDENTITY = Object.freeze(new Mat4());
            Mat4.ZERO = Object.freeze(new Mat4().set([
            		0,
            		0,
            		0,
            		0,
            		0,
            		0,
            		0,
            		0,
            		0,
            		0,
            		0,
            		0,
            		0,
            		0,
            		0,
            		0
            ]));
            
            class Quat {
            		clone() {
            				var cstr = this.constructor;
            				return new cstr(this.x, this.y, this.z, this.w);
            		}
            		conjugate(src) {
            				if (src === void 0) src = this;
            				this.x = src.x * -1;
            				this.y = src.y * -1;
            				this.z = src.z * -1;
            				this.w = src.w;
            				return this;
            		}
            		copy(rhs) {
            				this.x = rhs.x;
            				this.y = rhs.y;
            				this.z = rhs.z;
            				this.w = rhs.w;
            				return this;
            		}
            		equals(rhs) {
            				return this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;
            		}
            		equalsApprox(rhs, epsilon) {
            				if (epsilon === void 0) epsilon = 1e-6;
            				return Math.abs(this.x - rhs.x) < epsilon && Math.abs(this.y - rhs.y) < epsilon && Math.abs(this.z - rhs.z) < epsilon && Math.abs(this.w - rhs.w) < epsilon;
            		}
            		getAxisAngle(axis) {
            				var rad = Math.acos(this.w) * 2;
            				var s = Math.sin(rad / 2);
            				if (s !== 0) {
            						axis.x = this.x / s;
            						axis.y = this.y / s;
            						axis.z = this.z / s;
            						if (axis.x < 0 || axis.y < 0 || axis.z < 0) {
            								axis.x *= -1;
            								axis.y *= -1;
            								axis.z *= -1;
            								rad *= -1;
            						}
            				} else {
            						axis.x = 1;
            						axis.y = 0;
            						axis.z = 0;
            				}
            				return rad * math.RAD_TO_DEG;
            		}
            		getEulerAngles(eulers) {
            				if (eulers === void 0) eulers = new Vec3();
            				var x, y, z;
            				var qx = this.x;
            				var qy = this.y;
            				var qz = this.z;
            				var qw = this.w;
            				var a2 = 2 * (qw * qy - qx * qz);
            				if (a2 <= -0.99999) {
            						x = 2 * Math.atan2(qx, qw);
            						y = -Math.PI / 2;
            						z = 0;
            				} else if (a2 >= 0.99999) {
            						x = 2 * Math.atan2(qx, qw);
            						y = Math.PI / 2;
            						z = 0;
            				} else {
            						x = Math.atan2(2 * (qw * qx + qy * qz), 1 - 2 * (qx * qx + qy * qy));
            						y = Math.asin(a2);
            						z = Math.atan2(2 * (qw * qz + qx * qy), 1 - 2 * (qy * qy + qz * qz));
            				}
            				return eulers.set(x, y, z).mulScalar(math.RAD_TO_DEG);
            		}
            		invert(src) {
            				if (src === void 0) src = this;
            				return this.conjugate(src).normalize();
            		}
            		length() {
            				return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            		}
            		lengthSq() {
            				return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            		}
            		mul(rhs) {
            				var q1x = this.x;
            				var q1y = this.y;
            				var q1z = this.z;
            				var q1w = this.w;
            				var q2x = rhs.x;
            				var q2y = rhs.y;
            				var q2z = rhs.z;
            				var q2w = rhs.w;
            				this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
            				this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
            				this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
            				this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;
            				return this;
            		}
            		mulScalar(scalar, src) {
            				if (src === void 0) src = this;
            				this.x = src.x * scalar;
            				this.y = src.y * scalar;
            				this.z = src.z * scalar;
            				this.w = src.w * scalar;
            				return this;
            		}
            		mul2(lhs, rhs) {
            				var q1x = lhs.x;
            				var q1y = lhs.y;
            				var q1z = lhs.z;
            				var q1w = lhs.w;
            				var q2x = rhs.x;
            				var q2y = rhs.y;
            				var q2z = rhs.z;
            				var q2w = rhs.w;
            				this.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;
            				this.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;
            				this.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;
            				this.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;
            				return this;
            		}
            		normalize(src) {
            				if (src === void 0) src = this;
            				var len = src.length();
            				if (len === 0) {
            						this.x = this.y = this.z = 0;
            						this.w = 1;
            				} else {
            						len = 1 / len;
            						this.x = src.x * len;
            						this.y = src.y * len;
            						this.z = src.z * len;
            						this.w = src.w * len;
            				}
            				return this;
            		}
            		set(x, y, z, w) {
            				this.x = x;
            				this.y = y;
            				this.z = z;
            				this.w = w;
            				return this;
            		}
            		setFromAxisAngle(axis, angle) {
            				angle *= 0.5 * math.DEG_TO_RAD;
            				var sa = Math.sin(angle);
            				var ca = Math.cos(angle);
            				this.x = sa * axis.x;
            				this.y = sa * axis.y;
            				this.z = sa * axis.z;
            				this.w = ca;
            				return this;
            		}
            		setFromEulerAngles(ex, ey, ez) {
            				if (ex instanceof Vec3) {
            						var vec = ex;
            						ex = vec.x;
            						ey = vec.y;
            						ez = vec.z;
            				}
            				var halfToRad = 0.5 * math.DEG_TO_RAD;
            				ex *= halfToRad;
            				ey *= halfToRad;
            				ez *= halfToRad;
            				var sx = Math.sin(ex);
            				var cx = Math.cos(ex);
            				var sy = Math.sin(ey);
            				var cy = Math.cos(ey);
            				var sz = Math.sin(ez);
            				var cz = Math.cos(ez);
            				this.x = sx * cy * cz - cx * sy * sz;
            				this.y = cx * sy * cz + sx * cy * sz;
            				this.z = cx * cy * sz - sx * sy * cz;
            				this.w = cx * cy * cz + sx * sy * sz;
            				return this;
            		}
            		setFromMat4(m) {
            				var d = m.data;
            				var m00 = d[0];
            				var m01 = d[1];
            				var m02 = d[2];
            				var m10 = d[4];
            				var m11 = d[5];
            				var m12 = d[6];
            				var m20 = d[8];
            				var m21 = d[9];
            				var m22 = d[10];
            				var l;
            				l = m00 * m00 + m01 * m01 + m02 * m02;
            				if (l === 0) return this.set(0, 0, 0, 1);
            				l = 1 / Math.sqrt(l);
            				m00 *= l;
            				m01 *= l;
            				m02 *= l;
            				l = m10 * m10 + m11 * m11 + m12 * m12;
            				if (l === 0) return this.set(0, 0, 0, 1);
            				l = 1 / Math.sqrt(l);
            				m10 *= l;
            				m11 *= l;
            				m12 *= l;
            				l = m20 * m20 + m21 * m21 + m22 * m22;
            				if (l === 0) return this.set(0, 0, 0, 1);
            				l = 1 / Math.sqrt(l);
            				m20 *= l;
            				m21 *= l;
            				m22 *= l;
            				if (m22 < 0) {
            						if (m00 > m11) {
            								this.set(1 + m00 - m11 - m22, m01 + m10, m20 + m02, m12 - m21);
            						} else {
            								this.set(m01 + m10, 1 - m00 + m11 - m22, m12 + m21, m20 - m02);
            						}
            				} else {
            						if (m00 < -m11) {
            								this.set(m20 + m02, m12 + m21, 1 - m00 - m11 + m22, m01 - m10);
            						} else {
            								this.set(m12 - m21, m20 - m02, m01 - m10, 1 + m00 + m11 + m22);
            						}
            				}
            				return this.mulScalar(1.0 / this.length());
            		}
            		setFromDirections(from, to) {
            				var dotProduct = 1 + from.dot(to);
            				if (dotProduct < Number.EPSILON) {
            						if (Math.abs(from.x) > Math.abs(from.y)) {
            								this.x = -from.z;
            								this.y = 0;
            								this.z = from.x;
            								this.w = 0;
            						} else {
            								this.x = 0;
            								this.y = -from.z;
            								this.z = from.y;
            								this.w = 0;
            						}
            				} else {
            						this.x = from.y * to.z - from.z * to.y;
            						this.y = from.z * to.x - from.x * to.z;
            						this.z = from.x * to.y - from.y * to.x;
            						this.w = dotProduct;
            				}
            				return this.normalize();
            		}
            		slerp(lhs, rhs, alpha) {
            				var lx = lhs.x;
            				var ly = lhs.y;
            				var lz = lhs.z;
            				var lw = lhs.w;
            				var rx = rhs.x;
            				var ry = rhs.y;
            				var rz = rhs.z;
            				var rw = rhs.w;
            				var cosHalfTheta = lw * rw + lx * rx + ly * ry + lz * rz;
            				if (cosHalfTheta < 0) {
            						rw = -rw;
            						rx = -rx;
            						ry = -ry;
            						rz = -rz;
            						cosHalfTheta = -cosHalfTheta;
            				}
            				if (Math.abs(cosHalfTheta) >= 1) {
            						this.w = lw;
            						this.x = lx;
            						this.y = ly;
            						this.z = lz;
            						return this;
            				}
            				var halfTheta = Math.acos(cosHalfTheta);
            				var sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);
            				if (Math.abs(sinHalfTheta) < 0.001) {
            						this.w = lw * 0.5 + rw * 0.5;
            						this.x = lx * 0.5 + rx * 0.5;
            						this.y = ly * 0.5 + ry * 0.5;
            						this.z = lz * 0.5 + rz * 0.5;
            						return this;
            				}
            				var ratioA = Math.sin((1 - alpha) * halfTheta) / sinHalfTheta;
            				var ratioB = Math.sin(alpha * halfTheta) / sinHalfTheta;
            				this.w = lw * ratioA + rw * ratioB;
            				this.x = lx * ratioA + rx * ratioB;
            				this.y = ly * ratioA + ry * ratioB;
            				this.z = lz * ratioA + rz * ratioB;
            				return this;
            		}
            		transformVector(vec, res) {
            				if (res === void 0) res = new Vec3();
            				var x = vec.x, y = vec.y, z = vec.z;
            				var qx = this.x, qy = this.y, qz = this.z, qw = this.w;
            				var ix = qw * x + qy * z - qz * y;
            				var iy = qw * y + qz * x - qx * z;
            				var iz = qw * z + qx * y - qy * x;
            				var iw = -qx * x - qy * y - qz * z;
            				res.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            				res.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            				res.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
            				return res;
            		}
            		toString() {
            				return "[" + this.x + ", " + this.y + ", " + this.z + ", " + this.w + "]";
            		}
            		constructor(x = 0, y = 0, z = 0, w = 1){
            				if (x.length === 4) {
            						this.x = x[0];
            						this.y = x[1];
            						this.z = x[2];
            						this.w = x[3];
            				} else {
            						this.x = x;
            						this.y = y;
            						this.z = z;
            						this.w = w;
            				}
            		}
            }
            Quat.IDENTITY = Object.freeze(new Quat(0, 0, 0, 1));
            Quat.ZERO = Object.freeze(new Quat(0, 0, 0, 0));
            
            var tmpVecA$1 = new Vec3();
            var tmpVecB$1 = new Vec3();
            var tmpVecC = new Vec3();
            var tmpVecD = new Vec3();
            var tmpVecE = new Vec3();
            class BoundingBox {
            		add(other) {
            				var tc = this.center;
            				var tcx = tc.x;
            				var tcy = tc.y;
            				var tcz = tc.z;
            				var th = this.halfExtents;
            				var thx = th.x;
            				var thy = th.y;
            				var thz = th.z;
            				var tminx = tcx - thx;
            				var tmaxx = tcx + thx;
            				var tminy = tcy - thy;
            				var tmaxy = tcy + thy;
            				var tminz = tcz - thz;
            				var tmaxz = tcz + thz;
            				var oc = other.center;
            				var ocx = oc.x;
            				var ocy = oc.y;
            				var ocz = oc.z;
            				var oh = other.halfExtents;
            				var ohx = oh.x;
            				var ohy = oh.y;
            				var ohz = oh.z;
            				var ominx = ocx - ohx;
            				var omaxx = ocx + ohx;
            				var ominy = ocy - ohy;
            				var omaxy = ocy + ohy;
            				var ominz = ocz - ohz;
            				var omaxz = ocz + ohz;
            				if (ominx < tminx) tminx = ominx;
            				if (omaxx > tmaxx) tmaxx = omaxx;
            				if (ominy < tminy) tminy = ominy;
            				if (omaxy > tmaxy) tmaxy = omaxy;
            				if (ominz < tminz) tminz = ominz;
            				if (omaxz > tmaxz) tmaxz = omaxz;
            				tc.x = (tminx + tmaxx) * 0.5;
            				tc.y = (tminy + tmaxy) * 0.5;
            				tc.z = (tminz + tmaxz) * 0.5;
            				th.x = (tmaxx - tminx) * 0.5;
            				th.y = (tmaxy - tminy) * 0.5;
            				th.z = (tmaxz - tminz) * 0.5;
            		}
            		copy(src) {
            				this.center.copy(src.center);
            				this.halfExtents.copy(src.halfExtents);
            		}
            		clone() {
            				return new BoundingBox(this.center, this.halfExtents);
            		}
            		intersects(other) {
            				var aMax = this.getMax();
            				var aMin = this.getMin();
            				var bMax = other.getMax();
            				var bMin = other.getMin();
            				return aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;
            		}
            		_intersectsRay(ray, point) {
            				var tMin = tmpVecA$1.copy(this.getMin()).sub(ray.origin);
            				var tMax = tmpVecB$1.copy(this.getMax()).sub(ray.origin);
            				var dir = ray.direction;
            				if (dir.x === 0) {
            						tMin.x = tMin.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
            						tMax.x = tMax.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
            				} else {
            						tMin.x /= dir.x;
            						tMax.x /= dir.x;
            				}
            				if (dir.y === 0) {
            						tMin.y = tMin.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
            						tMax.y = tMax.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
            				} else {
            						tMin.y /= dir.y;
            						tMax.y /= dir.y;
            				}
            				if (dir.z === 0) {
            						tMin.z = tMin.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
            						tMax.z = tMax.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
            				} else {
            						tMin.z /= dir.z;
            						tMax.z /= dir.z;
            				}
            				var realMin = tmpVecC.set(Math.min(tMin.x, tMax.x), Math.min(tMin.y, tMax.y), Math.min(tMin.z, tMax.z));
            				var realMax = tmpVecD.set(Math.max(tMin.x, tMax.x), Math.max(tMin.y, tMax.y), Math.max(tMin.z, tMax.z));
            				var minMax = Math.min(Math.min(realMax.x, realMax.y), realMax.z);
            				var maxMin = Math.max(Math.max(realMin.x, realMin.y), realMin.z);
            				var intersects = minMax >= maxMin && maxMin >= 0;
            				if (intersects) {
            						point.copy(ray.direction).mulScalar(maxMin).add(ray.origin);
            				}
            				return intersects;
            		}
            		_fastIntersectsRay(ray) {
            				var diff = tmpVecA$1;
            				var cross = tmpVecB$1;
            				var prod = tmpVecC;
            				var absDiff = tmpVecD;
            				var absDir = tmpVecE;
            				var rayDir = ray.direction;
            				diff.sub2(ray.origin, this.center);
            				absDiff.set(Math.abs(diff.x), Math.abs(diff.y), Math.abs(diff.z));
            				prod.mul2(diff, rayDir);
            				if (absDiff.x > this.halfExtents.x && prod.x >= 0) {
            						return false;
            				}
            				if (absDiff.y > this.halfExtents.y && prod.y >= 0) {
            						return false;
            				}
            				if (absDiff.z > this.halfExtents.z && prod.z >= 0) {
            						return false;
            				}
            				absDir.set(Math.abs(rayDir.x), Math.abs(rayDir.y), Math.abs(rayDir.z));
            				cross.cross(rayDir, diff);
            				cross.set(Math.abs(cross.x), Math.abs(cross.y), Math.abs(cross.z));
            				if (cross.x > this.halfExtents.y * absDir.z + this.halfExtents.z * absDir.y) {
            						return false;
            				}
            				if (cross.y > this.halfExtents.x * absDir.z + this.halfExtents.z * absDir.x) {
            						return false;
            				}
            				if (cross.z > this.halfExtents.x * absDir.y + this.halfExtents.y * absDir.x) {
            						return false;
            				}
            				return true;
            		}
            		intersectsRay(ray, point) {
            				if (point) {
            						return this._intersectsRay(ray, point);
            				}
            				return this._fastIntersectsRay(ray);
            		}
            		setMinMax(min, max) {
            				this.center.add2(max, min).mulScalar(0.5);
            				this.halfExtents.sub2(max, min).mulScalar(0.5);
            		}
            		getMin() {
            				return this._min.copy(this.center).sub(this.halfExtents);
            		}
            		getMax() {
            				return this._max.copy(this.center).add(this.halfExtents);
            		}
            		containsPoint(point) {
            				var min = this.getMin();
            				var max = this.getMax();
            				if (point.x < min.x || point.x > max.x || point.y < min.y || point.y > max.y || point.z < min.z || point.z > max.z) {
            						return false;
            				}
            				return true;
            		}
            		setFromTransformedAabb(aabb, m, ignoreScale) {
            				if (ignoreScale === void 0) ignoreScale = false;
            				var ac = aabb.center;
            				var ar = aabb.halfExtents;
            				var d = m.data;
            				var mx0 = d[0];
            				var mx1 = d[4];
            				var mx2 = d[8];
            				var my0 = d[1];
            				var my1 = d[5];
            				var my2 = d[9];
            				var mz0 = d[2];
            				var mz1 = d[6];
            				var mz2 = d[10];
            				if (ignoreScale) {
            						var lengthSq = mx0 * mx0 + mx1 * mx1 + mx2 * mx2;
            						if (lengthSq > 0) {
            								var invLength = 1 / Math.sqrt(lengthSq);
            								mx0 *= invLength;
            								mx1 *= invLength;
            								mx2 *= invLength;
            						}
            						lengthSq = my0 * my0 + my1 * my1 + my2 * my2;
            						if (lengthSq > 0) {
            								var invLength1 = 1 / Math.sqrt(lengthSq);
            								my0 *= invLength1;
            								my1 *= invLength1;
            								my2 *= invLength1;
            						}
            						lengthSq = mz0 * mz0 + mz1 * mz1 + mz2 * mz2;
            						if (lengthSq > 0) {
            								var invLength2 = 1 / Math.sqrt(lengthSq);
            								mz0 *= invLength2;
            								mz1 *= invLength2;
            								mz2 *= invLength2;
            						}
            				}
            				this.center.set(d[12] + mx0 * ac.x + mx1 * ac.y + mx2 * ac.z, d[13] + my0 * ac.x + my1 * ac.y + my2 * ac.z, d[14] + mz0 * ac.x + mz1 * ac.y + mz2 * ac.z);
            				this.halfExtents.set(Math.abs(mx0) * ar.x + Math.abs(mx1) * ar.y + Math.abs(mx2) * ar.z, Math.abs(my0) * ar.x + Math.abs(my1) * ar.y + Math.abs(my2) * ar.z, Math.abs(mz0) * ar.x + Math.abs(mz1) * ar.y + Math.abs(mz2) * ar.z);
            		}
            		static computeMinMax(vertices, min, max, numVerts) {
            				if (numVerts === void 0) numVerts = vertices.length / 3;
            				if (numVerts > 0) {
            						var minx = vertices[0];
            						var miny = vertices[1];
            						var minz = vertices[2];
            						var maxx = minx;
            						var maxy = miny;
            						var maxz = minz;
            						var n = numVerts * 3;
            						for(var i = 3; i < n; i += 3){
            								var x = vertices[i];
            								var y = vertices[i + 1];
            								var z = vertices[i + 2];
            								if (x < minx) minx = x;
            								if (y < miny) miny = y;
            								if (z < minz) minz = z;
            								if (x > maxx) maxx = x;
            								if (y > maxy) maxy = y;
            								if (z > maxz) maxz = z;
            						}
            						min.set(minx, miny, minz);
            						max.set(maxx, maxy, maxz);
            				}
            		}
            		compute(vertices, numVerts) {
            				BoundingBox.computeMinMax(vertices, tmpVecA$1, tmpVecB$1, numVerts);
            				this.setMinMax(tmpVecA$1, tmpVecB$1);
            		}
            		intersectsBoundingSphere(sphere) {
            				var sq = this._distanceToBoundingSphereSq(sphere);
            				if (sq <= sphere.radius * sphere.radius) {
            						return true;
            				}
            				return false;
            		}
            		_distanceToBoundingSphereSq(sphere) {
            				var boxMin = this.getMin();
            				var boxMax = this.getMax();
            				var sq = 0;
            				var axis = [
            						'x',
            						'y',
            						'z'
            				];
            				for(var i = 0; i < 3; ++i){
            						var out = 0;
            						var pn = sphere.center[axis[i]];
            						var bMin = boxMin[axis[i]];
            						var bMax = boxMax[axis[i]];
            						var val = 0;
            						if (pn < bMin) {
            								val = bMin - pn;
            								out += val * val;
            						}
            						if (pn > bMax) {
            								val = pn - bMax;
            								out += val * val;
            						}
            						sq += out;
            				}
            				return sq;
            		}
            		_expand(expandMin, expandMax) {
            				tmpVecA$1.add2(this.getMin(), expandMin);
            				tmpVecB$1.add2(this.getMax(), expandMax);
            				this.setMinMax(tmpVecA$1, tmpVecB$1);
            		}
            		constructor(center, halfExtents){
            				this.center = new Vec3();
            				this.halfExtents = new Vec3(0.5, 0.5, 0.5);
            				this._min = new Vec3();
            				this._max = new Vec3();
            				if (center) {
            						this.center.copy(center);
            				}
            				if (halfExtents) {
            						this.halfExtents.copy(halfExtents);
            				}
            		}
            }
            
            var tmpVecA = new Vec3();
            var tmpVecB = new Vec3();
            class BoundingSphere {
            		containsPoint(point) {
            				var lenSq = tmpVecA.sub2(point, this.center).lengthSq();
            				var r = this.radius;
            				return lenSq < r * r;
            		}
            		intersectsRay(ray, point) {
            				var m = tmpVecA.copy(ray.origin).sub(this.center);
            				var b = m.dot(tmpVecB.copy(ray.direction).normalize());
            				var c = m.dot(m) - this.radius * this.radius;
            				if (c > 0 && b > 0) {
            						return false;
            				}
            				var discr = b * b - c;
            				if (discr < 0) {
            						return false;
            				}
            				var t = Math.abs(-b - Math.sqrt(discr));
            				if (point) {
            						point.copy(ray.direction).mulScalar(t).add(ray.origin);
            				}
            				return true;
            		}
            		intersectsBoundingSphere(sphere) {
            				tmpVecA.sub2(sphere.center, this.center);
            				var totalRadius = sphere.radius + this.radius;
            				if (tmpVecA.lengthSq() <= totalRadius * totalRadius) {
            						return true;
            				}
            				return false;
            		}
            		constructor(center = new Vec3(), radius = 0.5){
            				this.center = center;
            				this.radius = radius;
            		}
            }
            
            class Plane {
            		clone() {
            				var cstr = this.constructor;
            				return new cstr().copy(this);
            		}
            		copy(src) {
            				this.normal.copy(src.normal);
            				this.distance = src.distance;
            				return this;
            		}
            		intersectsLine(start, end, point) {
            				var d = this.distance;
            				var d0 = this.normal.dot(start) + d;
            				var d1 = this.normal.dot(end) + d;
            				var t = d0 / (d0 - d1);
            				var intersects = t >= 0 && t <= 1;
            				if (intersects && point) {
            						point.lerp(start, end, t);
            				}
            				return intersects;
            		}
            		intersectsRay(ray, point) {
            				var denominator = this.normal.dot(ray.direction);
            				if (denominator === 0) {
            						return false;
            				}
            				var t = -(this.normal.dot(ray.origin) + this.distance) / denominator;
            				if (t >= 0 && point) {
            						point.copy(ray.direction).mulScalar(t).add(ray.origin);
            				}
            				return t >= 0;
            		}
            		normalize() {
            				var invLength = 1 / this.normal.length();
            				this.normal.mulScalar(invLength);
            				this.distance *= invLength;
            				return this;
            		}
            		set(nx, ny, nz, d) {
            				this.normal.set(nx, ny, nz);
            				this.distance = d;
            				return this;
            		}
            		setFromPointNormal(point, normal) {
            				this.normal.copy(normal);
            				this.distance = -this.normal.dot(point);
            				return this;
            		}
            		constructor(normal = Vec3.UP, distance = 0){
            				this.normal = new Vec3();
            				this.normal.copy(normal);
            				this.distance = distance;
            		}
            }
            
            class Frustum {
            		clone() {
            				var cstr = this.constructor;
            				return new cstr().copy(this);
            		}
            		copy(src) {
            				for(var i = 0; i < 6; i++){
            						this.planes[i].copy(src.planes[i]);
            				}
            				return this;
            		}
            		setFromMat4(matrix) {
            				var [m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33] = matrix.data;
            				var planes = this.planes;
            				planes[0].set(m03 - m00, m13 - m10, m23 - m20, m33 - m30).normalize();
            				planes[1].set(m03 + m00, m13 + m10, m23 + m20, m33 + m30).normalize();
            				planes[2].set(m03 + m01, m13 + m11, m23 + m21, m33 + m31).normalize();
            				planes[3].set(m03 - m01, m13 - m11, m23 - m21, m33 - m31).normalize();
            				planes[4].set(m03 - m02, m13 - m12, m23 - m22, m33 - m32).normalize();
            				planes[5].set(m03 + m02, m13 + m12, m23 + m22, m33 + m32).normalize();
            		}
            		containsPoint(point) {
            				for(var p = 0; p < 6; p++){
            						var { normal, distance } = this.planes[p];
            						if (normal.dot(point) + distance <= 0) {
            								return false;
            						}
            				}
            				return true;
            		}
            		containsSphere(sphere) {
            				var { center, radius } = sphere;
            				var c = 0;
            				for(var p = 0; p < 6; p++){
            						var { normal, distance } = this.planes[p];
            						var d = normal.dot(center) + distance;
            						if (d <= -radius) {
            								return 0;
            						}
            						if (d > radius) {
            								c++;
            						}
            				}
            				return c === 6 ? 2 : 1;
            		}
            		constructor(){
            				this.planes = [];
            				for(var i = 0; i < 6; i++){
            						this.planes[i] = new Plane();
            				}
            		}
            }
            
            class Ray {
            		set(origin, direction) {
            				this.origin.copy(origin);
            				this.direction.copy(direction);
            				return this;
            		}
            		copy(src) {
            				return this.set(src.origin, src.direction);
            		}
            		clone() {
            				return new this.constructor(this.origin, this.direction);
            		}
            		constructor(origin, direction){
            				this.origin = new Vec3();
            				this.direction = Vec3.FORWARD.clone();
            				if (origin) {
            						this.origin.copy(origin);
            				}
            				if (direction) {
            						this.direction.copy(direction);
            				}
            		}
            }
            
            var DISTANCE_LINEAR = 'linear';
            var DISTANCE_INVERSE = 'inverse';
            var DISTANCE_EXPONENTIAL = 'exponential';
            
            var ADDRESS_REPEAT = 0;
            var ADDRESS_CLAMP_TO_EDGE = 1;
            var ADDRESS_MIRRORED_REPEAT = 2;
            var BLENDMODE_ZERO = 0;
            var BLENDMODE_ONE = 1;
            var BLENDMODE_SRC_COLOR = 2;
            var BLENDMODE_DST_COLOR = 4;
            var BLENDMODE_ONE_MINUS_DST_COLOR = 5;
            var BLENDMODE_SRC_ALPHA = 6;
            var BLENDMODE_ONE_MINUS_SRC_ALPHA = 8;
            var BLENDEQUATION_ADD = 0;
            var BLENDEQUATION_REVERSE_SUBTRACT = 2;
            var BLENDEQUATION_MIN = 3;
            var BLENDEQUATION_MAX = 4;
            var BUFFER_STATIC = 0;
            var BUFFER_DYNAMIC = 1;
            var BUFFER_STREAM = 2;
            var BUFFER_GPUDYNAMIC = 3;
            var CLEARFLAG_COLOR = 1;
            var CLEARFLAG_DEPTH = 2;
            var CLEARFLAG_STENCIL = 4;
            var CULLFACE_NONE = 0;
            var CULLFACE_BACK = 1;
            var CULLFACE_FRONT = 2;
            var CULLFACE_FRONTANDBACK = 3;
            var FILTER_NEAREST = 0;
            var FILTER_LINEAR = 1;
            var FILTER_NEAREST_MIPMAP_NEAREST = 2;
            var FILTER_NEAREST_MIPMAP_LINEAR = 3;
            var FILTER_LINEAR_MIPMAP_NEAREST = 4;
            var FILTER_LINEAR_MIPMAP_LINEAR = 5;
            var FUNC_NEVER = 0;
            var FUNC_LESS = 1;
            var FUNC_EQUAL = 2;
            var FUNC_LESSEQUAL = 3;
            var FUNC_GREATER = 4;
            var FUNC_NOTEQUAL = 5;
            var FUNC_GREATEREQUAL = 6;
            var FUNC_ALWAYS = 7;
            var INDEXFORMAT_UINT8 = 0;
            var INDEXFORMAT_UINT16 = 1;
            var INDEXFORMAT_UINT32 = 2;
            var PIXELFORMAT_A8 = 0;
            var PIXELFORMAT_L8 = 1;
            var PIXELFORMAT_LA8 = 2;
            var PIXELFORMAT_RGB565 = 3;
            var PIXELFORMAT_RGBA5551 = 4;
            var PIXELFORMAT_RGBA4 = 5;
            var PIXELFORMAT_RGB8 = 6;
            var PIXELFORMAT_RGBA8 = 7;
            var PIXELFORMAT_DXT1 = 8;
            var PIXELFORMAT_DXT3 = 9;
            var PIXELFORMAT_DXT5 = 10;
            var PIXELFORMAT_RGB16F = 11;
            var PIXELFORMAT_RGBA16F = 12;
            var PIXELFORMAT_RGB32F = 13;
            var PIXELFORMAT_RGBA32F = 14;
            var PIXELFORMAT_R32F = 15;
            var PIXELFORMAT_DEPTH = 16;
            var PIXELFORMAT_DEPTHSTENCIL = 17;
            var PIXELFORMAT_111110F = 18;
            var PIXELFORMAT_SRGB8 = 19;
            var PIXELFORMAT_SRGBA8 = 20;
            var PIXELFORMAT_ETC1 = 21;
            var PIXELFORMAT_ETC2_RGB = 22;
            var PIXELFORMAT_ETC2_RGBA = 23;
            var PIXELFORMAT_PVRTC_2BPP_RGB_1 = 24;
            var PIXELFORMAT_PVRTC_2BPP_RGBA_1 = 25;
            var PIXELFORMAT_PVRTC_4BPP_RGB_1 = 26;
            var PIXELFORMAT_PVRTC_4BPP_RGBA_1 = 27;
            var PIXELFORMAT_ASTC_4x4 = 28;
            var PIXELFORMAT_ATC_RGB = 29;
            var PIXELFORMAT_ATC_RGBA = 30;
            var PIXELFORMAT_BGRA8 = 31;
            var PIXELFORMAT_R8I = 32;
            var PIXELFORMAT_R8U = 33;
            var PIXELFORMAT_R16I = 34;
            var PIXELFORMAT_R16U = 35;
            var PIXELFORMAT_R32I = 36;
            var PIXELFORMAT_R32U = 37;
            var PIXELFORMAT_RG8I = 38;
            var PIXELFORMAT_RG8U = 39;
            var PIXELFORMAT_RG16I = 40;
            var PIXELFORMAT_RG16U = 41;
            var PIXELFORMAT_RG32I = 42;
            var PIXELFORMAT_RG32U = 43;
            var PIXELFORMAT_RGBA8I = 44;
            var PIXELFORMAT_RGBA8U = 45;
            var PIXELFORMAT_RGBA16I = 46;
            var PIXELFORMAT_RGBA16U = 47;
            var PIXELFORMAT_RGBA32I = 48;
            var PIXELFORMAT_RGBA32U = 49;
            var PIXELFORMAT_R16F = 50;
            var PIXELFORMAT_RG16F = 51;
            var PIXELFORMAT_R8 = 52;
            var PIXELFORMAT_RG8 = 53;
            var PIXELFORMAT_DXT1_SRGB = 54;
            var PIXELFORMAT_DXT3_SRGBA = 55;
            var PIXELFORMAT_DXT5_SRGBA = 56;
            var PIXELFORMAT_ETC2_SRGB = 61;
            var PIXELFORMAT_ETC2_SRGBA = 62;
            var PIXELFORMAT_ASTC_4x4_SRGB = 63;
            var PIXELFORMAT_SBGRA8 = 64;
            var PIXELFORMAT_BC6F = 65;
            var PIXELFORMAT_BC6UF = 66;
            var PIXELFORMAT_BC7 = 67;
            var PIXELFORMAT_BC7_SRGBA = 68;
            var PIXELFORMAT_DEPTH16 = 69;
            var pixelFormatInfo = new Map([
            		[
            				PIXELFORMAT_A8,
            				{
            						name: 'A8',
            						size: 1,
            						ldr: true
            				}
            		],
            		[
            				PIXELFORMAT_R8,
            				{
            						name: 'R8',
            						size: 1,
            						ldr: true
            				}
            		],
            		[
            				PIXELFORMAT_L8,
            				{
            						name: 'L8',
            						size: 1,
            						ldr: true
            				}
            		],
            		[
            				PIXELFORMAT_LA8,
            				{
            						name: 'LA8',
            						size: 2,
            						ldr: true
            				}
            		],
            		[
            				PIXELFORMAT_RG8,
            				{
            						name: 'RG8',
            						size: 2,
            						ldr: true
            				}
            		],
            		[
            				PIXELFORMAT_RGB565,
            				{
            						name: 'RGB565',
            						size: 2,
            						ldr: true
            				}
            		],
            		[
            				PIXELFORMAT_RGBA5551,
            				{
            						name: 'RGBA5551',
            						size: 2,
            						ldr: true
            				}
            		],
            		[
            				PIXELFORMAT_RGBA4,
            				{
            						name: 'RGBA4',
            						size: 2,
            						ldr: true
            				}
            		],
            		[
            				PIXELFORMAT_RGB8,
            				{
            						name: 'RGB8',
            						size: 4,
            						ldr: true
            				}
            		],
            		[
            				PIXELFORMAT_RGBA8,
            				{
            						name: 'RGBA8',
            						size: 4,
            						ldr: true,
            						srgbFormat: PIXELFORMAT_SRGBA8
            				}
            		],
            		[
            				PIXELFORMAT_R16F,
            				{
            						name: 'R16F',
            						size: 2
            				}
            		],
            		[
            				PIXELFORMAT_RG16F,
            				{
            						name: 'RG16F',
            						size: 4
            				}
            		],
            		[
            				PIXELFORMAT_RGB16F,
            				{
            						name: 'RGB16F',
            						size: 8
            				}
            		],
            		[
            				PIXELFORMAT_RGBA16F,
            				{
            						name: 'RGBA16F',
            						size: 8
            				}
            		],
            		[
            				PIXELFORMAT_RGB32F,
            				{
            						name: 'RGB32F',
            						size: 16
            				}
            		],
            		[
            				PIXELFORMAT_RGBA32F,
            				{
            						name: 'RGBA32F',
            						size: 16
            				}
            		],
            		[
            				PIXELFORMAT_R32F,
            				{
            						name: 'R32F',
            						size: 4
            				}
            		],
            		[
            				PIXELFORMAT_DEPTH,
            				{
            						name: 'DEPTH',
            						size: 4
            				}
            		],
            		[
            				PIXELFORMAT_DEPTH16,
            				{
            						name: 'DEPTH16',
            						size: 2
            				}
            		],
            		[
            				PIXELFORMAT_DEPTHSTENCIL,
            				{
            						name: 'DEPTHSTENCIL',
            						size: 4
            				}
            		],
            		[
            				PIXELFORMAT_111110F,
            				{
            						name: '111110F',
            						size: 4
            				}
            		],
            		[
            				PIXELFORMAT_SRGB8,
            				{
            						name: 'SRGB8',
            						size: 4,
            						ldr: true,
            						srgb: true
            				}
            		],
            		[
            				PIXELFORMAT_SRGBA8,
            				{
            						name: 'SRGBA8',
            						size: 4,
            						ldr: true,
            						srgb: true
            				}
            		],
            		[
            				PIXELFORMAT_BGRA8,
            				{
            						name: 'BGRA8',
            						size: 4,
            						ldr: true
            				}
            		],
            		[
            				PIXELFORMAT_SBGRA8,
            				{
            						name: 'SBGRA8',
            						size: 4,
            						ldr: true,
            						srgb: true
            				}
            		],
            		[
            				PIXELFORMAT_DXT1,
            				{
            						name: 'DXT1',
            						blockSize: 8,
            						ldr: true,
            						srgbFormat: PIXELFORMAT_DXT1_SRGB
            				}
            		],
            		[
            				PIXELFORMAT_DXT3,
            				{
            						name: 'DXT3',
            						blockSize: 16,
            						ldr: true,
            						srgbFormat: PIXELFORMAT_DXT3_SRGBA
            				}
            		],
            		[
            				PIXELFORMAT_DXT5,
            				{
            						name: 'DXT5',
            						blockSize: 16,
            						ldr: true,
            						srgbFormat: PIXELFORMAT_DXT5_SRGBA
            				}
            		],
            		[
            				PIXELFORMAT_ETC1,
            				{
            						name: 'ETC1',
            						blockSize: 8,
            						ldr: true
            				}
            		],
            		[
            				PIXELFORMAT_ETC2_RGB,
            				{
            						name: 'ETC2_RGB',
            						blockSize: 8,
            						ldr: true,
            						srgbFormat: PIXELFORMAT_ETC2_SRGB
            				}
            		],
            		[
            				PIXELFORMAT_ETC2_RGBA,
            				{
            						name: 'ETC2_RGBA',
            						blockSize: 16,
            						ldr: true,
            						srgbFormat: PIXELFORMAT_ETC2_SRGBA
            				}
            		],
            		[
            				PIXELFORMAT_PVRTC_2BPP_RGB_1,
            				{
            						name: 'PVRTC_2BPP_RGB_1',
            						ldr: true,
            						blockSize: 8
            				}
            		],
            		[
            				PIXELFORMAT_PVRTC_2BPP_RGBA_1,
            				{
            						name: 'PVRTC_2BPP_RGBA_1',
            						ldr: true,
            						blockSize: 8
            				}
            		],
            		[
            				PIXELFORMAT_PVRTC_4BPP_RGB_1,
            				{
            						name: 'PVRTC_4BPP_RGB_1',
            						ldr: true,
            						blockSize: 8
            				}
            		],
            		[
            				PIXELFORMAT_PVRTC_4BPP_RGBA_1,
            				{
            						name: 'PVRTC_4BPP_RGBA_1',
            						ldr: true,
            						blockSize: 8
            				}
            		],
            		[
            				PIXELFORMAT_ASTC_4x4,
            				{
            						name: 'ASTC_4x4',
            						blockSize: 16,
            						ldr: true,
            						srgbFormat: PIXELFORMAT_ASTC_4x4_SRGB
            				}
            		],
            		[
            				PIXELFORMAT_ATC_RGB,
            				{
            						name: 'ATC_RGB',
            						blockSize: 8,
            						ldr: true
            				}
            		],
            		[
            				PIXELFORMAT_ATC_RGBA,
            				{
            						name: 'ATC_RGBA',
            						blockSize: 16,
            						ldr: true
            				}
            		],
            		[
            				PIXELFORMAT_BC6F,
            				{
            						name: 'BC6H_RGBF',
            						blockSize: 16
            				}
            		],
            		[
            				PIXELFORMAT_BC6UF,
            				{
            						name: 'BC6H_RGBUF',
            						blockSize: 16
            				}
            		],
            		[
            				PIXELFORMAT_BC7,
            				{
            						name: 'BC7_RGBA',
            						blockSize: 16,
            						ldr: true,
            						srgbFormat: PIXELFORMAT_BC7_SRGBA
            				}
            		],
            		[
            				PIXELFORMAT_DXT1_SRGB,
            				{
            						name: 'DXT1_SRGB',
            						blockSize: 8,
            						ldr: true,
            						srgb: true
            				}
            		],
            		[
            				PIXELFORMAT_DXT3_SRGBA,
            				{
            						name: 'DXT3_SRGBA',
            						blockSize: 16,
            						ldr: true,
            						srgb: true
            				}
            		],
            		[
            				PIXELFORMAT_DXT5_SRGBA,
            				{
            						name: 'DXT5_SRGBA',
            						blockSize: 16,
            						ldr: true,
            						srgb: true
            				}
            		],
            		[
            				PIXELFORMAT_ETC2_SRGB,
            				{
            						name: 'ETC2_SRGB',
            						blockSize: 8,
            						ldr: true,
            						srgb: true
            				}
            		],
            		[
            				PIXELFORMAT_ETC2_SRGBA,
            				{
            						name: 'ETC2_SRGBA',
            						blockSize: 16,
            						ldr: true,
            						srgb: true
            				}
            		],
            		[
            				PIXELFORMAT_ASTC_4x4_SRGB,
            				{
            						name: 'ASTC_4x4_SRGB',
            						blockSize: 16,
            						ldr: true,
            						srgb: true
            				}
            		],
            		[
            				PIXELFORMAT_BC7_SRGBA,
            				{
            						name: 'BC7_SRGBA',
            						blockSize: 16,
            						ldr: true,
            						srgb: true
            				}
            		],
            		[
            				PIXELFORMAT_R8I,
            				{
            						name: 'R8I',
            						size: 1,
            						isInt: true
            				}
            		],
            		[
            				PIXELFORMAT_R8U,
            				{
            						name: 'R8U',
            						size: 1,
            						isInt: true
            				}
            		],
            		[
            				PIXELFORMAT_R16I,
            				{
            						name: 'R16I',
            						size: 2,
            						isInt: true
            				}
            		],
            		[
            				PIXELFORMAT_R16U,
            				{
            						name: 'R16U',
            						size: 2,
            						isInt: true
            				}
            		],
            		[
            				PIXELFORMAT_R32I,
            				{
            						name: 'R32I',
            						size: 4,
            						isInt: true
            				}
            		],
            		[
            				PIXELFORMAT_R32U,
            				{
            						name: 'R32U',
            						size: 4,
            						isInt: true
            				}
            		],
            		[
            				PIXELFORMAT_RG8I,
            				{
            						name: 'RG8I',
            						size: 2,
            						isInt: true
            				}
            		],
            		[
            				PIXELFORMAT_RG8U,
            				{
            						name: 'RG8U',
            						size: 2,
            						isInt: true
            				}
            		],
            		[
            				PIXELFORMAT_RG16I,
            				{
            						name: 'RG16I',
            						size: 4,
            						isInt: true
            				}
            		],
            		[
            				PIXELFORMAT_RG16U,
            				{
            						name: 'RG16U',
            						size: 4,
            						isInt: true
            				}
            		],
            		[
            				PIXELFORMAT_RG32I,
            				{
            						name: 'RG32I',
            						size: 8,
            						isInt: true
            				}
            		],
            		[
            				PIXELFORMAT_RG32U,
            				{
            						name: 'RG32U',
            						size: 8,
            						isInt: true
            				}
            		],
            		[
            				PIXELFORMAT_RGBA8I,
            				{
            						name: 'RGBA8I',
            						size: 4,
            						isInt: true
            				}
            		],
            		[
            				PIXELFORMAT_RGBA8U,
            				{
            						name: 'RGBA8U',
            						size: 4,
            						isInt: true
            				}
            		],
            		[
            				PIXELFORMAT_RGBA16I,
            				{
            						name: 'RGBA16I',
            						size: 8,
            						isInt: true
            				}
            		],
            		[
            				PIXELFORMAT_RGBA16U,
            				{
            						name: 'RGBA16U',
            						size: 8,
            						isInt: true
            				}
            		],
            		[
            				PIXELFORMAT_RGBA32I,
            				{
            						name: 'RGBA32I',
            						size: 16,
            						isInt: true
            				}
            		],
            		[
            				PIXELFORMAT_RGBA32U,
            				{
            						name: 'RGBA32U',
            						size: 16,
            						isInt: true
            				}
            		]
            ]);
            var isCompressedPixelFormat = (format)=>{
            		var _pixelFormatInfo_get;
            		return ((_pixelFormatInfo_get = pixelFormatInfo.get(format)) == null ? void 0 : _pixelFormatInfo_get.blockSize) !== undefined;
            };
            var isSrgbPixelFormat = (format)=>{
            		var _pixelFormatInfo_get;
            		return ((_pixelFormatInfo_get = pixelFormatInfo.get(format)) == null ? void 0 : _pixelFormatInfo_get.srgb) === true;
            };
            var isIntegerPixelFormat = (format)=>{
            		var _pixelFormatInfo_get;
            		return ((_pixelFormatInfo_get = pixelFormatInfo.get(format)) == null ? void 0 : _pixelFormatInfo_get.isInt) === true;
            };
            var pixelFormatLinearToGamma = (format)=>{
            		var _pixelFormatInfo_get;
            		return ((_pixelFormatInfo_get = pixelFormatInfo.get(format)) == null ? void 0 : _pixelFormatInfo_get.srgbFormat) || format;
            };
            var pixelFormatGammaToLinear = (format)=>{
            		for (var [key, value] of pixelFormatInfo){
            				if (value.srgbFormat === format) {
            						return key;
            				}
            		}
            		return format;
            };
            var requiresManualGamma = (format)=>{
            		var info = pixelFormatInfo.get(format);
            		return !!((info == null ? void 0 : info.ldr) && !(info == null ? void 0 : info.srgb));
            };
            var getPixelFormatArrayType = (format)=>{
            		switch(format){
            				case PIXELFORMAT_R32F:
            				case PIXELFORMAT_RGB32F:
            				case PIXELFORMAT_RGBA32F:
            						return Float32Array;
            				case PIXELFORMAT_R32I:
            				case PIXELFORMAT_RG32I:
            				case PIXELFORMAT_RGBA32I:
            						return Int32Array;
            				case PIXELFORMAT_R32U:
            				case PIXELFORMAT_RG32U:
            				case PIXELFORMAT_RGBA32U:
            						return Uint32Array;
            				case PIXELFORMAT_R16I:
            				case PIXELFORMAT_RG16I:
            				case PIXELFORMAT_RGBA16I:
            						return Int16Array;
            				case PIXELFORMAT_RG8:
            				case PIXELFORMAT_R16U:
            				case PIXELFORMAT_RG16U:
            				case PIXELFORMAT_RGBA16U:
            				case PIXELFORMAT_RGB565:
            				case PIXELFORMAT_RGBA5551:
            				case PIXELFORMAT_RGBA4:
            				case PIXELFORMAT_R16F:
            				case PIXELFORMAT_RG16F:
            				case PIXELFORMAT_RGB16F:
            				case PIXELFORMAT_RGBA16F:
            						return Uint16Array;
            				case PIXELFORMAT_R8I:
            				case PIXELFORMAT_RG8I:
            				case PIXELFORMAT_RGBA8I:
            						return Int8Array;
            				default:
            						return Uint8Array;
            		}
            };
            var PRIMITIVE_POINTS = 0;
            var PRIMITIVE_LINES = 1;
            var PRIMITIVE_LINELOOP = 2;
            var PRIMITIVE_LINESTRIP = 3;
            var PRIMITIVE_TRIANGLES = 4;
            var PRIMITIVE_TRISTRIP = 5;
            var PRIMITIVE_TRIFAN = 6;
            var SEMANTIC_POSITION = 'POSITION';
            var SEMANTIC_NORMAL = 'NORMAL';
            var SEMANTIC_TANGENT = 'TANGENT';
            var SEMANTIC_BLENDWEIGHT = 'BLENDWEIGHT';
            var SEMANTIC_BLENDINDICES = 'BLENDINDICES';
            var SEMANTIC_COLOR = 'COLOR';
            var SEMANTIC_TEXCOORD = 'TEXCOORD';
            var SEMANTIC_TEXCOORD0 = 'TEXCOORD0';
            var SEMANTIC_TEXCOORD1 = 'TEXCOORD1';
            var SEMANTIC_TEXCOORD2 = 'TEXCOORD2';
            var SEMANTIC_TEXCOORD3 = 'TEXCOORD3';
            var SEMANTIC_TEXCOORD4 = 'TEXCOORD4';
            var SEMANTIC_TEXCOORD5 = 'TEXCOORD5';
            var SEMANTIC_TEXCOORD6 = 'TEXCOORD6';
            var SEMANTIC_TEXCOORD7 = 'TEXCOORD7';
            var SEMANTIC_ATTR0 = 'ATTR0';
            var SEMANTIC_ATTR1 = 'ATTR1';
            var SEMANTIC_ATTR2 = 'ATTR2';
            var SEMANTIC_ATTR3 = 'ATTR3';
            var SEMANTIC_ATTR4 = 'ATTR4';
            var SEMANTIC_ATTR5 = 'ATTR5';
            var SEMANTIC_ATTR6 = 'ATTR6';
            var SEMANTIC_ATTR7 = 'ATTR7';
            var SEMANTIC_ATTR8 = 'ATTR8';
            var SEMANTIC_ATTR9 = 'ATTR9';
            var SEMANTIC_ATTR10 = 'ATTR10';
            var SEMANTIC_ATTR11 = 'ATTR11';
            var SEMANTIC_ATTR12 = 'ATTR12';
            var SEMANTIC_ATTR13 = 'ATTR13';
            var SEMANTIC_ATTR14 = 'ATTR14';
            var SEMANTIC_ATTR15 = 'ATTR15';
            var SHADERTAG_MATERIAL = 1;
            var STENCILOP_KEEP = 0;
            var STENCILOP_REPLACE = 2;
            var STENCILOP_INCREMENT = 3;
            var STENCILOP_DECREMENT = 5;
            var TEXTURELOCK_NONE = 0;
            var TEXTURELOCK_READ = 1;
            var TEXTURELOCK_WRITE = 2;
            var TEXTURETYPE_DEFAULT = 'default';
            var TEXTURETYPE_RGBM = 'rgbm';
            var TEXTURETYPE_RGBE = 'rgbe';
            var TEXTURETYPE_RGBP = 'rgbp';
            var TEXTURETYPE_SWIZZLEGGGR = 'swizzleGGGR';
            var TEXTUREDIMENSION_2D = '2d';
            var SAMPLETYPE_FLOAT = 0;
            var TEXTUREPROJECTION_NONE = 'none';
            var TEXTUREPROJECTION_CUBE = 'cube';
            var TEXTUREPROJECTION_EQUIRECT = 'equirect';
            var TEXTUREPROJECTION_OCTAHEDRAL = 'octahedral';
            var SHADERLANGUAGE_GLSL = 'glsl';
            var SHADERLANGUAGE_WGSL = 'wgsl';
            var TYPE_INT8 = 0;
            var TYPE_UINT8 = 1;
            var TYPE_INT16 = 2;
            var TYPE_UINT16 = 3;
            var TYPE_INT32 = 4;
            var TYPE_UINT32 = 5;
            var TYPE_FLOAT32 = 6;
            var UNIFORMTYPE_BOOL = 0;
            var UNIFORMTYPE_INT = 1;
            var UNIFORMTYPE_FLOAT = 2;
            var UNIFORMTYPE_VEC2 = 3;
            var UNIFORMTYPE_VEC3 = 4;
            var UNIFORMTYPE_VEC4 = 5;
            var UNIFORMTYPE_IVEC2 = 6;
            var UNIFORMTYPE_IVEC3 = 7;
            var UNIFORMTYPE_IVEC4 = 8;
            var UNIFORMTYPE_BVEC2 = 9;
            var UNIFORMTYPE_BVEC3 = 10;
            var UNIFORMTYPE_BVEC4 = 11;
            var UNIFORMTYPE_MAT2 = 12;
            var UNIFORMTYPE_MAT3 = 13;
            var UNIFORMTYPE_MAT4 = 14;
            var UNIFORMTYPE_TEXTURE2D = 15;
            var UNIFORMTYPE_TEXTURECUBE = 16;
            var UNIFORMTYPE_FLOATARRAY = 17;
            var UNIFORMTYPE_TEXTURE2D_SHADOW = 18;
            var UNIFORMTYPE_TEXTURECUBE_SHADOW = 19;
            var UNIFORMTYPE_TEXTURE3D = 20;
            var UNIFORMTYPE_VEC2ARRAY = 21;
            var UNIFORMTYPE_VEC3ARRAY = 22;
            var UNIFORMTYPE_VEC4ARRAY = 23;
            var UNIFORMTYPE_MAT4ARRAY = 24;
            var UNIFORMTYPE_TEXTURE2D_ARRAY = 25;
            var UNIFORMTYPE_UINT = 26;
            var UNIFORMTYPE_UVEC2 = 27;
            var UNIFORMTYPE_UVEC3 = 28;
            var UNIFORMTYPE_UVEC4 = 29;
            var UNIFORMTYPE_INTARRAY = 30;
            var UNIFORMTYPE_UINTARRAY = 31;
            var UNIFORMTYPE_BOOLARRAY = 32;
            var UNIFORMTYPE_IVEC2ARRAY = 33;
            var UNIFORMTYPE_UVEC2ARRAY = 34;
            var UNIFORMTYPE_BVEC2ARRAY = 35;
            var UNIFORMTYPE_IVEC3ARRAY = 36;
            var UNIFORMTYPE_UVEC3ARRAY = 37;
            var UNIFORMTYPE_BVEC3ARRAY = 38;
            var UNIFORMTYPE_IVEC4ARRAY = 39;
            var UNIFORMTYPE_UVEC4ARRAY = 40;
            var UNIFORMTYPE_BVEC4ARRAY = 41;
            var UNIFORMTYPE_ITEXTURE2D = 42;
            var UNIFORMTYPE_UTEXTURE2D = 43;
            var UNIFORMTYPE_ITEXTURECUBE = 44;
            var UNIFORMTYPE_UTEXTURECUBE = 45;
            var UNIFORMTYPE_ITEXTURE3D = 46;
            var UNIFORMTYPE_UTEXTURE3D = 47;
            var UNIFORMTYPE_ITEXTURE2D_ARRAY = 48;
            var UNIFORMTYPE_UTEXTURE2D_ARRAY = 49;
            var uniformTypeToNameWGSL = [
            		[
            				'bool'
            		],
            		[
            				'i32'
            		],
            		[
            				'f32'
            		],
            		[
            				'vec2f',
            				'vec2<f32>'
            		],
            		[
            				'vec3f',
            				'vec3<f32>'
            		],
            		[
            				'vec4f',
            				'vec4<f32>'
            		],
            		[
            				'vec2i',
            				'vec2<i32>'
            		],
            		[
            				'vec3i',
            				'vec3<i32>'
            		],
            		[
            				'vec4i',
            				'vec4<i32>'
            		],
            		[
            				'vec2<bool>'
            		],
            		[
            				'vec3<bool>'
            		],
            		[
            				'vec4<bool>'
            		],
            		[
            				'mat2x2f',
            				'mat2x2<f32>'
            		],
            		[
            				'mat3x3f',
            				'mat3x3<f32>'
            		],
            		[
            				'mat4x4f',
            				'mat4x4<f32>'
            		],
            		[
            				'texture_2d<f32>'
            		],
            		[
            				'texture_cube<f32>'
            		],
            		[
            				'array<f32>'
            		],
            		[
            				'texture_depth_2d'
            		],
            		[
            				'texture_depth_cube'
            		],
            		[
            				'texture_3d<f32>'
            		],
            		[
            				'array<vec2<f32>>'
            		],
            		[
            				'array<vec3<f32>>'
            		],
            		[
            				'array<vec4<f32>>'
            		],
            		[
            				'array<mat4x4<f32>>'
            		],
            		[
            				'texture_2d_array<f32>'
            		],
            		[
            				'u32'
            		],
            		[
            				'vec2u',
            				'vec2<u32>'
            		],
            		[
            				'vec3u',
            				'vec3<u32>'
            		],
            		[
            				'vec4u',
            				'vec4<u32>'
            		],
            		[
            				'array<i32>'
            		],
            		[
            				'array<u32>'
            		],
            		[
            				'array<bool>'
            		],
            		[
            				'array<vec2i>',
            				'array<vec2<i32>>'
            		],
            		[
            				'array<vec2u>',
            				'array<vec2<u32>>'
            		],
            		[
            				'array<vec2b>',
            				'array<vec2<bool>>'
            		],
            		[
            				'array<vec3i>',
            				'array<vec3<i32>>'
            		],
            		[
            				'array<vec3u>',
            				'array<vec3<u32>>'
            		],
            		[
            				'array<vec3b>',
            				'array<vec3<bool>>'
            		],
            		[
            				'array<vec4i>',
            				'array<vec4<i32>>'
            		],
            		[
            				'array<vec4u>',
            				'array<vec4<u32>>'
            		],
            		[
            				'array<vec4b>',
            				'array<vec4<bool>>'
            		],
            		[
            				'texture_2d<i32>'
            		],
            		[
            				'texture_2d<u32>'
            		],
            		[
            				'texture_cube<i32>'
            		],
            		[
            				'texture_cube<u32>'
            		],
            		[
            				'texture_3d<i32>'
            		],
            		[
            				'texture_3d<u32>'
            		],
            		[
            				'texture_2d_array<i32>'
            		],
            		[
            				'texture_2d_array<u32>'
            		]
            ];
            var uniformTypeToNameMapWGSL = new Map();
            uniformTypeToNameWGSL.forEach((names, index)=>{
            		names.forEach((name)=>uniformTypeToNameMapWGSL.set(name, index));
            });
            var DEVICETYPE_WEBGL2 = 'webgl2';
            var SHADERSTAGE_VERTEX = 1;
            var SHADERSTAGE_FRAGMENT = 2;
            var SHADERSTAGE_COMPUTE = 4;
            var DISPLAYFORMAT_LDR = 'ldr';
            var TEXPROPERTY_MIN_FILTER = 1;
            var TEXPROPERTY_MAG_FILTER = 2;
            var TEXPROPERTY_ADDRESS_U = 4;
            var TEXPROPERTY_ADDRESS_V = 8;
            var TEXPROPERTY_ADDRESS_W = 16;
            var TEXPROPERTY_COMPARE_ON_READ = 32;
            var TEXPROPERTY_COMPARE_FUNC = 64;
            var TEXPROPERTY_ANISOTROPY = 128;
            var TEXPROPERTY_ALL = 255;
            var BINDGROUP_VIEW = 0;
            var BINDGROUP_MESH = 1;
            var BINDGROUP_MESH_UB = 2;
            var UNIFORM_BUFFER_DEFAULT_SLOT_NAME = 'default';
            var typedArrayTypes = [
            		Int8Array,
            		Uint8Array,
            		Int16Array,
            		Uint16Array,
            		Int32Array,
            		Uint32Array,
            		Float32Array,
            		Uint16Array
            ];
            var typedArrayTypesByteSize = [
            		1,
            		1,
            		2,
            		2,
            		4,
            		4,
            		4,
            		2
            ];
            var typedArrayIndexFormats = [
            		Uint8Array,
            		Uint16Array,
            		Uint32Array
            ];
            var typedArrayIndexFormatsByteSize = [
            		1,
            		2,
            		4
            ];
            var semanticToLocation = {};
            semanticToLocation[SEMANTIC_POSITION] = 0;
            semanticToLocation[SEMANTIC_NORMAL] = 1;
            semanticToLocation[SEMANTIC_BLENDWEIGHT] = 2;
            semanticToLocation[SEMANTIC_BLENDINDICES] = 3;
            semanticToLocation[SEMANTIC_COLOR] = 4;
            semanticToLocation[SEMANTIC_TEXCOORD0] = 5;
            semanticToLocation[SEMANTIC_TEXCOORD1] = 6;
            semanticToLocation[SEMANTIC_TEXCOORD2] = 7;
            semanticToLocation[SEMANTIC_TEXCOORD3] = 8;
            semanticToLocation[SEMANTIC_TEXCOORD4] = 9;
            semanticToLocation[SEMANTIC_TEXCOORD5] = 10;
            semanticToLocation[SEMANTIC_TEXCOORD6] = 11;
            semanticToLocation[SEMANTIC_TEXCOORD7] = 12;
            semanticToLocation[SEMANTIC_TANGENT] = 13;
            semanticToLocation[SEMANTIC_ATTR0] = 0;
            semanticToLocation[SEMANTIC_ATTR1] = 1;
            semanticToLocation[SEMANTIC_ATTR2] = 2;
            semanticToLocation[SEMANTIC_ATTR3] = 3;
            semanticToLocation[SEMANTIC_ATTR4] = 4;
            semanticToLocation[SEMANTIC_ATTR5] = 5;
            semanticToLocation[SEMANTIC_ATTR6] = 6;
            semanticToLocation[SEMANTIC_ATTR7] = 7;
            semanticToLocation[SEMANTIC_ATTR8] = 8;
            semanticToLocation[SEMANTIC_ATTR9] = 9;
            semanticToLocation[SEMANTIC_ATTR10] = 10;
            semanticToLocation[SEMANTIC_ATTR11] = 11;
            semanticToLocation[SEMANTIC_ATTR12] = 12;
            semanticToLocation[SEMANTIC_ATTR13] = 13;
            semanticToLocation[SEMANTIC_ATTR14] = 14;
            semanticToLocation[SEMANTIC_ATTR15] = 15;
            var CHUNKAPI_1_65 = '1.65';
            
            var id$a = 0;
            class BindBaseFormat {
            		constructor(name, visibility){
            				this.slot = -1;
            				this.scopeId = null;
            				this.name = name;
            				this.visibility = visibility;
            		}
            }
            class BindUniformBufferFormat extends BindBaseFormat {
            }
            class BindStorageBufferFormat extends BindBaseFormat {
            		constructor(name, visibility, readOnly = false){
            				super(name, visibility), this.format = '';
            				this.readOnly = readOnly;
            		}
            }
            class BindTextureFormat extends BindBaseFormat {
            		constructor(name, visibility, textureDimension = TEXTUREDIMENSION_2D, sampleType = SAMPLETYPE_FLOAT, hasSampler = true, samplerName = null){
            				super(name, visibility);
            				this.textureDimension = textureDimension;
            				this.sampleType = sampleType;
            				this.hasSampler = hasSampler;
            				this.samplerName = samplerName != null ? samplerName : "" + name + "_sampler";
            		}
            }
            class BindStorageTextureFormat extends BindBaseFormat {
            		constructor(name, format = PIXELFORMAT_RGBA8, textureDimension = TEXTUREDIMENSION_2D, write = true, read = false){
            				super(name, SHADERSTAGE_COMPUTE);
            				this.format = format;
            				this.textureDimension = textureDimension;
            				this.write = write;
            				this.read = read;
            		}
            }
            class BindGroupFormat {
            		destroy() {
            				this.impl.destroy();
            		}
            		getTexture(name) {
            				var index = this.textureFormatsMap.get(name);
            				if (index !== undefined) {
            						return this.textureFormats[index];
            				}
            				return null;
            		}
            		getStorageTexture(name) {
            				var index = this.storageTextureFormatsMap.get(name);
            				if (index !== undefined) {
            						return this.storageTextureFormats[index];
            				}
            				return null;
            		}
            		loseContext() {}
            		constructor(graphicsDevice, formats){
            				this.uniformBufferFormats = [];
            				this.textureFormats = [];
            				this.storageTextureFormats = [];
            				this.storageBufferFormats = [];
            				this.id = id$a++;
            				var slot = 0;
            				formats.forEach((format)=>{
            						format.slot = slot++;
            						if (format instanceof BindTextureFormat && format.hasSampler) {
            								slot++;
            						}
            						if (format instanceof BindUniformBufferFormat) {
            								this.uniformBufferFormats.push(format);
            						} else if (format instanceof BindTextureFormat) {
            								this.textureFormats.push(format);
            						} else if (format instanceof BindStorageTextureFormat) {
            								this.storageTextureFormats.push(format);
            						} else if (format instanceof BindStorageBufferFormat) {
            								this.storageBufferFormats.push(format);
            						} else ;
            				});
            				this.device = graphicsDevice;
            				var scope = graphicsDevice.scope;
            				this.bufferFormatsMap = new Map();
            				this.uniformBufferFormats.forEach((bf, i)=>this.bufferFormatsMap.set(bf.name, i));
            				this.textureFormatsMap = new Map();
            				this.textureFormats.forEach((tf, i)=>{
            						this.textureFormatsMap.set(tf.name, i);
            						tf.scopeId = scope.resolve(tf.name);
            				});
            				this.storageTextureFormatsMap = new Map();
            				this.storageTextureFormats.forEach((tf, i)=>{
            						this.storageTextureFormatsMap.set(tf.name, i);
            						tf.scopeId = scope.resolve(tf.name);
            				});
            				this.storageBufferFormatsMap = new Map();
            				this.storageBufferFormats.forEach((bf, i)=>{
            						this.storageBufferFormatsMap.set(bf.name, i);
            						bf.scopeId = scope.resolve(bf.name);
            				});
            				this.impl = graphicsDevice.createBindGroupFormatImpl(this);
            		}
            }
            
            class DeviceCache {
            		get(device, onCreate) {
            				if (!this._cache.has(device)) {
            						this._cache.set(device, onCreate());
            						device.on('destroy', ()=>{
            								this.remove(device);
            						});
            						device.on('devicelost', ()=>{
            								var _this__cache_get_loseContext, _this__cache_get;
            								(_this__cache_get = this._cache.get(device)) == null ? void 0 : (_this__cache_get_loseContext = _this__cache_get.loseContext) == null ? void 0 : _this__cache_get_loseContext.call(_this__cache_get, device);
            						});
            				}
            				return this._cache.get(device);
            		}
            		remove(device) {
            				var _this__cache_get_destroy, _this__cache_get;
            				(_this__cache_get = this._cache.get(device)) == null ? void 0 : (_this__cache_get_destroy = _this__cache_get.destroy) == null ? void 0 : _this__cache_get_destroy.call(_this__cache_get, device);
            				this._cache.delete(device);
            		}
            		constructor(){
            				this._cache = new Map();
            		}
            }
            
            class TextureUtils {
            		static calcLevelDimension(dimension, mipLevel) {
            				return Math.max(dimension >> mipLevel, 1);
            		}
            		static calcMipLevelsCount(width, height, depth) {
            				if (depth === void 0) depth = 1;
            				return 1 + Math.floor(Math.log2(Math.max(width, height, depth)));
            		}
            		static calcLevelGpuSize(width, height, depth, format) {
            				var _pixelFormatInfo_get;
            				var formatInfo = pixelFormatInfo.get(format);
            				var _pixelFormatInfo_get_size;
            				var pixelSize = (_pixelFormatInfo_get_size = (_pixelFormatInfo_get = pixelFormatInfo.get(format)) == null ? void 0 : _pixelFormatInfo_get.size) != null ? _pixelFormatInfo_get_size : 0;
            				if (pixelSize > 0) {
            						return width * height * depth * pixelSize;
            				}
            				var _formatInfo_blockSize;
            				var blockSize = (_formatInfo_blockSize = formatInfo.blockSize) != null ? _formatInfo_blockSize : 0;
            				var blockWidth = Math.floor((width + 3) / 4);
            				var blockHeight = Math.floor((height + 3) / 4);
            				var blockDepth = Math.floor((depth + 3) / 4);
            				if (format === PIXELFORMAT_PVRTC_2BPP_RGB_1 || format === PIXELFORMAT_PVRTC_2BPP_RGBA_1) {
            						blockWidth = Math.max(Math.floor(blockWidth / 2), 1);
            				}
            				return blockWidth * blockHeight * blockDepth * blockSize;
            		}
            		static calcGpuSize(width, height, depth, format, mipmaps, cubemap) {
            				var result = 0;
            				while(1){
            						result += TextureUtils.calcLevelGpuSize(width, height, depth, format);
            						if (!mipmaps || width === 1 && height === 1 && depth === 1) {
            								break;
            						}
            						width = Math.max(width >> 1, 1);
            						height = Math.max(height >> 1, 1);
            						depth = Math.max(depth >> 1, 1);
            				}
            				return result * (cubemap ? 6 : 1);
            		}
            }
            
            var id$9 = 0;
            class Texture {
            		destroy() {
            				var device = this.device;
            				if (device) {
            						var idx = device.textures.indexOf(this);
            						if (idx !== -1) {
            								device.textures.splice(idx, 1);
            						}
            						device.scope.removeValue(this);
            						this.impl.destroy(device);
            						this.adjustVramSizeTracking(device._vram, -this._gpuSize);
            						this._levels = null;
            						this.device = null;
            				}
            		}
            		recreateImpl(upload) {
            				if (upload === void 0) upload = true;
            				var _this_impl;
            				var { device } = this;
            				(_this_impl = this.impl) == null ? void 0 : _this_impl.destroy(device);
            				this.impl = null;
            				this.impl = device.createTextureImpl(this);
            				this.dirtyAll();
            				if (upload) {
            						this.upload();
            				}
            		}
            		resize(width, height, depth) {
            				if (depth === void 0) depth = 1;
            				var device = this.device;
            				this.adjustVramSizeTracking(device._vram, -this._gpuSize);
            				this.impl.destroy(device);
            				this._width = Math.floor(width);
            				this._height = Math.floor(height);
            				this._depth = Math.floor(depth);
            				this._updateNumLevel();
            				this.impl = device.createTextureImpl(this);
            				this.dirtyAll();
            		}
            		loseContext() {
            				this.impl.loseContext();
            				this.dirtyAll();
            		}
            		adjustVramSizeTracking(vram, size) {
            				vram.tex += size;
            		}
            		propertyChanged(flag) {
            				this.impl.propertyChanged(flag);
            				this.renderVersionDirty = this.device.renderVersion;
            		}
            		_updateNumLevel() {
            				var maxLevels = this.mipmaps ? TextureUtils.calcMipLevelsCount(this.width, this.height) : 1;
            				var requestedLevels = this._numLevelsRequested;
            				this._numLevels = Math.min(requestedLevels != null ? requestedLevels : maxLevels, maxLevels);
            				this._mipmaps = this._numLevels > 1;
            		}
            		get lockedMode() {
            				return this._lockedMode;
            		}
            		set minFilter(v) {
            				if (this._minFilter !== v) {
            						if (isIntegerPixelFormat(this._format)) ; else {
            								this._minFilter = v;
            								this.propertyChanged(TEXPROPERTY_MIN_FILTER);
            						}
            				}
            		}
            		get minFilter() {
            				return this._minFilter;
            		}
            		set magFilter(v) {
            				if (this._magFilter !== v) {
            						if (isIntegerPixelFormat(this._format)) ; else {
            								this._magFilter = v;
            								this.propertyChanged(TEXPROPERTY_MAG_FILTER);
            						}
            				}
            		}
            		get magFilter() {
            				return this._magFilter;
            		}
            		set addressU(v) {
            				if (this._addressU !== v) {
            						this._addressU = v;
            						this.propertyChanged(TEXPROPERTY_ADDRESS_U);
            				}
            		}
            		get addressU() {
            				return this._addressU;
            		}
            		set addressV(v) {
            				if (this._addressV !== v) {
            						this._addressV = v;
            						this.propertyChanged(TEXPROPERTY_ADDRESS_V);
            				}
            		}
            		get addressV() {
            				return this._addressV;
            		}
            		set addressW(addressW) {
            				if (!this._volume) {
            						return;
            				}
            				if (addressW !== this._addressW) {
            						this._addressW = addressW;
            						this.propertyChanged(TEXPROPERTY_ADDRESS_W);
            				}
            		}
            		get addressW() {
            				return this._addressW;
            		}
            		set compareOnRead(v) {
            				if (this._compareOnRead !== v) {
            						this._compareOnRead = v;
            						this.propertyChanged(TEXPROPERTY_COMPARE_ON_READ);
            				}
            		}
            		get compareOnRead() {
            				return this._compareOnRead;
            		}
            		set compareFunc(v) {
            				if (this._compareFunc !== v) {
            						this._compareFunc = v;
            						this.propertyChanged(TEXPROPERTY_COMPARE_FUNC);
            				}
            		}
            		get compareFunc() {
            				return this._compareFunc;
            		}
            		set anisotropy(v) {
            				if (this._anisotropy !== v) {
            						this._anisotropy = v;
            						this.propertyChanged(TEXPROPERTY_ANISOTROPY);
            				}
            		}
            		get anisotropy() {
            				return this._anisotropy;
            		}
            		set mipmaps(v) {
            				if (this._mipmaps !== v) {
            						if (this.device.isWebGPU) ; else if (isIntegerPixelFormat(this._format)) ; else {
            								this._mipmaps = v;
            						}
            						if (v) this._needsMipmapsUpload = true;
            				}
            		}
            		get mipmaps() {
            				return this._mipmaps;
            		}
            		get numLevels() {
            				return this._numLevels;
            		}
            		get storage() {
            				return this._storage;
            		}
            		get width() {
            				return this._width;
            		}
            		get height() {
            				return this._height;
            		}
            		get depth() {
            				return this._depth;
            		}
            		get format() {
            				return this._format;
            		}
            		get cubemap() {
            				return this._cubemap;
            		}
            		get gpuSize() {
            				var mips = this.pot && this._mipmaps && !(this._compressed && this._levels.length === 1);
            				return TextureUtils.calcGpuSize(this._width, this._height, this._depth, this._format, mips, this._cubemap);
            		}
            		get array() {
            				return this._arrayLength > 0;
            		}
            		get arrayLength() {
            				return this._arrayLength;
            		}
            		get volume() {
            				return this._volume;
            		}
            		set type(value) {
            				if (this._type !== value) {
            						this._type = value;
            						this.device._shadersDirty = true;
            				}
            		}
            		get type() {
            				return this._type;
            		}
            		set srgb(value) {
            				var currentSrgb = isSrgbPixelFormat(this.format);
            				if (value !== currentSrgb) {
            						if (value) {
            								var srgbFormat = pixelFormatLinearToGamma(this.format);
            								if (this._format !== srgbFormat) {
            										this._format = srgbFormat;
            										this.recreateImpl();
            										this.device._shadersDirty = true;
            								}
            						} else {
            								var linearFormat = pixelFormatGammaToLinear(this.format);
            								if (this._format !== linearFormat) {
            										this._format = linearFormat;
            										this.recreateImpl();
            										this.device._shadersDirty = true;
            								}
            						}
            				}
            		}
            		get srgb() {
            				return isSrgbPixelFormat(this.format);
            		}
            		set flipY(flipY) {
            				if (this._flipY !== flipY) {
            						this._flipY = flipY;
            						this._needsUpload = true;
            				}
            		}
            		get flipY() {
            				return this._flipY;
            		}
            		set premultiplyAlpha(premultiplyAlpha) {
            				if (this._premultiplyAlpha !== premultiplyAlpha) {
            						this._premultiplyAlpha = premultiplyAlpha;
            						this._needsUpload = true;
            				}
            		}
            		get premultiplyAlpha() {
            				return this._premultiplyAlpha;
            		}
            		get pot() {
            				return math.powerOfTwo(this._width) && math.powerOfTwo(this._height);
            		}
            		get encoding() {
            				switch(this.type){
            						case TEXTURETYPE_RGBM:
            								return 'rgbm';
            						case TEXTURETYPE_RGBE:
            								return 'rgbe';
            						case TEXTURETYPE_RGBP:
            								return 'rgbp';
            				}
            				return requiresManualGamma(this.format) ? 'srgb' : 'linear';
            		}
            		dirtyAll() {
            				this._levelsUpdated = this._cubemap ? [
            						[
            								true,
            								true,
            								true,
            								true,
            								true,
            								true
            						]
            				] : [
            						true
            				];
            				this._needsUpload = true;
            				this._needsMipmapsUpload = this._mipmaps;
            				this._mipmapsUploaded = false;
            				this.propertyChanged(TEXPROPERTY_ALL);
            		}
            		lock(options) {
            				if (options === void 0) options = {};
            				var _options, _options1, _options2;
            				var _level;
            				(_level = (_options = options).level) != null ? _level : _options.level = 0;
            				var _face;
            				(_face = (_options1 = options).face) != null ? _face : _options1.face = 0;
            				var _mode;
            				(_mode = (_options2 = options).mode) != null ? _mode : _options2.mode = TEXTURELOCK_WRITE;
            				this._lockedMode = options.mode;
            				this._lockedLevel = options.level;
            				var levels = this.cubemap ? this._levels[options.face] : this._levels;
            				if (levels[options.level] === null) {
            						var width = Math.max(1, this._width >> options.level);
            						var height = Math.max(1, this._height >> options.level);
            						var depth = Math.max(1, this._depth >> options.level);
            						var data = new ArrayBuffer(TextureUtils.calcLevelGpuSize(width, height, depth, this._format));
            						levels[options.level] = new (getPixelFormatArrayType(this._format))(data);
            				}
            				return levels[options.level];
            		}
            		setSource(source, mipLevel) {
            				if (mipLevel === void 0) mipLevel = 0;
            				var invalid = false;
            				var width, height;
            				if (this._cubemap) {
            						if (source[0]) {
            								width = source[0].width || 0;
            								height = source[0].height || 0;
            								for(var i = 0; i < 6; i++){
            										var face = source[i];
            										if (!face || face.width !== width || face.height !== height || !this.device._isBrowserInterface(face)) {
            												invalid = true;
            												break;
            										}
            								}
            						} else {
            								invalid = true;
            						}
            						if (!invalid) {
            								for(var i1 = 0; i1 < 6; i1++){
            										if (this._levels[mipLevel][i1] !== source[i1]) {
            												this._levelsUpdated[mipLevel][i1] = true;
            										}
            								}
            						}
            				} else {
            						if (!this.device._isBrowserInterface(source)) {
            								invalid = true;
            						}
            						if (!invalid) {
            								if (source !== this._levels[mipLevel]) {
            										this._levelsUpdated[mipLevel] = true;
            								}
            								if (source instanceof HTMLVideoElement) {
            										width = source.videoWidth;
            										height = source.videoHeight;
            								} else {
            										width = source.width;
            										height = source.height;
            								}
            						}
            				}
            				if (invalid) {
            						this._width = 4;
            						this._height = 4;
            						if (this._cubemap) {
            								for(var i2 = 0; i2 < 6; i2++){
            										this._levels[mipLevel][i2] = null;
            										this._levelsUpdated[mipLevel][i2] = true;
            								}
            						} else {
            								this._levels[mipLevel] = null;
            								this._levelsUpdated[mipLevel] = true;
            						}
            				} else {
            						if (mipLevel === 0) {
            								this._width = width;
            								this._height = height;
            						}
            						this._levels[mipLevel] = source;
            				}
            				if (this._invalid !== invalid || !invalid) {
            						this._invalid = invalid;
            						this.upload();
            				}
            		}
            		getSource(mipLevel) {
            				if (mipLevel === void 0) mipLevel = 0;
            				return this._levels[mipLevel];
            		}
            		unlock() {
            				if (this._lockedMode === TEXTURELOCK_NONE) ;
            				if (this._lockedMode === TEXTURELOCK_WRITE) {
            						this.upload();
            				}
            				this._lockedLevel = -1;
            				this._lockedMode = TEXTURELOCK_NONE;
            		}
            		upload() {
            				this._needsUpload = true;
            				this._needsMipmapsUpload = this._mipmaps;
            				this.impl.uploadImmediate == null ? void 0 : this.impl.uploadImmediate.call(this.impl, this.device, this);
            		}
            		read(x, y, width, height, options) {
            				if (options === void 0) options = {};
            				return this.impl.read == null ? void 0 : this.impl.read.call(this.impl, x, y, width, height, options);
            		}
            		constructor(graphicsDevice, options = {}){
            				this._gpuSize = 0;
            				this.id = id$9++;
            				this._invalid = false;
            				this._lockedLevel = -1;
            				this._lockedMode = TEXTURELOCK_NONE;
            				this.renderVersionDirty = 0;
            				this._storage = false;
            				this._numLevels = 0;
            				this.device = graphicsDevice;
            				var _options_name;
            				this.name = (_options_name = options.name) != null ? _options_name : '';
            				var _options_width;
            				this._width = Math.floor((_options_width = options.width) != null ? _options_width : 4);
            				var _options_height;
            				this._height = Math.floor((_options_height = options.height) != null ? _options_height : 4);
            				var _options_format;
            				this._format = (_options_format = options.format) != null ? _options_format : PIXELFORMAT_RGBA8;
            				this._compressed = isCompressedPixelFormat(this._format);
            				this._integerFormat = isIntegerPixelFormat(this._format);
            				if (this._integerFormat) {
            						options.minFilter = FILTER_NEAREST;
            						options.magFilter = FILTER_NEAREST;
            				}
            				var _options_volume;
            				this._volume = (_options_volume = options.volume) != null ? _options_volume : false;
            				var _options_depth;
            				this._depth = Math.floor((_options_depth = options.depth) != null ? _options_depth : 1);
            				var _options_arrayLength;
            				this._arrayLength = Math.floor((_options_arrayLength = options.arrayLength) != null ? _options_arrayLength : 0);
            				var _options_storage;
            				this._storage = (_options_storage = options.storage) != null ? _options_storage : false;
            				var _options_cubemap;
            				this._cubemap = (_options_cubemap = options.cubemap) != null ? _options_cubemap : false;
            				var _options_flipY;
            				this._flipY = (_options_flipY = options.flipY) != null ? _options_flipY : false;
            				var _options_premultiplyAlpha;
            				this._premultiplyAlpha = (_options_premultiplyAlpha = options.premultiplyAlpha) != null ? _options_premultiplyAlpha : false;
            				var _options_mipmaps;
            				this._mipmaps = (_options_mipmaps = options.mipmaps) != null ? _options_mipmaps : true;
            				this._numLevelsRequested = options.numLevels;
            				if (options.numLevels !== undefined) {
            						this._numLevels = options.numLevels;
            				}
            				this._updateNumLevel();
            				var _options_minFilter;
            				this._minFilter = (_options_minFilter = options.minFilter) != null ? _options_minFilter : FILTER_LINEAR_MIPMAP_LINEAR;
            				var _options_magFilter;
            				this._magFilter = (_options_magFilter = options.magFilter) != null ? _options_magFilter : FILTER_LINEAR;
            				var _options_anisotropy;
            				this._anisotropy = (_options_anisotropy = options.anisotropy) != null ? _options_anisotropy : 1;
            				var _options_addressU;
            				this._addressU = (_options_addressU = options.addressU) != null ? _options_addressU : ADDRESS_REPEAT;
            				var _options_addressV;
            				this._addressV = (_options_addressV = options.addressV) != null ? _options_addressV : ADDRESS_REPEAT;
            				var _options_addressW;
            				this._addressW = (_options_addressW = options.addressW) != null ? _options_addressW : ADDRESS_REPEAT;
            				var _options_compareOnRead;
            				this._compareOnRead = (_options_compareOnRead = options.compareOnRead) != null ? _options_compareOnRead : false;
            				var _options_compareFunc;
            				this._compareFunc = (_options_compareFunc = options.compareFunc) != null ? _options_compareFunc : FUNC_LESS;
            				this._type = options.hasOwnProperty('type') ? options.type : TEXTURETYPE_DEFAULT;
            				this.projection = TEXTUREPROJECTION_NONE;
            				if (this._cubemap) {
            						this.projection = TEXTUREPROJECTION_CUBE;
            				} else if (options.projection && options.projection !== TEXTUREPROJECTION_CUBE) {
            						this.projection = options.projection;
            				}
            				this._levels = options.levels;
            				var upload = !!options.levels;
            				if (!this._levels) {
            						this._levels = this._cubemap ? [
            								[
            										null,
            										null,
            										null,
            										null,
            										null,
            										null
            								]
            						] : [
            								null
            						];
            				}
            				this.recreateImpl(upload);
            				graphicsDevice.textures.push(this);
            		}
            }
            
            var textureData = {
            		white: [
            				255,
            				255,
            				255,
            				255
            		],
            		gray: [
            				128,
            				128,
            				128,
            				255
            		],
            		black: [
            				0,
            				0,
            				0,
            				255
            		],
            		normal: [
            				128,
            				128,
            				255,
            				255
            		],
            		pink: [
            				255,
            				128,
            				255,
            				255
            		]
            };
            class BuiltInTextures {
            		destroy() {
            				this.map.forEach((texture)=>{
            						texture.destroy();
            				});
            		}
            		constructor(){
            				this.map = new Map();
            		}
            }
            var deviceCache$3 = new DeviceCache();
            var getBuiltInTexture = (device, name)=>{
            		var cache = deviceCache$3.get(device, ()=>{
            				return new BuiltInTextures();
            		});
            		if (!cache.map.has(name)) {
            				var texture = new Texture(device, {
            						name: "built-in-texture-" + name,
            						width: 1,
            						height: 1,
            						format: PIXELFORMAT_RGBA8
            				});
            				var pixels = texture.lock();
            				var data = textureData[name];
            				pixels.set(data);
            				texture.unlock();
            				cache.map.set(name, texture);
            		}
            		return cache.map.get(name);
            };
            
            var id$8 = 0;
            class DynamicBindGroup {
            		constructor(){
            				this.offsets = [];
            		}
            }
            class BindGroup {
            		destroy() {
            				this.impl.destroy();
            				this.impl = null;
            				this.format = null;
            				this.defaultUniformBuffer = null;
            		}
            		setUniformBuffer(name, uniformBuffer) {
            				var index = this.format.bufferFormatsMap.get(name);
            				if (this.uniformBuffers[index] !== uniformBuffer) {
            						this.uniformBuffers[index] = uniformBuffer;
            						this.dirty = true;
            				}
            		}
            		setStorageBuffer(name, storageBuffer) {
            				var index = this.format.storageBufferFormatsMap.get(name);
            				if (this.storageBuffers[index] !== storageBuffer) {
            						this.storageBuffers[index] = storageBuffer;
            						this.dirty = true;
            				}
            		}
            		setTexture(name, texture) {
            				var index = this.format.textureFormatsMap.get(name);
            				if (this.textures[index] !== texture) {
            						this.textures[index] = texture;
            						this.dirty = true;
            				} else if (this.renderVersionUpdated < texture.renderVersionDirty) {
            						this.dirty = true;
            				}
            		}
            		setStorageTexture(name, texture) {
            				var index = this.format.storageTextureFormatsMap.get(name);
            				if (this.storageTextures[index] !== texture) {
            						this.storageTextures[index] = texture;
            						this.dirty = true;
            				} else if (this.renderVersionUpdated < texture.renderVersionDirty) {
            						this.dirty = true;
            				}
            		}
            		updateUniformBuffers() {
            				for(var i = 0; i < this.uniformBuffers.length; i++){
            						this.uniformBuffers[i].update();
            				}
            		}
            		update() {
            				var { textureFormats, storageTextureFormats, storageBufferFormats } = this.format;
            				for(var i = 0; i < textureFormats.length; i++){
            						var textureFormat = textureFormats[i];
            						var value = textureFormat.scopeId.value;
            						if (!value) {
            								if (textureFormat.name === 'uSceneDepthMap') {
            										value = getBuiltInTexture(this.device, 'white');
            								}
            								if (textureFormat.name === 'uSceneColorMap') {
            										value = getBuiltInTexture(this.device, 'pink');
            								}
            								if (!value) {
            										value = getBuiltInTexture(this.device, 'pink');
            								}
            						}
            						this.setTexture(textureFormat.name, value);
            				}
            				for(var i1 = 0; i1 < storageTextureFormats.length; i1++){
            						var storageTextureFormat = storageTextureFormats[i1];
            						var value1 = storageTextureFormat.scopeId.value;
            						this.setStorageTexture(storageTextureFormat.name, value1);
            				}
            				for(var i2 = 0; i2 < storageBufferFormats.length; i2++){
            						var storageBufferFormat = storageBufferFormats[i2];
            						var value2 = storageBufferFormat.scopeId.value;
            						this.setStorageBuffer(storageBufferFormat.name, value2);
            				}
            				this.uniformBufferOffsets.length = this.uniformBuffers.length;
            				for(var i3 = 0; i3 < this.uniformBuffers.length; i3++){
            						var uniformBuffer = this.uniformBuffers[i3];
            						this.uniformBufferOffsets[i3] = uniformBuffer.offset;
            						if (this.renderVersionUpdated < uniformBuffer.renderVersionDirty) {
            								this.dirty = true;
            						}
            				}
            				if (this.dirty) {
            						this.dirty = false;
            						this.renderVersionUpdated = this.device.renderVersion;
            						this.impl.update(this);
            				}
            		}
            		constructor(graphicsDevice, format, defaultUniformBuffer){
            				this.renderVersionUpdated = -1;
            				this.uniformBufferOffsets = [];
            				this.id = id$8++;
            				this.device = graphicsDevice;
            				this.format = format;
            				this.dirty = true;
            				this.impl = graphicsDevice.createBindGroupImpl(this);
            				this.textures = [];
            				this.storageTextures = [];
            				this.storageBuffers = [];
            				this.uniformBuffers = [];
            				this.defaultUniformBuffer = defaultUniformBuffer;
            				if (defaultUniformBuffer) {
            						this.setUniformBuffer(UNIFORM_BUFFER_DEFAULT_SLOT_NAME, defaultUniformBuffer);
            				}
            		}
            }
            
            var BitPacking = {
            		set (storage, value, shift, mask) {
            				if (mask === void 0) mask = 1;
            				var data = storage & ~(mask << shift);
            				return data | value << shift;
            		},
            		get (storage, shift, mask) {
            				if (mask === void 0) mask = 1;
            				return storage >> shift & mask;
            		},
            		all (storage, shift, mask) {
            				if (mask === void 0) mask = 1;
            				var shifted = mask << shift;
            				return (storage & shifted) === shifted;
            		},
            		any (storage, shift, mask) {
            				if (mask === void 0) mask = 1;
            				return (storage & mask << shift) !== 0;
            		}
            };
            
            var opMask = 7;
            var factorMask = 15;
            var colorOpShift = 0;
            var colorSrcFactorShift = 3;
            var colorDstFactorShift = 7;
            var alphaOpShift = 11;
            var alphaSrcFactorShift = 14;
            var alphaDstFactorShift = 18;
            var redWriteShift = 22;
            var greenWriteShift = 23;
            var blueWriteShift = 24;
            var alphaWriteShift = 25;
            var blendShift = 26;
            var allWriteMasks = 15;
            var allWriteShift = redWriteShift;
            class BlendState {
            		set blend(value) {
            				this.target0 = BitPacking.set(this.target0, value ? 1 : 0, blendShift);
            		}
            		get blend() {
            				return BitPacking.all(this.target0, blendShift);
            		}
            		setColorBlend(op, srcFactor, dstFactor) {
            				this.target0 = BitPacking.set(this.target0, op, colorOpShift, opMask);
            				this.target0 = BitPacking.set(this.target0, srcFactor, colorSrcFactorShift, factorMask);
            				this.target0 = BitPacking.set(this.target0, dstFactor, colorDstFactorShift, factorMask);
            		}
            		setAlphaBlend(op, srcFactor, dstFactor) {
            				this.target0 = BitPacking.set(this.target0, op, alphaOpShift, opMask);
            				this.target0 = BitPacking.set(this.target0, srcFactor, alphaSrcFactorShift, factorMask);
            				this.target0 = BitPacking.set(this.target0, dstFactor, alphaDstFactorShift, factorMask);
            		}
            		setColorWrite(redWrite, greenWrite, blueWrite, alphaWrite) {
            				this.redWrite = redWrite;
            				this.greenWrite = greenWrite;
            				this.blueWrite = blueWrite;
            				this.alphaWrite = alphaWrite;
            		}
            		get colorOp() {
            				return BitPacking.get(this.target0, colorOpShift, opMask);
            		}
            		get colorSrcFactor() {
            				return BitPacking.get(this.target0, colorSrcFactorShift, factorMask);
            		}
            		get colorDstFactor() {
            				return BitPacking.get(this.target0, colorDstFactorShift, factorMask);
            		}
            		get alphaOp() {
            				return BitPacking.get(this.target0, alphaOpShift, opMask);
            		}
            		get alphaSrcFactor() {
            				return BitPacking.get(this.target0, alphaSrcFactorShift, factorMask);
            		}
            		get alphaDstFactor() {
            				return BitPacking.get(this.target0, alphaDstFactorShift, factorMask);
            		}
            		set redWrite(value) {
            				this.target0 = BitPacking.set(this.target0, value ? 1 : 0, redWriteShift);
            		}
            		get redWrite() {
            				return BitPacking.all(this.target0, redWriteShift);
            		}
            		set greenWrite(value) {
            				this.target0 = BitPacking.set(this.target0, value ? 1 : 0, greenWriteShift);
            		}
            		get greenWrite() {
            				return BitPacking.all(this.target0, greenWriteShift);
            		}
            		set blueWrite(value) {
            				this.target0 = BitPacking.set(this.target0, value ? 1 : 0, blueWriteShift);
            		}
            		get blueWrite() {
            				return BitPacking.all(this.target0, blueWriteShift);
            		}
            		set alphaWrite(value) {
            				this.target0 = BitPacking.set(this.target0, value ? 1 : 0, alphaWriteShift);
            		}
            		get alphaWrite() {
            				return BitPacking.all(this.target0, alphaWriteShift);
            		}
            		get allWrite() {
            				return BitPacking.get(this.target0, allWriteShift, allWriteMasks);
            		}
            		copy(rhs) {
            				this.target0 = rhs.target0;
            				return this;
            		}
            		clone() {
            				var clone = new this.constructor();
            				return clone.copy(this);
            		}
            		get key() {
            				return this.target0;
            		}
            		equals(rhs) {
            				return this.target0 === rhs.target0;
            		}
            		constructor(blend = false, colorOp = BLENDEQUATION_ADD, colorSrcFactor = BLENDMODE_ONE, colorDstFactor = BLENDMODE_ZERO, alphaOp, alphaSrcFactor, alphaDstFactor, redWrite = true, greenWrite = true, blueWrite = true, alphaWrite = true){
            				this.target0 = 0;
            				this.setColorBlend(colorOp, colorSrcFactor, colorDstFactor);
            				this.setAlphaBlend(alphaOp != null ? alphaOp : colorOp, alphaSrcFactor != null ? alphaSrcFactor : colorSrcFactor, alphaDstFactor != null ? alphaDstFactor : colorDstFactor);
            				this.setColorWrite(redWrite, greenWrite, blueWrite, alphaWrite);
            				this.blend = blend;
            		}
            }
            BlendState.NOBLEND = Object.freeze(new BlendState());
            BlendState.NOWRITE = Object.freeze(new BlendState(undefined, undefined, undefined, undefined, undefined, undefined, undefined, false, false, false, false));
            BlendState.ALPHABLEND = Object.freeze(new BlendState(true, BLENDEQUATION_ADD, BLENDMODE_SRC_ALPHA, BLENDMODE_ONE_MINUS_SRC_ALPHA));
            BlendState.ADDBLEND = Object.freeze(new BlendState(true, BLENDEQUATION_ADD, BLENDMODE_ONE, BLENDMODE_ONE));
            
            class StringIds {
            		get(name) {
            				var value = this.map.get(name);
            				if (value === undefined) {
            						value = this.id++;
            						this.map.set(name, value);
            				}
            				return value;
            		}
            		constructor(){
            				this.map = new Map();
            				this.id = 0;
            		}
            }
            
            var stringIds$2 = new StringIds();
            var funcMask = 7;
            var funcShift = 0;
            var writeShift = 3;
            class DepthState {
            		set test(value) {
            				this.func = value ? FUNC_LESSEQUAL : FUNC_ALWAYS;
            				this.updateKey();
            		}
            		get test() {
            				return this.func !== FUNC_ALWAYS;
            		}
            		set write(value) {
            				this.data = BitPacking.set(this.data, value ? 1 : 0, writeShift);
            				this.updateKey();
            		}
            		get write() {
            				return BitPacking.all(this.data, writeShift);
            		}
            		set func(value) {
            				this.data = BitPacking.set(this.data, value, funcShift, funcMask);
            				this.updateKey();
            		}
            		get func() {
            				return BitPacking.get(this.data, funcShift, funcMask);
            		}
            		set depthBias(value) {
            				this._depthBias = value;
            				this.updateKey();
            		}
            		get depthBias() {
            				return this._depthBias;
            		}
            		set depthBiasSlope(value) {
            				this._depthBiasSlope = value;
            				this.updateKey();
            		}
            		get depthBiasSlope() {
            				return this._depthBiasSlope;
            		}
            		copy(rhs) {
            				this.data = rhs.data;
            				this._depthBias = rhs._depthBias;
            				this._depthBiasSlope = rhs._depthBiasSlope;
            				this.key = rhs.key;
            				return this;
            		}
            		clone() {
            				var clone = new this.constructor();
            				return clone.copy(this);
            		}
            		updateKey() {
            				var { data, _depthBias, _depthBiasSlope } = this;
            				var key = data + "-" + _depthBias + "-" + _depthBiasSlope;
            				this.key = stringIds$2.get(key);
            		}
            		equals(rhs) {
            				return this.key === rhs.key;
            		}
            		constructor(func = FUNC_LESSEQUAL, write = true){
            				this.data = 0;
            				this._depthBias = 0;
            				this._depthBiasSlope = 0;
            				this.key = 0;
            				this.func = func;
            				this.write = write;
            		}
            }
            DepthState.DEFAULT = Object.freeze(new DepthState());
            DepthState.NODEPTH = Object.freeze(new DepthState(FUNC_ALWAYS, false));
            DepthState.WRITEDEPTH = Object.freeze(new DepthState(FUNC_ALWAYS, true));
            
            class Version {
            		equals(other) {
            				return this.globalId === other.globalId && this.revision === other.revision;
            		}
            		copy(other) {
            				this.globalId = other.globalId;
            				this.revision = other.revision;
            		}
            		reset() {
            				this.globalId = 0;
            				this.revision = 0;
            		}
            		constructor(){
            				this.globalId = 0;
            				this.revision = 0;
            		}
            }
            
            var idCounter = 0;
            class VersionedObject {
            		increment() {
            				this.version.revision++;
            		}
            		constructor(){
            				idCounter++;
            				this.version = new Version();
            				this.version.globalId = idCounter;
            		}
            }
            
            class ScopeId {
            		toJSON(key) {
            				return undefined;
            		}
            		setValue(value) {
            				this.value = value;
            				this.versionObject.increment();
            		}
            		getValue() {
            				return this.value;
            		}
            		constructor(name){
            				this.name = name;
            				this.value = null;
            				this.versionObject = new VersionedObject();
            		}
            }
            
            class ScopeSpace {
            		resolve(name) {
            				if (!this.variables.has(name)) {
            						this.variables.set(name, new ScopeId(name));
            				}
            				return this.variables.get(name);
            		}
            		removeValue(value) {
            				for(var uniformName in this.variables){
            						var uniform = this.variables[uniformName];
            						if (uniform.value === value) {
            								uniform.value = null;
            						}
            				}
            		}
            		constructor(name){
            				this.name = name;
            				this.variables = new Map();
            		}
            }
            
            var id$7 = 0;
            class VertexBuffer {
            		destroy() {
            				var device = this.device;
            				var idx = device.buffers.indexOf(this);
            				if (idx !== -1) {
            						device.buffers.splice(idx, 1);
            				}
            				if (this.impl.initialized) {
            						this.impl.destroy(device);
            						this.adjustVramSizeTracking(device._vram, -this.storage.byteLength);
            				}
            		}
            		adjustVramSizeTracking(vram, size) {
            				vram.vb += size;
            		}
            		loseContext() {
            				this.impl.loseContext();
            		}
            		getFormat() {
            				return this.format;
            		}
            		getUsage() {
            				return this.usage;
            		}
            		getNumVertices() {
            				return this.numVertices;
            		}
            		lock() {
            				return this.storage;
            		}
            		unlock() {
            				this.impl.unlock(this);
            		}
            		setData(data) {
            				if (data.byteLength !== this.numBytes) {
            						return false;
            				}
            				this.storage = data;
            				this.unlock();
            				return true;
            		}
            		constructor(graphicsDevice, format, numVertices, options){
            				this.usage = BUFFER_STATIC;
            				var _options_usage;
            				this.usage = (_options_usage = options == null ? void 0 : options.usage) != null ? _options_usage : BUFFER_STATIC;
            				this.device = graphicsDevice;
            				this.format = format;
            				this.numVertices = numVertices;
            				this.id = id$7++;
            				this.impl = graphicsDevice.createVertexBufferImpl(this, format, options);
            				this.numBytes = format.verticesByteSize ? format.verticesByteSize : format.size * numVertices;
            				this.adjustVramSizeTracking(graphicsDevice._vram, this.numBytes);
            				var initialData = options == null ? void 0 : options.data;
            				if (initialData) {
            						this.setData(initialData);
            				} else {
            						this.storage = new ArrayBuffer(this.numBytes);
            				}
            				this.device.buffers.push(this);
            		}
            }
            
            function hashCode(str) {
            		if (str === null || str === undefined) {
            				return 0;
            		}
            		var hash = 0;
            		for(var i = 0, len = str.length; i < len; i++){
            				hash = (hash << 5) - hash + str.charCodeAt(i);
            				hash |= 0;
            		}
            		return hash;
            }
            function hash32Fnv1a(array) {
            		var prime = 16777619;
            		var hash = 2166136261;
            		for(var i = 0; i < array.length; i++){
            				hash ^= array[i];
            				hash *= prime;
            		}
            		return hash >>> 0;
            }
            
            var stringIds$1 = new StringIds();
            var webgpuValidElementSizes = [
            		2,
            		4,
            		8,
            		12,
            		16
            ];
            var deviceCache$2 = new DeviceCache();
            class VertexFormat {
            		get elements() {
            				return this._elements;
            		}
            		static getDefaultInstancingFormat(graphicsDevice) {
            				return deviceCache$2.get(graphicsDevice, ()=>{
            						return new VertexFormat(graphicsDevice, [
            								{
            										semantic: SEMANTIC_ATTR12,
            										components: 4,
            										type: TYPE_FLOAT32
            								},
            								{
            										semantic: SEMANTIC_ATTR13,
            										components: 4,
            										type: TYPE_FLOAT32
            								},
            								{
            										semantic: SEMANTIC_ATTR14,
            										components: 4,
            										type: TYPE_FLOAT32
            								},
            								{
            										semantic: SEMANTIC_ATTR15,
            										components: 4,
            										type: TYPE_FLOAT32
            								}
            						]);
            				});
            		}
            		static isElementValid(graphicsDevice, elementDesc) {
            				var elementSize = elementDesc.components * typedArrayTypesByteSize[elementDesc.type];
            				if (graphicsDevice.isWebGPU && !webgpuValidElementSizes.includes(elementSize)) {
            						return false;
            				}
            				return true;
            		}
            		update() {
            				this._evaluateHash();
            		}
            		_evaluateHash() {
            				var stringElementsBatch = [];
            				var stringElementsRender = [];
            				var len = this._elements.length;
            				for(var i = 0; i < len; i++){
            						var { name, dataType, numComponents, normalize, offset, stride, size, asInt } = this._elements[i];
            						var stringElementBatch = name + dataType + numComponents + normalize + asInt;
            						stringElementsBatch.push(stringElementBatch);
            						var stringElementRender = stringElementBatch + offset + stride + size;
            						stringElementsRender.push(stringElementRender);
            				}
            				stringElementsBatch.sort();
            				var batchingString = stringElementsBatch.join();
            				this.batchingHash = hashCode(batchingString);
            				this.shaderProcessingHashString = batchingString;
            				this.renderingHashString = stringElementsRender.join('_');
            				this.renderingHash = stringIds$1.get(this.renderingHashString);
            		}
            		constructor(graphicsDevice, description, vertexCount){
            				this.device = graphicsDevice;
            				this._elements = [];
            				this.hasUv0 = false;
            				this.hasUv1 = false;
            				this.hasColor = false;
            				this.hasTangents = false;
            				this.verticesByteSize = 0;
            				this.vertexCount = vertexCount;
            				this.interleaved = vertexCount === undefined;
            				this.instancing = false;
            				this.size = description.reduce((total, desc)=>{
            						return total + Math.ceil(desc.components * typedArrayTypesByteSize[desc.type] / 4) * 4;
            				}, 0);
            				var offset = 0, elementSize;
            				for(var i = 0, len = description.length; i < len; i++){
            						var elementDesc = description[i];
            						elementSize = elementDesc.components * typedArrayTypesByteSize[elementDesc.type];
            						if (vertexCount) {
            								offset = math.roundUp(offset, elementSize);
            						}
            						var _elementDesc_asInt;
            						var asInt = (_elementDesc_asInt = elementDesc.asInt) != null ? _elementDesc_asInt : false;
            						var _elementDesc_normalize;
            						var normalize = asInt ? false : (_elementDesc_normalize = elementDesc.normalize) != null ? _elementDesc_normalize : false;
            						var element = {
            								name: elementDesc.semantic,
            								offset: vertexCount ? offset : elementDesc.hasOwnProperty('offset') ? elementDesc.offset : offset,
            								stride: vertexCount ? elementSize : elementDesc.hasOwnProperty('stride') ? elementDesc.stride : this.size,
            								dataType: elementDesc.type,
            								numComponents: elementDesc.components,
            								normalize: normalize,
            								size: elementSize,
            								asInt: asInt
            						};
            						this._elements.push(element);
            						if (vertexCount) {
            								offset += elementSize * vertexCount;
            						} else {
            								offset += Math.ceil(elementSize / 4) * 4;
            						}
            						if (elementDesc.semantic === SEMANTIC_TEXCOORD0) {
            								this.hasUv0 = true;
            						} else if (elementDesc.semantic === SEMANTIC_TEXCOORD1) {
            								this.hasUv1 = true;
            						} else if (elementDesc.semantic === SEMANTIC_COLOR) {
            								this.hasColor = true;
            						} else if (elementDesc.semantic === SEMANTIC_TANGENT) {
            								this.hasTangents = true;
            						}
            				}
            				if (vertexCount) {
            						this.verticesByteSize = offset;
            				}
            				this._evaluateHash();
            		}
            }
            
            var stringIds = new StringIds();
            class StencilParameters {
            		set func(value) {
            				this._func = value;
            				this._dirty = true;
            		}
            		get func() {
            				return this._func;
            		}
            		set ref(value) {
            				this._ref = value;
            				this._dirty = true;
            		}
            		get ref() {
            				return this._ref;
            		}
            		set fail(value) {
            				this._fail = value;
            				this._dirty = true;
            		}
            		get fail() {
            				return this._fail;
            		}
            		set zfail(value) {
            				this._zfail = value;
            				this._dirty = true;
            		}
            		get zfail() {
            				return this._zfail;
            		}
            		set zpass(value) {
            				this._zpass = value;
            				this._dirty = true;
            		}
            		get zpass() {
            				return this._zpass;
            		}
            		set readMask(value) {
            				this._readMask = value;
            				this._dirty = true;
            		}
            		get readMask() {
            				return this._readMask;
            		}
            		set writeMask(value) {
            				this._writeMask = value;
            				this._dirty = true;
            		}
            		get writeMask() {
            				return this._writeMask;
            		}
            		_evalKey() {
            				var { _func, _ref, _fail, _zfail, _zpass, _readMask, _writeMask } = this;
            				var key = _func + "," + _ref + "," + _fail + "," + _zfail + "," + _zpass + "," + _readMask + "," + _writeMask;
            				this._key = stringIds.get(key);
            				this._dirty = false;
            		}
            		get key() {
            				if (this._dirty) {
            						this._evalKey();
            				}
            				return this._key;
            		}
            		copy(rhs) {
            				this._func = rhs._func;
            				this._ref = rhs._ref;
            				this._readMask = rhs._readMask;
            				this._writeMask = rhs._writeMask;
            				this._fail = rhs._fail;
            				this._zfail = rhs._zfail;
            				this._zpass = rhs._zpass;
            				this._dirty = rhs._dirty;
            				this._key = rhs._key;
            				return this;
            		}
            		clone() {
            				var clone = new this.constructor();
            				return clone.copy(this);
            		}
            		constructor(options = {}){
            				this._dirty = true;
            				var _options_func;
            				this._func = (_options_func = options.func) != null ? _options_func : FUNC_ALWAYS;
            				var _options_ref;
            				this._ref = (_options_ref = options.ref) != null ? _options_ref : 0;
            				var _options_readMask;
            				this._readMask = (_options_readMask = options.readMask) != null ? _options_readMask : 0xFF;
            				var _options_writeMask;
            				this._writeMask = (_options_writeMask = options.writeMask) != null ? _options_writeMask : 0xFF;
            				var _options_fail;
            				this._fail = (_options_fail = options.fail) != null ? _options_fail : STENCILOP_KEEP;
            				var _options_zfail;
            				this._zfail = (_options_zfail = options.zfail) != null ? _options_zfail : STENCILOP_KEEP;
            				var _options_zpass;
            				this._zpass = (_options_zpass = options.zpass) != null ? _options_zpass : STENCILOP_KEEP;
            				this._evalKey();
            		}
            }
            StencilParameters.DEFAULT = Object.freeze(new StencilParameters());
            
            function _extends$h() {
            		_extends$h = Object.assign || function(target) {
            				for(var i = 1; i < arguments.length; i++){
            						var source = arguments[i];
            						for(var key in source){
            								if (Object.prototype.hasOwnProperty.call(source, key)) {
            										target[key] = source[key];
            								}
            						}
            				}
            				return target;
            		};
            		return _extends$h.apply(this, arguments);
            }
            class GraphicsDevice extends EventHandler {
            		postInit() {
            				var vertexFormat = new VertexFormat(this, [
            						{
            								semantic: SEMANTIC_POSITION,
            								components: 2,
            								type: TYPE_FLOAT32
            						}
            				]);
            				var positions = new Float32Array([
            						-1,
            						-1,
            						1,
            						-1,
            						-1,
            						1,
            						1,
            						1
            				]);
            				this.quadVertexBuffer = new VertexBuffer(this, vertexFormat, 4, {
            						data: positions
            				});
            		}
            		initCapsDefines() {
            				var { capsDefines } = this;
            				capsDefines.clear();
            				if (this.textureFloatFilterable) capsDefines.set('CAPS_TEXTURE_FLOAT_FILTERABLE', '');
            				if (this.textureFloatRenderable) capsDefines.set('CAPS_TEXTURE_FLOAT_RENDERABLE', '');
            		}
            		destroy() {
            				var _this_quadVertexBuffer, _this_dynamicBuffers, _this_gpuProfiler;
            				this.fire('destroy');
            				(_this_quadVertexBuffer = this.quadVertexBuffer) == null ? void 0 : _this_quadVertexBuffer.destroy();
            				this.quadVertexBuffer = null;
            				(_this_dynamicBuffers = this.dynamicBuffers) == null ? void 0 : _this_dynamicBuffers.destroy();
            				this.dynamicBuffers = null;
            				(_this_gpuProfiler = this.gpuProfiler) == null ? void 0 : _this_gpuProfiler.destroy();
            				this.gpuProfiler = null;
            		}
            		onDestroyShader(shader) {
            				this.fire('destroy:shader', shader);
            				var idx = this.shaders.indexOf(shader);
            				if (idx !== -1) {
            						this.shaders.splice(idx, 1);
            				}
            		}
            		postDestroy() {
            				this.scope = null;
            				this.canvas = null;
            		}
            		loseContext() {
            				var _this_gpuProfiler;
            				this.contextLost = true;
            				this.backBufferSize.set(-1, -1);
            				for (var texture of this.textures){
            						texture.loseContext();
            				}
            				for (var buffer of this.buffers){
            						buffer.loseContext();
            				}
            				for (var target of this.targets){
            						target.loseContext();
            				}
            				(_this_gpuProfiler = this.gpuProfiler) == null ? void 0 : _this_gpuProfiler.loseContext();
            		}
            		restoreContext() {
            				var _this_gpuProfiler_restoreContext, _this_gpuProfiler;
            				this.contextLost = false;
            				this.initializeRenderState();
            				this.initializeContextCaches();
            				for (var buffer of this.buffers){
            						buffer.unlock();
            				}
            				(_this_gpuProfiler = this.gpuProfiler) == null ? void 0 : (_this_gpuProfiler_restoreContext = _this_gpuProfiler.restoreContext) == null ? void 0 : _this_gpuProfiler_restoreContext.call(_this_gpuProfiler);
            		}
            		toJSON(key) {
            				return undefined;
            		}
            		initializeContextCaches() {
            				this.indexBuffer = null;
            				this.vertexBuffers = [];
            				this.shader = null;
            				this.shaderValid = undefined;
            				this.shaderAsyncCompile = false;
            				this.renderTarget = null;
            		}
            		initializeRenderState() {
            				this.blendState = new BlendState();
            				this.depthState = new DepthState();
            				this.cullMode = CULLFACE_BACK;
            				this.vx = this.vy = this.vw = this.vh = 0;
            				this.sx = this.sy = this.sw = this.sh = 0;
            				this.blendColor = new Color(0, 0, 0, 0);
            		}
            		setStencilState(stencilFront, stencilBack) {}
            		setBlendState(blendState) {}
            		setBlendColor(r, g, b, a) {}
            		setDepthState(depthState) {}
            		setCullMode(cullMode) {}
            		setRenderTarget(renderTarget) {
            				this.renderTarget = renderTarget;
            		}
            		setIndexBuffer(indexBuffer) {
            				this.indexBuffer = indexBuffer;
            		}
            		setVertexBuffer(vertexBuffer) {
            				if (vertexBuffer) {
            						this.vertexBuffers.push(vertexBuffer);
            				}
            		}
            		clearVertexBuffer() {
            				this.vertexBuffers.length = 0;
            		}
            		clearIndexBuffer() {
            				this.indexBuffer = null;
            		}
            		getRenderTarget() {
            				return this.renderTarget;
            		}
            		initRenderTarget(target) {
            				if (target.initialized) return;
            				target.init();
            				this.targets.add(target);
            		}
            		_isBrowserInterface(texture) {
            				return this._isImageBrowserInterface(texture) || this._isImageCanvasInterface(texture) || this._isImageVideoInterface(texture);
            		}
            		_isImageBrowserInterface(texture) {
            				return typeof ImageBitmap !== 'undefined' && texture instanceof ImageBitmap || typeof HTMLImageElement !== 'undefined' && texture instanceof HTMLImageElement;
            		}
            		_isImageCanvasInterface(texture) {
            				return typeof HTMLCanvasElement !== 'undefined' && texture instanceof HTMLCanvasElement;
            		}
            		_isImageVideoInterface(texture) {
            				return typeof HTMLVideoElement !== 'undefined' && texture instanceof HTMLVideoElement;
            		}
            		resizeCanvas(width, height) {
            				var pixelRatio = Math.min(this._maxPixelRatio, platform.browser ? window.devicePixelRatio : 1);
            				var w = Math.floor(width * pixelRatio);
            				var h = Math.floor(height * pixelRatio);
            				if (w !== this.canvas.width || h !== this.canvas.height) {
            						this.setResolution(w, h);
            				}
            		}
            		setResolution(width, height) {
            				this.canvas.width = width;
            				this.canvas.height = height;
            				this.fire(GraphicsDevice.EVENT_RESIZE, width, height);
            		}
            		updateClientRect() {
            				if (platform.worker) {
            						this.clientRect.width = this.canvas.width;
            						this.clientRect.height = this.canvas.height;
            				} else {
            						var rect = this.canvas.getBoundingClientRect();
            						this.clientRect.width = rect.width;
            						this.clientRect.height = rect.height;
            				}
            		}
            		get width() {
            				return this.canvas.width;
            		}
            		get height() {
            				return this.canvas.height;
            		}
            		set fullscreen(fullscreen) {}
            		get fullscreen() {
            				return false;
            		}
            		set maxPixelRatio(ratio) {
            				this._maxPixelRatio = ratio;
            		}
            		get maxPixelRatio() {
            				return this._maxPixelRatio;
            		}
            		get deviceType() {
            				return this._deviceType;
            		}
            		startRenderPass(renderPass) {}
            		endRenderPass(renderPass) {}
            		startComputePass(name) {}
            		endComputePass() {}
            		frameStart() {
            				this.renderPassIndex = 0;
            				this.renderVersion++;
            		}
            		frameEnd() {}
            		computeDispatch(computes, name) {
            		}
            		getRenderableHdrFormat(formats, filterable, samples) {
            				if (formats === void 0) formats = [
            						PIXELFORMAT_111110F,
            						PIXELFORMAT_RGBA16F,
            						PIXELFORMAT_RGBA32F
            				];
            				if (filterable === void 0) filterable = true;
            				if (samples === void 0) samples = 1;
            				for(var i = 0; i < formats.length; i++){
            						var format = formats[i];
            						switch(format){
            								case PIXELFORMAT_111110F:
            										{
            												if (this.textureRG11B10Renderable) {
            														return format;
            												}
            												break;
            										}
            								case PIXELFORMAT_RGBA16F:
            										if (this.textureHalfFloatRenderable) {
            												return format;
            										}
            										break;
            								case PIXELFORMAT_RGBA32F:
            										if (this.isWebGPU && samples > 1) {
            												continue;
            										}
            										if (this.textureFloatRenderable && (!filterable || this.textureFloatFilterable)) {
            												return format;
            										}
            										break;
            						}
            				}
            				return undefined;
            		}
            		validateAttributes(shader, vb0Format, vb1Format) {}
            		constructor(canvas, options){
            				var _this_initOptions, _this_initOptions1, _this_initOptions2, _this_initOptions3, _this_initOptions4, _this_initOptions5;
            				super(), this.backBuffer = null, this.backBufferSize = new Vec2(), this.backBufferAntialias = false, this.isWebGPU = false, this.isWebGL2 = false, this.isHdr = false, this.maxColorAttachments = 1, this.maxSamples = 1, this.supportsCompute = false, this.supportsStorageTextureRead = false, this.renderTarget = null, this.shaders = [], this.textures = [], this.targets = new Set(), this.renderVersion = 0, this.insideRenderPass = false, this.supportsUniformBuffers = false, this.supportsClipDistances = false, this.textureRG11B10Renderable = false, this.textureFloatFilterable = false, this.blendState = new BlendState(), this.depthState = new DepthState(), this.stencilEnabled = false, this.stencilFront = new StencilParameters(), this.stencilBack = new StencilParameters(), this.defaultClearOptions = {
            						color: [
            								0,
            								0,
            								0,
            								1
            						],
            						depth: 1,
            						stencil: 0,
            						flags: CLEARFLAG_COLOR | CLEARFLAG_DEPTH
            				}, this.clientRect = {
            						width: 0,
            						height: 0
            				}, this._shadersDirty = false, this.capsDefines = new Map();
            				this.canvas = canvas;
            				if ('setAttribute' in canvas) {
            						canvas.setAttribute('data-engine', "PlayCanvas " + version);
            				}
            				this.initOptions = _extends$h({}, options);
            				var _alpha;
            				(_alpha = (_this_initOptions = this.initOptions).alpha) != null ? _alpha : _this_initOptions.alpha = true;
            				var _depth;
            				(_depth = (_this_initOptions1 = this.initOptions).depth) != null ? _depth : _this_initOptions1.depth = true;
            				var _stencil;
            				(_stencil = (_this_initOptions2 = this.initOptions).stencil) != null ? _stencil : _this_initOptions2.stencil = true;
            				var _antialias;
            				(_antialias = (_this_initOptions3 = this.initOptions).antialias) != null ? _antialias : _this_initOptions3.antialias = true;
            				var _powerPreference;
            				(_powerPreference = (_this_initOptions4 = this.initOptions).powerPreference) != null ? _powerPreference : _this_initOptions4.powerPreference = 'high-performance';
            				var _displayFormat;
            				(_displayFormat = (_this_initOptions5 = this.initOptions).displayFormat) != null ? _displayFormat : _this_initOptions5.displayFormat = DISPLAYFORMAT_LDR;
            				this._maxPixelRatio = platform.browser ? Math.min(1, window.devicePixelRatio) : 1;
            				this.buffers = [];
            				this._vram = {
            						tex: 0,
            						vb: 0,
            						ib: 0,
            						ub: 0,
            						sb: 0
            				};
            				this._shaderStats = {
            						vsCompiled: 0,
            						fsCompiled: 0,
            						linked: 0,
            						materialShaders: 0,
            						compileTime: 0
            				};
            				this.initializeContextCaches();
            				this._drawCallsPerFrame = 0;
            				this._shaderSwitchesPerFrame = 0;
            				this._primsPerFrame = [];
            				for(var i = PRIMITIVE_POINTS; i <= PRIMITIVE_TRIFAN; i++){
            						this._primsPerFrame[i] = 0;
            				}
            				this._renderTargetCreationTime = 0;
            				this.scope = new ScopeSpace('Device');
            				this.textureBias = this.scope.resolve('textureBias');
            				this.textureBias.setValue(0.0);
            		}
            }
            GraphicsDevice.EVENT_RESIZE = 'resizecanvas';
            
            var id$6 = 0;
            class RenderTarget {
            		destroy() {
            				var device = this._device;
            				if (device) {
            						device.targets.delete(this);
            						if (device.renderTarget === this) {
            								device.setRenderTarget(null);
            						}
            						this.destroyFrameBuffers();
            				}
            		}
            		destroyFrameBuffers() {
            				var device = this._device;
            				if (device) {
            						this.impl.destroy(device);
            				}
            		}
            		destroyTextureBuffers() {
            				var _this__depthBuffer, _this__colorBuffers;
            				(_this__depthBuffer = this._depthBuffer) == null ? void 0 : _this__depthBuffer.destroy();
            				this._depthBuffer = null;
            				(_this__colorBuffers = this._colorBuffers) == null ? void 0 : _this__colorBuffers.forEach((colorBuffer)=>{
            						colorBuffer.destroy();
            				});
            				this._colorBuffers = null;
            				this._colorBuffer = null;
            		}
            		resize(width, height) {
            				if (this.width !== width || this.height !== height) {
            						var _this__depthBuffer, _this__colorBuffers;
            						if (this.mipLevel > 0) {
            								return;
            						}
            						var device = this._device;
            						this.destroyFrameBuffers();
            						if (device.renderTarget === this) {
            								device.setRenderTarget(null);
            						}
            						(_this__depthBuffer = this._depthBuffer) == null ? void 0 : _this__depthBuffer.resize(width, height);
            						(_this__colorBuffers = this._colorBuffers) == null ? void 0 : _this__colorBuffers.forEach((colorBuffer)=>{
            								colorBuffer.resize(width, height);
            						});
            						this.validateMrt();
            						this.impl = device.createRenderTargetImpl(this);
            				}
            		}
            		validateMrt() {}
            		init() {
            				this.impl.init(this._device, this);
            		}
            		get initialized() {
            				return this.impl.initialized;
            		}
            		get device() {
            				return this._device;
            		}
            		loseContext() {
            				this.impl.loseContext();
            		}
            		resolve(color, depth) {
            				if (color === void 0) color = true;
            				if (depth === void 0) depth = !!this._depthBuffer;
            				if (this._device && this._samples > 1) {
            						this.impl.resolve(this._device, this, color, depth);
            				}
            		}
            		copy(source, color, depth) {
            				if (!this._device) {
            						if (source._device) {
            								this._device = source._device;
            						} else {
            								return false;
            						}
            				}
            				var success = this._device.copyRenderTarget(source, this, color, depth);
            				return success;
            		}
            		get samples() {
            				return this._samples;
            		}
            		get depth() {
            				return this._depth;
            		}
            		get stencil() {
            				return this._stencil;
            		}
            		get colorBuffer() {
            				return this._colorBuffer;
            		}
            		getColorBuffer(index) {
            				var _this__colorBuffers;
            				return (_this__colorBuffers = this._colorBuffers) == null ? void 0 : _this__colorBuffers[index];
            		}
            		get depthBuffer() {
            				return this._depthBuffer;
            		}
            		get face() {
            				return this._face;
            		}
            		get mipLevel() {
            				return this._mipLevel;
            		}
            		get mipmaps() {
            				return this._mipmaps;
            		}
            		get width() {
            				var _this__colorBuffer, _this__depthBuffer;
            				var width = ((_this__colorBuffer = this._colorBuffer) == null ? void 0 : _this__colorBuffer.width) || ((_this__depthBuffer = this._depthBuffer) == null ? void 0 : _this__depthBuffer.width) || this._device.width;
            				if (this._mipLevel > 0) {
            						width = TextureUtils.calcLevelDimension(width, this._mipLevel);
            				}
            				return width;
            		}
            		get height() {
            				var _this__colorBuffer, _this__depthBuffer;
            				var height = ((_this__colorBuffer = this._colorBuffer) == null ? void 0 : _this__colorBuffer.height) || ((_this__depthBuffer = this._depthBuffer) == null ? void 0 : _this__depthBuffer.height) || this._device.height;
            				if (this._mipLevel > 0) {
            						height = TextureUtils.calcLevelDimension(height, this._mipLevel);
            				}
            				return height;
            		}
            		isColorBufferSrgb(index) {
            				if (index === void 0) index = 0;
            				if (this.device.backBuffer === this) {
            						return isSrgbPixelFormat(this.device.backBufferFormat);
            				}
            				var colorBuffer = this.getColorBuffer(index);
            				return colorBuffer ? isSrgbPixelFormat(colorBuffer.format) : false;
            		}
            		constructor(options = {}){
            				var _options_colorBuffer, _options_colorBuffers, _options_depthBuffer;
            				this.id = id$6++;
            				var _options_colorBuffer_device, _ref, _ref1;
            				var device = (_ref1 = (_ref = (_options_colorBuffer_device = (_options_colorBuffer = options.colorBuffer) == null ? void 0 : _options_colorBuffer.device) != null ? _options_colorBuffer_device : (_options_colorBuffers = options.colorBuffers) == null ? void 0 : _options_colorBuffers[0].device) != null ? _ref : (_options_depthBuffer = options.depthBuffer) == null ? void 0 : _options_depthBuffer.device) != null ? _ref1 : options.graphicsDevice;
            				this._device = device;
            				var { maxSamples } = this._device;
            				var _options_samples;
            				this._samples = Math.min((_options_samples = options.samples) != null ? _options_samples : 1, maxSamples);
            				if (device.isWebGPU) {
            						this._samples = this._samples > 1 ? maxSamples : 1;
            				}
            				this._colorBuffer = options.colorBuffer;
            				if (options.colorBuffer) {
            						this._colorBuffers = [
            								options.colorBuffer
            						];
            				}
            				this._depthBuffer = options.depthBuffer;
            				var _options_face;
            				this._face = (_options_face = options.face) != null ? _options_face : 0;
            				if (this._depthBuffer) {
            						var format = this._depthBuffer._format;
            						if (format === PIXELFORMAT_DEPTH || format === PIXELFORMAT_DEPTH16) {
            								this._depth = true;
            								this._stencil = false;
            						} else if (format === PIXELFORMAT_DEPTHSTENCIL) {
            								this._depth = true;
            								this._stencil = true;
            						} else if (format === PIXELFORMAT_R32F && this._depthBuffer.device.isWebGPU && this._samples > 1) {
            								this._depth = true;
            								this._stencil = false;
            						} else {
            								this._depth = false;
            								this._stencil = false;
            						}
            				} else {
            						var _options_depth;
            						this._depth = (_options_depth = options.depth) != null ? _options_depth : true;
            						var _options_stencil;
            						this._stencil = (_options_stencil = options.stencil) != null ? _options_stencil : false;
            				}
            				if (options.colorBuffers) {
            						if (!this._colorBuffers) {
            								this._colorBuffers = [
            										...options.colorBuffers
            								];
            								this._colorBuffer = options.colorBuffers[0];
            						}
            				}
            				var _options_autoResolve;
            				this.autoResolve = (_options_autoResolve = options.autoResolve) != null ? _options_autoResolve : true;
            				this.name = options.name;
            				if (!this.name) {
            						var _this__colorBuffer;
            						this.name = (_this__colorBuffer = this._colorBuffer) == null ? void 0 : _this__colorBuffer.name;
            				}
            				if (!this.name) {
            						var _this__depthBuffer;
            						this.name = (_this__depthBuffer = this._depthBuffer) == null ? void 0 : _this__depthBuffer.name;
            				}
            				if (!this.name) {
            						this.name = 'Untitled';
            				}
            				var _options_flipY;
            				this.flipY = (_options_flipY = options.flipY) != null ? _options_flipY : false;
            				var _options_mipLevel;
            				this._mipLevel = (_options_mipLevel = options.mipLevel) != null ? _options_mipLevel : 0;
            				if (this._mipLevel > 0 && this._depth) {
            						this._mipLevel = 0;
            				}
            				this._mipmaps = options.mipLevel === undefined;
            				this.validateMrt();
            				this.impl = device.createRenderTargetImpl(this);
            		}
            }
            
            class RefCountedObject {
            		incRefCount() {
            				this._refCount++;
            		}
            		decRefCount() {
            				this._refCount--;
            		}
            		get refCount() {
            				return this._refCount;
            		}
            		constructor(){
            				this._refCount = 0;
            		}
            }
            
            class Entry extends RefCountedObject {
            		constructor(obj){
            				super();
            				this.object = obj;
            				this.incRefCount();
            		}
            }
            class RefCountedKeyCache {
            		destroy() {
            				this.cache.forEach((entry)=>{
            						var _entry_object;
            						(_entry_object = entry.object) == null ? void 0 : _entry_object.destroy();
            				});
            				this.cache.clear();
            		}
            		clear() {
            				this.cache.clear();
            		}
            		get(key) {
            				var entry = this.cache.get(key);
            				if (entry) {
            						entry.incRefCount();
            						return entry.object;
            				}
            				return null;
            		}
            		set(key, object) {
            				this.cache.set(key, new Entry(object));
            		}
            		release(key) {
            				var entry = this.cache.get(key);
            				if (entry) {
            						entry.decRefCount();
            						if (entry.refCount === 0) {
            								var _entry_object;
            								this.cache.delete(key);
            								(_entry_object = entry.object) == null ? void 0 : _entry_object.destroy();
            						}
            				}
            		}
            		constructor(){
            				this.cache = new Map();
            		}
            }
            
            class MultisampledTextureCache extends RefCountedKeyCache {
            		loseContext(device) {
            				this.clear();
            		}
            }
            var multisampledTextureCache = new DeviceCache();
            var getMultisampledTextureCache = (device)=>{
            		return multisampledTextureCache.get(device, ()=>{
            				return new MultisampledTextureCache();
            		});
            };
            
            var uniformTypeToNumComponents = [];
            uniformTypeToNumComponents[UNIFORMTYPE_FLOAT] = 1;
            uniformTypeToNumComponents[UNIFORMTYPE_VEC2] = 2;
            uniformTypeToNumComponents[UNIFORMTYPE_VEC3] = 3;
            uniformTypeToNumComponents[UNIFORMTYPE_VEC4] = 4;
            uniformTypeToNumComponents[UNIFORMTYPE_INT] = 1;
            uniformTypeToNumComponents[UNIFORMTYPE_IVEC2] = 2;
            uniformTypeToNumComponents[UNIFORMTYPE_IVEC3] = 3;
            uniformTypeToNumComponents[UNIFORMTYPE_IVEC4] = 4;
            uniformTypeToNumComponents[UNIFORMTYPE_BOOL] = 1;
            uniformTypeToNumComponents[UNIFORMTYPE_BVEC2] = 2;
            uniformTypeToNumComponents[UNIFORMTYPE_BVEC3] = 3;
            uniformTypeToNumComponents[UNIFORMTYPE_BVEC4] = 4;
            uniformTypeToNumComponents[UNIFORMTYPE_MAT2] = 8;
            uniformTypeToNumComponents[UNIFORMTYPE_MAT3] = 12;
            uniformTypeToNumComponents[UNIFORMTYPE_MAT4] = 16;
            uniformTypeToNumComponents[UNIFORMTYPE_UINT] = 1;
            uniformTypeToNumComponents[UNIFORMTYPE_UVEC2] = 2;
            uniformTypeToNumComponents[UNIFORMTYPE_UVEC3] = 3;
            uniformTypeToNumComponents[UNIFORMTYPE_UVEC4] = 4;
            class UniformFormat {
            		get isArrayType() {
            				return this.count > 0;
            		}
            		calculateOffset(offset) {
            				var alignment = this.byteSize <= 8 ? this.byteSize : 16;
            				if (this.count) {
            						alignment = 16;
            				}
            				offset = math.roundUp(offset, alignment);
            				this.offset = offset / 4;
            		}
            		constructor(name, type, count = 0){
            				this.shortName = name;
            				this.name = count ? "" + name + "[0]" : name;
            				this.type = type;
            				this.numComponents = uniformTypeToNumComponents[type];
            				this.updateType = type;
            				if (count > 0) {
            						switch(type){
            								case UNIFORMTYPE_FLOAT:
            										this.updateType = UNIFORMTYPE_FLOATARRAY;
            										break;
            								case UNIFORMTYPE_INT:
            										this.updateType = UNIFORMTYPE_INTARRAY;
            										break;
            								case UNIFORMTYPE_UINT:
            										this.updateType = UNIFORMTYPE_UINTARRAY;
            										break;
            								case UNIFORMTYPE_BOOL:
            										this.updateType = UNIFORMTYPE_BOOLARRAY;
            										break;
            								case UNIFORMTYPE_VEC2:
            										this.updateType = UNIFORMTYPE_VEC2ARRAY;
            										break;
            								case UNIFORMTYPE_IVEC2:
            										this.updateType = UNIFORMTYPE_IVEC2ARRAY;
            										break;
            								case UNIFORMTYPE_UVEC2:
            										this.updateType = UNIFORMTYPE_UVEC2ARRAY;
            										break;
            								case UNIFORMTYPE_BVEC2:
            										this.updateType = UNIFORMTYPE_BVEC2ARRAY;
            										break;
            								case UNIFORMTYPE_VEC3:
            										this.updateType = UNIFORMTYPE_VEC3ARRAY;
            										break;
            								case UNIFORMTYPE_IVEC3:
            										this.updateType = UNIFORMTYPE_IVEC3ARRAY;
            										break;
            								case UNIFORMTYPE_UVEC3:
            										this.updateType = UNIFORMTYPE_UVEC3ARRAY;
            										break;
            								case UNIFORMTYPE_BVEC3:
            										this.updateType = UNIFORMTYPE_BVEC3ARRAY;
            										break;
            								case UNIFORMTYPE_VEC4:
            										this.updateType = UNIFORMTYPE_VEC4ARRAY;
            										break;
            								case UNIFORMTYPE_IVEC4:
            										this.updateType = UNIFORMTYPE_IVEC4ARRAY;
            										break;
            								case UNIFORMTYPE_UVEC4:
            										this.updateType = UNIFORMTYPE_UVEC4ARRAY;
            										break;
            								case UNIFORMTYPE_BVEC4:
            										this.updateType = UNIFORMTYPE_BVEC4ARRAY;
            										break;
            								case UNIFORMTYPE_MAT4:
            										this.updateType = UNIFORMTYPE_MAT4ARRAY;
            										break;
            						}
            				}
            				this.count = count;
            				var componentSize = this.numComponents;
            				if (count) {
            						componentSize = math.roundUp(componentSize, 4);
            				}
            				this.byteSize = componentSize * 4;
            				if (count) {
            						this.byteSize *= count;
            				}
            		}
            }
            class UniformBufferFormat {
            		get(name) {
            				return this.map.get(name);
            		}
            		constructor(graphicsDevice, uniforms){
            				this.byteSize = 0;
            				this.map = new Map();
            				this.scope = graphicsDevice.scope;
            				this.uniforms = uniforms;
            				var offset = 0;
            				for(var i = 0; i < uniforms.length; i++){
            						var uniform = uniforms[i];
            						uniform.calculateOffset(offset);
            						offset = uniform.offset * 4 + uniform.byteSize;
            						uniform.scopeId = this.scope.resolve(uniform.name);
            						this.map.set(uniform.name, uniform);
            				}
            				this.byteSize = math.roundUp(offset, 16);
            		}
            }
            
            var KEYWORD = /[ \t]*#(ifn?def|if|endif|else|elif|define|undef|extension|include)/g;
            var DEFINE = /define[ \t]+([^\n]+)\r?(?:\n|$)/g;
            var EXTENSION = /extension[ \t]+([\w-]+)[ \t]*:[ \t]*(enable|require)/g;
            var UNDEF = /undef[ \t]+([^\n]+)\r?(?:\n|$)/g;
            var IF = /(ifdef|ifndef|if)[ \t]*([^\r\n]+)\r?\n/g;
            var ENDIF = /(endif|else|elif)(?:[ \t]+([^\r\n]*))?\r?\n?/g;
            var IDENTIFIER$1 = /\{?[\w-]+\}?/;
            var DEFINED = /(!|\s)?defined\(([\w-]+)\)/;
            var COMPARISON = /([a-z_]\w*)\s*(==|!=|<|<=|>|>=)\s*([\w"']+)/i;
            var INVALID = /[+\-]/g;
            var INCLUDE = /include[ \t]+"([\w-]+)(?:\s*,\s*([\w-]+))?"\r?(?:\n|$)/g;
            var LOOP_INDEX = /\{i\}/g;
            var FRAGCOLOR = /(pcFragColor[1-8])\b/g;
            class Preprocessor {
            		static run(source, includes, options) {
            				if (includes === void 0) includes = new Map();
            				if (options === void 0) options = {};
            				Preprocessor.sourceName = options.sourceName;
            				source = this.stripComments(source);
            				source = source.split(/\r?\n/).map((line)=>line.trimEnd()).join('\n');
            				var defines = new Map();
            				var injectDefines = new Map();
            				source = this._preprocess(source, defines, injectDefines, includes, options.stripDefines);
            				if (source === null) return null;
            				var intDefines = new Map();
            				defines.forEach((value, key)=>{
            						if (Number.isInteger(parseFloat(value)) && !value.includes('.')) {
            								intDefines.set(key, value);
            						}
            				});
            				source = this.stripComments(source);
            				source = this.stripUnusedColorAttachments(source, options);
            				source = this.RemoveEmptyLines(source);
            				source = this.processArraySize(source, intDefines);
            				source = this.injectDefines(source, injectDefines);
            				return source;
            		}
            		static stripUnusedColorAttachments(source, options) {
            				if (options.stripUnusedColorAttachments) {
            						var counts = new Map();
            						var matches = source.match(FRAGCOLOR);
            						matches == null ? void 0 : matches.forEach((match)=>{
            								var index = parseInt(match.charAt(match.length - 1), 10);
            								var _counts_get;
            								counts.set(index, ((_counts_get = counts.get(index)) != null ? _counts_get : 0) + 1);
            						});
            						var anySingleUse = Array.from(counts.values()).some((count)=>count === 1);
            						if (anySingleUse) {
            								var lines = source.split('\n');
            								var keepLines = [];
            								for(var i = 0; i < lines.length; i++){
            										var match = lines[i].match(FRAGCOLOR);
            										if (match) {
            												var index = parseInt(match[0].charAt(match[0].length - 1), 10);
            												if (index > 0 && counts.get(index) === 1) {
            														continue;
            												}
            										}
            										keepLines.push(lines[i]);
            								}
            								source = keepLines.join('\n');
            						}
            				}
            				return source;
            		}
            		static stripComments(source) {
            				return source.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, '$1');
            		}
            		static processArraySize(source, intDefines) {
            				if (source !== null) {
            						intDefines.forEach((value, key)=>{
            								source = source.replace(new RegExp("\\[" + key + "\\]", 'g'), "[" + value + "]");
            						});
            				}
            				return source;
            		}
            		static injectDefines(source, injectDefines) {
            				if (source !== null && injectDefines.size > 0) {
            						var lines = source.split('\n');
            						injectDefines.forEach((value, key)=>{
            								var regex = new RegExp(key, 'g');
            								for(var i = 0; i < lines.length; i++){
            										if (!lines[i].includes('#')) {
            												lines[i] = lines[i].replace(regex, value);
            										}
            								}
            						});
            						source = lines.join('\n');
            				}
            				return source;
            		}
            		static RemoveEmptyLines(source) {
            				if (source !== null) {
            						source = source.split(/\r?\n/).map((line)=>line.trim() === '' ? '' : line).join('\n');
            						source = source.replace(/(\n\n){3,}/g, '\n\n');
            				}
            				return source;
            		}
            		static _preprocess(source, defines, injectDefines, includes, stripDefines) {
            				if (defines === void 0) defines = new Map();
            				var originalSource = source;
            				var stack = [];
            				var error = false;
            				var match;
            				while((match = KEYWORD.exec(source)) !== null && !error){
            						var keyword = match[1];
            						switch(keyword){
            								case 'define':
            										{
            												DEFINE.lastIndex = match.index;
            												var define = DEFINE.exec(source);
            												error || (error = define === null);
            												var expression = define[1];
            												IDENTIFIER$1.lastIndex = define.index;
            												var identifierValue = IDENTIFIER$1.exec(expression);
            												var identifier = identifierValue[0];
            												var value = expression.substring(identifier.length).trim();
            												if (value === '') value = 'true';
            												var keep = Preprocessor._keep(stack);
            												var stripThisDefine = stripDefines;
            												if (keep) {
            														var replacementDefine = identifier.startsWith('{') && identifier.endsWith('}');
            														if (replacementDefine) {
            																stripThisDefine = true;
            														}
            														if (replacementDefine) {
            																injectDefines.set(identifier, value);
            														} else {
            																defines.set(identifier, value);
            														}
            														if (stripThisDefine) {
            																source = source.substring(0, define.index - 1) + source.substring(DEFINE.lastIndex);
            																KEYWORD.lastIndex = define.index - 1;
            														}
            												}
            												if (!stripThisDefine) {
            														KEYWORD.lastIndex = define.index + define[0].length;
            												}
            												break;
            										}
            								case 'undef':
            										{
            												UNDEF.lastIndex = match.index;
            												var undef = UNDEF.exec(source);
            												var identifier1 = undef[1].trim();
            												var keep1 = Preprocessor._keep(stack);
            												if (keep1) {
            														defines.delete(identifier1);
            														if (stripDefines) {
            																source = source.substring(0, undef.index - 1) + source.substring(UNDEF.lastIndex);
            																KEYWORD.lastIndex = undef.index - 1;
            														}
            												}
            												if (!stripDefines) {
            														KEYWORD.lastIndex = undef.index + undef[0].length;
            												}
            												break;
            										}
            								case 'extension':
            										{
            												EXTENSION.lastIndex = match.index;
            												var extension = EXTENSION.exec(source);
            												error || (error = extension === null);
            												if (extension) {
            														var identifier2 = extension[1];
            														var keep2 = Preprocessor._keep(stack);
            														if (keep2) {
            																defines.set(identifier2, 'true');
            														}
            												}
            												KEYWORD.lastIndex = extension.index + extension[0].length;
            												break;
            										}
            								case 'ifdef':
            								case 'ifndef':
            								case 'if':
            										{
            												IF.lastIndex = match.index;
            												var iff = IF.exec(source);
            												var expression1 = iff[2];
            												var evaluated = Preprocessor.evaluate(expression1, defines);
            												error || (error = evaluated.error);
            												var result = evaluated.result;
            												if (keyword === 'ifndef') {
            														result = !result;
            												}
            												stack.push({
            														anyKeep: result,
            														keep: result,
            														start: match.index,
            														end: IF.lastIndex
            												});
            												KEYWORD.lastIndex = iff.index + iff[0].length;
            												break;
            										}
            								case 'endif':
            								case 'else':
            								case 'elif':
            										{
            												ENDIF.lastIndex = match.index;
            												var endif = ENDIF.exec(source);
            												var blockInfo = stack.pop();
            												if (!blockInfo) {
            														console.error('Shader preprocessing encountered "#' + endif[1] + '" without a preceding #if #ifdef #ifndef while preprocessing ' + Preprocessor.sourceName + " on line:\n " + source.substring(match.index, match.index + 100) + "...", {
            																source: originalSource
            														});
            														error = true;
            														continue;
            												}
            												var blockCode = blockInfo.keep ? source.substring(blockInfo.end, match.index) : '';
            												source = source.substring(0, blockInfo.start) + blockCode + source.substring(ENDIF.lastIndex);
            												KEYWORD.lastIndex = blockInfo.start + blockCode.length;
            												var endifCommand = endif[1];
            												if (endifCommand === 'else' || endifCommand === 'elif') {
            														var result1 = false;
            														if (!blockInfo.anyKeep) {
            																if (endifCommand === 'else') {
            																		result1 = !blockInfo.keep;
            																} else {
            																		var evaluated1 = Preprocessor.evaluate(endif[2], defines);
            																		result1 = evaluated1.result;
            																		error || (error = evaluated1.error);
            																}
            														}
            														stack.push({
            																anyKeep: blockInfo.anyKeep || result1,
            																keep: result1,
            																start: KEYWORD.lastIndex,
            																end: KEYWORD.lastIndex
            														});
            												}
            												break;
            										}
            								case 'include':
            										{
            												var _include_;
            												INCLUDE.lastIndex = match.index;
            												var include = INCLUDE.exec(source);
            												error || (error = include === null);
            												if (!include) {
            														error = true;
            														continue;
            												}
            												var identifier3 = include[1].trim();
            												var countIdentifier = (_include_ = include[2]) == null ? void 0 : _include_.trim();
            												var keep3 = Preprocessor._keep(stack);
            												if (keep3) {
            														var includeSource = includes == null ? void 0 : includes.get(identifier3);
            														if (includeSource !== undefined) {
            																includeSource = this.stripComments(includeSource);
            																if (countIdentifier) {
            																		var countString = defines.get(countIdentifier);
            																		var count = parseFloat(countString);
            																		if (Number.isInteger(count)) {
            																				var result2 = '';
            																				for(var i = 0; i < count; i++){
            																						result2 += includeSource.replace(LOOP_INDEX, String(i));
            																				}
            																				includeSource = result2;
            																		} else {
            																				console.error('Include Count identifier "' + countIdentifier + '" not resolved while preprocessing ' + Preprocessor.sourceName + " on line:\n " + source.substring(match.index, match.index + 100) + "...", {
            																						source: originalSource
            																				});
            																				error = true;
            																		}
            																}
            																source = source.substring(0, include.index - 1) + includeSource + source.substring(INCLUDE.lastIndex);
            																KEYWORD.lastIndex = include.index - 1;
            														} else {
            																console.error('Include "' + identifier3 + '" not resolved while preprocessing ' + Preprocessor.sourceName, {
            																		source: originalSource
            																});
            																error = true;
            																continue;
            														}
            												}
            												break;
            										}
            						}
            				}
            				if (stack.length > 0) {
            						console.error("Shader preprocessing reached the end of the file without encountering the necessary #endif to close a preceding #if, #ifdef, or #ifndef block. " + Preprocessor.sourceName);
            						error = true;
            				}
            				if (error) {
            						console.error('Failed to preprocess shader: ', {
            								source: originalSource
            						});
            						return null;
            				}
            				return source;
            		}
            		static _keep(stack) {
            				for(var i = 0; i < stack.length; i++){
            						if (!stack[i].keep) {
            								return false;
            						}
            				}
            				return true;
            		}
            		static evaluateAtomicExpression(expr, defines) {
            				var error = false;
            				expr = expr.trim();
            				var invert = false;
            				var definedMatch = DEFINED.exec(expr);
            				if (definedMatch) {
            						invert = definedMatch[1] === '!';
            						expr = definedMatch[2].trim();
            						var exists = defines.has(expr);
            						return {
            								result: invert ? !exists : exists,
            								error
            						};
            				}
            				var comparisonMatch = COMPARISON.exec(expr);
            				if (comparisonMatch) {
            						var _defines_get;
            						var left = (_defines_get = defines.get(comparisonMatch[1].trim())) != null ? _defines_get : comparisonMatch[1].trim();
            						var _defines_get1;
            						var right = (_defines_get1 = defines.get(comparisonMatch[3].trim())) != null ? _defines_get1 : comparisonMatch[3].trim();
            						var operator = comparisonMatch[2].trim();
            						var result = false;
            						switch(operator){
            								case '==':
            										result = left === right;
            										break;
            								case '!=':
            										result = left !== right;
            										break;
            								case '<':
            										result = left < right;
            										break;
            								case '<=':
            										result = left <= right;
            										break;
            								case '>':
            										result = left > right;
            										break;
            								case '>=':
            										result = left >= right;
            										break;
            								default:
            										error = true;
            						}
            						return {
            								result,
            								error
            						};
            				}
            				var result1 = defines.has(expr);
            				return {
            						result: result1,
            						error
            				};
            		}
            		static evaluate(expression, defines) {
            				var correct = INVALID.exec(expression) === null;
            				var orSegments = expression.split('||');
            				for (var orSegment of orSegments){
            						var andSegments = orSegment.split('&&');
            						var andResult = true;
            						for (var andSegment of andSegments){
            								var { result, error } = Preprocessor.evaluateAtomicExpression(andSegment.trim(), defines);
            								if (!result || error) {
            										andResult = false;
            										break;
            								}
            						}
            						if (andResult) {
            								return {
            										result: true,
            										error: !correct
            								};
            						}
            				}
            				return {
            						result: false,
            						error: !correct
            				};
            		}
            }
            
            var gles3PS = "\n#ifndef outType_0\n#define outType_0 vec4\n#endif\nlayout(location = 0) out highp outType_0 pcFragColor0;\n#if COLOR_ATTACHMENT_1\nlayout(location = 1) out highp outType_1 pcFragColor1;\n#endif\n#if COLOR_ATTACHMENT_2\nlayout(location = 2) out highp outType_2 pcFragColor2;\n#endif\n#if COLOR_ATTACHMENT_3\nlayout(location = 3) out highp outType_3 pcFragColor3;\n#endif\n#if COLOR_ATTACHMENT_4\nlayout(location = 4) out highp outType_4 pcFragColor4;\n#endif\n#if COLOR_ATTACHMENT_5\nlayout(location = 5) out highp outType_5 pcFragColor5;\n#endif\n#if COLOR_ATTACHMENT_6\nlayout(location = 6) out highp outType_6 pcFragColor6;\n#endif\n#if COLOR_ATTACHMENT_7\nlayout(location = 7) out highp outType_7 pcFragColor7;\n#endif\n#define gl_FragColor pcFragColor0\n#define varying in\n#define texture2D texture\n#define texture2DBias texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLod textureLod\n#define texture2DProjLod textureProjLod\n#define textureCubeLod textureLod\n#define texture2DGrad textureGrad\n#define texture2DProjGrad textureProjGrad\n#define textureCubeGrad textureGrad\n#define utexture2D texture\n#define itexture2D texture\n#define texture2DLodEXT texture2DLodEXT_is_no_longer_supported_use_texture2DLod_instead\n#define texture2DProjLodEXT texture2DProjLodEXT_is_no_longer_supported_use_texture2DProjLod\n#define textureCubeLodEXT textureCubeLodEXT_is_no_longer_supported_use_textureCubeLod_instead\n#define texture2DGradEXT texture2DGradEXT_is_no_longer_supported_use_texture2DGrad_instead\n#define texture2DProjGradEXT texture2DProjGradEXT_is_no_longer_supported_use_texture2DProjGrad_instead\n#define textureCubeGradEXT textureCubeGradEXT_is_no_longer_supported_use_textureCubeGrad_instead\n#define textureShadow(res, uv) textureGrad(res, uv, vec2(1, 1), vec2(1, 1))\n#define SHADOWMAP_PASS(name) name\n#define SHADOWMAP_ACCEPT(name) sampler2DShadow name\n#define TEXTURE_PASS(name) name\n#define TEXTURE_ACCEPT(name) sampler2D name\n#define TEXTURE_ACCEPT_HIGHP(name) highp sampler2D name\n#define GL2\n";
            
            var gles3VS = "\n#define attribute in\n#define varying out\n#define texture2D texture\n#define utexture2D texture\n#define itexture2D texture\n#define GL2\n#define VERTEXSHADER\n#define TEXTURE_PASS(name) name\n#define TEXTURE_ACCEPT(name) sampler2D name\n#define TEXTURE_ACCEPT_HIGHP(name) highp sampler2D name\n";
            
            var webgpuPS = "\n#extension GL_EXT_samplerless_texture_functions : require\n#ifndef outType_0\n#define outType_0 vec4\n#endif\n#ifndef outType_1\n#define outType_1 vec4\n#endif\n#ifndef outType_2\n#define outType_2 vec4\n#endif\n#ifndef outType_3\n#define outType_3 vec4\n#endif\n#ifndef outType_4\n#define outType_4 vec4\n#endif\n#ifndef outType_5\n#define outType_5 vec4\n#endif\n#ifndef outType_6\n#define outType_6 vec4\n#endif\n#ifndef outType_7\n#define outType_7 vec4\n#endif\nlayout(location = 0) out highp outType_0 pcFragColor0;\nlayout(location = 1) out highp outType_1 pcFragColor1;\nlayout(location = 2) out highp outType_2 pcFragColor2;\nlayout(location = 3) out highp outType_3 pcFragColor3;\nlayout(location = 4) out highp outType_4 pcFragColor4;\nlayout(location = 5) out highp outType_5 pcFragColor5;\nlayout(location = 6) out highp outType_6 pcFragColor6;\nlayout(location = 7) out highp outType_7 pcFragColor7;\n#define gl_FragColor pcFragColor0\n#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)\n#define texture2DBias(res, uv, bias) texture(sampler2D(res, res ## _sampler), uv, bias)\n#define texture2DLod(res, uv, lod) textureLod(sampler2D(res, res ## _sampler), uv, lod)\n#define textureCube(res, uv) texture(samplerCube(res, res ## _sampler), uv)\n#define textureCubeLod(res, uv, lod) textureLod(samplerCube(res, res ## _sampler), uv, lod)\n#define textureShadow(res, uv) textureLod(sampler2DShadow(res, res ## _sampler), uv, 0.0)\n#define itexture2D(res, uv) texture(isampler2D(res, res ## _sampler), uv)\n#define utexture2D(res, uv) texture(usampler2D(res, res ## _sampler), uv)\n#define texture2DLodEXT texture2DLodEXT_is_no_longer_supported_use_texture2DLod_instead\n#define texture2DProjLodEXT texture2DProjLodEXT_is_no_longer_supported_use_texture2DProjLod\n#define textureCubeLodEXT textureCubeLodEXT_is_no_longer_supported_use_textureCubeLod_instead\n#define texture2DGradEXT texture2DGradEXT_is_no_longer_supported_use_texture2DGrad_instead\n#define texture2DProjGradEXT texture2DProjGradEXT_is_no_longer_supported_use_texture2DProjGrad_instead\n#define textureCubeGradEXT textureCubeGradEXT_is_no_longer_supported_use_textureCubeGrad_instead\n#define SHADOWMAP_PASS(name) name, name ## _sampler\n#define SHADOWMAP_ACCEPT(name) texture2D name, sampler name ## _sampler\n#define TEXTURE_PASS(name) name, name ## _sampler\n#define TEXTURE_ACCEPT(name) texture2D name, sampler name ## _sampler\n#define TEXTURE_ACCEPT_HIGHP TEXTURE_ACCEPT\n#define GL2\n#define WEBGPU\n";
            
            var webgpuVS = "\n#extension GL_EXT_samplerless_texture_functions : require\n#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)\n#define itexture2D(res, uv) texture(isampler2D(res, res ## _sampler), uv)\n#define utexture2D(res, uv) texture(usampler2D(res, res ## _sampler), uv)\n#define TEXTURE_PASS(name) name, name ## _sampler\n#define TEXTURE_ACCEPT(name) texture2D name, sampler name ## _sampler\n#define TEXTURE_ACCEPT_HIGHP TEXTURE_ACCEPT\n#define GL2\n#define WEBGPU\n#define VERTEXSHADER\n#define gl_VertexID gl_VertexIndex\n#define gl_InstanceID gl_InstanceIndex\n";
            
            var wgslFS = "\n";
            
            var wgslVS = "\n#define VERTEXSHADER\n";
            
            var sharedGLSL = "\nvec2 getGrabScreenPos(vec4 clipPos) {\n	vec2 uv = (clipPos.xy / clipPos.w) * 0.5 + 0.5;\n	#ifdef WEBGPU\n		uv.y = 1.0 - uv.y;\n	#endif\n	return uv;\n}\nvec2 getImageEffectUV(vec2 uv) {\n	#ifdef WEBGPU\n		uv.y = 1.0 - uv.y;\n	#endif\n	return uv;\n}\n";
            
            var sharedWGSL = "\nfn getGrabScreenPos(clipPos: vec4<f32>) -> vec2<f32> {\n	var uv: vec2<f32> = (clipPos.xy / clipPos.w) * 0.5 + vec2<f32>(0.5);\n	uv.y = 1.0 - uv.y;\n	return uv;\n}\nfn getImageEffectUV(uv: vec2<f32>) -> vec2<f32> {\n	var modifiedUV: vec2<f32> = uv;\n	modifiedUV.y = 1.0 - modifiedUV.y;\n	return modifiedUV;\n}\nstruct WrappedF32 { @size(16) element: f32 }\nstruct WrappedI32 { @size(16) element: i32 }\nstruct WrappedU32 { @size(16) element: u32 }\nstruct WrappedVec2F { @size(16) element: vec2f }\nstruct WrappedVec2I { @size(16) element: vec2i }\nstruct WrappedVec2U { @size(16) element: vec2u }\n";
            
            var _attrib2Semantic = {
            		vertex_position: SEMANTIC_POSITION,
            		vertex_normal: SEMANTIC_NORMAL,
            		vertex_tangent: SEMANTIC_TANGENT,
            		vertex_texCoord0: SEMANTIC_TEXCOORD0,
            		vertex_texCoord1: SEMANTIC_TEXCOORD1,
            		vertex_texCoord2: SEMANTIC_TEXCOORD2,
            		vertex_texCoord3: SEMANTIC_TEXCOORD3,
            		vertex_texCoord4: SEMANTIC_TEXCOORD4,
            		vertex_texCoord5: SEMANTIC_TEXCOORD5,
            		vertex_texCoord6: SEMANTIC_TEXCOORD6,
            		vertex_texCoord7: SEMANTIC_TEXCOORD7,
            		vertex_color: SEMANTIC_COLOR,
            		vertex_boneIndices: SEMANTIC_BLENDINDICES,
            		vertex_boneWeights: SEMANTIC_BLENDWEIGHT
            };
            class ShaderUtils {
            		static createDefinition(device, options) {
            				var getDefines = (gpu, gl2, isVertex, options)=>{
            						var deviceIntro = device.isWebGPU ? gpu : gl2;
            						var attachmentsDefine = '';
            						if (!isVertex) {
            								var _options_fragmentOutputTypes;
            								var fragmentOutputTypes = (_options_fragmentOutputTypes = options.fragmentOutputTypes) != null ? _options_fragmentOutputTypes : 'vec4';
            								if (!Array.isArray(fragmentOutputTypes)) {
            										fragmentOutputTypes = [
            												fragmentOutputTypes
            										];
            								}
            								for(var i = 0; i < device.maxColorAttachments; i++){
            										attachmentsDefine += "#define COLOR_ATTACHMENT_" + i + "\n";
            										var _fragmentOutputTypes_i;
            										var outType = (_fragmentOutputTypes_i = fragmentOutputTypes[i]) != null ? _fragmentOutputTypes_i : 'vec4';
            										attachmentsDefine += "#define outType_" + i + " " + outType + "\n";
            								}
            						}
            						return attachmentsDefine + deviceIntro;
            				};
            				var _options_name;
            				var name = (_options_name = options.name) != null ? _options_name : 'Untitled';
            				var vertCode;
            				var fragCode;
            				var vertexDefinesCode = ShaderUtils.getDefinesCode(device, options.vertexDefines);
            				var fragmentDefinesCode = ShaderUtils.getDefinesCode(device, options.fragmentDefines);
            				var wgsl = options.shaderLanguage === SHADERLANGUAGE_WGSL;
            				if (wgsl) {
            						vertCode = "\n                " + wgslVS + "\n                " + sharedWGSL + "\n                " + vertexDefinesCode + "\n                " + options.vertexCode + "\n            ";
            						fragCode = "\n                " + wgslFS + "\n                " + sharedWGSL + "\n                " + fragmentDefinesCode + "\n                " + options.fragmentCode + "\n            ";
            				} else {
            						vertCode = ShaderUtils.versionCode(device) + getDefines(webgpuVS, gles3VS, true, options) + vertexDefinesCode + ShaderUtils.precisionCode(device) + "\n                " + sharedGLSL + "\n                " + ShaderUtils.getShaderNameCode(name) + "\n                " + options.vertexCode;
            						fragCode = (options.fragmentPreamble || '') + ShaderUtils.versionCode(device) + getDefines(webgpuPS, gles3PS, false, options) + fragmentDefinesCode + ShaderUtils.precisionCode(device) + "\n                " + sharedGLSL + "\n                " + ShaderUtils.getShaderNameCode(name) + "\n                " + (options.fragmentCode || ShaderUtils.dummyFragmentCode());
            				}
            				var _options_shaderLanguage;
            				return {
            						name: name,
            						shaderLanguage: (_options_shaderLanguage = options.shaderLanguage) != null ? _options_shaderLanguage : SHADERLANGUAGE_GLSL,
            						attributes: options.attributes,
            						vshader: vertCode,
            						vincludes: options.vertexIncludes,
            						fincludes: options.fragmentIncludes,
            						fshader: fragCode,
            						useTransformFeedback: options.useTransformFeedback,
            						meshUniformBufferFormat: options.meshUniformBufferFormat,
            						meshBindGroupFormat: options.meshBindGroupFormat
            				};
            		}
            		static getDefinesCode(device, defines) {
            				var code = '';
            				device.capsDefines.forEach((value, key)=>{
            						code += "#define " + key + " " + value + "\n";
            				});
            				code += '\n';
            				defines == null ? void 0 : defines.forEach((value, key)=>{
            						code += "#define " + key + " " + value + "\n";
            				});
            				code += '\n';
            				return code;
            		}
            		static getShaderNameCode(name) {
            				return "#define SHADER_NAME " + name + "\n";
            		}
            		static dummyFragmentCode() {
            				return 'void main(void) {gl_FragColor = vec4(0.0);}';
            		}
            		static versionCode(device) {
            				return device.isWebGPU ? '#version 450\n' : '#version 300 es\n';
            		}
            		static precisionCode(device, forcePrecision) {
            				if (forcePrecision && forcePrecision !== 'highp' && forcePrecision !== 'mediump' && forcePrecision !== 'lowp') {
            						forcePrecision = null;
            				}
            				if (forcePrecision) {
            						if (forcePrecision === 'highp' && device.maxPrecision !== 'highp') {
            								forcePrecision = 'mediump';
            						}
            						if (forcePrecision === 'mediump' && device.maxPrecision === 'lowp') {
            								forcePrecision = 'lowp';
            						}
            				}
            				var precision = forcePrecision ? forcePrecision : device.precision;
            				var code = "\n            precision " + precision + " float;\n            precision " + precision + " int;\n            precision " + precision + " usampler2D;\n            precision " + precision + " isampler2D;\n            precision " + precision + " sampler2DShadow;\n            precision " + precision + " samplerCubeShadow;\n            precision " + precision + " sampler2DArray;\n        ";
            				return code;
            		}
            		static collectAttributes(vsCode) {
            				var attribs = {};
            				var attrs = 0;
            				var found = vsCode.indexOf('attribute');
            				while(found >= 0){
            						if (found > 0 && vsCode[found - 1] === '/') break;
            						var ignore = false;
            						if (found > 0) {
            								var startOfLine = vsCode.lastIndexOf('\n', found);
            								startOfLine = startOfLine !== -1 ? startOfLine + 1 : 0;
            								var lineStartString = vsCode.substring(startOfLine, found);
            								if (lineStartString.includes('#')) {
            										ignore = true;
            								}
            						}
            						if (!ignore) {
            								var endOfLine = vsCode.indexOf(';', found);
            								var startOfAttribName = vsCode.lastIndexOf(' ', endOfLine);
            								var attribName = vsCode.substring(startOfAttribName + 1, endOfLine);
            								if (attribs[attribName]) ; else {
            										var semantic = _attrib2Semantic[attribName];
            										if (semantic !== undefined) {
            												attribs[attribName] = semantic;
            										} else {
            												attribs[attribName] = "ATTR" + attrs;
            												attrs++;
            										}
            								}
            						}
            						found = vsCode.indexOf('attribute', found + 1);
            				}
            				return attribs;
            		}
            }
            
            var id$5 = 0;
            class Shader {
            		init() {
            				this.ready = false;
            				this.failed = false;
            		}
            		get label() {
            				return "Shader Id " + this.id + " (" + (this.definition.shaderLanguage === SHADERLANGUAGE_WGSL ? 'WGSL' : 'GLSL') + ") " + this.name;
            		}
            		destroy() {
            				this.device.onDestroyShader(this);
            				this.impl.destroy(this);
            		}
            		loseContext() {
            				this.init();
            				this.impl.loseContext();
            		}
            		restoreContext() {
            				this.impl.restoreContext(this.device, this);
            		}
            		constructor(graphicsDevice, definition){
            				this.attributes = new Map();
            				this.id = id$5++;
            				this.device = graphicsDevice;
            				this.definition = definition;
            				this.name = definition.name || 'Untitled';
            				this.init();
            				if (definition.cshader) ; else {
            						var wgsl = definition.shaderLanguage === SHADERLANGUAGE_WGSL;
            						definition.vshader = Preprocessor.run(definition.vshader, definition.vincludes, {
            								sourceName: "vertex shader for " + this.label,
            								stripDefines: wgsl
            						});
            						if (definition.shaderLanguage === SHADERLANGUAGE_GLSL) {
            								var _definition;
            								var _attributes;
            								(_attributes = (_definition = definition).attributes) != null ? _attributes : _definition.attributes = ShaderUtils.collectAttributes(definition.vshader);
            						}
            						var stripUnusedColorAttachments = graphicsDevice.isWebGL2 && (platform.name === 'osx' || platform.name === 'ios');
            						definition.fshader = Preprocessor.run(definition.fshader, definition.fincludes, {
            								stripUnusedColorAttachments,
            								stripDefines: wgsl,
            								sourceName: "fragment shader for " + this.label
            						});
            						if (!definition.vshader || !definition.fshader) {
            								this.failed = true;
            								return;
            						}
            				}
            				this.impl = graphicsDevice.createShaderImpl(this);
            		}
            }
            
            class DynamicBufferAllocation {
            }
            
            var _updateFunctions = [];
            _updateFunctions[UNIFORMTYPE_FLOAT] = function(uniformBuffer, value, offset) {
            		var dst = uniformBuffer.storageFloat32;
            		dst[offset] = value;
            };
            _updateFunctions[UNIFORMTYPE_VEC2] = (uniformBuffer, value, offset)=>{
            		var dst = uniformBuffer.storageFloat32;
            		dst[offset] = value[0];
            		dst[offset + 1] = value[1];
            };
            _updateFunctions[UNIFORMTYPE_VEC3] = (uniformBuffer, value, offset)=>{
            		var dst = uniformBuffer.storageFloat32;
            		dst[offset] = value[0];
            		dst[offset + 1] = value[1];
            		dst[offset + 2] = value[2];
            };
            _updateFunctions[UNIFORMTYPE_VEC4] = (uniformBuffer, value, offset)=>{
            		var dst = uniformBuffer.storageFloat32;
            		dst[offset] = value[0];
            		dst[offset + 1] = value[1];
            		dst[offset + 2] = value[2];
            		dst[offset + 3] = value[3];
            };
            _updateFunctions[UNIFORMTYPE_INT] = function(uniformBuffer, value, offset) {
            		var dst = uniformBuffer.storageInt32;
            		dst[offset] = value;
            };
            _updateFunctions[UNIFORMTYPE_IVEC2] = function(uniformBuffer, value, offset) {
            		var dst = uniformBuffer.storageInt32;
            		dst[offset] = value[0];
            		dst[offset + 1] = value[1];
            };
            _updateFunctions[UNIFORMTYPE_IVEC3] = function(uniformBuffer, value, offset) {
            		var dst = uniformBuffer.storageInt32;
            		dst[offset] = value[0];
            		dst[offset + 1] = value[1];
            		dst[offset + 2] = value[2];
            };
            _updateFunctions[UNIFORMTYPE_IVEC4] = function(uniformBuffer, value, offset) {
            		var dst = uniformBuffer.storageInt32;
            		dst[offset] = value[0];
            		dst[offset + 1] = value[1];
            		dst[offset + 2] = value[2];
            		dst[offset + 3] = value[3];
            };
            _updateFunctions[UNIFORMTYPE_MAT2] = (uniformBuffer, value, offset)=>{
            		var dst = uniformBuffer.storageFloat32;
            		dst[offset] = value[0];
            		dst[offset + 1] = value[1];
            		dst[offset + 4] = value[2];
            		dst[offset + 5] = value[3];
            		dst[offset + 8] = value[4];
            		dst[offset + 9] = value[5];
            };
            _updateFunctions[UNIFORMTYPE_MAT3] = (uniformBuffer, value, offset)=>{
            		var dst = uniformBuffer.storageFloat32;
            		dst[offset] = value[0];
            		dst[offset + 1] = value[1];
            		dst[offset + 2] = value[2];
            		dst[offset + 4] = value[3];
            		dst[offset + 5] = value[4];
            		dst[offset + 6] = value[5];
            		dst[offset + 8] = value[6];
            		dst[offset + 9] = value[7];
            		dst[offset + 10] = value[8];
            };
            _updateFunctions[UNIFORMTYPE_FLOATARRAY] = function(uniformBuffer, value, offset, count) {
            		var dst = uniformBuffer.storageFloat32;
            		for(var i = 0; i < count; i++){
            				dst[offset + i * 4] = value[i];
            		}
            };
            _updateFunctions[UNIFORMTYPE_VEC2ARRAY] = (uniformBuffer, value, offset, count)=>{
            		var dst = uniformBuffer.storageFloat32;
            		for(var i = 0; i < count; i++){
            				dst[offset + i * 4] = value[i * 2];
            				dst[offset + i * 4 + 1] = value[i * 2 + 1];
            		}
            };
            _updateFunctions[UNIFORMTYPE_VEC3ARRAY] = (uniformBuffer, value, offset, count)=>{
            		var dst = uniformBuffer.storageFloat32;
            		for(var i = 0; i < count; i++){
            				dst[offset + i * 4] = value[i * 3];
            				dst[offset + i * 4 + 1] = value[i * 3 + 1];
            				dst[offset + i * 4 + 2] = value[i * 3 + 2];
            		}
            };
            _updateFunctions[UNIFORMTYPE_UINT] = (uniformBuffer, value, offset, count)=>{
            		var dst = uniformBuffer.storageUint32;
            		dst[offset] = value;
            };
            _updateFunctions[UNIFORMTYPE_UVEC2] = (uniformBuffer, value, offset, count)=>{
            		var dst = uniformBuffer.storageUint32;
            		dst[offset] = value[0];
            		dst[offset + 1] = value[1];
            };
            _updateFunctions[UNIFORMTYPE_UVEC3] = (uniformBuffer, value, offset, count)=>{
            		var dst = uniformBuffer.storageUint32;
            		dst[offset] = value[0];
            		dst[offset + 1] = value[1];
            		dst[offset + 2] = value[2];
            };
            _updateFunctions[UNIFORMTYPE_UVEC4] = (uniformBuffer, value, offset, count)=>{
            		var dst = uniformBuffer.storageUint32;
            		dst[offset] = value[0];
            		dst[offset + 1] = value[1];
            		dst[offset + 2] = value[2];
            		dst[offset + 3] = value[3];
            };
            _updateFunctions[UNIFORMTYPE_INTARRAY] = function(uniformBuffer, value, offset, count) {
            		var dst = uniformBuffer.storageInt32;
            		for(var i = 0; i < count; i++){
            				dst[offset + i * 4] = value[i];
            		}
            };
            _updateFunctions[UNIFORMTYPE_BOOLARRAY] = _updateFunctions[UNIFORMTYPE_INTARRAY];
            _updateFunctions[UNIFORMTYPE_UINTARRAY] = function(uniformBuffer, value, offset, count) {
            		var dst = uniformBuffer.storageUint32;
            		for(var i = 0; i < count; i++){
            				dst[offset + i * 4] = value[i];
            		}
            };
            _updateFunctions[UNIFORMTYPE_IVEC2ARRAY] = (uniformBuffer, value, offset, count)=>{
            		var dst = uniformBuffer.storageInt32;
            		for(var i = 0; i < count; i++){
            				dst[offset + i * 4] = value[i * 2];
            				dst[offset + i * 4 + 1] = value[i * 2 + 1];
            		}
            };
            _updateFunctions[UNIFORMTYPE_BVEC2ARRAY] = _updateFunctions[UNIFORMTYPE_IVEC2ARRAY];
            _updateFunctions[UNIFORMTYPE_UVEC2ARRAY] = (uniformBuffer, value, offset, count)=>{
            		var dst = uniformBuffer.storageUint32;
            		for(var i = 0; i < count; i++){
            				dst[offset + i * 4] = value[i * 2];
            				dst[offset + i * 4 + 1] = value[i * 2 + 1];
            		}
            };
            _updateFunctions[UNIFORMTYPE_IVEC3ARRAY] = (uniformBuffer, value, offset, count)=>{
            		var dst = uniformBuffer.storageInt32;
            		for(var i = 0; i < count; i++){
            				dst[offset + i * 4] = value[i * 3];
            				dst[offset + i * 4 + 1] = value[i * 3 + 1];
            				dst[offset + i * 4 + 2] = value[i * 3 + 2];
            		}
            };
            _updateFunctions[UNIFORMTYPE_BVEC3ARRAY] = _updateFunctions[UNIFORMTYPE_IVEC3ARRAY];
            _updateFunctions[UNIFORMTYPE_UVEC3ARRAY] = (uniformBuffer, value, offset, count)=>{
            		var dst = uniformBuffer.storageUint32;
            		for(var i = 0; i < count; i++){
            				dst[offset + i * 4] = value[i * 3];
            				dst[offset + i * 4 + 1] = value[i * 3 + 1];
            				dst[offset + i * 4 + 2] = value[i * 3 + 2];
            		}
            };
            class UniformBuffer {
            		destroy() {
            				if (this.persistent) {
            						var device = this.device;
            						this.impl.destroy(device);
            						device._vram.ub -= this.format.byteSize;
            				}
            		}
            		get offset() {
            				return this.persistent ? 0 : this.allocation.offset;
            		}
            		assignStorage(storage) {
            				this.storageInt32 = storage;
            				this.storageUint32 = new Uint32Array(storage.buffer, storage.byteOffset, storage.byteLength / 4);
            				this.storageFloat32 = new Float32Array(storage.buffer, storage.byteOffset, storage.byteLength / 4);
            		}
            		loseContext() {
            				var _this_impl;
            				(_this_impl = this.impl) == null ? void 0 : _this_impl.loseContext();
            		}
            		setUniform(uniformFormat, value) {
            				var offset = uniformFormat.offset;
            				if (value !== null && value !== undefined) {
            						var updateFunction = _updateFunctions[uniformFormat.updateType];
            						if (updateFunction) {
            								updateFunction(this, value, offset, uniformFormat.count);
            						} else {
            								this.storageFloat32.set(value, offset);
            						}
            				}
            		}
            		set(name, value) {
            				var uniformFormat = this.format.map.get(name);
            				if (uniformFormat) {
            						this.setUniform(uniformFormat, value);
            				}
            		}
            		startUpdate(dynamicBindGroup) {
            				if (!this.persistent) {
            						var allocation = this.allocation;
            						var oldGpuBuffer = allocation.gpuBuffer;
            						this.device.dynamicBuffers.alloc(allocation, this.format.byteSize);
            						this.assignStorage(allocation.storage);
            						if (dynamicBindGroup) {
            								dynamicBindGroup.bindGroup = allocation.gpuBuffer.getBindGroup(this);
            								dynamicBindGroup.offsets[0] = allocation.offset;
            						}
            						if (oldGpuBuffer !== allocation.gpuBuffer) {
            								this.renderVersionDirty = this.device.renderVersion;
            						}
            				}
            		}
            		endUpdate() {
            				if (this.persistent) {
            						this.impl.unlock(this);
            				} else {
            						this.storageFloat32 = null;
            						this.storageInt32 = null;
            				}
            		}
            		update(dynamicBindGroup) {
            				this.startUpdate(dynamicBindGroup);
            				var uniforms = this.format.uniforms;
            				for(var i = 0; i < uniforms.length; i++){
            						var value = uniforms[i].scopeId.value;
            						this.setUniform(uniforms[i], value);
            				}
            				this.endUpdate();
            		}
            		constructor(graphicsDevice, format, persistent = true){
            				this.renderVersionDirty = 0;
            				this.device = graphicsDevice;
            				this.format = format;
            				this.persistent = persistent;
            				if (persistent) {
            						this.impl = graphicsDevice.createUniformBufferImpl(this);
            						var storage = new ArrayBuffer(format.byteSize);
            						this.assignStorage(new Int32Array(storage));
            						graphicsDevice._vram.ub += this.format.byteSize;
            				} else {
            						this.allocation = new DynamicBufferAllocation();
            				}
            		}
            }
            
            class GpuProfiler {
            		loseContext() {
            				this.pastFrameAllocations.clear();
            		}
            		set enabled(value) {
            				this._enableRequest = value;
            		}
            		get enabled() {
            				return this._enableRequest;
            		}
            		processEnableRequest() {
            				if (this._enableRequest !== this._enabled) {
            						this._enabled = this._enableRequest;
            						if (!this._enabled) {
            								this._frameTime = 0;
            						}
            				}
            		}
            		request(renderVersion) {
            				this.pastFrameAllocations.set(renderVersion, this.frameAllocations);
            				this.frameAllocations = [];
            		}
            		report(renderVersion, timings) {
            				if (timings) {
            						var allocations = this.pastFrameAllocations.get(renderVersion);
            						if (timings.length > 0) {
            								this._frameTime = timings[0];
            						}
            						if (Tracing.get(TRACEID_GPU_TIMINGS)) {
            								var total = 0;
            								for(var i = 0; i < allocations.length; ++i){
            										allocations[i];
            										total += timings[i];
            								}
            						}
            				}
            				this.pastFrameAllocations.delete(renderVersion);
            		}
            		getSlot(name) {
            				var slot = this.frameAllocations.length;
            				this.frameAllocations.push(name);
            				return slot;
            		}
            		get slotCount() {
            				return this.frameAllocations.length;
            		}
            		constructor(){
            				this.frameAllocations = [];
            				this.pastFrameAllocations = new Map();
            				this._enabled = false;
            				this._enableRequest = false;
            				this._frameTime = 0;
            		}
            }
            
            class WebglBuffer {
            		destroy(device) {
            				if (this.bufferId) {
            						device.gl.deleteBuffer(this.bufferId);
            						this.bufferId = null;
            				}
            		}
            		get initialized() {
            				return !!this.bufferId;
            		}
            		loseContext() {
            				this.bufferId = null;
            		}
            		unlock(device, usage, target, storage) {
            				var gl = device.gl;
            				if (!this.bufferId) {
            						var glUsage;
            						switch(usage){
            								case BUFFER_STATIC:
            										glUsage = gl.STATIC_DRAW;
            										break;
            								case BUFFER_DYNAMIC:
            										glUsage = gl.DYNAMIC_DRAW;
            										break;
            								case BUFFER_STREAM:
            										glUsage = gl.STREAM_DRAW;
            										break;
            								case BUFFER_GPUDYNAMIC:
            										glUsage = gl.DYNAMIC_COPY;
            										break;
            						}
            						this.bufferId = gl.createBuffer();
            						gl.bindBuffer(target, this.bufferId);
            						gl.bufferData(target, storage, glUsage);
            				} else {
            						gl.bindBuffer(target, this.bufferId);
            						gl.bufferSubData(target, 0, storage);
            				}
            		}
            		constructor(){
            				this.bufferId = null;
            		}
            }
            
            class WebglVertexBuffer extends WebglBuffer {
            		destroy(device) {
            				super.destroy(device);
            				device.unbindVertexArray();
            		}
            		loseContext() {
            				super.loseContext();
            				this.vao = null;
            		}
            		unlock(vertexBuffer) {
            				var device = vertexBuffer.device;
            				super.unlock(device, vertexBuffer.usage, device.gl.ARRAY_BUFFER, vertexBuffer.storage);
            		}
            		constructor(...args){
            				super(...args), this.vao = null;
            		}
            }
            
            class WebglIndexBuffer extends WebglBuffer {
            		unlock(indexBuffer) {
            				var device = indexBuffer.device;
            				super.unlock(device, indexBuffer.usage, device.gl.ELEMENT_ARRAY_BUFFER, indexBuffer.storage);
            		}
            		constructor(indexBuffer){
            				super();
            				var gl = indexBuffer.device.gl;
            				var format = indexBuffer.format;
            				if (format === INDEXFORMAT_UINT8) {
            						this.glFormat = gl.UNSIGNED_BYTE;
            				} else if (format === INDEXFORMAT_UINT16) {
            						this.glFormat = gl.UNSIGNED_SHORT;
            				} else if (format === INDEXFORMAT_UINT32) {
            						this.glFormat = gl.UNSIGNED_INT;
            				}
            		}
            }
            
            class WebglShaderInput {
            		constructor(graphicsDevice, name, type, locationId){
            				this.locationId = locationId;
            				this.scopeId = graphicsDevice.scope.resolve(name);
            				this.version = new Version();
            				if (name.substring(name.length - 3) === '[0]') {
            						switch(type){
            								case UNIFORMTYPE_FLOAT:
            										type = UNIFORMTYPE_FLOATARRAY;
            										break;
            								case UNIFORMTYPE_INT:
            										type = UNIFORMTYPE_INTARRAY;
            										break;
            								case UNIFORMTYPE_UINT:
            										type = UNIFORMTYPE_UINTARRAY;
            										break;
            								case UNIFORMTYPE_BOOL:
            										type = UNIFORMTYPE_BOOLARRAY;
            										break;
            								case UNIFORMTYPE_VEC2:
            										type = UNIFORMTYPE_VEC2ARRAY;
            										break;
            								case UNIFORMTYPE_IVEC2:
            										type = UNIFORMTYPE_IVEC2ARRAY;
            										break;
            								case UNIFORMTYPE_UVEC2:
            										type = UNIFORMTYPE_UVEC2ARRAY;
            										break;
            								case UNIFORMTYPE_BVEC2:
            										type = UNIFORMTYPE_BVEC2ARRAY;
            										break;
            								case UNIFORMTYPE_VEC3:
            										type = UNIFORMTYPE_VEC3ARRAY;
            										break;
            								case UNIFORMTYPE_IVEC3:
            										type = UNIFORMTYPE_IVEC3ARRAY;
            										break;
            								case UNIFORMTYPE_UVEC3:
            										type = UNIFORMTYPE_UVEC3ARRAY;
            										break;
            								case UNIFORMTYPE_BVEC3:
            										type = UNIFORMTYPE_BVEC3ARRAY;
            										break;
            								case UNIFORMTYPE_VEC4:
            										type = UNIFORMTYPE_VEC4ARRAY;
            										break;
            								case UNIFORMTYPE_IVEC4:
            										type = UNIFORMTYPE_IVEC4ARRAY;
            										break;
            								case UNIFORMTYPE_UVEC4:
            										type = UNIFORMTYPE_UVEC4ARRAY;
            										break;
            								case UNIFORMTYPE_BVEC4:
            										type = UNIFORMTYPE_BVEC4ARRAY;
            										break;
            						}
            				}
            				this.dataType = type;
            				this.value = [
            						null,
            						null,
            						null,
            						null
            				];
            				this.array = [];
            		}
            }
            
            var _vertexShaderBuiltins = new Set([
            		'gl_VertexID',
            		'gl_InstanceID',
            		'gl_DrawID',
            		'gl_BaseVertex',
            		'gl_BaseInstance'
            ]);
            class CompiledShaderCache {
            		destroy(device) {
            				this.map.forEach((shader)=>{
            						device.gl.deleteShader(shader);
            				});
            		}
            		loseContext(device) {
            				this.map.clear();
            		}
            		constructor(){
            				this.map = new Map();
            		}
            }
            var _vertexShaderCache = new DeviceCache();
            var _fragmentShaderCache = new DeviceCache();
            class WebglShader {
            		destroy(shader) {
            				if (this.glProgram) {
            						shader.device.gl.deleteProgram(this.glProgram);
            						this.glProgram = null;
            				}
            		}
            		init() {
            				this.uniforms = [];
            				this.samplers = [];
            				this.attributes = [];
            				this.glProgram = null;
            				this.glVertexShader = null;
            				this.glFragmentShader = null;
            		}
            		loseContext() {
            				this.init();
            		}
            		restoreContext(device, shader) {
            				this.compile(device, shader);
            				this.link(device, shader);
            		}
            		compile(device, shader) {
            				var definition = shader.definition;
            				this.glVertexShader = this._compileShaderSource(device, definition.vshader, true);
            				this.glFragmentShader = this._compileShaderSource(device, definition.fshader, false);
            		}
            		link(device, shader) {
            				if (this.glProgram) {
            						return;
            				}
            				var gl = device.gl;
            				if (gl.isContextLost()) {
            						return;
            				}
            				var glProgram = gl.createProgram();
            				this.glProgram = glProgram;
            				gl.attachShader(glProgram, this.glVertexShader);
            				gl.attachShader(glProgram, this.glFragmentShader);
            				var definition = shader.definition;
            				var attrs = definition.attributes;
            				if (definition.useTransformFeedback) {
            						var outNames = [];
            						for(var attr in attrs){
            								if (attrs.hasOwnProperty(attr)) {
            										outNames.push("out_" + attr);
            								}
            						}
            						gl.transformFeedbackVaryings(glProgram, outNames, gl.INTERLEAVED_ATTRIBS);
            				}
            				for(var attr1 in attrs){
            						if (attrs.hasOwnProperty(attr1)) {
            								var semantic = attrs[attr1];
            								var loc = semanticToLocation[semantic];
            								gl.bindAttribLocation(glProgram, loc, attr1);
            						}
            				}
            				gl.linkProgram(glProgram);
            		}
            		_compileShaderSource(device, src, isVertexShader) {
            				var gl = device.gl;
            				if (gl.isContextLost()) {
            						return null;
            				}
            				var shaderDeviceCache = isVertexShader ? _vertexShaderCache : _fragmentShaderCache;
            				var shaderCache = shaderDeviceCache.get(device, ()=>{
            						return new CompiledShaderCache();
            				});
            				var glShader = shaderCache.map.get(src);
            				if (!glShader) {
            						glShader = gl.createShader(isVertexShader ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
            						gl.shaderSource(glShader, src);
            						gl.compileShader(glShader);
            						shaderCache.map.set(src, glShader);
            				}
            				return glShader;
            		}
            		finalize(device, shader) {
            				var gl = device.gl;
            				if (gl.isContextLost()) {
            						return true;
            				}
            				var glProgram = this.glProgram;
            				var definition = shader.definition;
            				var linkStatus = gl.getProgramParameter(glProgram, gl.LINK_STATUS);
            				if (!linkStatus) {
            						if (!this._isCompiled(device, shader, this.glVertexShader, definition.vshader, 'vertex')) {
            								return false;
            						}
            						if (!this._isCompiled(device, shader, this.glFragmentShader, definition.fshader, 'fragment')) {
            								return false;
            						}
            						var message = "Failed to link shader program. Error: " + gl.getProgramInfoLog(glProgram);
            						console.error(message);
            						return false;
            				}
            				var numAttributes = gl.getProgramParameter(glProgram, gl.ACTIVE_ATTRIBUTES);
            				shader.attributes.clear();
            				for(var i = 0; i < numAttributes; i++){
            						var info = gl.getActiveAttrib(glProgram, i);
            						var location = gl.getAttribLocation(glProgram, info.name);
            						if (_vertexShaderBuiltins.has(info.name)) {
            								continue;
            						}
            						if (definition.attributes[info.name] === undefined) {
            								console.error('Vertex shader attribute "' + info.name + '" is not mapped to a semantic in shader definition, shader [' + shader.label + "]", shader);
            								shader.failed = true;
            						} else {
            								shader.attributes.set(location, info.name);
            						}
            				}
            				var samplerTypes = device._samplerTypes;
            				var numUniforms = gl.getProgramParameter(glProgram, gl.ACTIVE_UNIFORMS);
            				for(var i1 = 0; i1 < numUniforms; i1++){
            						var info1 = gl.getActiveUniform(glProgram, i1);
            						var location1 = gl.getUniformLocation(glProgram, info1.name);
            						var shaderInput = new WebglShaderInput(device, info1.name, device.pcUniformType[info1.type], location1);
            						if (samplerTypes.has(info1.type)) {
            								this.samplers.push(shaderInput);
            						} else {
            								this.uniforms.push(shaderInput);
            						}
            				}
            				shader.ready = true;
            				return true;
            		}
            		_isCompiled(device, shader, glShader, source, shaderType) {
            				var gl = device.gl;
            				if (!gl.getShaderParameter(glShader, gl.COMPILE_STATUS)) {
            						var infoLog = gl.getShaderInfoLog(glShader);
            						var [code, error] = this._processError(source, infoLog);
            						var message = "Failed to compile " + shaderType + " shader:\n\n" + infoLog + "\n" + code + " while rendering " + void 0;
            						console.error(message);
            						return false;
            				}
            				return true;
            		}
            		isLinked(device) {
            				var { extParallelShaderCompile } = device;
            				if (extParallelShaderCompile) {
            						return device.gl.getProgramParameter(this.glProgram, extParallelShaderCompile.COMPLETION_STATUS_KHR);
            				}
            				return true;
            		}
            		_processError(src, infoLog) {
            				var error = {};
            				var code = '';
            				if (src) {
            						var lines = src.split('\n');
            						var from = 0;
            						var to = lines.length;
            						if (infoLog && infoLog.startsWith('ERROR:')) {
            								var match = infoLog.match(/^ERROR:\s(\d+):(\d+):\s*(.+)/);
            								if (match) {
            										error.message = match[3];
            										error.line = parseInt(match[2], 10);
            										from = Math.max(0, error.line - 6);
            										to = Math.min(lines.length, error.line + 5);
            								}
            						}
            						for(var i = from; i < to; i++){
            								var linePrefix = i + 1 === error.line ? '> ' : '  ';
            								code += "" + linePrefix + (i + 1) + ":	" + lines[i] + "\n";
            						}
            						error.source = src;
            				}
            				return [
            						code,
            						error
            				];
            		}
            		constructor(shader){
            				this.compileDuration = 0;
            				this.init();
            				this.compile(shader.device, shader);
            				this.link(shader.device, shader);
            				shader.device.shaders.push(shader);
            		}
            }
            
            function downsampleImage(image, size) {
            		var srcW = image.width;
            		var srcH = image.height;
            		if (srcW > size || srcH > size) {
            				var scale = size / Math.max(srcW, srcH);
            				var dstW = Math.floor(srcW * scale);
            				var dstH = Math.floor(srcH * scale);
            				var canvas = document.createElement('canvas');
            				canvas.width = dstW;
            				canvas.height = dstH;
            				var context = canvas.getContext('2d');
            				context.drawImage(image, 0, 0, srcW, srcH, 0, 0, dstW, dstH);
            				return canvas;
            		}
            		return image;
            }
            class WebglTexture {
            		destroy(device) {
            				if (this._glTexture) {
            						for(var i = 0; i < device.textureUnits.length; i++){
            								var textureUnit = device.textureUnits[i];
            								for(var j = 0; j < textureUnit.length; j++){
            										if (textureUnit[j] === this._glTexture) {
            												textureUnit[j] = null;
            										}
            								}
            						}
            						device.gl.deleteTexture(this._glTexture);
            						this._glTexture = null;
            				}
            		}
            		loseContext() {
            				this._glTexture = null;
            		}
            		propertyChanged(flag) {
            				this.dirtyParameterFlags |= flag;
            		}
            		initialize(device, texture) {
            				var gl = device.gl;
            				this._glTexture = gl.createTexture();
            				this._glTarget = texture._cubemap ? gl.TEXTURE_CUBE_MAP : texture._volume ? gl.TEXTURE_3D : texture.array ? gl.TEXTURE_2D_ARRAY : gl.TEXTURE_2D;
            				switch(texture._format){
            						case PIXELFORMAT_A8:
            								this._glFormat = gl.ALPHA;
            								this._glInternalFormat = gl.ALPHA;
            								this._glPixelType = gl.UNSIGNED_BYTE;
            								break;
            						case PIXELFORMAT_L8:
            								this._glFormat = gl.LUMINANCE;
            								this._glInternalFormat = gl.LUMINANCE;
            								this._glPixelType = gl.UNSIGNED_BYTE;
            								break;
            						case PIXELFORMAT_LA8:
            								this._glFormat = gl.LUMINANCE_ALPHA;
            								this._glInternalFormat = gl.LUMINANCE_ALPHA;
            								this._glPixelType = gl.UNSIGNED_BYTE;
            								break;
            						case PIXELFORMAT_R8:
            								this._glFormat = gl.RED;
            								this._glInternalFormat = gl.R8;
            								this._glPixelType = gl.UNSIGNED_BYTE;
            								break;
            						case PIXELFORMAT_RG8:
            								this._glFormat = gl.RG;
            								this._glInternalFormat = gl.RG8;
            								this._glPixelType = gl.UNSIGNED_BYTE;
            								break;
            						case PIXELFORMAT_RGB565:
            								this._glFormat = gl.RGB;
            								this._glInternalFormat = gl.RGB565;
            								this._glPixelType = gl.UNSIGNED_SHORT_5_6_5;
            								break;
            						case PIXELFORMAT_RGBA5551:
            								this._glFormat = gl.RGBA;
            								this._glInternalFormat = gl.RGB5_A1;
            								this._glPixelType = gl.UNSIGNED_SHORT_5_5_5_1;
            								break;
            						case PIXELFORMAT_RGBA4:
            								this._glFormat = gl.RGBA;
            								this._glInternalFormat = gl.RGBA4;
            								this._glPixelType = gl.UNSIGNED_SHORT_4_4_4_4;
            								break;
            						case PIXELFORMAT_RGB8:
            								this._glFormat = gl.RGB;
            								this._glInternalFormat = gl.RGB8;
            								this._glPixelType = gl.UNSIGNED_BYTE;
            								break;
            						case PIXELFORMAT_RGBA8:
            								this._glFormat = gl.RGBA;
            								this._glInternalFormat = gl.RGBA8;
            								this._glPixelType = gl.UNSIGNED_BYTE;
            								break;
            						case PIXELFORMAT_BGRA8:
            						case PIXELFORMAT_SBGRA8:
            								break;
            						case PIXELFORMAT_DXT1:
            								this._glFormat = gl.RGB;
            								this._glInternalFormat = device.extCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;
            								break;
            						case PIXELFORMAT_DXT3:
            								this._glFormat = gl.RGBA;
            								this._glInternalFormat = device.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            								break;
            						case PIXELFORMAT_DXT5:
            								this._glFormat = gl.RGBA;
            								this._glInternalFormat = device.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            								break;
            						case PIXELFORMAT_ETC1:
            								this._glFormat = gl.RGB;
            								this._glInternalFormat = device.extCompressedTextureETC1.COMPRESSED_RGB_ETC1_WEBGL;
            								break;
            						case PIXELFORMAT_PVRTC_2BPP_RGB_1:
            								this._glFormat = gl.RGB;
            								this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            								break;
            						case PIXELFORMAT_PVRTC_2BPP_RGBA_1:
            								this._glFormat = gl.RGBA;
            								this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            								break;
            						case PIXELFORMAT_PVRTC_4BPP_RGB_1:
            								this._glFormat = gl.RGB;
            								this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            								break;
            						case PIXELFORMAT_PVRTC_4BPP_RGBA_1:
            								this._glFormat = gl.RGBA;
            								this._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            								break;
            						case PIXELFORMAT_ETC2_RGB:
            								this._glFormat = gl.RGB;
            								this._glInternalFormat = device.extCompressedTextureETC.COMPRESSED_RGB8_ETC2;
            								break;
            						case PIXELFORMAT_ETC2_RGBA:
            								this._glFormat = gl.RGBA;
            								this._glInternalFormat = device.extCompressedTextureETC.COMPRESSED_RGBA8_ETC2_EAC;
            								break;
            						case PIXELFORMAT_ASTC_4x4:
            								this._glFormat = gl.RGBA;
            								this._glInternalFormat = device.extCompressedTextureASTC.COMPRESSED_RGBA_ASTC_4x4_KHR;
            								break;
            						case PIXELFORMAT_ATC_RGB:
            								this._glFormat = gl.RGB;
            								this._glInternalFormat = device.extCompressedTextureATC.COMPRESSED_RGB_ATC_WEBGL;
            								break;
            						case PIXELFORMAT_ATC_RGBA:
            								this._glFormat = gl.RGBA;
            								this._glInternalFormat = device.extCompressedTextureATC.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;
            								break;
            						case PIXELFORMAT_BC6F:
            								this._glFormat = gl.RGB;
            								this._glInternalFormat = device.extTextureCompressionBPTC.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
            								break;
            						case PIXELFORMAT_BC6UF:
            								this._glFormat = gl.RGB;
            								this._glInternalFormat = device.extTextureCompressionBPTC.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
            								break;
            						case PIXELFORMAT_BC7:
            								this._glFormat = gl.RGBA;
            								this._glInternalFormat = device.extTextureCompressionBPTC.COMPRESSED_RGBA_BPTC_UNORM_EXT;
            								break;
            						case PIXELFORMAT_DXT1_SRGB:
            								this._glFormat = gl.SRGB;
            								this._glInternalFormat = device.extCompressedTextureS3TC_SRGB.COMPRESSED_SRGB_S3TC_DXT1_EXT;
            								break;
            						case PIXELFORMAT_DXT3_SRGBA:
            								this._glFormat = gl.SRGB_ALPHA;
            								this._glInternalFormat = device.extCompressedTextureS3TC_SRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
            								break;
            						case PIXELFORMAT_DXT5_SRGBA:
            								this._glFormat = gl.SRGB_ALPHA;
            								this._glInternalFormat = device.extCompressedTextureS3TC_SRGB.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
            								break;
            						case PIXELFORMAT_ETC2_SRGB:
            								this._glFormat = gl.SRGB;
            								this._glInternalFormat = device.extCompressedTextureETC.COMPRESSED_SRGB8_ETC2;
            								break;
            						case PIXELFORMAT_ETC2_SRGBA:
            								this._glFormat = gl.SRGB_ALPHA;
            								this._glInternalFormat = device.extCompressedTextureETC.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
            								break;
            						case PIXELFORMAT_ASTC_4x4_SRGB:
            								this._glFormat = gl.SRGB_ALPHA;
            								this._glInternalFormat = device.extCompressedTextureASTC.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
            								break;
            						case PIXELFORMAT_BC7_SRGBA:
            								this._glFormat = gl.RGBA;
            								this._glInternalFormat = device.extTextureCompressionBPTC.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;
            								break;
            						case PIXELFORMAT_R16F:
            								this._glFormat = gl.RED;
            								this._glInternalFormat = gl.R16F;
            								this._glPixelType = gl.HALF_FLOAT;
            								break;
            						case PIXELFORMAT_RG16F:
            								this._glFormat = gl.RG;
            								this._glInternalFormat = gl.RG16F;
            								this._glPixelType = gl.HALF_FLOAT;
            								break;
            						case PIXELFORMAT_RGB16F:
            								this._glFormat = gl.RGB;
            								this._glInternalFormat = gl.RGB16F;
            								this._glPixelType = gl.HALF_FLOAT;
            								break;
            						case PIXELFORMAT_RGBA16F:
            								this._glFormat = gl.RGBA;
            								this._glInternalFormat = gl.RGBA16F;
            								this._glPixelType = gl.HALF_FLOAT;
            								break;
            						case PIXELFORMAT_RGB32F:
            								this._glFormat = gl.RGB;
            								this._glInternalFormat = gl.RGB32F;
            								this._glPixelType = gl.FLOAT;
            								break;
            						case PIXELFORMAT_RGBA32F:
            								this._glFormat = gl.RGBA;
            								this._glInternalFormat = gl.RGBA32F;
            								this._glPixelType = gl.FLOAT;
            								break;
            						case PIXELFORMAT_R32F:
            								this._glFormat = gl.RED;
            								this._glInternalFormat = gl.R32F;
            								this._glPixelType = gl.FLOAT;
            								break;
            						case PIXELFORMAT_DEPTH:
            								this._glFormat = gl.DEPTH_COMPONENT;
            								this._glInternalFormat = gl.DEPTH_COMPONENT32F;
            								this._glPixelType = gl.FLOAT;
            								break;
            						case PIXELFORMAT_DEPTH16:
            								this._glFormat = gl.DEPTH_COMPONENT;
            								this._glInternalFormat = gl.DEPTH_COMPONENT16;
            								this._glPixelType = gl.UNSIGNED_SHORT;
            								break;
            						case PIXELFORMAT_DEPTHSTENCIL:
            								this._glFormat = gl.DEPTH_STENCIL;
            								this._glInternalFormat = gl.DEPTH24_STENCIL8;
            								this._glPixelType = gl.UNSIGNED_INT_24_8;
            								break;
            						case PIXELFORMAT_111110F:
            								this._glFormat = gl.RGB;
            								this._glInternalFormat = gl.R11F_G11F_B10F;
            								this._glPixelType = gl.UNSIGNED_INT_10F_11F_11F_REV;
            								break;
            						case PIXELFORMAT_SRGB8:
            								this._glFormat = gl.RGB;
            								this._glInternalFormat = gl.SRGB8;
            								this._glPixelType = gl.UNSIGNED_BYTE;
            								break;
            						case PIXELFORMAT_SRGBA8:
            								this._glFormat = gl.RGBA;
            								this._glInternalFormat = gl.SRGB8_ALPHA8;
            								this._glPixelType = gl.UNSIGNED_BYTE;
            								break;
            						case PIXELFORMAT_R8I:
            								this._glFormat = gl.RED_INTEGER;
            								this._glInternalFormat = gl.R8I;
            								this._glPixelType = gl.BYTE;
            								break;
            						case PIXELFORMAT_R8U:
            								this._glFormat = gl.RED_INTEGER;
            								this._glInternalFormat = gl.R8UI;
            								this._glPixelType = gl.UNSIGNED_BYTE;
            								break;
            						case PIXELFORMAT_R16I:
            								this._glFormat = gl.RED_INTEGER;
            								this._glInternalFormat = gl.R16I;
            								this._glPixelType = gl.SHORT;
            								break;
            						case PIXELFORMAT_R16U:
            								this._glFormat = gl.RED_INTEGER;
            								this._glInternalFormat = gl.R16UI;
            								this._glPixelType = gl.UNSIGNED_SHORT;
            								break;
            						case PIXELFORMAT_R32I:
            								this._glFormat = gl.RED_INTEGER;
            								this._glInternalFormat = gl.R32I;
            								this._glPixelType = gl.INT;
            								break;
            						case PIXELFORMAT_R32U:
            								this._glFormat = gl.RED_INTEGER;
            								this._glInternalFormat = gl.R32UI;
            								this._glPixelType = gl.UNSIGNED_INT;
            								break;
            						case PIXELFORMAT_RG8I:
            								this._glFormat = gl.RG_INTEGER;
            								this._glInternalFormat = gl.RG8I;
            								this._glPixelType = gl.BYTE;
            								break;
            						case PIXELFORMAT_RG8U:
            								this._glFormat = gl.RG_INTEGER;
            								this._glInternalFormat = gl.RG8UI;
            								this._glPixelType = gl.UNSIGNED_BYTE;
            								break;
            						case PIXELFORMAT_RG16I:
            								this._glFormat = gl.RG_INTEGER;
            								this._glInternalFormat = gl.RG16I;
            								this._glPixelType = gl.SHORT;
            								break;
            						case PIXELFORMAT_RG16U:
            								this._glFormat = gl.RG_INTEGER;
            								this._glInternalFormat = gl.RG16UI;
            								this._glPixelType = gl.UNSIGNED_SHORT;
            								break;
            						case PIXELFORMAT_RG32I:
            								this._glFormat = gl.RG_INTEGER;
            								this._glInternalFormat = gl.RG32I;
            								this._glPixelType = gl.INT;
            								break;
            						case PIXELFORMAT_RG32U:
            								this._glFormat = gl.RG_INTEGER;
            								this._glInternalFormat = gl.RG32UI;
            								this._glPixelType = gl.UNSIGNED_INT;
            								break;
            						case PIXELFORMAT_RGBA8I:
            								this._glFormat = gl.RGBA_INTEGER;
            								this._glInternalFormat = gl.RGBA8I;
            								this._glPixelType = gl.BYTE;
            								break;
            						case PIXELFORMAT_RGBA8U:
            								this._glFormat = gl.RGBA_INTEGER;
            								this._glInternalFormat = gl.RGBA8UI;
            								this._glPixelType = gl.UNSIGNED_BYTE;
            								break;
            						case PIXELFORMAT_RGBA16I:
            								this._glFormat = gl.RGBA_INTEGER;
            								this._glInternalFormat = gl.RGBA16I;
            								this._glPixelType = gl.SHORT;
            								break;
            						case PIXELFORMAT_RGBA16U:
            								this._glFormat = gl.RGBA_INTEGER;
            								this._glInternalFormat = gl.RGBA16UI;
            								this._glPixelType = gl.UNSIGNED_SHORT;
            								break;
            						case PIXELFORMAT_RGBA32I:
            								this._glFormat = gl.RGBA_INTEGER;
            								this._glInternalFormat = gl.RGBA32I;
            								this._glPixelType = gl.INT;
            								break;
            						case PIXELFORMAT_RGBA32U:
            								this._glFormat = gl.RGBA_INTEGER;
            								this._glInternalFormat = gl.RGBA32UI;
            								this._glPixelType = gl.UNSIGNED_INT;
            								break;
            				}
            				this._glCreated = false;
            		}
            		upload(device, texture) {
            				var gl = device.gl;
            				if (!texture._needsUpload && (texture._needsMipmapsUpload && texture._mipmapsUploaded || !texture.pot)) {
            						return;
            				}
            				var mipLevel = 0;
            				var mipObject;
            				var resMult;
            				var requiredMipLevels = texture.numLevels;
            				if (texture.array) {
            						gl.texStorage3D(gl.TEXTURE_2D_ARRAY, requiredMipLevels, this._glInternalFormat, texture._width, texture._height, texture._arrayLength);
            				}
            				while(texture._levels[mipLevel] || mipLevel === 0){
            						if (!texture._needsUpload && mipLevel === 0) {
            								mipLevel++;
            								continue;
            						} else if (mipLevel && (!texture._needsMipmapsUpload || !texture._mipmaps)) {
            								break;
            						}
            						mipObject = texture._levels[mipLevel];
            						resMult = 1 / Math.pow(2, mipLevel);
            						if (mipLevel === 1 && !texture._compressed && !texture._integerFormat && texture._levels.length < requiredMipLevels) {
            								gl.generateMipmap(this._glTarget);
            								texture._mipmapsUploaded = true;
            						}
            						if (texture._cubemap) {
            								var face = void 0;
            								if (device._isBrowserInterface(mipObject[0])) {
            										for(face = 0; face < 6; face++){
            												if (!texture._levelsUpdated[0][face]) {
            														continue;
            												}
            												var src = mipObject[face];
            												if (device._isImageBrowserInterface(src)) {
            														if (src.width > device.maxCubeMapSize || src.height > device.maxCubeMapSize) {
            																src = downsampleImage(src, device.maxCubeMapSize);
            																if (mipLevel === 0) {
            																		texture._width = src.width;
            																		texture._height = src.height;
            																}
            														}
            												}
            												device.setUnpackFlipY(false);
            												device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
            												if (this._glCreated) {
            														gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, 0, 0, this._glFormat, this._glPixelType, src);
            												} else {
            														gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, this._glFormat, this._glPixelType, src);
            												}
            										}
            								} else {
            										resMult = 1 / Math.pow(2, mipLevel);
            										for(face = 0; face < 6; face++){
            												if (!texture._levelsUpdated[0][face]) {
            														continue;
            												}
            												var texData = mipObject[face];
            												if (texture._compressed) {
            														if (this._glCreated && texData) {
            																gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, 0, 0, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), this._glInternalFormat, texData);
            														} else {
            																gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, texData);
            														}
            												} else {
            														device.setUnpackFlipY(false);
            														device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
            														if (this._glCreated && texData) {
            																gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, 0, 0, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), this._glFormat, this._glPixelType, texData);
            														} else {
            																gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, this._glFormat, this._glPixelType, texData);
            														}
            												}
            										}
            								}
            						} else if (texture._volume) {
            								if (texture._compressed) {
            										gl.compressedTexImage3D(gl.TEXTURE_3D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, mipObject);
            								} else {
            										device.setUnpackFlipY(false);
            										device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
            										gl.texImage3D(gl.TEXTURE_3D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, this._glFormat, this._glPixelType, mipObject);
            								}
            						} else if (texture.array && typeof mipObject === 'object') {
            								if (texture._arrayLength === mipObject.length) {
            										if (texture._compressed) {
            												for(var index = 0; index < texture._arrayLength; index++){
            														gl.compressedTexSubImage3D(gl.TEXTURE_2D_ARRAY, mipLevel, 0, 0, index, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), 1, this._glInternalFormat, mipObject[index]);
            												}
            										} else {
            												for(var index1 = 0; index1 < texture._arrayLength; index1++){
            														gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, mipLevel, 0, 0, index1, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), 1, this._glFormat, this._glPixelType, mipObject[index1]);
            												}
            										}
            								}
            						} else {
            								if (device._isBrowserInterface(mipObject)) {
            										if (device._isImageBrowserInterface(mipObject)) {
            												if (mipObject.width > device.maxTextureSize || mipObject.height > device.maxTextureSize) {
            														mipObject = downsampleImage(mipObject, device.maxTextureSize);
            														if (mipLevel === 0) {
            																texture._width = mipObject.width;
            																texture._height = mipObject.height;
            														}
            												}
            										}
            										var w = mipObject.width || mipObject.videoWidth;
            										var h = mipObject.height || mipObject.videoHeight;
            										device.setUnpackFlipY(texture._flipY);
            										device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
            										if (this._glCreated && texture._width === w && texture._height === h && !device._isImageVideoInterface(mipObject)) {
            												gl.texSubImage2D(gl.TEXTURE_2D, mipLevel, 0, 0, this._glFormat, this._glPixelType, mipObject);
            										} else {
            												gl.texImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, this._glFormat, this._glPixelType, mipObject);
            												if (mipLevel === 0) {
            														texture._width = w;
            														texture._height = h;
            												}
            										}
            								} else {
            										resMult = 1 / Math.pow(2, mipLevel);
            										if (texture._compressed) {
            												if (this._glCreated && mipObject) {
            														gl.compressedTexSubImage2D(gl.TEXTURE_2D, mipLevel, 0, 0, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), this._glInternalFormat, mipObject);
            												} else {
            														gl.compressedTexImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), 0, mipObject);
            												}
            										} else {
            												device.setUnpackFlipY(false);
            												device.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);
            												if (this._glCreated && mipObject) {
            														gl.texSubImage2D(gl.TEXTURE_2D, mipLevel, 0, 0, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), this._glFormat, this._glPixelType, mipObject);
            												} else {
            														gl.texImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, this._glFormat, this._glPixelType, mipObject);
            												}
            										}
            								}
            								if (mipLevel === 0) {
            										texture._mipmapsUploaded = false;
            								} else {
            										texture._mipmapsUploaded = true;
            								}
            						}
            						mipLevel++;
            				}
            				if (texture._needsUpload) {
            						if (texture._cubemap) {
            								for(var i = 0; i < 6; i++){
            										texture._levelsUpdated[0][i] = false;
            								}
            						} else {
            								texture._levelsUpdated[0] = false;
            						}
            				}
            				if (!texture._compressed && !texture._integerFormat && texture._mipmaps && texture._needsMipmapsUpload && texture._levels.length === 1) {
            						gl.generateMipmap(this._glTarget);
            						texture._mipmapsUploaded = true;
            				}
            				if (texture._gpuSize) {
            						texture.adjustVramSizeTracking(device._vram, -texture._gpuSize);
            				}
            				texture._gpuSize = texture.gpuSize;
            				texture.adjustVramSizeTracking(device._vram, texture._gpuSize);
            				this._glCreated = true;
            		}
            		read(x, y, width, height, options) {
            				var texture = this.texture;
            				var device = texture.device;
            				return device.readTextureAsync(texture, x, y, width, height, options);
            		}
            		constructor(texture){
            				this._glTexture = null;
            				this.dirtyParameterFlags = 0;
            				this.texture = texture;
            		}
            }
            
            class FramebufferPair {
            		destroy(gl) {
            				if (this.msaaFB) {
            						gl.deleteRenderbuffer(this.msaaFB);
            						this.msaaFB = null;
            				}
            				if (this.resolveFB) {
            						gl.deleteRenderbuffer(this.resolveFB);
            						this.resolveFB = null;
            				}
            		}
            		constructor(msaaFB, resolveFB){
            				this.msaaFB = msaaFB;
            				this.resolveFB = resolveFB;
            		}
            }
            class WebglRenderTarget {
            		destroy(device) {
            				var _this_colorMrtFramebuffers;
            				var gl = device.gl;
            				this._isInitialized = false;
            				if (this._glFrameBuffer) {
            						if (this._glFrameBuffer !== this.suppliedColorFramebuffer) {
            								gl.deleteFramebuffer(this._glFrameBuffer);
            						}
            						this._glFrameBuffer = null;
            				}
            				if (this._glDepthBuffer) {
            						gl.deleteRenderbuffer(this._glDepthBuffer);
            						this._glDepthBuffer = null;
            				}
            				if (this._glResolveFrameBuffer) {
            						if (this._glResolveFrameBuffer !== this.suppliedColorFramebuffer) {
            								gl.deleteFramebuffer(this._glResolveFrameBuffer);
            						}
            						this._glResolveFrameBuffer = null;
            				}
            				this._glMsaaColorBuffers.forEach((buffer)=>{
            						gl.deleteRenderbuffer(buffer);
            				});
            				this._glMsaaColorBuffers.length = 0;
            				(_this_colorMrtFramebuffers = this.colorMrtFramebuffers) == null ? void 0 : _this_colorMrtFramebuffers.forEach((framebuffer)=>{
            						framebuffer.destroy(gl);
            				});
            				this.colorMrtFramebuffers = null;
            				if (this._glMsaaDepthBuffer) {
            						this._glMsaaDepthBuffer = null;
            						if (this.msaaDepthBufferKey) {
            								getMultisampledTextureCache(device).release(this.msaaDepthBufferKey);
            						}
            				}
            				this.suppliedColorFramebuffer = undefined;
            		}
            		get initialized() {
            				return this._isInitialized;
            		}
            		init(device, target) {
            				var gl = device.gl;
            				this._isInitialized = true;
            				var buffers = [];
            				if (this.suppliedColorFramebuffer !== undefined) {
            						this._glFrameBuffer = this.suppliedColorFramebuffer;
            				} else {
            						var _target__colorBuffers;
            						this._glFrameBuffer = gl.createFramebuffer();
            						device.setFramebuffer(this._glFrameBuffer);
            						var _target__colorBuffers_length;
            						var colorBufferCount = (_target__colorBuffers_length = (_target__colorBuffers = target._colorBuffers) == null ? void 0 : _target__colorBuffers.length) != null ? _target__colorBuffers_length : 0;
            						var attachmentBaseConstant = gl.COLOR_ATTACHMENT0;
            						for(var i = 0; i < colorBufferCount; ++i){
            								var colorBuffer = target.getColorBuffer(i);
            								if (colorBuffer) {
            										if (!colorBuffer.impl._glTexture) {
            												colorBuffer._width = Math.min(colorBuffer.width, device.maxRenderBufferSize);
            												colorBuffer._height = Math.min(colorBuffer.height, device.maxRenderBufferSize);
            												device.setTexture(colorBuffer, 0);
            										}
            										gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentBaseConstant + i, colorBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, colorBuffer.impl._glTexture, target.mipLevel);
            										buffers.push(attachmentBaseConstant + i);
            								}
            						}
            						gl.drawBuffers(buffers);
            						var depthBuffer = target._depthBuffer;
            						if (depthBuffer || target._depth) {
            								var attachmentPoint = target._stencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
            								if (depthBuffer) {
            										if (!depthBuffer.impl._glTexture) {
            												depthBuffer._width = Math.min(depthBuffer.width, device.maxRenderBufferSize);
            												depthBuffer._height = Math.min(depthBuffer.height, device.maxRenderBufferSize);
            												device.setTexture(depthBuffer, 0);
            										}
            										gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentPoint, depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, target._depthBuffer.impl._glTexture, target.mipLevel);
            								} else {
            										var willRenderMsaa = target._samples > 1;
            										if (!willRenderMsaa) {
            												if (!this._glDepthBuffer) {
            														this._glDepthBuffer = gl.createRenderbuffer();
            												}
            												var internalFormat = target._stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT32F;
            												gl.bindRenderbuffer(gl.RENDERBUFFER, this._glDepthBuffer);
            												gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, target.width, target.height);
            												gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachmentPoint, gl.RENDERBUFFER, this._glDepthBuffer);
            												gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            										}
            								}
            						}
            				}
            				if (target._samples > 1) {
            						var _target__colorBuffers1;
            						this._glResolveFrameBuffer = this._glFrameBuffer;
            						this._glFrameBuffer = gl.createFramebuffer();
            						device.setFramebuffer(this._glFrameBuffer);
            						var _target__colorBuffers_length1;
            						var colorBufferCount1 = (_target__colorBuffers_length1 = (_target__colorBuffers1 = target._colorBuffers) == null ? void 0 : _target__colorBuffers1.length) != null ? _target__colorBuffers_length1 : 0;
            						if (this.suppliedColorFramebuffer !== undefined) {
            								var buffer = gl.createRenderbuffer();
            								this._glMsaaColorBuffers.push(buffer);
            								var internalFormat1 = device.backBufferFormat === PIXELFORMAT_RGBA8 ? gl.RGBA8 : gl.RGB8;
            								gl.bindRenderbuffer(gl.RENDERBUFFER, buffer);
            								gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, internalFormat1, target.width, target.height);
            								gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, buffer);
            						} else {
            								for(var i1 = 0; i1 < colorBufferCount1; ++i1){
            										var colorBuffer1 = target.getColorBuffer(i1);
            										if (colorBuffer1) {
            												var buffer1 = gl.createRenderbuffer();
            												this._glMsaaColorBuffers.push(buffer1);
            												gl.bindRenderbuffer(gl.RENDERBUFFER, buffer1);
            												gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, colorBuffer1.impl._glInternalFormat, target.width, target.height);
            												gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i1, gl.RENDERBUFFER, buffer1);
            										}
            								}
            						}
            						if (target._depth) {
            								var internalFormat2 = target._stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT32F;
            								var attachmentPoint1 = target._stencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
            								var key;
            								var depthBuffer1 = target._depthBuffer;
            								if (depthBuffer1) {
            										key = depthBuffer1.id + ":" + target.width + ":" + target.height + ":" + target._samples + ":" + internalFormat2 + ":" + attachmentPoint1;
            										this._glMsaaDepthBuffer = getMultisampledTextureCache(device).get(key);
            								}
            								if (!this._glMsaaDepthBuffer) {
            										this._glMsaaDepthBuffer = gl.createRenderbuffer();
            										gl.bindRenderbuffer(gl.RENDERBUFFER, this._glMsaaDepthBuffer);
            										gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, internalFormat2, target.width, target.height);
            										this._glMsaaDepthBuffer.destroy = function() {
            												gl.deleteRenderbuffer(this);
            										};
            										if (depthBuffer1) {
            												getMultisampledTextureCache(device).set(key, this._glMsaaDepthBuffer);
            										}
            								}
            								this.msaaDepthBufferKey = key;
            								gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachmentPoint1, gl.RENDERBUFFER, this._glMsaaDepthBuffer);
            						}
            						if (colorBufferCount1 > 1) {
            								this._createMsaaMrtFramebuffers(device, target, colorBufferCount1);
            								device.setFramebuffer(this._glFrameBuffer);
            								gl.drawBuffers(buffers);
            						}
            				}
            		}
            		_createMsaaMrtFramebuffers(device, target, colorBufferCount) {
            				var gl = device.gl;
            				this.colorMrtFramebuffers = [];
            				for(var i = 0; i < colorBufferCount; ++i){
            						var colorBuffer = target.getColorBuffer(i);
            						var srcFramebuffer = gl.createFramebuffer();
            						device.setFramebuffer(srcFramebuffer);
            						var buffer = this._glMsaaColorBuffers[i];
            						gl.bindRenderbuffer(gl.RENDERBUFFER, buffer);
            						gl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, colorBuffer.impl._glInternalFormat, target.width, target.height);
            						gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, buffer);
            						gl.drawBuffers([
            								gl.COLOR_ATTACHMENT0
            						]);
            						var dstFramebuffer = gl.createFramebuffer();
            						device.setFramebuffer(dstFramebuffer);
            						gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, colorBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, colorBuffer.impl._glTexture, 0);
            						this.colorMrtFramebuffers[i] = new FramebufferPair(srcFramebuffer, dstFramebuffer);
            				}
            		}
            		_checkFbo(device, target, type) {
            				var gl = device.gl;
            				var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
            				switch(status){
            						case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            								break;
            						case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            								break;
            						case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            								break;
            						case gl.FRAMEBUFFER_UNSUPPORTED:
            								break;
            				}
            		}
            		loseContext() {
            				this._glFrameBuffer = null;
            				this._glDepthBuffer = null;
            				this._glResolveFrameBuffer = null;
            				this._glMsaaColorBuffers.length = 0;
            				this._glMsaaDepthBuffer = null;
            				this.msaaDepthBufferKey = undefined;
            				this.colorMrtFramebuffers = null;
            				this.suppliedColorFramebuffer = undefined;
            				this._isInitialized = false;
            		}
            		internalResolve(device, src, dst, target, mask) {
            				device.setScissor(0, 0, target.width, target.height);
            				var gl = device.gl;
            				gl.bindFramebuffer(gl.READ_FRAMEBUFFER, src);
            				gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dst);
            				gl.blitFramebuffer(0, 0, target.width, target.height, 0, 0, target.width, target.height, mask, gl.NEAREST);
            		}
            		resolve(device, target, color, depth) {
            				var gl = device.gl;
            				if (this.colorMrtFramebuffers) {
            						if (color) {
            								for(var i = 0; i < this.colorMrtFramebuffers.length; i++){
            										var fbPair = this.colorMrtFramebuffers[i];
            										this.internalResolve(device, fbPair.msaaFB, fbPair.resolveFB, target, gl.COLOR_BUFFER_BIT);
            								}
            						}
            						if (depth) {
            								this.internalResolve(device, this._glFrameBuffer, this._glResolveFrameBuffer, target, gl.DEPTH_BUFFER_BIT);
            						}
            				} else {
            						this.internalResolve(device, this._glFrameBuffer, this._glResolveFrameBuffer, target, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0));
            				}
            				gl.bindFramebuffer(gl.FRAMEBUFFER, this._glFrameBuffer);
            		}
            		constructor(){
            				this._glFrameBuffer = null;
            				this._glDepthBuffer = null;
            				this._glResolveFrameBuffer = null;
            				this.colorMrtFramebuffers = null;
            				this._glMsaaColorBuffers = [];
            				this._glMsaaDepthBuffer = null;
            				this._isInitialized = false;
            		}
            }
            
            class FrameQueriesInfo {
            		destroy(gl) {
            				this.queries.forEach((query)=>gl.deleteQuery(query));
            				this.queries = null;
            		}
            		constructor(){
            				this.queries = [];
            		}
            }
            class WebglGpuProfiler extends GpuProfiler {
            		destroy() {
            				this.freeQueries.forEach((query)=>this.device.gl.deleteQuery(query));
            				this.frameQueries.forEach((query)=>this.device.gl.deleteQuery(query));
            				this.previousFrameQueries.forEach((frameQueriesInfo)=>frameQueriesInfo.destroy(this.device.gl));
            				this.freeQueries = null;
            				this.frameQueries = null;
            				this.previousFrameQueries = null;
            		}
            		loseContext() {
            				super.loseContext();
            				this.freeQueries = [];
            				this.frameQueries = [];
            				this.previousFrameQueries = [];
            		}
            		restoreContext() {
            				this.ext = this.device.extDisjointTimerQuery;
            		}
            		getQuery() {
            				var _this_freeQueries_pop;
            				return (_this_freeQueries_pop = this.freeQueries.pop()) != null ? _this_freeQueries_pop : this.device.gl.createQuery();
            		}
            		start(name) {
            				if (this.ext) {
            						var slot = this.getSlot(name);
            						var query = this.getQuery();
            						this.frameQueries[slot] = query;
            						this.device.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, query);
            						return slot;
            				}
            				return undefined;
            		}
            		end(slot) {
            				if (slot !== undefined) {
            						this.device.gl.endQuery(this.ext.TIME_ELAPSED_EXT);
            				}
            		}
            		frameStart() {
            				this.processEnableRequest();
            				if (this._enabled) {
            						this.frameGPUMarkerSlot = this.start('GpuFrame');
            				}
            		}
            		frameEnd() {
            				if (this._enabled) {
            						this.end(this.frameGPUMarkerSlot);
            				}
            		}
            		request() {
            				if (this._enabled) {
            						var ext = this.ext;
            						var gl = this.device.gl;
            						var renderVersion = this.device.renderVersion;
            						var frameQueries = this.frameQueries;
            						if (frameQueries.length > 0) {
            								this.frameQueries = [];
            								var frameQueriesInfo = new FrameQueriesInfo();
            								frameQueriesInfo.queries = frameQueries;
            								frameQueriesInfo.renderVersion = renderVersion;
            								this.previousFrameQueries.push(frameQueriesInfo);
            						}
            						if (this.previousFrameQueries.length > 0) {
            								var previousQueriesInfo = this.previousFrameQueries[0];
            								var previousQueries = previousQueriesInfo.queries;
            								var lastQuery = previousQueries[previousQueries.length - 1];
            								var available = gl.getQueryParameter(lastQuery, gl.QUERY_RESULT_AVAILABLE);
            								var disjoint = gl.getParameter(ext.GPU_DISJOINT_EXT);
            								if (available && !disjoint) {
            										this.previousFrameQueries.shift();
            										var timings = this.timings;
            										timings.length = 0;
            										for(var i = 0; i < previousQueries.length; i++){
            												var query = previousQueries[i];
            												var duration = gl.getQueryParameter(query, gl.QUERY_RESULT);
            												timings[i] = duration * 0.000001;
            												this.freeQueries.push(query);
            										}
            										this.report(previousQueriesInfo.renderVersion, timings);
            								}
            								if (disjoint) {
            										this.previousFrameQueries.forEach((frameQueriesInfo)=>{
            												this.report(frameQueriesInfo.renderVersion, null);
            												frameQueriesInfo.destroy(gl);
            										});
            										this.previousFrameQueries.length = 0;
            								}
            						}
            						super.request(renderVersion);
            				}
            		}
            		constructor(device){
            				super(), this.freeQueries = [], this.frameQueries = [], this.previousFrameQueries = [], this.timings = [];
            				this.device = device;
            				this.ext = device.extDisjointTimerQuery;
            		}
            }
            
            function asyncGeneratorStep$3(gen, resolve, reject, _next, _throw, key, arg) {
            		try {
            				var info = gen[key](arg);
            				var value = info.value;
            		} catch (error) {
            				reject(error);
            				return;
            		}
            		if (info.done) {
            				resolve(value);
            		} else {
            				Promise.resolve(value).then(_next, _throw);
            		}
            }
            function _async_to_generator$3(fn) {
            		return function() {
            				var self = this, args = arguments;
            				return new Promise(function(resolve, reject) {
            						var gen = fn.apply(self, args);
            						function _next(value) {
            								asyncGeneratorStep$3(gen, resolve, reject, _next, _throw, "next", value);
            						}
            						function _throw(err) {
            								asyncGeneratorStep$3(gen, resolve, reject, _next, _throw, "throw", err);
            						}
            						_next(undefined);
            				});
            		};
            }
            var invalidateAttachments = [];
            class WebglGraphicsDevice extends GraphicsDevice {
            		postInit() {
            				super.postInit();
            				this.gpuProfiler = new WebglGpuProfiler(this);
            		}
            		destroy() {
            				super.destroy();
            				var gl = this.gl;
            				if (this.feedback) {
            						gl.deleteTransformFeedback(this.feedback);
            				}
            				this.clearVertexArrayObjectCache();
            				this.canvas.removeEventListener('webglcontextlost', this._contextLostHandler, false);
            				this.canvas.removeEventListener('webglcontextrestored', this._contextRestoredHandler, false);
            				this._contextLostHandler = null;
            				this._contextRestoredHandler = null;
            				this.gl = null;
            				super.postDestroy();
            		}
            		createBackbuffer(frameBuffer) {
            				this.supportsStencil = this.initOptions.stencil;
            				this.backBuffer = new RenderTarget({
            						name: 'WebglFramebuffer',
            						graphicsDevice: this,
            						depth: this.initOptions.depth,
            						stencil: this.supportsStencil,
            						samples: this.samples
            				});
            				this.backBuffer.impl.suppliedColorFramebuffer = frameBuffer;
            		}
            		updateBackbufferFormat(framebuffer) {
            				var gl = this.gl;
            				gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            				var alphaBits = this.gl.getParameter(this.gl.ALPHA_BITS);
            				this.backBufferFormat = alphaBits ? PIXELFORMAT_RGBA8 : PIXELFORMAT_RGB8;
            		}
            		updateBackbuffer() {
            				var resolutionChanged = this.canvas.width !== this.backBufferSize.x || this.canvas.height !== this.backBufferSize.y;
            				if (this._defaultFramebufferChanged || resolutionChanged) {
            						if (this._defaultFramebufferChanged) {
            								this.updateBackbufferFormat(this._defaultFramebuffer);
            						}
            						this._defaultFramebufferChanged = false;
            						this.backBufferSize.set(this.canvas.width, this.canvas.height);
            						this.backBuffer.destroy();
            						this.createBackbuffer(this._defaultFramebuffer);
            				}
            		}
            		createVertexBufferImpl(vertexBuffer, format) {
            				return new WebglVertexBuffer();
            		}
            		createIndexBufferImpl(indexBuffer) {
            				return new WebglIndexBuffer(indexBuffer);
            		}
            		createShaderImpl(shader) {
            				return new WebglShader(shader);
            		}
            		createTextureImpl(texture) {
            				return new WebglTexture(texture);
            		}
            		createRenderTargetImpl(renderTarget) {
            				return new WebglRenderTarget();
            		}
            		getPrecision() {
            				var gl = this.gl;
            				var precision = 'highp';
            				if (gl.getShaderPrecisionFormat) {
            						var vertexShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT);
            						var vertexShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT);
            						var fragmentShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);
            						var fragmentShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);
            						if (vertexShaderPrecisionHighpFloat && vertexShaderPrecisionMediumpFloat && fragmentShaderPrecisionHighpFloat && fragmentShaderPrecisionMediumpFloat) {
            								var highpAvailable = vertexShaderPrecisionHighpFloat.precision > 0 && fragmentShaderPrecisionHighpFloat.precision > 0;
            								var mediumpAvailable = vertexShaderPrecisionMediumpFloat.precision > 0 && fragmentShaderPrecisionMediumpFloat.precision > 0;
            								if (!highpAvailable) {
            										if (mediumpAvailable) {
            												precision = 'mediump';
            										} else {
            												precision = 'lowp';
            										}
            								}
            						}
            				}
            				return precision;
            		}
            		getExtension() {
            				for(var i = 0; i < arguments.length; i++){
            						if (this.supportedExtensions.indexOf(arguments[i]) !== -1) {
            								return this.gl.getExtension(arguments[i]);
            						}
            				}
            				return null;
            		}
            		get extDisjointTimerQuery() {
            				if (!this._extDisjointTimerQuery) {
            						this._extDisjointTimerQuery = this.getExtension('EXT_disjoint_timer_query_webgl2', 'EXT_disjoint_timer_query');
            				}
            				return this._extDisjointTimerQuery;
            		}
            		initializeExtensions() {
            				var gl = this.gl;
            				var _gl_getSupportedExtensions;
            				this.supportedExtensions = (_gl_getSupportedExtensions = gl.getSupportedExtensions()) != null ? _gl_getSupportedExtensions : [];
            				this._extDisjointTimerQuery = null;
            				this.textureRG11B10Renderable = true;
            				this.extColorBufferFloat = this.getExtension('EXT_color_buffer_float');
            				this.textureFloatRenderable = !!this.extColorBufferFloat;
            				this.extColorBufferHalfFloat = this.getExtension('EXT_color_buffer_half_float');
            				this.textureHalfFloatRenderable = !!this.extColorBufferHalfFloat || !!this.extColorBufferFloat;
            				this.extDebugRendererInfo = this.getExtension('WEBGL_debug_renderer_info');
            				this.extTextureFloatLinear = this.getExtension('OES_texture_float_linear');
            				this.textureFloatFilterable = !!this.extTextureFloatLinear;
            				this.extFloatBlend = this.getExtension('EXT_float_blend');
            				this.extTextureFilterAnisotropic = this.getExtension('EXT_texture_filter_anisotropic', 'WEBKIT_EXT_texture_filter_anisotropic');
            				this.extParallelShaderCompile = this.getExtension('KHR_parallel_shader_compile');
            				this.extCompressedTextureETC1 = this.getExtension('WEBGL_compressed_texture_etc1');
            				this.extCompressedTextureETC = this.getExtension('WEBGL_compressed_texture_etc');
            				this.extCompressedTexturePVRTC = this.getExtension('WEBGL_compressed_texture_pvrtc', 'WEBKIT_WEBGL_compressed_texture_pvrtc');
            				this.extCompressedTextureS3TC = this.getExtension('WEBGL_compressed_texture_s3tc', 'WEBKIT_WEBGL_compressed_texture_s3tc');
            				this.extCompressedTextureS3TC_SRGB = this.getExtension('WEBGL_compressed_texture_s3tc_srgb');
            				this.extCompressedTextureATC = this.getExtension('WEBGL_compressed_texture_atc');
            				this.extCompressedTextureASTC = this.getExtension('WEBGL_compressed_texture_astc');
            				this.extTextureCompressionBPTC = this.getExtension('EXT_texture_compression_bptc');
            		}
            		initializeCapabilities() {
            				var gl = this.gl;
            				var ext;
            				var userAgent = typeof navigator !== 'undefined' ? navigator.userAgent : '';
            				this.maxPrecision = this.precision = this.getPrecision();
            				var contextAttribs = gl.getContextAttributes();
            				var _contextAttribs_antialias;
            				this.supportsMsaa = (_contextAttribs_antialias = contextAttribs == null ? void 0 : contextAttribs.antialias) != null ? _contextAttribs_antialias : false;
            				var _contextAttribs_stencil;
            				this.supportsStencil = (_contextAttribs_stencil = contextAttribs == null ? void 0 : contextAttribs.stencil) != null ? _contextAttribs_stencil : false;
            				this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            				this.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
            				this.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
            				this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
            				this.maxCombinedTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
            				this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
            				this.vertexUniformsCount = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
            				this.fragmentUniformsCount = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
            				this.maxColorAttachments = gl.getParameter(gl.MAX_COLOR_ATTACHMENTS);
            				this.maxVolumeSize = gl.getParameter(gl.MAX_3D_TEXTURE_SIZE);
            				ext = this.extDebugRendererInfo;
            				this.unmaskedRenderer = ext ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) : '';
            				this.unmaskedVendor = ext ? gl.getParameter(ext.UNMASKED_VENDOR_WEBGL) : '';
            				var maliRendererRegex = /\bMali-G52+/;
            				var samsungModelRegex = /SM-[a-zA-Z0-9]+/;
            				this.supportsGpuParticles = !(this.unmaskedVendor === 'ARM' && userAgent.match(samsungModelRegex)) && !this.unmaskedRenderer.match(maliRendererRegex);
            				ext = this.extTextureFilterAnisotropic;
            				this.maxAnisotropy = ext ? gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
            				var antialiasSupported = !this.forceDisableMultisampling;
            				this.maxSamples = antialiasSupported ? gl.getParameter(gl.MAX_SAMPLES) : 1;
            				this.maxSamples = Math.min(this.maxSamples, 4);
            				this.samples = antialiasSupported && this.backBufferAntialias ? this.maxSamples : 1;
            				this.supportsAreaLights = !platform.android;
            				if (this.maxTextures <= 8) {
            						this.supportsAreaLights = false;
            				}
            				this.initCapsDefines();
            		}
            		initializeRenderState() {
            				super.initializeRenderState();
            				var gl = this.gl;
            				gl.disable(gl.BLEND);
            				gl.blendFunc(gl.ONE, gl.ZERO);
            				gl.blendEquation(gl.FUNC_ADD);
            				gl.colorMask(true, true, true, true);
            				gl.blendColor(0, 0, 0, 0);
            				gl.enable(gl.CULL_FACE);
            				this.cullFace = gl.BACK;
            				gl.cullFace(gl.BACK);
            				gl.enable(gl.DEPTH_TEST);
            				gl.depthFunc(gl.LEQUAL);
            				gl.depthMask(true);
            				this.stencil = false;
            				gl.disable(gl.STENCIL_TEST);
            				this.stencilFuncFront = this.stencilFuncBack = FUNC_ALWAYS;
            				this.stencilRefFront = this.stencilRefBack = 0;
            				this.stencilMaskFront = this.stencilMaskBack = 0xFF;
            				gl.stencilFunc(gl.ALWAYS, 0, 0xFF);
            				this.stencilFailFront = this.stencilFailBack = STENCILOP_KEEP;
            				this.stencilZfailFront = this.stencilZfailBack = STENCILOP_KEEP;
            				this.stencilZpassFront = this.stencilZpassBack = STENCILOP_KEEP;
            				this.stencilWriteMaskFront = 0xFF;
            				this.stencilWriteMaskBack = 0xFF;
            				gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
            				gl.stencilMask(0xFF);
            				this.alphaToCoverage = false;
            				this.raster = true;
            				gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
            				gl.disable(gl.RASTERIZER_DISCARD);
            				this.depthBiasEnabled = false;
            				gl.disable(gl.POLYGON_OFFSET_FILL);
            				this.clearDepth = 1;
            				gl.clearDepth(1);
            				this.clearColor = new Color(0, 0, 0, 0);
            				gl.clearColor(0, 0, 0, 0);
            				this.clearStencil = 0;
            				gl.clearStencil(0);
            				gl.hint(gl.FRAGMENT_SHADER_DERIVATIVE_HINT, gl.NICEST);
            				gl.enable(gl.SCISSOR_TEST);
            				gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
            				this.unpackFlipY = false;
            				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
            				this.unpackPremultiplyAlpha = false;
            				gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            				gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
            		}
            		initTextureUnits(count) {
            				if (count === void 0) count = 16;
            				this.textureUnits = [];
            				for(var i = 0; i < count; i++){
            						this.textureUnits.push([
            								null,
            								null,
            								null
            						]);
            				}
            		}
            		initializeContextCaches() {
            				super.initializeContextCaches();
            				this._vaoMap = new Map();
            				this.boundVao = null;
            				this.activeFramebuffer = null;
            				this.feedback = null;
            				this.transformFeedbackBuffer = null;
            				this.textureUnit = 0;
            				this.initTextureUnits(this.maxCombinedTextures);
            		}
            		loseContext() {
            				super.loseContext();
            				for (var shader of this.shaders){
            						shader.loseContext();
            				}
            		}
            		restoreContext() {
            				this.initializeExtensions();
            				this.initializeCapabilities();
            				super.restoreContext();
            				for (var shader of this.shaders){
            						shader.restoreContext();
            				}
            		}
            		setViewport(x, y, w, h) {
            				if (this.vx !== x || this.vy !== y || this.vw !== w || this.vh !== h) {
            						this.gl.viewport(x, y, w, h);
            						this.vx = x;
            						this.vy = y;
            						this.vw = w;
            						this.vh = h;
            				}
            		}
            		setScissor(x, y, w, h) {
            				if (this.sx !== x || this.sy !== y || this.sw !== w || this.sh !== h) {
            						this.gl.scissor(x, y, w, h);
            						this.sx = x;
            						this.sy = y;
            						this.sw = w;
            						this.sh = h;
            				}
            		}
            		setFramebuffer(fb) {
            				if (this.activeFramebuffer !== fb) {
            						var gl = this.gl;
            						gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
            						this.activeFramebuffer = fb;
            				}
            		}
            		copyRenderTarget(source, dest, color, depth) {
            				var _this_backBuffer, _this_backBuffer1;
            				var gl = this.gl;
            				if (source === this.backBuffer) {
            						source = null;
            				}
            				if (color) {
            						if (!dest) {
            								if (!source._colorBuffer) {
            										return false;
            								}
            						} else if (source) {
            								if (!source._colorBuffer || !dest._colorBuffer) {
            										return false;
            								}
            								if (source._colorBuffer._format !== dest._colorBuffer._format) {
            										return false;
            								}
            						}
            				}
            				if (depth && source) {
            						if (!source._depth) {
            								if (!source._depthBuffer || !dest._depthBuffer) {
            										return false;
            								}
            								if (source._depthBuffer._format !== dest._depthBuffer._format) {
            										return false;
            								}
            						}
            				}
            				var prevRt = this.renderTarget;
            				this.renderTarget = dest;
            				this.updateBegin();
            				var src = source ? source.impl._glFrameBuffer : (_this_backBuffer = this.backBuffer) == null ? void 0 : _this_backBuffer.impl._glFrameBuffer;
            				var dst = dest ? dest.impl._glFrameBuffer : (_this_backBuffer1 = this.backBuffer) == null ? void 0 : _this_backBuffer1.impl._glFrameBuffer;
            				gl.bindFramebuffer(gl.READ_FRAMEBUFFER, src);
            				gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dst);
            				var w = source ? source.width : dest ? dest.width : this.width;
            				var h = source ? source.height : dest ? dest.height : this.height;
            				gl.blitFramebuffer(0, 0, w, h, 0, 0, w, h, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0), gl.NEAREST);
            				this.renderTarget = prevRt;
            				gl.bindFramebuffer(gl.FRAMEBUFFER, prevRt ? prevRt.impl._glFrameBuffer : null);
            				return true;
            		}
            		frameStart() {
            				super.frameStart();
            				this.updateBackbuffer();
            				this.gpuProfiler.frameStart();
            		}
            		frameEnd() {
            				super.frameEnd();
            				this.gpuProfiler.frameEnd();
            				this.gpuProfiler.request();
            		}
            		startRenderPass(renderPass) {
            				var _renderPass_renderTarget;
            				var rt = (_renderPass_renderTarget = renderPass.renderTarget) != null ? _renderPass_renderTarget : this.backBuffer;
            				this.renderTarget = rt;
            				this.updateBegin();
            				var { width, height } = rt;
            				this.setViewport(0, 0, width, height);
            				this.setScissor(0, 0, width, height);
            				var colorOps = renderPass.colorOps;
            				var depthStencilOps = renderPass.depthStencilOps;
            				if ((colorOps == null ? void 0 : colorOps.clear) || depthStencilOps.clearDepth || depthStencilOps.clearStencil) {
            						var clearFlags = 0;
            						var clearOptions = {};
            						if (colorOps == null ? void 0 : colorOps.clear) {
            								clearFlags |= CLEARFLAG_COLOR;
            								clearOptions.color = [
            										colorOps.clearValue.r,
            										colorOps.clearValue.g,
            										colorOps.clearValue.b,
            										colorOps.clearValue.a
            								];
            						}
            						if (depthStencilOps.clearDepth) {
            								clearFlags |= CLEARFLAG_DEPTH;
            								clearOptions.depth = depthStencilOps.clearDepthValue;
            						}
            						if (depthStencilOps.clearStencil) {
            								clearFlags |= CLEARFLAG_STENCIL;
            								clearOptions.stencil = depthStencilOps.clearStencilValue;
            						}
            						clearOptions.flags = clearFlags;
            						this.clear(clearOptions);
            				}
            				this.insideRenderPass = true;
            		}
            		endRenderPass(renderPass) {
            				this.unbindVertexArray();
            				var target = this.renderTarget;
            				var colorBufferCount = renderPass.colorArrayOps.length;
            				if (target) {
            						var _renderPass_colorOps;
            						invalidateAttachments.length = 0;
            						var gl = this.gl;
            						for(var i = 0; i < colorBufferCount; i++){
            								var colorOps = renderPass.colorArrayOps[i];
            								if (!(colorOps.store || colorOps.resolve)) {
            										invalidateAttachments.push(gl.COLOR_ATTACHMENT0 + i);
            								}
            						}
            						if (target !== this.backBuffer) {
            								if (!renderPass.depthStencilOps.storeDepth) {
            										invalidateAttachments.push(gl.DEPTH_ATTACHMENT);
            								}
            								if (!renderPass.depthStencilOps.storeStencil) {
            										invalidateAttachments.push(gl.STENCIL_ATTACHMENT);
            								}
            						}
            						if (invalidateAttachments.length > 0) {
            								if (renderPass.fullSizeClearRect) {
            										gl.invalidateFramebuffer(gl.DRAW_FRAMEBUFFER, invalidateAttachments);
            								}
            						}
            						if (colorBufferCount && ((_renderPass_colorOps = renderPass.colorOps) == null ? void 0 : _renderPass_colorOps.resolve)) {
            								if (renderPass.samples > 1 && target.autoResolve) {
            										target.resolve(true, false);
            								}
            						}
            						if (target.depthBuffer && renderPass.depthStencilOps.resolveDepth) {
            								if (renderPass.samples > 1 && target.autoResolve) {
            										target.resolve(false, true);
            								}
            						}
            						for(var i1 = 0; i1 < colorBufferCount; i1++){
            								var colorOps1 = renderPass.colorArrayOps[i1];
            								if (colorOps1.genMipmaps) {
            										var colorBuffer = target._colorBuffers[i1];
            										if (colorBuffer && colorBuffer.impl._glTexture && colorBuffer.mipmaps) {
            												this.activeTexture(this.maxCombinedTextures - 1);
            												this.bindTexture(colorBuffer);
            												this.gl.generateMipmap(colorBuffer.impl._glTarget);
            										}
            								}
            						}
            				}
            				this.insideRenderPass = false;
            		}
            		set defaultFramebuffer(value) {
            				if (this._defaultFramebuffer !== value) {
            						this._defaultFramebuffer = value;
            						this._defaultFramebufferChanged = true;
            				}
            		}
            		get defaultFramebuffer() {
            				return this._defaultFramebuffer;
            		}
            		updateBegin() {
            				this.boundVao = null;
            				if (this._tempEnableSafariTextureUnitWorkaround) {
            						for(var unit = 0; unit < this.textureUnits.length; ++unit){
            								for(var slot = 0; slot < 3; ++slot){
            										this.textureUnits[unit][slot] = null;
            								}
            						}
            				}
            				var _this_renderTarget;
            				var target = (_this_renderTarget = this.renderTarget) != null ? _this_renderTarget : this.backBuffer;
            				var targetImpl = target.impl;
            				if (!targetImpl.initialized) {
            						this.initRenderTarget(target);
            				}
            				this.setFramebuffer(targetImpl._glFrameBuffer);
            		}
            		updateEnd() {
            				this.unbindVertexArray();
            				var target = this.renderTarget;
            				if (target && target !== this.backBuffer) {
            						if (target._samples > 1 && target.autoResolve) {
            								target.resolve();
            						}
            						var colorBuffer = target._colorBuffer;
            						if (colorBuffer && colorBuffer.impl._glTexture && colorBuffer.mipmaps) {
            								this.activeTexture(this.maxCombinedTextures - 1);
            								this.bindTexture(colorBuffer);
            								this.gl.generateMipmap(colorBuffer.impl._glTarget);
            						}
            				}
            		}
            		setUnpackFlipY(flipY) {
            				if (this.unpackFlipY !== flipY) {
            						this.unpackFlipY = flipY;
            						var gl = this.gl;
            						gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);
            				}
            		}
            		setUnpackPremultiplyAlpha(premultiplyAlpha) {
            				if (this.unpackPremultiplyAlpha !== premultiplyAlpha) {
            						this.unpackPremultiplyAlpha = premultiplyAlpha;
            						var gl = this.gl;
            						gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);
            				}
            		}
            		activeTexture(textureUnit) {
            				if (this.textureUnit !== textureUnit) {
            						this.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);
            						this.textureUnit = textureUnit;
            				}
            		}
            		bindTexture(texture) {
            				var impl = texture.impl;
            				var textureTarget = impl._glTarget;
            				var textureObject = impl._glTexture;
            				var textureUnit = this.textureUnit;
            				var slot = this.targetToSlot[textureTarget];
            				if (this.textureUnits[textureUnit][slot] !== textureObject) {
            						this.gl.bindTexture(textureTarget, textureObject);
            						this.textureUnits[textureUnit][slot] = textureObject;
            				}
            		}
            		bindTextureOnUnit(texture, textureUnit) {
            				var impl = texture.impl;
            				var textureTarget = impl._glTarget;
            				var textureObject = impl._glTexture;
            				var slot = this.targetToSlot[textureTarget];
            				if (this.textureUnits[textureUnit][slot] !== textureObject) {
            						this.activeTexture(textureUnit);
            						this.gl.bindTexture(textureTarget, textureObject);
            						this.textureUnits[textureUnit][slot] = textureObject;
            				}
            		}
            		setTextureParameters(texture) {
            				var gl = this.gl;
            				var flags = texture.impl.dirtyParameterFlags;
            				var target = texture.impl._glTarget;
            				if (flags & TEXPROPERTY_MIN_FILTER) {
            						var filter = texture._minFilter;
            						if (!texture._mipmaps || texture._compressed && texture._levels.length === 1) {
            								if (filter === FILTER_NEAREST_MIPMAP_NEAREST || filter === FILTER_NEAREST_MIPMAP_LINEAR) {
            										filter = FILTER_NEAREST;
            								} else if (filter === FILTER_LINEAR_MIPMAP_NEAREST || filter === FILTER_LINEAR_MIPMAP_LINEAR) {
            										filter = FILTER_LINEAR;
            								}
            						}
            						gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, this.glFilter[filter]);
            				}
            				if (flags & TEXPROPERTY_MAG_FILTER) {
            						gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, this.glFilter[texture._magFilter]);
            				}
            				if (flags & TEXPROPERTY_ADDRESS_U) {
            						gl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture._addressU]);
            				}
            				if (flags & TEXPROPERTY_ADDRESS_V) {
            						gl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture._addressV]);
            				}
            				if (flags & TEXPROPERTY_ADDRESS_W) {
            						gl.texParameteri(target, gl.TEXTURE_WRAP_R, this.glAddress[texture._addressW]);
            				}
            				if (flags & TEXPROPERTY_COMPARE_ON_READ) {
            						gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, texture._compareOnRead ? gl.COMPARE_REF_TO_TEXTURE : gl.NONE);
            				}
            				if (flags & TEXPROPERTY_COMPARE_FUNC) {
            						gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, this.glComparison[texture._compareFunc]);
            				}
            				if (flags & TEXPROPERTY_ANISOTROPY) {
            						var ext = this.extTextureFilterAnisotropic;
            						if (ext) {
            								gl.texParameterf(target, ext.TEXTURE_MAX_ANISOTROPY_EXT, math.clamp(Math.round(texture._anisotropy), 1, this.maxAnisotropy));
            						}
            				}
            		}
            		setTexture(texture, textureUnit) {
            				var impl = texture.impl;
            				if (!impl._glTexture) {
            						impl.initialize(this, texture);
            				}
            				if (impl.dirtyParameterFlags > 0 || texture._needsUpload || texture._needsMipmapsUpload) {
            						this.activeTexture(textureUnit);
            						this.bindTexture(texture);
            						if (impl.dirtyParameterFlags) {
            								this.setTextureParameters(texture);
            								impl.dirtyParameterFlags = 0;
            						}
            						if (texture._needsUpload || texture._needsMipmapsUpload) {
            								impl.upload(this, texture);
            								texture._needsUpload = false;
            								texture._needsMipmapsUpload = false;
            						}
            				} else {
            						this.bindTextureOnUnit(texture, textureUnit);
            				}
            		}
            		createVertexArray(vertexBuffers) {
            				var key, vao;
            				var useCache = vertexBuffers.length > 1;
            				if (useCache) {
            						key = '';
            						for(var i = 0; i < vertexBuffers.length; i++){
            								var vertexBuffer = vertexBuffers[i];
            								key += vertexBuffer.id + vertexBuffer.format.renderingHash;
            						}
            						vao = this._vaoMap.get(key);
            				}
            				if (!vao) {
            						var gl = this.gl;
            						vao = gl.createVertexArray();
            						gl.bindVertexArray(vao);
            						gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
            						for(var i1 = 0; i1 < vertexBuffers.length; i1++){
            								var vertexBuffer1 = vertexBuffers[i1];
            								gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer1.impl.bufferId);
            								var elements = vertexBuffer1.format.elements;
            								for(var j = 0; j < elements.length; j++){
            										var e = elements[j];
            										var loc = semanticToLocation[e.name];
            										if (e.asInt) {
            												gl.vertexAttribIPointer(loc, e.numComponents, this.glType[e.dataType], e.stride, e.offset);
            										} else {
            												gl.vertexAttribPointer(loc, e.numComponents, this.glType[e.dataType], e.normalize, e.stride, e.offset);
            										}
            										gl.enableVertexAttribArray(loc);
            										if (vertexBuffer1.format.instancing) {
            												gl.vertexAttribDivisor(loc, 1);
            										}
            								}
            						}
            						gl.bindVertexArray(null);
            						gl.bindBuffer(gl.ARRAY_BUFFER, null);
            						if (useCache) {
            								this._vaoMap.set(key, vao);
            						}
            				}
            				return vao;
            		}
            		unbindVertexArray() {
            				if (this.boundVao) {
            						this.boundVao = null;
            						this.gl.bindVertexArray(null);
            				}
            		}
            		setBuffers() {
            				var gl = this.gl;
            				var vao;
            				if (this.vertexBuffers.length === 1) {
            						var vertexBuffer = this.vertexBuffers[0];
            						if (!vertexBuffer.impl.vao) {
            								vertexBuffer.impl.vao = this.createVertexArray(this.vertexBuffers);
            						}
            						vao = vertexBuffer.impl.vao;
            				} else {
            						vao = this.createVertexArray(this.vertexBuffers);
            				}
            				if (this.boundVao !== vao) {
            						this.boundVao = vao;
            						gl.bindVertexArray(vao);
            				}
            				this.clearVertexBuffer();
            				var bufferId = this.indexBuffer ? this.indexBuffer.impl.bufferId : null;
            				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferId);
            		}
            		draw(primitive, numInstances, keepBuffers) {
            				var gl = this.gl;
            				this.activateShader(this);
            				if (!this.shaderValid) {
            						return;
            				}
            				var sampler, samplerValue, texture, numTextures;
            				var uniform, scopeId, uniformVersion, programVersion;
            				var shader = this.shader;
            				if (!shader) {
            						return;
            				}
            				var samplers = shader.impl.samplers;
            				var uniforms = shader.impl.uniforms;
            				if (!keepBuffers) {
            						this.setBuffers();
            				}
            				var textureUnit = 0;
            				for(var i = 0, len = samplers.length; i < len; i++){
            						sampler = samplers[i];
            						samplerValue = sampler.scopeId.value;
            						if (!samplerValue) {
            								var samplerName = sampler.scopeId.name;
            								if (samplerName === 'uSceneDepthMap') {
            										samplerValue = getBuiltInTexture(this, 'white');
            								}
            								if (samplerName === 'uSceneColorMap') {
            										samplerValue = getBuiltInTexture(this, 'pink');
            								}
            								if (!samplerValue) {
            										samplerValue = getBuiltInTexture(this, 'pink');
            								}
            						}
            						if (samplerValue instanceof Texture) {
            								texture = samplerValue;
            								this.setTexture(texture, textureUnit);
            								if (sampler.slot !== textureUnit) {
            										gl.uniform1i(sampler.locationId, textureUnit);
            										sampler.slot = textureUnit;
            								}
            								textureUnit++;
            						} else {
            								sampler.array.length = 0;
            								numTextures = samplerValue.length;
            								for(var j = 0; j < numTextures; j++){
            										texture = samplerValue[j];
            										this.setTexture(texture, textureUnit);
            										sampler.array[j] = textureUnit;
            										textureUnit++;
            								}
            								gl.uniform1iv(sampler.locationId, sampler.array);
            						}
            				}
            				for(var i1 = 0, len1 = uniforms.length; i1 < len1; i1++){
            						uniform = uniforms[i1];
            						scopeId = uniform.scopeId;
            						uniformVersion = uniform.version;
            						programVersion = scopeId.versionObject.version;
            						if (uniformVersion.globalId !== programVersion.globalId || uniformVersion.revision !== programVersion.revision) {
            								uniformVersion.globalId = programVersion.globalId;
            								uniformVersion.revision = programVersion.revision;
            								if (scopeId.value !== null) {
            										this.commitFunction[uniform.dataType](uniform, scopeId.value);
            								}
            						}
            				}
            				if (this.transformFeedbackBuffer) {
            						gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.transformFeedbackBuffer.impl.bufferId);
            						gl.beginTransformFeedback(gl.POINTS);
            				}
            				var mode = this.glPrimitive[primitive.type];
            				var count = primitive.count;
            				if (primitive.indexed) {
            						var indexBuffer = this.indexBuffer;
            						var format = indexBuffer.impl.glFormat;
            						var offset = primitive.base * indexBuffer.bytesPerIndex;
            						if (numInstances > 0) {
            								gl.drawElementsInstanced(mode, count, format, offset, numInstances);
            						} else {
            								gl.drawElements(mode, count, format, offset);
            						}
            				} else {
            						var first = primitive.base;
            						if (numInstances > 0) {
            								gl.drawArraysInstanced(mode, first, count, numInstances);
            						} else {
            								gl.drawArrays(mode, first, count);
            						}
            				}
            				if (this.transformFeedbackBuffer) {
            						gl.endTransformFeedback();
            						gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
            				}
            				this._drawCallsPerFrame++;
            		}
            		clear(options) {
            				var defaultOptions = this.defaultClearOptions;
            				options = options || defaultOptions;
            				var _options_flags;
            				var flags = (_options_flags = options.flags) != null ? _options_flags : defaultOptions.flags;
            				if (flags !== 0) {
            						var gl = this.gl;
            						if (flags & CLEARFLAG_COLOR) {
            								var _options_color;
            								var color = (_options_color = options.color) != null ? _options_color : defaultOptions.color;
            								var r = color[0];
            								var g = color[1];
            								var b = color[2];
            								var a = color[3];
            								var c = this.clearColor;
            								if (r !== c.r || g !== c.g || b !== c.b || a !== c.a) {
            										this.gl.clearColor(r, g, b, a);
            										this.clearColor.set(r, g, b, a);
            								}
            								this.setBlendState(BlendState.NOBLEND);
            						}
            						if (flags & CLEARFLAG_DEPTH) {
            								var _options_depth;
            								var depth = (_options_depth = options.depth) != null ? _options_depth : defaultOptions.depth;
            								if (depth !== this.clearDepth) {
            										this.gl.clearDepth(depth);
            										this.clearDepth = depth;
            								}
            								this.setDepthState(DepthState.WRITEDEPTH);
            						}
            						if (flags & CLEARFLAG_STENCIL) {
            								var _options_stencil;
            								var stencil = (_options_stencil = options.stencil) != null ? _options_stencil : defaultOptions.stencil;
            								if (stencil !== this.clearStencil) {
            										this.gl.clearStencil(stencil);
            										this.clearStencil = stencil;
            								}
            								gl.stencilMask(0xFF);
            								this.stencilWriteMaskFront = 0xFF;
            								this.stencilWriteMaskBack = 0xFF;
            						}
            						gl.clear(this.glClearFlag[flags]);
            				}
            		}
            		submit() {
            				this.gl.flush();
            		}
            		readPixels(x, y, w, h, pixels) {
            				var gl = this.gl;
            				gl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
            		}
            		readPixelsAsync(x, y, w, h, pixels) {
            				var _this = this;
            				return _async_to_generator$3(function*() {
            						var _this_renderTarget_colorBuffer;
            						var gl = _this.gl;
            						var clientWaitAsync = (flags, interval_ms)=>{
            								var sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
            								_this.submit();
            								return new Promise((resolve, reject)=>{
            										function test() {
            												var res = gl.clientWaitSync(sync, flags, 0);
            												if (res === gl.WAIT_FAILED) {
            														gl.deleteSync(sync);
            														reject(new Error('webgl clientWaitSync sync failed'));
            												} else if (res === gl.TIMEOUT_EXPIRED) {
            														setTimeout(test, interval_ms);
            												} else {
            														gl.deleteSync(sync);
            														resolve();
            												}
            										}
            										test();
            								});
            						};
            						var impl = (_this_renderTarget_colorBuffer = _this.renderTarget.colorBuffer) == null ? void 0 : _this_renderTarget_colorBuffer.impl;
            						var _impl__glFormat;
            						var format = (_impl__glFormat = impl == null ? void 0 : impl._glFormat) != null ? _impl__glFormat : gl.RGBA;
            						var _impl__glPixelType;
            						var pixelType = (_impl__glPixelType = impl == null ? void 0 : impl._glPixelType) != null ? _impl__glPixelType : gl.UNSIGNED_BYTE;
            						var buf = gl.createBuffer();
            						gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
            						gl.bufferData(gl.PIXEL_PACK_BUFFER, pixels.byteLength, gl.STREAM_READ);
            						gl.readPixels(x, y, w, h, format, pixelType, 0);
            						gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
            						yield clientWaitAsync(0, 20);
            						gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
            						gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, pixels);
            						gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
            						gl.deleteBuffer(buf);
            						return pixels;
            				})();
            		}
            		readTextureAsync(texture, x, y, width, height, options) {
            				var _options_face;
            				var face = (_options_face = options.face) != null ? _options_face : 0;
            				var _options_renderTarget;
            				var renderTarget = (_options_renderTarget = options.renderTarget) != null ? _options_renderTarget : new RenderTarget({
            						colorBuffer: texture,
            						depth: false,
            						face: face
            				});
            				var buffer = new ArrayBuffer(TextureUtils.calcLevelGpuSize(width, height, 1, texture._format));
            				var _options_data;
            				var data = (_options_data = options.data) != null ? _options_data : new (getPixelFormatArrayType(texture._format))(buffer);
            				this.setRenderTarget(renderTarget);
            				this.initRenderTarget(renderTarget);
            				return new Promise((resolve, reject)=>{
            						this.readPixelsAsync(x, y, width, height, data).then((data)=>{
            								if (!options.renderTarget) {
            										renderTarget.destroy();
            								}
            								resolve(data);
            						}).catch(reject);
            				});
            		}
            		setAlphaToCoverage(state) {
            				if (this.alphaToCoverage !== state) {
            						this.alphaToCoverage = state;
            						if (state) {
            								this.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
            						} else {
            								this.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);
            						}
            				}
            		}
            		setTransformFeedbackBuffer(tf) {
            				if (this.transformFeedbackBuffer !== tf) {
            						this.transformFeedbackBuffer = tf;
            						var gl = this.gl;
            						if (tf) {
            								if (!this.feedback) {
            										this.feedback = gl.createTransformFeedback();
            								}
            								gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, this.feedback);
            						} else {
            								gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
            						}
            				}
            		}
            		setRaster(on) {
            				if (this.raster !== on) {
            						this.raster = on;
            						if (on) {
            								this.gl.disable(this.gl.RASTERIZER_DISCARD);
            						} else {
            								this.gl.enable(this.gl.RASTERIZER_DISCARD);
            						}
            				}
            		}
            		setStencilTest(enable) {
            				if (this.stencil !== enable) {
            						var gl = this.gl;
            						if (enable) {
            								gl.enable(gl.STENCIL_TEST);
            						} else {
            								gl.disable(gl.STENCIL_TEST);
            						}
            						this.stencil = enable;
            				}
            		}
            		setStencilFunc(func, ref, mask) {
            				if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask || this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {
            						this.gl.stencilFunc(this.glComparison[func], ref, mask);
            						this.stencilFuncFront = this.stencilFuncBack = func;
            						this.stencilRefFront = this.stencilRefBack = ref;
            						this.stencilMaskFront = this.stencilMaskBack = mask;
            				}
            		}
            		setStencilFuncFront(func, ref, mask) {
            				if (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask) {
            						var gl = this.gl;
            						gl.stencilFuncSeparate(gl.FRONT, this.glComparison[func], ref, mask);
            						this.stencilFuncFront = func;
            						this.stencilRefFront = ref;
            						this.stencilMaskFront = mask;
            				}
            		}
            		setStencilFuncBack(func, ref, mask) {
            				if (this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {
            						var gl = this.gl;
            						gl.stencilFuncSeparate(gl.BACK, this.glComparison[func], ref, mask);
            						this.stencilFuncBack = func;
            						this.stencilRefBack = ref;
            						this.stencilMaskBack = mask;
            				}
            		}
            		setStencilOperation(fail, zfail, zpass, writeMask) {
            				if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass || this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {
            						this.gl.stencilOp(this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
            						this.stencilFailFront = this.stencilFailBack = fail;
            						this.stencilZfailFront = this.stencilZfailBack = zfail;
            						this.stencilZpassFront = this.stencilZpassBack = zpass;
            				}
            				if (this.stencilWriteMaskFront !== writeMask || this.stencilWriteMaskBack !== writeMask) {
            						this.gl.stencilMask(writeMask);
            						this.stencilWriteMaskFront = writeMask;
            						this.stencilWriteMaskBack = writeMask;
            				}
            		}
            		setStencilOperationFront(fail, zfail, zpass, writeMask) {
            				if (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass) {
            						this.gl.stencilOpSeparate(this.gl.FRONT, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
            						this.stencilFailFront = fail;
            						this.stencilZfailFront = zfail;
            						this.stencilZpassFront = zpass;
            				}
            				if (this.stencilWriteMaskFront !== writeMask) {
            						this.gl.stencilMaskSeparate(this.gl.FRONT, writeMask);
            						this.stencilWriteMaskFront = writeMask;
            				}
            		}
            		setStencilOperationBack(fail, zfail, zpass, writeMask) {
            				if (this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {
            						this.gl.stencilOpSeparate(this.gl.BACK, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);
            						this.stencilFailBack = fail;
            						this.stencilZfailBack = zfail;
            						this.stencilZpassBack = zpass;
            				}
            				if (this.stencilWriteMaskBack !== writeMask) {
            						this.gl.stencilMaskSeparate(this.gl.BACK, writeMask);
            						this.stencilWriteMaskBack = writeMask;
            				}
            		}
            		setBlendState(blendState) {
            				var currentBlendState = this.blendState;
            				if (!currentBlendState.equals(blendState)) {
            						var gl = this.gl;
            						var { blend, colorOp, alphaOp, colorSrcFactor, colorDstFactor, alphaSrcFactor, alphaDstFactor } = blendState;
            						if (currentBlendState.blend !== blend) {
            								if (blend) {
            										gl.enable(gl.BLEND);
            								} else {
            										gl.disable(gl.BLEND);
            								}
            						}
            						if (currentBlendState.colorOp !== colorOp || currentBlendState.alphaOp !== alphaOp) {
            								var glBlendEquation = this.glBlendEquation;
            								gl.blendEquationSeparate(glBlendEquation[colorOp], glBlendEquation[alphaOp]);
            						}
            						if (currentBlendState.colorSrcFactor !== colorSrcFactor || currentBlendState.colorDstFactor !== colorDstFactor || currentBlendState.alphaSrcFactor !== alphaSrcFactor || currentBlendState.alphaDstFactor !== alphaDstFactor) {
            								gl.blendFuncSeparate(this.glBlendFunctionColor[colorSrcFactor], this.glBlendFunctionColor[colorDstFactor], this.glBlendFunctionAlpha[alphaSrcFactor], this.glBlendFunctionAlpha[alphaDstFactor]);
            						}
            						if (currentBlendState.allWrite !== blendState.allWrite) {
            								this.gl.colorMask(blendState.redWrite, blendState.greenWrite, blendState.blueWrite, blendState.alphaWrite);
            						}
            						currentBlendState.copy(blendState);
            				}
            		}
            		setBlendColor(r, g, b, a) {
            				var c = this.blendColor;
            				if (r !== c.r || g !== c.g || b !== c.b || a !== c.a) {
            						this.gl.blendColor(r, g, b, a);
            						c.set(r, g, b, a);
            				}
            		}
            		setStencilState(stencilFront, stencilBack) {
            				if (stencilFront || stencilBack) {
            						this.setStencilTest(true);
            						if (stencilFront === stencilBack) {
            								this.setStencilFunc(stencilFront.func, stencilFront.ref, stencilFront.readMask);
            								this.setStencilOperation(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);
            						} else {
            								stencilFront != null ? stencilFront : stencilFront = StencilParameters.DEFAULT;
            								this.setStencilFuncFront(stencilFront.func, stencilFront.ref, stencilFront.readMask);
            								this.setStencilOperationFront(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);
            								stencilBack != null ? stencilBack : stencilBack = StencilParameters.DEFAULT;
            								this.setStencilFuncBack(stencilBack.func, stencilBack.ref, stencilBack.readMask);
            								this.setStencilOperationBack(stencilBack.fail, stencilBack.zfail, stencilBack.zpass, stencilBack.writeMask);
            						}
            				} else {
            						this.setStencilTest(false);
            				}
            		}
            		setDepthState(depthState) {
            				var currentDepthState = this.depthState;
            				if (!currentDepthState.equals(depthState)) {
            						var gl = this.gl;
            						var write = depthState.write;
            						if (currentDepthState.write !== write) {
            								gl.depthMask(write);
            						}
            						var { func, test } = depthState;
            						if (!test && write) {
            								test = true;
            								func = FUNC_ALWAYS;
            						}
            						if (currentDepthState.func !== func) {
            								gl.depthFunc(this.glComparison[func]);
            						}
            						if (currentDepthState.test !== test) {
            								if (test) {
            										gl.enable(gl.DEPTH_TEST);
            								} else {
            										gl.disable(gl.DEPTH_TEST);
            								}
            						}
            						var { depthBias, depthBiasSlope } = depthState;
            						if (depthBias || depthBiasSlope) {
            								if (!this.depthBiasEnabled) {
            										this.depthBiasEnabled = true;
            										this.gl.enable(this.gl.POLYGON_OFFSET_FILL);
            								}
            								gl.polygonOffset(depthBiasSlope, depthBias);
            						} else {
            								if (this.depthBiasEnabled) {
            										this.depthBiasEnabled = false;
            										this.gl.disable(this.gl.POLYGON_OFFSET_FILL);
            								}
            						}
            						currentDepthState.copy(depthState);
            				}
            		}
            		setCullMode(cullMode) {
            				if (this.cullMode !== cullMode) {
            						if (cullMode === CULLFACE_NONE) {
            								this.gl.disable(this.gl.CULL_FACE);
            						} else {
            								if (this.cullMode === CULLFACE_NONE) {
            										this.gl.enable(this.gl.CULL_FACE);
            								}
            								var mode = this.glCull[cullMode];
            								if (this.cullFace !== mode) {
            										this.gl.cullFace(mode);
            										this.cullFace = mode;
            								}
            						}
            						this.cullMode = cullMode;
            				}
            		}
            		setShader(shader, asyncCompile) {
            				if (asyncCompile === void 0) asyncCompile = false;
            				if (shader !== this.shader) {
            						this.shader = shader;
            						this.shaderAsyncCompile = asyncCompile;
            						this.shaderValid = undefined;
            				}
            		}
            		activateShader(device) {
            				var { shader } = this;
            				var { impl } = shader;
            				if (this.shaderValid === undefined) {
            						if (shader.failed) {
            								this.shaderValid = false;
            						} else if (!shader.ready) {
            								if (this.shaderAsyncCompile) {
            										if (impl.isLinked(device)) {
            												if (!impl.finalize(this, shader)) {
            														shader.failed = true;
            														this.shaderValid = false;
            												}
            										} else {
            												this.shaderValid = false;
            										}
            								} else {
            										if (!impl.finalize(this, shader)) {
            												shader.failed = true;
            												this.shaderValid = false;
            										}
            								}
            						}
            				}
            				if (this.shaderValid === undefined) {
            						this.gl.useProgram(impl.glProgram);
            						this.shaderValid = true;
            				}
            		}
            		clearVertexArrayObjectCache() {
            				var gl = this.gl;
            				this._vaoMap.forEach((item, key, mapObj)=>{
            						gl.deleteVertexArray(item);
            				});
            				this._vaoMap.clear();
            		}
            		set fullscreen(fullscreen) {
            				if (fullscreen) {
            						var canvas = this.gl.canvas;
            						canvas.requestFullscreen();
            				} else {
            						document.exitFullscreen();
            				}
            		}
            		get fullscreen() {
            				return !!document.fullscreenElement;
            		}
            		constructor(canvas, options = {}){
            				super(canvas, options), this._defaultFramebuffer = null, this._defaultFramebufferChanged = false;
            				options = this.initOptions;
            				this.updateClientRect();
            				this.initTextureUnits();
            				this.contextLost = false;
            				this._contextLostHandler = (event)=>{
            						event.preventDefault();
            						this.loseContext();
            						this.fire('devicelost');
            				};
            				this._contextRestoredHandler = ()=>{
            						this.restoreContext();
            						this.fire('devicerestored');
            				};
            				var ua = typeof navigator !== 'undefined' && navigator.userAgent;
            				this.forceDisableMultisampling = ua && ua.includes('AppleWebKit') && (ua.includes('15.4') || ua.includes('15_4'));
            				if (this.forceDisableMultisampling) {
            						options.antialias = false;
            				}
            				if (platform.browserName === 'firefox') {
            						var ua1 = typeof navigator !== 'undefined' ? navigator.userAgent : '';
            						var match = ua1.match(/Firefox\/(\d+(\.\d+)*)/);
            						var firefoxVersion = match ? match[1] : null;
            						if (firefoxVersion) {
            								var version = parseFloat(firefoxVersion);
            								var disableAntialias = platform.name === 'windows' && (version >= 120 || version === 115) || platform.name === 'android' && version >= 132;
            								if (disableAntialias) {
            										options.antialias = false;
            								}
            						}
            				}
            				var _options_antialias;
            				this.backBufferAntialias = (_options_antialias = options.antialias) != null ? _options_antialias : false;
            				options.antialias = false;
            				var _options_gl;
            				var gl = (_options_gl = options.gl) != null ? _options_gl : canvas.getContext('webgl2', options);
            				if (!gl) {
            						throw new Error('WebGL not supported');
            				}
            				this.gl = gl;
            				this.isWebGL2 = true;
            				this._deviceType = DEVICETYPE_WEBGL2;
            				this.updateBackbufferFormat(null);
            				var isChrome = platform.browserName === 'chrome';
            				var isSafari = platform.browserName === 'safari';
            				var isMac = platform.browser && navigator.appVersion.indexOf('Mac') !== -1;
            				this._tempEnableSafariTextureUnitWorkaround = isSafari;
            				this._tempMacChromeBlitFramebufferWorkaround = isMac && isChrome && !options.alpha;
            				canvas.addEventListener('webglcontextlost', this._contextLostHandler, false);
            				canvas.addEventListener('webglcontextrestored', this._contextRestoredHandler, false);
            				this.initializeExtensions();
            				this.initializeCapabilities();
            				this.initializeRenderState();
            				this.initializeContextCaches();
            				this.createBackbuffer(null);
            				this.supportsImageBitmap = !isSafari && typeof ImageBitmap !== 'undefined';
            				this._samplerTypes = new Set([
            						gl.SAMPLER_2D,
            						gl.SAMPLER_CUBE,
            						gl.UNSIGNED_INT_SAMPLER_2D,
            						gl.INT_SAMPLER_2D,
            						gl.SAMPLER_2D_SHADOW,
            						gl.SAMPLER_CUBE_SHADOW,
            						gl.SAMPLER_3D,
            						gl.INT_SAMPLER_3D,
            						gl.UNSIGNED_INT_SAMPLER_3D,
            						gl.SAMPLER_2D_ARRAY,
            						gl.INT_SAMPLER_2D_ARRAY,
            						gl.UNSIGNED_INT_SAMPLER_2D_ARRAY
            				]);
            				this.glAddress = [
            						gl.REPEAT,
            						gl.CLAMP_TO_EDGE,
            						gl.MIRRORED_REPEAT
            				];
            				this.glBlendEquation = [
            						gl.FUNC_ADD,
            						gl.FUNC_SUBTRACT,
            						gl.FUNC_REVERSE_SUBTRACT,
            						gl.MIN,
            						gl.MAX
            				];
            				this.glBlendFunctionColor = [
            						gl.ZERO,
            						gl.ONE,
            						gl.SRC_COLOR,
            						gl.ONE_MINUS_SRC_COLOR,
            						gl.DST_COLOR,
            						gl.ONE_MINUS_DST_COLOR,
            						gl.SRC_ALPHA,
            						gl.SRC_ALPHA_SATURATE,
            						gl.ONE_MINUS_SRC_ALPHA,
            						gl.DST_ALPHA,
            						gl.ONE_MINUS_DST_ALPHA,
            						gl.CONSTANT_COLOR,
            						gl.ONE_MINUS_CONSTANT_COLOR
            				];
            				this.glBlendFunctionAlpha = [
            						gl.ZERO,
            						gl.ONE,
            						gl.SRC_COLOR,
            						gl.ONE_MINUS_SRC_COLOR,
            						gl.DST_COLOR,
            						gl.ONE_MINUS_DST_COLOR,
            						gl.SRC_ALPHA,
            						gl.SRC_ALPHA_SATURATE,
            						gl.ONE_MINUS_SRC_ALPHA,
            						gl.DST_ALPHA,
            						gl.ONE_MINUS_DST_ALPHA,
            						gl.CONSTANT_ALPHA,
            						gl.ONE_MINUS_CONSTANT_ALPHA
            				];
            				this.glComparison = [
            						gl.NEVER,
            						gl.LESS,
            						gl.EQUAL,
            						gl.LEQUAL,
            						gl.GREATER,
            						gl.NOTEQUAL,
            						gl.GEQUAL,
            						gl.ALWAYS
            				];
            				this.glStencilOp = [
            						gl.KEEP,
            						gl.ZERO,
            						gl.REPLACE,
            						gl.INCR,
            						gl.INCR_WRAP,
            						gl.DECR,
            						gl.DECR_WRAP,
            						gl.INVERT
            				];
            				this.glClearFlag = [
            						0,
            						gl.COLOR_BUFFER_BIT,
            						gl.DEPTH_BUFFER_BIT,
            						gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT,
            						gl.STENCIL_BUFFER_BIT,
            						gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT,
            						gl.STENCIL_BUFFER_BIT | gl.DEPTH_BUFFER_BIT,
            						gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT
            				];
            				this.glCull = [
            						0,
            						gl.BACK,
            						gl.FRONT,
            						gl.FRONT_AND_BACK
            				];
            				this.glFilter = [
            						gl.NEAREST,
            						gl.LINEAR,
            						gl.NEAREST_MIPMAP_NEAREST,
            						gl.NEAREST_MIPMAP_LINEAR,
            						gl.LINEAR_MIPMAP_NEAREST,
            						gl.LINEAR_MIPMAP_LINEAR
            				];
            				this.glPrimitive = [
            						gl.POINTS,
            						gl.LINES,
            						gl.LINE_LOOP,
            						gl.LINE_STRIP,
            						gl.TRIANGLES,
            						gl.TRIANGLE_STRIP,
            						gl.TRIANGLE_FAN
            				];
            				this.glType = [
            						gl.BYTE,
            						gl.UNSIGNED_BYTE,
            						gl.SHORT,
            						gl.UNSIGNED_SHORT,
            						gl.INT,
            						gl.UNSIGNED_INT,
            						gl.FLOAT,
            						gl.HALF_FLOAT
            				];
            				this.pcUniformType = {};
            				this.pcUniformType[gl.BOOL] = UNIFORMTYPE_BOOL;
            				this.pcUniformType[gl.INT] = UNIFORMTYPE_INT;
            				this.pcUniformType[gl.FLOAT] = UNIFORMTYPE_FLOAT;
            				this.pcUniformType[gl.FLOAT_VEC2] = UNIFORMTYPE_VEC2;
            				this.pcUniformType[gl.FLOAT_VEC3] = UNIFORMTYPE_VEC3;
            				this.pcUniformType[gl.FLOAT_VEC4] = UNIFORMTYPE_VEC4;
            				this.pcUniformType[gl.INT_VEC2] = UNIFORMTYPE_IVEC2;
            				this.pcUniformType[gl.INT_VEC3] = UNIFORMTYPE_IVEC3;
            				this.pcUniformType[gl.INT_VEC4] = UNIFORMTYPE_IVEC4;
            				this.pcUniformType[gl.BOOL_VEC2] = UNIFORMTYPE_BVEC2;
            				this.pcUniformType[gl.BOOL_VEC3] = UNIFORMTYPE_BVEC3;
            				this.pcUniformType[gl.BOOL_VEC4] = UNIFORMTYPE_BVEC4;
            				this.pcUniformType[gl.FLOAT_MAT2] = UNIFORMTYPE_MAT2;
            				this.pcUniformType[gl.FLOAT_MAT3] = UNIFORMTYPE_MAT3;
            				this.pcUniformType[gl.FLOAT_MAT4] = UNIFORMTYPE_MAT4;
            				this.pcUniformType[gl.SAMPLER_2D] = UNIFORMTYPE_TEXTURE2D;
            				this.pcUniformType[gl.SAMPLER_CUBE] = UNIFORMTYPE_TEXTURECUBE;
            				this.pcUniformType[gl.UNSIGNED_INT] = UNIFORMTYPE_UINT;
            				this.pcUniformType[gl.UNSIGNED_INT_VEC2] = UNIFORMTYPE_UVEC2;
            				this.pcUniformType[gl.UNSIGNED_INT_VEC3] = UNIFORMTYPE_UVEC3;
            				this.pcUniformType[gl.UNSIGNED_INT_VEC4] = UNIFORMTYPE_UVEC4;
            				this.pcUniformType[gl.SAMPLER_2D_SHADOW] = UNIFORMTYPE_TEXTURE2D_SHADOW;
            				this.pcUniformType[gl.SAMPLER_CUBE_SHADOW] = UNIFORMTYPE_TEXTURECUBE_SHADOW;
            				this.pcUniformType[gl.SAMPLER_2D_ARRAY] = UNIFORMTYPE_TEXTURE2D_ARRAY;
            				this.pcUniformType[gl.SAMPLER_3D] = UNIFORMTYPE_TEXTURE3D;
            				this.pcUniformType[gl.INT_SAMPLER_2D] = UNIFORMTYPE_ITEXTURE2D;
            				this.pcUniformType[gl.UNSIGNED_INT_SAMPLER_2D] = UNIFORMTYPE_UTEXTURE2D;
            				this.pcUniformType[gl.INT_SAMPLER_CUBE] = UNIFORMTYPE_ITEXTURECUBE;
            				this.pcUniformType[gl.UNSIGNED_INT_SAMPLER_2D] = UNIFORMTYPE_UTEXTURECUBE;
            				this.pcUniformType[gl.INT_SAMPLER_3D] = UNIFORMTYPE_ITEXTURE3D;
            				this.pcUniformType[gl.UNSIGNED_INT_SAMPLER_3D] = UNIFORMTYPE_UTEXTURE3D;
            				this.pcUniformType[gl.INT_SAMPLER_2D_ARRAY] = UNIFORMTYPE_ITEXTURE2D_ARRAY;
            				this.pcUniformType[gl.UNSIGNED_INT_SAMPLER_2D_ARRAY] = UNIFORMTYPE_UTEXTURE2D_ARRAY;
            				this.targetToSlot = {};
            				this.targetToSlot[gl.TEXTURE_2D] = 0;
            				this.targetToSlot[gl.TEXTURE_CUBE_MAP] = 1;
            				this.targetToSlot[gl.TEXTURE_3D] = 2;
            				var scopeX, scopeY, scopeZ, scopeW;
            				var uniformValue;
            				this.commitFunction = [];
            				this.commitFunction[UNIFORMTYPE_BOOL] = function(uniform, value) {
            						if (uniform.value !== value) {
            								gl.uniform1i(uniform.locationId, value);
            								uniform.value = value;
            						}
            				};
            				this.commitFunction[UNIFORMTYPE_INT] = this.commitFunction[UNIFORMTYPE_BOOL];
            				this.commitFunction[UNIFORMTYPE_FLOAT] = function(uniform, value) {
            						if (uniform.value !== value) {
            								gl.uniform1f(uniform.locationId, value);
            								uniform.value = value;
            						}
            				};
            				this.commitFunction[UNIFORMTYPE_VEC2] = function(uniform, value) {
            						uniformValue = uniform.value;
            						scopeX = value[0];
            						scopeY = value[1];
            						if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
            								gl.uniform2fv(uniform.locationId, value);
            								uniformValue[0] = scopeX;
            								uniformValue[1] = scopeY;
            						}
            				};
            				this.commitFunction[UNIFORMTYPE_VEC3] = function(uniform, value) {
            						uniformValue = uniform.value;
            						scopeX = value[0];
            						scopeY = value[1];
            						scopeZ = value[2];
            						if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
            								gl.uniform3fv(uniform.locationId, value);
            								uniformValue[0] = scopeX;
            								uniformValue[1] = scopeY;
            								uniformValue[2] = scopeZ;
            						}
            				};
            				this.commitFunction[UNIFORMTYPE_VEC4] = function(uniform, value) {
            						uniformValue = uniform.value;
            						scopeX = value[0];
            						scopeY = value[1];
            						scopeZ = value[2];
            						scopeW = value[3];
            						if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
            								gl.uniform4fv(uniform.locationId, value);
            								uniformValue[0] = scopeX;
            								uniformValue[1] = scopeY;
            								uniformValue[2] = scopeZ;
            								uniformValue[3] = scopeW;
            						}
            				};
            				this.commitFunction[UNIFORMTYPE_IVEC2] = function(uniform, value) {
            						uniformValue = uniform.value;
            						scopeX = value[0];
            						scopeY = value[1];
            						if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
            								gl.uniform2iv(uniform.locationId, value);
            								uniformValue[0] = scopeX;
            								uniformValue[1] = scopeY;
            						}
            				};
            				this.commitFunction[UNIFORMTYPE_BVEC2] = this.commitFunction[UNIFORMTYPE_IVEC2];
            				this.commitFunction[UNIFORMTYPE_IVEC3] = function(uniform, value) {
            						uniformValue = uniform.value;
            						scopeX = value[0];
            						scopeY = value[1];
            						scopeZ = value[2];
            						if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
            								gl.uniform3iv(uniform.locationId, value);
            								uniformValue[0] = scopeX;
            								uniformValue[1] = scopeY;
            								uniformValue[2] = scopeZ;
            						}
            				};
            				this.commitFunction[UNIFORMTYPE_BVEC3] = this.commitFunction[UNIFORMTYPE_IVEC3];
            				this.commitFunction[UNIFORMTYPE_IVEC4] = function(uniform, value) {
            						uniformValue = uniform.value;
            						scopeX = value[0];
            						scopeY = value[1];
            						scopeZ = value[2];
            						scopeW = value[3];
            						if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
            								gl.uniform4iv(uniform.locationId, value);
            								uniformValue[0] = scopeX;
            								uniformValue[1] = scopeY;
            								uniformValue[2] = scopeZ;
            								uniformValue[3] = scopeW;
            						}
            				};
            				this.commitFunction[UNIFORMTYPE_BVEC4] = this.commitFunction[UNIFORMTYPE_IVEC4];
            				this.commitFunction[UNIFORMTYPE_MAT2] = function(uniform, value) {
            						gl.uniformMatrix2fv(uniform.locationId, false, value);
            				};
            				this.commitFunction[UNIFORMTYPE_MAT3] = function(uniform, value) {
            						gl.uniformMatrix3fv(uniform.locationId, false, value);
            				};
            				this.commitFunction[UNIFORMTYPE_MAT4] = function(uniform, value) {
            						gl.uniformMatrix4fv(uniform.locationId, false, value);
            				};
            				this.commitFunction[UNIFORMTYPE_FLOATARRAY] = function(uniform, value) {
            						gl.uniform1fv(uniform.locationId, value);
            				};
            				this.commitFunction[UNIFORMTYPE_VEC2ARRAY] = function(uniform, value) {
            						gl.uniform2fv(uniform.locationId, value);
            				};
            				this.commitFunction[UNIFORMTYPE_VEC3ARRAY] = function(uniform, value) {
            						gl.uniform3fv(uniform.locationId, value);
            				};
            				this.commitFunction[UNIFORMTYPE_VEC4ARRAY] = function(uniform, value) {
            						gl.uniform4fv(uniform.locationId, value);
            				};
            				this.commitFunction[UNIFORMTYPE_UINT] = function(uniform, value) {
            						if (uniform.value !== value) {
            								gl.uniform1ui(uniform.locationId, value);
            								uniform.value = value;
            						}
            				};
            				this.commitFunction[UNIFORMTYPE_UVEC2] = function(uniform, value) {
            						uniformValue = uniform.value;
            						scopeX = value[0];
            						scopeY = value[1];
            						if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {
            								gl.uniform2uiv(uniform.locationId, value);
            								uniformValue[0] = scopeX;
            								uniformValue[1] = scopeY;
            						}
            				};
            				this.commitFunction[UNIFORMTYPE_UVEC3] = function(uniform, value) {
            						uniformValue = uniform.value;
            						scopeX = value[0];
            						scopeY = value[1];
            						scopeZ = value[2];
            						if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {
            								gl.uniform3uiv(uniform.locationId, value);
            								uniformValue[0] = scopeX;
            								uniformValue[1] = scopeY;
            								uniformValue[2] = scopeZ;
            						}
            				};
            				this.commitFunction[UNIFORMTYPE_UVEC4] = function(uniform, value) {
            						uniformValue = uniform.value;
            						scopeX = value[0];
            						scopeY = value[1];
            						scopeZ = value[2];
            						scopeW = value[3];
            						if (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {
            								gl.uniform4uiv(uniform.locationId, value);
            								uniformValue[0] = scopeX;
            								uniformValue[1] = scopeY;
            								uniformValue[2] = scopeZ;
            								uniformValue[3] = scopeW;
            						}
            				};
            				this.commitFunction[UNIFORMTYPE_INTARRAY] = function(uniform, value) {
            						gl.uniform1iv(uniform.locationId, value);
            				};
            				this.commitFunction[UNIFORMTYPE_UINTARRAY] = function(uniform, value) {
            						gl.uniform1uiv(uniform.locationId, value);
            				};
            				this.commitFunction[UNIFORMTYPE_BOOLARRAY] = this.commitFunction[UNIFORMTYPE_INTARRAY];
            				this.commitFunction[UNIFORMTYPE_IVEC2ARRAY] = function(uniform, value) {
            						gl.uniform2iv(uniform.locationId, value);
            				};
            				this.commitFunction[UNIFORMTYPE_UVEC2ARRAY] = function(uniform, value) {
            						gl.uniform2uiv(uniform.locationId, value);
            				};
            				this.commitFunction[UNIFORMTYPE_BVEC2ARRAY] = this.commitFunction[UNIFORMTYPE_IVEC2ARRAY];
            				this.commitFunction[UNIFORMTYPE_IVEC3ARRAY] = function(uniform, value) {
            						gl.uniform3iv(uniform.locationId, value);
            				};
            				this.commitFunction[UNIFORMTYPE_UVEC3ARRAY] = function(uniform, value) {
            						gl.uniform3uiv(uniform.locationId, value);
            				};
            				this.commitFunction[UNIFORMTYPE_BVEC3ARRAY] = this.commitFunction[UNIFORMTYPE_IVEC3ARRAY];
            				this.commitFunction[UNIFORMTYPE_IVEC4ARRAY] = function(uniform, value) {
            						gl.uniform4iv(uniform.locationId, value);
            				};
            				this.commitFunction[UNIFORMTYPE_UVEC4ARRAY] = function(uniform, value) {
            						gl.uniform4uiv(uniform.locationId, value);
            				};
            				this.commitFunction[UNIFORMTYPE_BVEC4ARRAY] = this.commitFunction[UNIFORMTYPE_IVEC4ARRAY];
            				this.commitFunction[UNIFORMTYPE_MAT4ARRAY] = function(uniform, value) {
            						gl.uniformMatrix4fv(uniform.locationId, false, value);
            				};
            				this.constantTexSource = this.scope.resolve('source');
            				this.postInit();
            		}
            }
            
            var id$4 = 0;
            class IndexBuffer {
            		destroy() {
            				var device = this.device;
            				var idx = device.buffers.indexOf(this);
            				if (idx !== -1) {
            						device.buffers.splice(idx, 1);
            				}
            				if (this.device.indexBuffer === this) {
            						this.device.indexBuffer = null;
            				}
            				if (this.impl.initialized) {
            						this.impl.destroy(device);
            						this.adjustVramSizeTracking(device._vram, -this.storage.byteLength);
            				}
            		}
            		adjustVramSizeTracking(vram, size) {
            				vram.ib += size;
            		}
            		loseContext() {
            				this.impl.loseContext();
            		}
            		getFormat() {
            				return this.format;
            		}
            		getNumIndices() {
            				return this.numIndices;
            		}
            		lock() {
            				return this.storage;
            		}
            		unlock() {
            				this.impl.unlock(this);
            		}
            		setData(data) {
            				if (data.byteLength !== this.numBytes) {
            						return false;
            				}
            				this.storage = data;
            				this.unlock();
            				return true;
            		}
            		_lockTypedArray() {
            				var lock = this.lock();
            				var indices = this.format === INDEXFORMAT_UINT32 ? new Uint32Array(lock) : this.format === INDEXFORMAT_UINT16 ? new Uint16Array(lock) : new Uint8Array(lock);
            				return indices;
            		}
            		writeData(data, count) {
            				var indices = this._lockTypedArray();
            				if (data.length > count) {
            						if (ArrayBuffer.isView(data)) {
            								data = data.subarray(0, count);
            								indices.set(data);
            						} else {
            								for(var i = 0; i < count; i++){
            										indices[i] = data[i];
            								}
            						}
            				} else {
            						indices.set(data);
            				}
            				this.unlock();
            		}
            		readData(data) {
            				var indices = this._lockTypedArray();
            				var count = this.numIndices;
            				if (ArrayBuffer.isView(data)) {
            						data.set(indices);
            				} else {
            						data.length = 0;
            						for(var i = 0; i < count; i++){
            								data[i] = indices[i];
            						}
            				}
            				return count;
            		}
            		constructor(graphicsDevice, format, numIndices, usage = BUFFER_STATIC, initialData, options){
            				this.device = graphicsDevice;
            				this.format = format;
            				this.numIndices = numIndices;
            				this.usage = usage;
            				this.id = id$4++;
            				this.impl = graphicsDevice.createIndexBufferImpl(this, options);
            				var bytesPerIndex = typedArrayIndexFormatsByteSize[format];
            				this.bytesPerIndex = bytesPerIndex;
            				this.numBytes = this.numIndices * bytesPerIndex;
            				if (initialData) {
            						this.setData(initialData);
            				} else {
            						this.storage = new ArrayBuffer(this.numBytes);
            				}
            				this.adjustVramSizeTracking(graphicsDevice._vram, this.numBytes);
            				this.device.buffers.push(this);
            		}
            }
            
            class ColorAttachmentOps {
            		constructor(){
            				this.clearValue = new Color(0, 0, 0, 1);
            				this.clearValueLinear = new Color(0, 0, 0, 1);
            				this.clear = false;
            				this.store = false;
            				this.resolve = true;
            				this.genMipmaps = false;
            		}
            }
            class DepthStencilAttachmentOps {
            		constructor(){
            				this.clearDepthValue = 1;
            				this.clearStencilValue = 0;
            				this.clearDepth = false;
            				this.clearStencil = false;
            				this.storeDepth = false;
            				this.resolveDepth = false;
            				this.storeStencil = false;
            		}
            }
            class RenderPass {
            		get colorOps() {
            				return this.colorArrayOps[0];
            		}
            		set name(value) {
            				this._name = value;
            		}
            		get name() {
            				if (!this._name) {
            						this._name = this.constructor.name;
            				}
            				return this._name;
            		}
            		set scaleX(value) {
            				this._options.scaleX = value;
            		}
            		get scaleX() {
            				return this._options.scaleX;
            		}
            		set scaleY(value) {
            				this._options.scaleY = value;
            		}
            		get scaleY() {
            				return this._options.scaleY;
            		}
            		set options(value) {
            				this._options = value;
            				if (value) {
            						var _this_scaleX;
            						this.scaleX = (_this_scaleX = this.scaleX) != null ? _this_scaleX : 1;
            						var _this_scaleY;
            						this.scaleY = (_this_scaleY = this.scaleY) != null ? _this_scaleY : 1;
            				}
            		}
            		get options() {
            				return this._options;
            		}
            		init(renderTarget, options) {
            				if (renderTarget === void 0) renderTarget = null;
            				this.options = options;
            				this.renderTarget = renderTarget;
            				this.samples = Math.max(this.renderTarget ? this.renderTarget.samples : this.device.samples, 1);
            				this.allocateAttachments();
            				this.postInit();
            		}
            		allocateAttachments() {
            				var _rt__colorBuffers;
            				var rt = this.renderTarget;
            				this.depthStencilOps = new DepthStencilAttachmentOps();
            				if (rt == null ? void 0 : rt.depthBuffer) {
            						this.depthStencilOps.storeDepth = true;
            				}
            				var _rt__colorBuffers_length;
            				var numColorOps = rt ? (_rt__colorBuffers_length = (_rt__colorBuffers = rt._colorBuffers) == null ? void 0 : _rt__colorBuffers.length) != null ? _rt__colorBuffers_length : 0 : 1;
            				this.colorArrayOps.length = 0;
            				for(var i = 0; i < numColorOps; i++){
            						var _this_renderTarget__colorBuffers, _this_renderTarget, _this_renderTarget1;
            						var colorOps = new ColorAttachmentOps();
            						this.colorArrayOps[i] = colorOps;
            						if (this.samples === 1) {
            								colorOps.store = true;
            								colorOps.resolve = false;
            						}
            						var colorBuffer = (_this_renderTarget = this.renderTarget) == null ? void 0 : (_this_renderTarget__colorBuffers = _this_renderTarget._colorBuffers) == null ? void 0 : _this_renderTarget__colorBuffers[i];
            						if (((_this_renderTarget1 = this.renderTarget) == null ? void 0 : _this_renderTarget1.mipmaps) && (colorBuffer == null ? void 0 : colorBuffer.mipmaps)) {
            								var intFormat = isIntegerPixelFormat(colorBuffer._format);
            								colorOps.genMipmaps = !intFormat;
            						}
            				}
            		}
            		destroy() {}
            		postInit() {}
            		frameUpdate() {
            				if (this._options && this.renderTarget) {
            						var _this__options_resizeSource;
            						var resizeSource = (_this__options_resizeSource = this._options.resizeSource) != null ? _this__options_resizeSource : this.device.backBuffer;
            						var width = Math.floor(resizeSource.width * this.scaleX);
            						var height = Math.floor(resizeSource.height * this.scaleY);
            						this.renderTarget.resize(width, height);
            				}
            		}
            		before() {}
            		execute() {}
            		after() {}
            		onEnable() {}
            		onDisable() {}
            		set enabled(value) {
            				if (this._enabled !== value) {
            						this._enabled = value;
            						if (value) {
            								this.onEnable();
            						} else {
            								this.onDisable();
            						}
            				}
            		}
            		get enabled() {
            				return this._enabled;
            		}
            		setClearColor(color) {
            				var count = this.colorArrayOps.length;
            				for(var i = 0; i < count; i++){
            						var colorOps = this.colorArrayOps[i];
            						if (color) {
            								colorOps.clearValue.copy(color);
            								colorOps.clearValueLinear.linear(color);
            						}
            						colorOps.clear = !!color;
            				}
            		}
            		setClearDepth(depthValue) {
            				if (depthValue) {
            						this.depthStencilOps.clearDepthValue = depthValue;
            				}
            				this.depthStencilOps.clearDepth = depthValue !== undefined;
            		}
            		setClearStencil(stencilValue) {
            				if (stencilValue) {
            						this.depthStencilOps.clearStencilValue = stencilValue;
            				}
            				this.depthStencilOps.clearStencil = stencilValue !== undefined;
            		}
            		render() {
            				if (this.enabled) {
            						var device = this.device;
            						var realPass = this.renderTarget !== undefined;
            						this.before();
            						if (this.executeEnabled) {
            								if (realPass && !this._skipStart) {
            										device.startRenderPass(this);
            								}
            								this.execute();
            								if (realPass && !this._skipEnd) {
            										device.endRenderPass(this);
            								}
            						}
            						this.after();
            						device.renderPassIndex++;
            				}
            		}
            		constructor(graphicsDevice){
            				this._enabled = true;
            				this._skipStart = false;
            				this._skipEnd = false;
            				this.executeEnabled = true;
            				this.samples = 0;
            				this.colorArrayOps = [];
            				this.requiresCubemaps = true;
            				this.fullSizeClearRect = true;
            				this.beforePasses = [];
            				this.afterPasses = [];
            				this.device = graphicsDevice;
            		}
            }
            
            function set1(a) {
            		this.array[this.index] = a;
            }
            function set2(a, b) {
            		this.array[this.index] = a;
            		this.array[this.index + 1] = b;
            }
            function set3(a, b, c) {
            		this.array[this.index] = a;
            		this.array[this.index + 1] = b;
            		this.array[this.index + 2] = c;
            }
            function set4(a, b, c, d) {
            		this.array[this.index] = a;
            		this.array[this.index + 1] = b;
            		this.array[this.index + 2] = c;
            		this.array[this.index + 3] = d;
            }
            function arraySet1(index, inputArray, inputIndex) {
            		this.array[index] = inputArray[inputIndex];
            }
            function arraySet2(index, inputArray, inputIndex) {
            		this.array[index] = inputArray[inputIndex];
            		this.array[index + 1] = inputArray[inputIndex + 1];
            }
            function arraySet3(index, inputArray, inputIndex) {
            		this.array[index] = inputArray[inputIndex];
            		this.array[index + 1] = inputArray[inputIndex + 1];
            		this.array[index + 2] = inputArray[inputIndex + 2];
            }
            function arraySet4(index, inputArray, inputIndex) {
            		this.array[index] = inputArray[inputIndex];
            		this.array[index + 1] = inputArray[inputIndex + 1];
            		this.array[index + 2] = inputArray[inputIndex + 2];
            		this.array[index + 3] = inputArray[inputIndex + 3];
            }
            function arrayGet1(offset, outputArray, outputIndex) {
            		outputArray[outputIndex] = this.array[offset];
            }
            function arrayGet2(offset, outputArray, outputIndex) {
            		outputArray[outputIndex] = this.array[offset];
            		outputArray[outputIndex + 1] = this.array[offset + 1];
            }
            function arrayGet3(offset, outputArray, outputIndex) {
            		outputArray[outputIndex] = this.array[offset];
            		outputArray[outputIndex + 1] = this.array[offset + 1];
            		outputArray[outputIndex + 2] = this.array[offset + 2];
            }
            function arrayGet4(offset, outputArray, outputIndex) {
            		outputArray[outputIndex] = this.array[offset];
            		outputArray[outputIndex + 1] = this.array[offset + 1];
            		outputArray[outputIndex + 2] = this.array[offset + 2];
            		outputArray[outputIndex + 3] = this.array[offset + 3];
            }
            class VertexIteratorAccessor {
            		get(offset) {
            				return this.array[this.index + offset];
            		}
            		set(a, b, c, d) {}
            		getToArray(offset, outputArray, outputIndex) {}
            		setFromArray(index, inputArray, inputIndex) {}
            		constructor(buffer, vertexElement, vertexFormat){
            				this.index = 0;
            				this.numComponents = vertexElement.numComponents;
            				if (vertexFormat.interleaved) {
            						this.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset);
            				} else {
            						this.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset, vertexFormat.vertexCount * vertexElement.numComponents);
            				}
            				this.stride = vertexElement.stride / this.array.constructor.BYTES_PER_ELEMENT;
            				switch(vertexElement.numComponents){
            						case 1:
            								this.set = set1;
            								this.getToArray = arrayGet1;
            								this.setFromArray = arraySet1;
            								break;
            						case 2:
            								this.set = set2;
            								this.getToArray = arrayGet2;
            								this.setFromArray = arraySet2;
            								break;
            						case 3:
            								this.set = set3;
            								this.getToArray = arrayGet3;
            								this.setFromArray = arraySet3;
            								break;
            						case 4:
            								this.set = set4;
            								this.getToArray = arrayGet4;
            								this.setFromArray = arraySet4;
            								break;
            				}
            		}
            }
            class VertexIterator {
            		next(count) {
            				if (count === void 0) count = 1;
            				var i = 0;
            				var accessors = this.accessors;
            				var numAccessors = this.accessors.length;
            				while(i < numAccessors){
            						var accessor = accessors[i++];
            						accessor.index += count * accessor.stride;
            				}
            		}
            		end() {
            				this.vertexBuffer.unlock();
            		}
            		writeData(semantic, data, numVertices) {
            				var element = this.element[semantic];
            				if (element) {
            						if (numVertices > this.vertexBuffer.numVertices) {
            								numVertices = this.vertexBuffer.numVertices;
            						}
            						var numComponents = element.numComponents;
            						if (this.vertexBuffer.getFormat().interleaved) {
            								var index = 0;
            								for(var i = 0; i < numVertices; i++){
            										element.setFromArray(index, data, i * numComponents);
            										index += element.stride;
            								}
            						} else {
            								if (data.length > numVertices * numComponents) {
            										var copyCount = numVertices * numComponents;
            										if (ArrayBuffer.isView(data)) {
            												data = data.subarray(0, copyCount);
            												element.array.set(data);
            										} else {
            												for(var i1 = 0; i1 < copyCount; i1++){
            														element.array[i1] = data[i1];
            												}
            										}
            								} else {
            										element.array.set(data);
            								}
            						}
            				}
            		}
            		readData(semantic, data) {
            				var element = this.element[semantic];
            				var count = 0;
            				if (element) {
            						count = this.vertexBuffer.numVertices;
            						var i;
            						var numComponents = element.numComponents;
            						if (this.vertexBuffer.getFormat().interleaved) {
            								if (Array.isArray(data)) {
            										data.length = 0;
            								}
            								element.index = 0;
            								var offset = 0;
            								for(i = 0; i < count; i++){
            										element.getToArray(offset, data, i * numComponents);
            										offset += element.stride;
            								}
            						} else {
            								if (ArrayBuffer.isView(data)) {
            										data.set(element.array);
            								} else {
            										data.length = 0;
            										var copyCount = count * numComponents;
            										for(i = 0; i < copyCount; i++){
            												data[i] = element.array[i];
            										}
            								}
            						}
            				}
            				return count;
            		}
            		constructor(vertexBuffer){
            				this.vertexBuffer = vertexBuffer;
            				this.vertexFormatSize = vertexBuffer.getFormat().size;
            				this.buffer = this.vertexBuffer.lock();
            				this.accessors = [];
            				this.element = {};
            				var vertexFormat = this.vertexBuffer.getFormat();
            				for(var i = 0; i < vertexFormat.elements.length; i++){
            						var vertexElement = vertexFormat.elements[i];
            						this.accessors[i] = new VertexIteratorAccessor(this.buffer, vertexElement, vertexFormat);
            						this.element[vertexElement.name] = this.accessors[i];
            				}
            		}
            }
            
            var MOUSEBUTTON_NONE = -1;
            
            class KeyboardEvent {
            		constructor(keyboard, event){
            				this.key = null;
            				this.element = null;
            				this.event = null;
            				if (event) {
            						this.key = event.keyCode;
            						this.element = event.target;
            						this.event = event;
            				}
            		}
            }
            
            var _keyboardEvent = new KeyboardEvent();
            function makeKeyboardEvent(event) {
            		_keyboardEvent.key = event.keyCode;
            		_keyboardEvent.element = event.target;
            		_keyboardEvent.event = event;
            		return _keyboardEvent;
            }
            function toKeyCode(s) {
            		if (typeof s === 'string') {
            				return s.toUpperCase().charCodeAt(0);
            		}
            		return s;
            }
            var _keyCodeToKeyIdentifier = {
            		'9': 'Tab',
            		'13': 'Enter',
            		'16': 'Shift',
            		'17': 'Control',
            		'18': 'Alt',
            		'27': 'Escape',
            		'37': 'Left',
            		'38': 'Up',
            		'39': 'Right',
            		'40': 'Down',
            		'46': 'Delete',
            		'91': 'Win'
            };
            class Keyboard extends EventHandler {
            		attach(element) {
            				if (this._element) {
            						this.detach();
            				}
            				this._element = element;
            				this._element.addEventListener('keydown', this._keyDownHandler, false);
            				this._element.addEventListener('keypress', this._keyPressHandler, false);
            				this._element.addEventListener('keyup', this._keyUpHandler, false);
            				document.addEventListener('visibilitychange', this._visibilityChangeHandler, false);
            				window.addEventListener('blur', this._windowBlurHandler, false);
            		}
            		detach() {
            				if (!this._element) {
            						return;
            				}
            				this._element.removeEventListener('keydown', this._keyDownHandler);
            				this._element.removeEventListener('keypress', this._keyPressHandler);
            				this._element.removeEventListener('keyup', this._keyUpHandler);
            				this._element = null;
            				document.removeEventListener('visibilitychange', this._visibilityChangeHandler, false);
            				window.removeEventListener('blur', this._windowBlurHandler, false);
            		}
            		toKeyIdentifier(keyCode) {
            				keyCode = toKeyCode(keyCode);
            				var id = _keyCodeToKeyIdentifier[keyCode.toString()];
            				if (id) {
            						return id;
            				}
            				var hex = keyCode.toString(16).toUpperCase();
            				var length = hex.length;
            				for(var count = 0; count < 4 - length; count++){
            						hex = "0" + hex;
            				}
            				return "U+" + hex;
            		}
            		_handleKeyDown(event) {
            				var code = event.keyCode || event.charCode;
            				if (code === undefined) return;
            				var id = this.toKeyIdentifier(code);
            				this._keymap[id] = true;
            				this.fire('keydown', makeKeyboardEvent(event));
            				if (this.preventDefault) {
            						event.preventDefault();
            				}
            				if (this.stopPropagation) {
            						event.stopPropagation();
            				}
            		}
            		_handleKeyUp(event) {
            				var code = event.keyCode || event.charCode;
            				if (code === undefined) return;
            				var id = this.toKeyIdentifier(code);
            				delete this._keymap[id];
            				this.fire('keyup', makeKeyboardEvent(event));
            				if (this.preventDefault) {
            						event.preventDefault();
            				}
            				if (this.stopPropagation) {
            						event.stopPropagation();
            				}
            		}
            		_handleKeyPress(event) {
            				this.fire('keypress', makeKeyboardEvent(event));
            				if (this.preventDefault) {
            						event.preventDefault();
            				}
            				if (this.stopPropagation) {
            						event.stopPropagation();
            				}
            		}
            		_handleVisibilityChange() {
            				if (document.visibilityState === 'hidden') {
            						this._handleWindowBlur();
            				}
            		}
            		_handleWindowBlur() {
            				this._keymap = {};
            				this._lastmap = {};
            		}
            		update() {
            				for(var prop in this._lastmap){
            						delete this._lastmap[prop];
            				}
            				for(var prop1 in this._keymap){
            						if (this._keymap.hasOwnProperty(prop1)) {
            								this._lastmap[prop1] = this._keymap[prop1];
            						}
            				}
            		}
            		isPressed(key) {
            				var keyCode = toKeyCode(key);
            				var id = this.toKeyIdentifier(keyCode);
            				return !!this._keymap[id];
            		}
            		wasPressed(key) {
            				var keyCode = toKeyCode(key);
            				var id = this.toKeyIdentifier(keyCode);
            				return !!this._keymap[id] && !!!this._lastmap[id];
            		}
            		wasReleased(key) {
            				var keyCode = toKeyCode(key);
            				var id = this.toKeyIdentifier(keyCode);
            				return !!!this._keymap[id] && !!this._lastmap[id];
            		}
            		constructor(element, options = {}){
            				super(), this._element = null, this._keymap = {}, this._lastmap = {};
            				this._keyDownHandler = this._handleKeyDown.bind(this);
            				this._keyUpHandler = this._handleKeyUp.bind(this);
            				this._keyPressHandler = this._handleKeyPress.bind(this);
            				this._visibilityChangeHandler = this._handleVisibilityChange.bind(this);
            				this._windowBlurHandler = this._handleWindowBlur.bind(this);
            				if (element) {
            						this.attach(element);
            				}
            				this.preventDefault = options.preventDefault || false;
            				this.stopPropagation = options.stopPropagation || false;
            		}
            }
            Keyboard.EVENT_KEYDOWN = 'keydown';
            Keyboard.EVENT_KEYUP = 'keyup';
            
            function isMousePointerLocked() {
            		return !!(document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement);
            }
            class MouseEvent {
            		constructor(mouse, event){
            				this.x = 0;
            				this.y = 0;
            				this.dx = 0;
            				this.dy = 0;
            				this.button = MOUSEBUTTON_NONE;
            				this.wheelDelta = 0;
            				this.ctrlKey = false;
            				this.altKey = false;
            				this.shiftKey = false;
            				this.metaKey = false;
            				var coords = {
            						x: 0,
            						y: 0
            				};
            				if (event) {
            						if (event instanceof MouseEvent) {
            								throw Error('Expected MouseEvent');
            						}
            						coords = mouse._getTargetCoords(event);
            				} else {
            						event = {};
            				}
            				if (coords) {
            						this.x = coords.x;
            						this.y = coords.y;
            				} else if (isMousePointerLocked()) {
            						this.x = 0;
            						this.y = 0;
            				} else {
            						return;
            				}
            				if (event.type === 'wheel') {
            						if (event.deltaY > 0) {
            								this.wheelDelta = 1;
            						} else if (event.deltaY < 0) {
            								this.wheelDelta = -1;
            						}
            				}
            				if (isMousePointerLocked()) {
            						this.dx = event.movementX || event.webkitMovementX || event.mozMovementX || 0;
            						this.dy = event.movementY || event.webkitMovementY || event.mozMovementY || 0;
            				} else {
            						this.dx = this.x - mouse._lastX;
            						this.dy = this.y - mouse._lastY;
            				}
            				if (event.type === 'mousedown' || event.type === 'mouseup') {
            						this.button = event.button;
            				}
            				this.buttons = mouse._buttons.slice(0);
            				this.element = event.target;
            				var _event_ctrlKey;
            				this.ctrlKey = (_event_ctrlKey = event.ctrlKey) != null ? _event_ctrlKey : false;
            				var _event_altKey;
            				this.altKey = (_event_altKey = event.altKey) != null ? _event_altKey : false;
            				var _event_shiftKey;
            				this.shiftKey = (_event_shiftKey = event.shiftKey) != null ? _event_shiftKey : false;
            				var _event_metaKey;
            				this.metaKey = (_event_metaKey = event.metaKey) != null ? _event_metaKey : false;
            				this.event = event;
            		}
            }
            
            class Mouse extends EventHandler {
            		static isPointerLocked() {
            				return isMousePointerLocked();
            		}
            		attach(element) {
            				this._target = element;
            				if (this._attached) return;
            				this._attached = true;
            				var passiveOptions = {
            						passive: false
            				};
            				var options = platform.passiveEvents ? passiveOptions : false;
            				window.addEventListener('mouseup', this._upHandler, options);
            				window.addEventListener('mousedown', this._downHandler, options);
            				window.addEventListener('mousemove', this._moveHandler, options);
            				window.addEventListener('wheel', this._wheelHandler, options);
            		}
            		detach() {
            				if (!this._attached) return;
            				this._attached = false;
            				this._target = null;
            				var passiveOptions = {
            						passive: false
            				};
            				var options = platform.passiveEvents ? passiveOptions : false;
            				window.removeEventListener('mouseup', this._upHandler, options);
            				window.removeEventListener('mousedown', this._downHandler, options);
            				window.removeEventListener('mousemove', this._moveHandler, options);
            				window.removeEventListener('wheel', this._wheelHandler, options);
            		}
            		disableContextMenu() {
            				if (!this._target) return;
            				this._target.addEventListener('contextmenu', this._contextMenuHandler);
            		}
            		enableContextMenu() {
            				if (!this._target) return;
            				this._target.removeEventListener('contextmenu', this._contextMenuHandler);
            		}
            		enablePointerLock(success, error) {
            				if (!document.body.requestPointerLock) {
            						if (error) {
            								error();
            						}
            						return;
            				}
            				var s = ()=>{
            						success();
            						document.removeEventListener('pointerlockchange', s);
            				};
            				var e = ()=>{
            						error();
            						document.removeEventListener('pointerlockerror', e);
            				};
            				if (success) {
            						document.addEventListener('pointerlockchange', s, false);
            				}
            				if (error) {
            						document.addEventListener('pointerlockerror', e, false);
            				}
            				document.body.requestPointerLock();
            		}
            		disablePointerLock(success) {
            				if (!document.exitPointerLock) {
            						return;
            				}
            				var s = ()=>{
            						success();
            						document.removeEventListener('pointerlockchange', s);
            				};
            				if (success) {
            						document.addEventListener('pointerlockchange', s, false);
            				}
            				document.exitPointerLock();
            		}
            		update() {
            				this._lastbuttons[0] = this._buttons[0];
            				this._lastbuttons[1] = this._buttons[1];
            				this._lastbuttons[2] = this._buttons[2];
            		}
            		isPressed(button) {
            				return this._buttons[button];
            		}
            		wasPressed(button) {
            				return this._buttons[button] && !this._lastbuttons[button];
            		}
            		wasReleased(button) {
            				return !this._buttons[button] && this._lastbuttons[button];
            		}
            		_handleUp(event) {
            				this._buttons[event.button] = false;
            				var e = new MouseEvent(this, event);
            				if (!e.event) return;
            				this.fire('mouseup', e);
            		}
            		_handleDown(event) {
            				this._buttons[event.button] = true;
            				var e = new MouseEvent(this, event);
            				if (!e.event) return;
            				this.fire('mousedown', e);
            		}
            		_handleMove(event) {
            				var e = new MouseEvent(this, event);
            				if (!e.event) return;
            				this.fire('mousemove', e);
            				this._lastX = e.x;
            				this._lastY = e.y;
            		}
            		_handleWheel(event) {
            				var e = new MouseEvent(this, event);
            				if (!e.event) return;
            				this.fire('mousewheel', e);
            		}
            		_getTargetCoords(event) {
            				var rect = this._target.getBoundingClientRect();
            				var left = Math.floor(rect.left);
            				var top = Math.floor(rect.top);
            				if (event.clientX < left || event.clientX >= left + this._target.clientWidth || event.clientY < top || event.clientY >= top + this._target.clientHeight) {
            						return null;
            				}
            				return {
            						x: event.clientX - left,
            						y: event.clientY - top
            				};
            		}
            		constructor(element){
            				super(), this._lastX = 0, this._lastY = 0, this._buttons = [
            						false,
            						false,
            						false
            				], this._lastbuttons = [
            						false,
            						false,
            						false
            				], this._target = null, this._attached = false;
            				this._upHandler = this._handleUp.bind(this);
            				this._downHandler = this._handleDown.bind(this);
            				this._moveHandler = this._handleMove.bind(this);
            				this._wheelHandler = this._handleWheel.bind(this);
            				this._contextMenuHandler = (event)=>{
            						event.preventDefault();
            				};
            				this.attach(element);
            		}
            }
            Mouse.EVENT_MOUSEMOVE = 'mousemove';
            Mouse.EVENT_MOUSEDOWN = 'mousedown';
            Mouse.EVENT_MOUSEUP = 'mouseup';
            Mouse.EVENT_MOUSEWHEEL = 'mousewheel';
            
            class Http {
            		get(url, options, callback) {
            				if (typeof options === 'function') {
            						callback = options;
            						options = {};
            				}
            				return this.request('GET', url, options, callback);
            		}
            		post(url, data, options, callback) {
            				if (typeof options === 'function') {
            						callback = options;
            						options = {};
            				}
            				options.postdata = data;
            				return this.request('POST', url, options, callback);
            		}
            		put(url, data, options, callback) {
            				if (typeof options === 'function') {
            						callback = options;
            						options = {};
            				}
            				options.postdata = data;
            				return this.request('PUT', url, options, callback);
            		}
            		del(url, options, callback) {
            				if (typeof options === 'function') {
            						callback = options;
            						options = {};
            				}
            				return this.request('DELETE', url, options, callback);
            		}
            		request(method, url, options, callback) {
            				var uri, query, postdata;
            				var errored = false;
            				if (typeof options === 'function') {
            						callback = options;
            						options = {};
            				}
            				if (options.retry) {
            						options = Object.assign({
            								retries: 0,
            								maxRetries: 5
            						}, options);
            				}
            				options.callback = callback;
            				if (options.async == null) {
            						options.async = true;
            				}
            				if (options.headers == null) {
            						options.headers = {};
            				}
            				if (options.postdata != null) {
            						if (options.postdata instanceof Document) {
            								postdata = options.postdata;
            						} else if (options.postdata instanceof FormData) {
            								postdata = options.postdata;
            						} else if (options.postdata instanceof Object) {
            								var contentType = options.headers['Content-Type'];
            								if (contentType === undefined) {
            										options.headers['Content-Type'] = Http.ContentType.FORM_URLENCODED;
            										contentType = options.headers['Content-Type'];
            								}
            								switch(contentType){
            										case Http.ContentType.FORM_URLENCODED:
            												{
            														postdata = '';
            														var bFirstItem = true;
            														for(var key in options.postdata){
            																if (options.postdata.hasOwnProperty(key)) {
            																		if (bFirstItem) {
            																				bFirstItem = false;
            																		} else {
            																				postdata += '&';
            																		}
            																		var encodedKey = encodeURIComponent(key);
            																		var encodedValue = encodeURIComponent(options.postdata[key]);
            																		postdata += encodedKey + "=" + encodedValue;
            																}
            														}
            														break;
            												}
            										default:
            										case Http.ContentType.JSON:
            												if (contentType == null) {
            														options.headers['Content-Type'] = Http.ContentType.JSON;
            												}
            												postdata = JSON.stringify(options.postdata);
            												break;
            								}
            						} else {
            								postdata = options.postdata;
            						}
            				}
            				if (options.cache === false) {
            						var timestamp = now();
            						uri = new URI(url);
            						if (!uri.query) {
            								uri.query = "ts=" + timestamp;
            						} else {
            								uri.query = uri.query + "&ts=" + timestamp;
            						}
            						url = uri.toString();
            				}
            				if (options.query) {
            						uri = new URI(url);
            						query = extend(uri.getQuery(), options.query);
            						uri.setQuery(query);
            						url = uri.toString();
            				}
            				var xhr = new XMLHttpRequest();
            				xhr.open(method, url, options.async);
            				xhr.withCredentials = options.withCredentials !== undefined ? options.withCredentials : false;
            				xhr.responseType = options.responseType || this._guessResponseType(url);
            				for(var header in options.headers){
            						if (options.headers.hasOwnProperty(header)) {
            								xhr.setRequestHeader(header, options.headers[header]);
            						}
            				}
            				xhr.onreadystatechange = ()=>{
            						this._onReadyStateChange(method, url, options, xhr);
            				};
            				xhr.onerror = ()=>{
            						this._onError(method, url, options, xhr);
            						errored = true;
            				};
            				try {
            						xhr.send(postdata);
            				} catch (e) {
            						if (!errored) {
            								options.error(xhr.status, xhr, e);
            						}
            				}
            				return xhr;
            		}
            		_guessResponseType(url) {
            				var uri = new URI(url);
            				var ext = path.getExtension(uri.path).toLowerCase();
            				if (Http.binaryExtensions.indexOf(ext) >= 0) {
            						return Http.ResponseType.ARRAY_BUFFER;
            				} else if (ext === '.json') {
            						return Http.ResponseType.JSON;
            				} else if (ext === '.xml') {
            						return Http.ResponseType.DOCUMENT;
            				}
            				return Http.ResponseType.TEXT;
            		}
            		_isBinaryContentType(contentType) {
            				var binTypes = [
            						Http.ContentType.BASIS,
            						Http.ContentType.BIN,
            						Http.ContentType.DDS,
            						Http.ContentType.GLB,
            						Http.ContentType.MP3,
            						Http.ContentType.MP4,
            						Http.ContentType.OGG,
            						Http.ContentType.OPUS,
            						Http.ContentType.WAV
            				];
            				if (binTypes.indexOf(contentType) >= 0) {
            						return true;
            				}
            				return false;
            		}
            		_isBinaryResponseType(responseType) {
            				return responseType === Http.ResponseType.ARRAY_BUFFER || responseType === Http.ResponseType.BLOB || responseType === Http.ResponseType.JSON;
            		}
            		_onReadyStateChange(method, url, options, xhr) {
            				if (xhr.readyState === 4) {
            						switch(xhr.status){
            								case 0:
            										{
            												if (xhr.responseURL && xhr.responseURL.startsWith('file:///')) {
            														this._onSuccess(method, url, options, xhr);
            												} else {
            														this._onError(method, url, options, xhr);
            												}
            												break;
            										}
            								case 200:
            								case 201:
            								case 206:
            								case 304:
            										{
            												this._onSuccess(method, url, options, xhr);
            												break;
            										}
            								default:
            										{
            												this._onError(method, url, options, xhr);
            												break;
            										}
            						}
            				}
            		}
            		_onSuccess(method, url, options, xhr) {
            				var response;
            				var contentType;
            				var header = xhr.getResponseHeader('Content-Type');
            				if (header) {
            						var parts = header.split(';');
            						contentType = parts[0].trim();
            				}
            				try {
            						if (this._isBinaryContentType(contentType) || this._isBinaryResponseType(xhr.responseType)) {
            								response = xhr.response;
            						} else if (contentType === Http.ContentType.JSON || url.split('?')[0].endsWith('.json')) {
            								response = JSON.parse(xhr.responseText);
            						} else if (xhr.responseType === Http.ResponseType.DOCUMENT || contentType === Http.ContentType.XML) {
            								response = xhr.responseXML;
            						} else {
            								response = xhr.responseText;
            						}
            						options.callback(null, response);
            				} catch (err) {
            						options.callback(err);
            				}
            		}
            		_onError(method, url, options, xhr) {
            				if (options.retrying) {
            						return;
            				}
            				if (options.retry && options.retries < options.maxRetries) {
            						options.retries++;
            						options.retrying = true;
            						var retryDelay = math.clamp(Math.pow(2, options.retries) * Http.retryDelay, 0, options.maxRetryDelay || 5000);
            						console.log(method + ": " + url + " - Error " + xhr.status + ". Retrying in " + retryDelay + " ms");
            						setTimeout(()=>{
            								options.retrying = false;
            								this.request(method, url, options, options.callback);
            						}, retryDelay);
            				} else {
            						options.callback(xhr.status === 0 ? 'Network error' : xhr.status, null);
            				}
            		}
            }
            Http.ContentType = {
            		AAC: 'audio/aac',
            		BASIS: 'image/basis',
            		BIN: 'application/octet-stream',
            		DDS: 'image/dds',
            		FORM_URLENCODED: 'application/x-www-form-urlencoded',
            		GIF: 'image/gif',
            		GLB: 'model/gltf-binary',
            		JPEG: 'image/jpeg',
            		JSON: 'application/json',
            		MP3: 'audio/mpeg',
            		MP4: 'audio/mp4',
            		OGG: 'audio/ogg',
            		OPUS: 'audio/ogg; codecs="opus"',
            		PNG: 'image/png',
            		TEXT: 'text/plain',
            		WAV: 'audio/x-wav',
            		XML: 'application/xml'
            };
            Http.ResponseType = {
            		TEXT: 'text',
            		ARRAY_BUFFER: 'arraybuffer',
            		BLOB: 'blob',
            		DOCUMENT: 'document',
            		JSON: 'json'
            };
            Http.binaryExtensions = [
            		'.model',
            		'.wav',
            		'.ogg',
            		'.mp3',
            		'.mp4',
            		'.m4a',
            		'.aac',
            		'.dds',
            		'.basis',
            		'.glb',
            		'.opus'
            ];
            Http.retryDelay = 100;
            var http = new Http();
            
            function hasAudioContext() {
            		return !!(typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined');
            }
            
            class Channel {
            		getVolume() {
            				return this.volume;
            		}
            		getLoop() {
            				return this.loop;
            		}
            		setLoop(loop) {
            				this.loop = loop;
            				if (this.source) {
            						this.source.loop = loop;
            				}
            		}
            		getPitch() {
            				return this.pitch;
            		}
            		onManagerVolumeChange() {
            				this.setVolume(this.getVolume());
            		}
            		onManagerSuspend() {
            				if (this.isPlaying() && !this.suspended) {
            						this.suspended = true;
            						this.pause();
            				}
            		}
            		onManagerResume() {
            				if (this.suspended) {
            						this.suspended = false;
            						this.unpause();
            				}
            		}
            		play() {
            				if (this.source) {
            						throw new Error('Call stop() before calling play()');
            				}
            				this._createSource();
            				if (!this.source) {
            						return;
            				}
            				this.startTime = this.manager.context.currentTime;
            				this.source.start(0, this.startOffset % this.source.buffer.duration);
            				this.setVolume(this.volume);
            				this.setLoop(this.loop);
            				this.setPitch(this.pitch);
            				this.manager.on('volumechange', this.onManagerVolumeChange, this);
            				this.manager.on('suspend', this.onManagerSuspend, this);
            				this.manager.on('resume', this.onManagerResume, this);
            				if (this.manager.suspended) {
            						this.onManagerSuspend();
            				}
            		}
            		pause() {
            				if (this.source) {
            						this.paused = true;
            						this.startOffset += this.manager.context.currentTime - this.startTime;
            						this.source.stop(0);
            						this.source = null;
            				}
            		}
            		unpause() {
            				if (this.source || !this.paused) {
            						console.warn('Call pause() before unpausing.');
            						return;
            				}
            				this._createSource();
            				if (!this.source) {
            						return;
            				}
            				this.startTime = this.manager.context.currentTime;
            				this.source.start(0, this.startOffset % this.source.buffer.duration);
            				this.setVolume(this.volume);
            				this.setLoop(this.loop);
            				this.setPitch(this.pitch);
            				this.paused = false;
            		}
            		stop() {
            				if (this.source) {
            						this.source.stop(0);
            						this.source = null;
            				}
            				this.manager.off('volumechange', this.onManagerVolumeChange, this);
            				this.manager.off('suspend', this.onManagerSuspend, this);
            				this.manager.off('resume', this.onManagerResume, this);
            		}
            		setVolume(volume) {
            				volume = math.clamp(volume, 0, 1);
            				this.volume = volume;
            				if (this.gain) {
            						this.gain.gain.value = volume * this.manager.volume;
            				}
            		}
            		setPitch(pitch) {
            				this.pitch = pitch;
            				if (this.source) {
            						this.source.playbackRate.value = pitch;
            				}
            		}
            		isPlaying() {
            				return !this.paused && this.source.playbackState === this.source.PLAYING_STATE;
            		}
            		getDuration() {
            				return this.source ? this.source.buffer.duration : 0;
            		}
            		_createSource() {
            				var context = this.manager.context;
            				if (this.sound.buffer) {
            						this.source = context.createBufferSource();
            						this.source.buffer = this.sound.buffer;
            						this.source.connect(this.gain);
            						this.gain.connect(context.destination);
            						if (!this.loop) {
            								this.source.onended = this.pause.bind(this);
            						}
            				}
            		}
            		constructor(manager, sound, options = {}){
            				var _options_volume;
            				this.volume = (_options_volume = options.volume) != null ? _options_volume : 1;
            				var _options_loop;
            				this.loop = (_options_loop = options.loop) != null ? _options_loop : false;
            				var _options_pitch;
            				this.pitch = (_options_pitch = options.pitch) != null ? _options_pitch : 1;
            				this.sound = sound;
            				this.paused = false;
            				this.suspended = false;
            				this.manager = manager;
            				this.source = null;
            				if (hasAudioContext()) {
            						this.startTime = 0;
            						this.startOffset = 0;
            						var context = manager.context;
            						this.gain = context.createGain();
            				} else if (sound.audio) {
            						this.source = sound.audio.cloneNode(false);
            						this.source.pause();
            				}
            		}
            }
            if (!hasAudioContext()) {
            		Object.assign(Channel.prototype, {
            				play: function play() {
            						if (this.source) {
            								this.paused = false;
            								this.setVolume(this.volume);
            								this.setLoop(this.loop);
            								this.setPitch(this.pitch);
            								this.source.play();
            						}
            						this.manager.on('volumechange', this.onManagerVolumeChange, this);
            						this.manager.on('suspend', this.onManagerSuspend, this);
            						this.manager.on('resume', this.onManagerResume, this);
            						if (this.manager.suspended) {
            								this.onManagerSuspend();
            						}
            				},
            				pause: function pause() {
            						if (this.source) {
            								this.paused = true;
            								this.source.pause();
            						}
            				},
            				unpause: function unpause() {
            						if (this.source) {
            								this.paused = false;
            								this.source.play();
            						}
            				},
            				stop: function stop() {
            						if (this.source) {
            								this.source.pause();
            						}
            						this.manager.off('volumechange', this.onManagerVolumeChange, this);
            						this.manager.off('suspend', this.onManagerSuspend, this);
            						this.manager.off('resume', this.onManagerResume, this);
            				},
            				setVolume: function setVolume(volume) {
            						volume = math.clamp(volume, 0, 1);
            						this.volume = volume;
            						if (this.source) {
            								this.source.volume = volume * this.manager.volume;
            						}
            				},
            				setPitch: function setPitch(pitch) {
            						this.pitch = pitch;
            						if (this.source) {
            								this.source.playbackRate = pitch;
            						}
            				},
            				getDuration: function getDuration() {
            						return this.source && !isNaN(this.source.duration) ? this.source.duration : 0;
            				},
            				isPlaying: function isPlaying() {
            						return !this.source.paused;
            				}
            		});
            }
            
            var MAX_DISTANCE$1 = 10000;
            class Channel3d extends Channel {
            		getPosition() {
            				return this.position;
            		}
            		setPosition(position) {
            				this.position.copy(position);
            				var panner = this.panner;
            				if ('positionX' in panner) {
            						panner.positionX.value = position.x;
            						panner.positionY.value = position.y;
            						panner.positionZ.value = position.z;
            				} else if (panner.setPosition) {
            						panner.setPosition(position.x, position.y, position.z);
            				}
            		}
            		getVelocity() {
            				return this.velocity;
            		}
            		setVelocity(velocity) {
            				this.velocity.copy(velocity);
            		}
            		getMaxDistance() {
            				return this.panner.maxDistance;
            		}
            		setMaxDistance(max) {
            				this.panner.maxDistance = max;
            		}
            		getMinDistance() {
            				return this.panner.refDistance;
            		}
            		setMinDistance(min) {
            				this.panner.refDistance = min;
            		}
            		getRollOffFactor() {
            				return this.panner.rolloffFactor;
            		}
            		setRollOffFactor(factor) {
            				this.panner.rolloffFactor = factor;
            		}
            		getDistanceModel() {
            				return this.panner.distanceModel;
            		}
            		setDistanceModel(distanceModel) {
            				this.panner.distanceModel = distanceModel;
            		}
            		_createSource() {
            				var context = this.manager.context;
            				this.source = context.createBufferSource();
            				this.source.buffer = this.sound.buffer;
            				this.source.connect(this.panner);
            				this.panner.connect(this.gain);
            				this.gain.connect(context.destination);
            				if (!this.loop) {
            						this.source.onended = this.pause.bind(this);
            				}
            		}
            		constructor(manager, sound, options){
            				super(manager, sound, options);
            				this.position = new Vec3();
            				this.velocity = new Vec3();
            				if (hasAudioContext()) {
            						this.panner = manager.context.createPanner();
            				} else {
            						this.maxDistance = MAX_DISTANCE$1;
            						this.minDistance = 1;
            						this.rollOffFactor = 1;
            						this.distanceModel = DISTANCE_INVERSE;
            				}
            		}
            }
            if (!hasAudioContext()) {
            		var offset$1 = new Vec3();
            		var fallOff$1 = function fallOff(posOne, posTwo, refDistance, maxDistance, rolloffFactor, distanceModel) {
            				offset$1 = offset$1.sub2(posOne, posTwo);
            				var distance = offset$1.length();
            				if (distance < refDistance) {
            						return 1;
            				} else if (distance > maxDistance) {
            						return 0;
            				}
            				var result = 0;
            				if (distanceModel === DISTANCE_LINEAR) {
            						result = 1 - rolloffFactor * (distance - refDistance) / (maxDistance - refDistance);
            				} else if (distanceModel === DISTANCE_INVERSE) {
            						result = refDistance / (refDistance + rolloffFactor * (distance - refDistance));
            				} else if (distanceModel === DISTANCE_EXPONENTIAL) {
            						result = Math.pow(distance / refDistance, -rolloffFactor);
            				}
            				return math.clamp(result, 0, 1);
            		};
            		Object.assign(Channel3d.prototype, {
            				setPosition: function setPosition(position) {
            						this.position.copy(position);
            						if (this.source) {
            								var listener = this.manager.listener;
            								var lpos = listener.getPosition();
            								var factor = fallOff$1(lpos, this.position, this.minDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);
            								var v = this.getVolume();
            								this.source.volume = v * factor;
            						}
            				},
            				getMaxDistance: function getMaxDistance() {
            						return this.maxDistance;
            				},
            				setMaxDistance: function setMaxDistance(max) {
            						this.maxDistance = max;
            				},
            				getMinDistance: function getMinDistance() {
            						return this.minDistance;
            				},
            				setMinDistance: function setMinDistance(min) {
            						this.minDistance = min;
            				},
            				getRollOffFactor: function getRollOffFactor() {
            						return this.rollOffFactor;
            				},
            				setRollOffFactor: function setRollOffFactor(factor) {
            						this.rollOffFactor = factor;
            				},
            				getDistanceModel: function getDistanceModel() {
            						return this.distanceModel;
            				},
            				setDistanceModel: function setDistanceModel(distanceModel) {
            						this.distanceModel = distanceModel;
            				}
            		});
            }
            
            class Listener {
            		getPosition() {
            				return this.position;
            		}
            		setPosition(position) {
            				this.position.copy(position);
            				var listener = this.listener;
            				if (listener) {
            						if ('positionX' in listener) {
            								listener.positionX.value = position.x;
            								listener.positionY.value = position.y;
            								listener.positionZ.value = position.z;
            						} else if (listener.setPosition) {
            								listener.setPosition(position.x, position.y, position.z);
            						}
            				}
            		}
            		setOrientation(orientation) {
            				this.orientation.copy(orientation);
            				var listener = this.listener;
            				if (listener) {
            						var m = orientation.data;
            						if ('forwardX' in listener) {
            								listener.forwardX.value = -m[8];
            								listener.forwardY.value = -m[9];
            								listener.forwardZ.value = -m[10];
            								listener.upX.value = m[4];
            								listener.upY.value = m[5];
            								listener.upZ.value = m[6];
            						} else if (listener.setOrientation) {
            								listener.setOrientation(-m[8], -m[9], -m[10], m[4], m[5], m[6]);
            						}
            				}
            		}
            		getOrientation() {
            				return this.orientation;
            		}
            		get listener() {
            				var context = this._manager.context;
            				return context ? context.listener : null;
            		}
            		constructor(manager){
            				this.position = new Vec3();
            				this.orientation = new Mat4();
            				this._manager = manager;
            		}
            }
            
            var CONTEXT_STATE_RUNNING = 'running';
            var USER_INPUT_EVENTS = [
            		'click',
            		'touchstart',
            		'mousedown'
            ];
            class SoundManager extends EventHandler {
            		set volume(volume) {
            				volume = math.clamp(volume, 0, 1);
            				this._volume = volume;
            				this.fire('volumechange', volume);
            		}
            		get volume() {
            				return this._volume;
            		}
            		get suspended() {
            				return this._userSuspended;
            		}
            		get context() {
            				if (!this._context && this.AudioContext) {
            						this._context = new this.AudioContext();
            						if (this._context.state !== CONTEXT_STATE_RUNNING) {
            								this._registerUnlockListeners();
            						}
            				}
            				return this._context;
            		}
            		suspend() {
            				if (!this._userSuspended) {
            						this._userSuspended = true;
            						if (this._context && this._context.state === CONTEXT_STATE_RUNNING) {
            								this._suspend();
            						}
            				}
            		}
            		resume() {
            				if (this._userSuspended) {
            						this._userSuspended = false;
            						if (this._context && this._context.state !== CONTEXT_STATE_RUNNING) {
            								this._resume();
            						}
            				}
            		}
            		destroy() {
            				this.fire('destroy');
            				if (this._context) {
            						var _this__context;
            						this._removeUnlockListeners();
            						(_this__context = this._context) == null ? void 0 : _this__context.close();
            						this._context = null;
            				}
            		}
            		playSound(sound, options) {
            				if (options === void 0) options = {};
            				var channel = null;
            				if (Channel) {
            						channel = new Channel(this, sound, options);
            						channel.play();
            				}
            				return channel;
            		}
            		playSound3d(sound, position, options) {
            				if (options === void 0) options = {};
            				var channel = null;
            				if (Channel3d) {
            						channel = new Channel3d(this, sound, options);
            						channel.setPosition(position);
            						if (options.volume) {
            								channel.setVolume(options.volume);
            						}
            						if (options.loop) {
            								channel.setLoop(options.loop);
            						}
            						if (options.maxDistance) {
            								channel.setMaxDistance(options.maxDistance);
            						}
            						if (options.minDistance) {
            								channel.setMinDistance(options.minDistance);
            						}
            						if (options.rollOffFactor) {
            								channel.setRollOffFactor(options.rollOffFactor);
            						}
            						if (options.distanceModel) {
            								channel.setDistanceModel(options.distanceModel);
            						}
            						channel.play();
            				}
            				return channel;
            		}
            		_resume() {
            				this._context.resume().then(()=>{
            						var source = this._context.createBufferSource();
            						source.buffer = this._context.createBuffer(1, 1, this._context.sampleRate);
            						source.connect(this._context.destination);
            						source.start(0);
            						source.onended = (event)=>{
            								source.disconnect(0);
            								this.fire('resume');
            						};
            				}, (e)=>{}).catch((e)=>{});
            		}
            		_suspend() {
            				this._context.suspend().then(()=>{
            						this.fire('suspend');
            				}, (e)=>{}).catch((e)=>{});
            		}
            		_unlockHandler() {
            				this._removeUnlockListeners();
            				if (!this._userSuspended && this._context.state !== CONTEXT_STATE_RUNNING) {
            						this._resume();
            				}
            		}
            		_registerUnlockListeners() {
            				USER_INPUT_EVENTS.forEach((eventName)=>{
            						window.addEventListener(eventName, this._unlockHandlerFunc, false);
            				});
            		}
            		_removeUnlockListeners() {
            				USER_INPUT_EVENTS.forEach((eventName)=>{
            						window.removeEventListener(eventName, this._unlockHandlerFunc, false);
            				});
            		}
            		constructor(){
            				super();
            				this._context = null;
            				this.AudioContext = typeof AudioContext !== 'undefined' && AudioContext || typeof webkitAudioContext !== 'undefined' && webkitAudioContext;
            				if (!this.AudioContext) ;
            				this._unlockHandlerFunc = this._unlockHandler.bind(this);
            				this._userSuspended = false;
            				this.listener = new Listener(this);
            				this._volume = 1;
            		}
            }
            
            class Sound {
            		get duration() {
            				var duration = 0;
            				if (this.buffer) {
            						duration = this.buffer.duration;
            				} else if (this.audio) {
            						duration = this.audio.duration;
            				}
            				return duration || 0;
            		}
            		constructor(resource){
            				if (resource instanceof Audio) {
            						this.audio = resource;
            				} else {
            						this.buffer = resource;
            				}
            		}
            }
            
            var STATE_PLAYING = 0;
            var STATE_PAUSED = 1;
            var STATE_STOPPED = 2;
            function capTime(time, duration) {
            		return time % duration || 0;
            }
            class SoundInstance extends EventHandler {
            		set currentTime(value) {
            				if (value < 0) return;
            				if (this._state === STATE_PLAYING) {
            						var suspend = this._suspendInstanceEvents;
            						this._suspendInstanceEvents = true;
            						this.stop();
            						this._startOffset = value;
            						this.play();
            						this._suspendInstanceEvents = suspend;
            				} else {
            						this._startOffset = value;
            						this._currentTime = value;
            				}
            		}
            		get currentTime() {
            				if (this._startOffset !== null) {
            						return this._startOffset;
            				}
            				if (this._state === STATE_PAUSED) {
            						return this._currentTime;
            				}
            				if (this._state === STATE_STOPPED || !this.source) {
            						return 0;
            				}
            				this._updateCurrentTime();
            				return this._currentTime;
            		}
            		set duration(value) {
            				this._duration = Math.max(0, Number(value) || 0);
            				var isPlaying = this._state === STATE_PLAYING;
            				this.stop();
            				if (isPlaying) {
            						this.play();
            				}
            		}
            		get duration() {
            				if (!this._sound) {
            						return 0;
            				}
            				if (this._duration) {
            						return capTime(this._duration, this._sound.duration);
            				}
            				return this._sound.duration;
            		}
            		get isPaused() {
            				return this._state === STATE_PAUSED;
            		}
            		get isPlaying() {
            				return this._state === STATE_PLAYING;
            		}
            		get isStopped() {
            				return this._state === STATE_STOPPED;
            		}
            		get isSuspended() {
            				return this._suspended;
            		}
            		set loop(value) {
            				this._loop = !!value;
            				if (this.source) {
            						this.source.loop = this._loop;
            				}
            		}
            		get loop() {
            				return this._loop;
            		}
            		set pitch(pitch) {
            				this._currentOffset = this.currentTime;
            				this._startedAt = this._manager.context.currentTime;
            				this._pitch = Math.max(Number(pitch) || 0, 0.01);
            				if (this.source) {
            						this.source.playbackRate.value = this._pitch;
            				}
            		}
            		get pitch() {
            				return this._pitch;
            		}
            		set sound(value) {
            				this._sound = value;
            				if (this._state !== STATE_STOPPED) {
            						this.stop();
            				} else {
            						this._createSource();
            				}
            		}
            		get sound() {
            				return this._sound;
            		}
            		set startTime(value) {
            				this._startTime = Math.max(0, Number(value) || 0);
            				var isPlaying = this._state === STATE_PLAYING;
            				this.stop();
            				if (isPlaying) {
            						this.play();
            				}
            		}
            		get startTime() {
            				return this._startTime;
            		}
            		set volume(volume) {
            				volume = math.clamp(volume, 0, 1);
            				this._volume = volume;
            				if (this.gain) {
            						this.gain.gain.value = volume * this._manager.volume;
            				}
            		}
            		get volume() {
            				return this._volume;
            		}
            		_onPlay() {
            				this.fire('play');
            				if (this._onPlayCallback) {
            						this._onPlayCallback(this);
            				}
            		}
            		_onPause() {
            				this.fire('pause');
            				if (this._onPauseCallback) {
            						this._onPauseCallback(this);
            				}
            		}
            		_onResume() {
            				this.fire('resume');
            				if (this._onResumeCallback) {
            						this._onResumeCallback(this);
            				}
            		}
            		_onStop() {
            				this.fire('stop');
            				if (this._onStopCallback) {
            						this._onStopCallback(this);
            				}
            		}
            		_onEnded() {
            				if (this._suspendEndEvent > 0) {
            						this._suspendEndEvent--;
            						return;
            				}
            				this.fire('end');
            				if (this._onEndCallback) {
            						this._onEndCallback(this);
            				}
            				this.stop();
            		}
            		_onManagerVolumeChange() {
            				this.volume = this._volume;
            		}
            		_onManagerSuspend() {
            				if (this._state === STATE_PLAYING && !this._suspended) {
            						this._suspended = true;
            						this.pause();
            				}
            		}
            		_onManagerResume() {
            				if (this._suspended) {
            						this._suspended = false;
            						this.resume();
            				}
            		}
            		_initializeNodes() {
            				this.gain = this._manager.context.createGain();
            				this._inputNode = this.gain;
            				this._connectorNode = this.gain;
            				this._connectorNode.connect(this._manager.context.destination);
            		}
            		play() {
            				if (this._state !== STATE_STOPPED) {
            						this.stop();
            				}
            				this._state = STATE_PLAYING;
            				this._playWhenLoaded = false;
            				if (this._waitingContextSuspension) {
            						return false;
            				}
            				if (this._manager.suspended) {
            						this._manager.once('resume', this._playAudioImmediate, this);
            						this._waitingContextSuspension = true;
            						return false;
            				}
            				this._playAudioImmediate();
            				return true;
            		}
            		_playAudioImmediate() {
            				this._waitingContextSuspension = false;
            				if (this._state !== STATE_PLAYING) {
            						return;
            				}
            				if (!this.source) {
            						this._createSource();
            				}
            				var offset = capTime(this._startOffset, this.duration);
            				offset = capTime(this._startTime + offset, this._sound.duration);
            				this._startOffset = null;
            				if (this._duration) {
            						this.source.start(0, offset, this._duration);
            				} else {
            						this.source.start(0, offset);
            				}
            				this._startedAt = this._manager.context.currentTime;
            				this._currentTime = 0;
            				this._currentOffset = offset;
            				this.volume = this._volume;
            				this.loop = this._loop;
            				this.pitch = this._pitch;
            				this._manager.on('volumechange', this._onManagerVolumeChange, this);
            				this._manager.on('suspend', this._onManagerSuspend, this);
            				this._manager.on('resume', this._onManagerResume, this);
            				this._manager.on('destroy', this._onManagerDestroy, this);
            				if (!this._suspendInstanceEvents) {
            						this._onPlay();
            				}
            		}
            		pause() {
            				this._playWhenLoaded = false;
            				if (this._state !== STATE_PLAYING) {
            						return false;
            				}
            				this._state = STATE_PAUSED;
            				if (this._waitingContextSuspension) {
            						return true;
            				}
            				this._updateCurrentTime();
            				this._suspendEndEvent++;
            				this.source.stop(0);
            				this.source = null;
            				this._startOffset = null;
            				if (!this._suspendInstanceEvents) {
            						this._onPause();
            				}
            				return true;
            		}
            		resume() {
            				if (this._state !== STATE_PAUSED) {
            						return false;
            				}
            				var offset = this.currentTime;
            				this._state = STATE_PLAYING;
            				if (this._waitingContextSuspension) {
            						return true;
            				}
            				if (!this.source) {
            						this._createSource();
            				}
            				if (this._startOffset !== null) {
            						offset = capTime(this._startOffset, this.duration);
            						offset = capTime(this._startTime + offset, this._sound.duration);
            						this._startOffset = null;
            				}
            				if (this._duration) {
            						this.source.start(0, offset, this._duration);
            				} else {
            						this.source.start(0, offset);
            				}
            				this._startedAt = this._manager.context.currentTime;
            				this._currentOffset = offset;
            				this.volume = this._volume;
            				this.loop = this._loop;
            				this.pitch = this._pitch;
            				this._playWhenLoaded = false;
            				if (!this._suspendInstanceEvents) {
            						this._onResume();
            				}
            				return true;
            		}
            		stop() {
            				this._playWhenLoaded = false;
            				if (this._state === STATE_STOPPED) {
            						return false;
            				}
            				var wasPlaying = this._state === STATE_PLAYING;
            				this._state = STATE_STOPPED;
            				if (this._waitingContextSuspension) {
            						return true;
            				}
            				this._manager.off('volumechange', this._onManagerVolumeChange, this);
            				this._manager.off('suspend', this._onManagerSuspend, this);
            				this._manager.off('resume', this._onManagerResume, this);
            				this._manager.off('destroy', this._onManagerDestroy, this);
            				this._startedAt = 0;
            				this._currentTime = 0;
            				this._currentOffset = 0;
            				this._startOffset = null;
            				this._suspendEndEvent++;
            				if (wasPlaying && this.source) {
            						this.source.stop(0);
            				}
            				this.source = null;
            				if (!this._suspendInstanceEvents) {
            						this._onStop();
            				}
            				return true;
            		}
            		setExternalNodes(firstNode, lastNode) {
            				if (!firstNode) {
            						console.error('The firstNode must be a valid Audio Node');
            						return;
            				}
            				if (!lastNode) {
            						lastNode = firstNode;
            				}
            				var speakers = this._manager.context.destination;
            				if (this._firstNode !== firstNode) {
            						if (this._firstNode) {
            								this._connectorNode.disconnect(this._firstNode);
            						} else {
            								this._connectorNode.disconnect(speakers);
            						}
            						this._firstNode = firstNode;
            						this._connectorNode.connect(firstNode);
            				}
            				if (this._lastNode !== lastNode) {
            						if (this._lastNode) {
            								this._lastNode.disconnect(speakers);
            						}
            						this._lastNode = lastNode;
            						this._lastNode.connect(speakers);
            				}
            		}
            		clearExternalNodes() {
            				var speakers = this._manager.context.destination;
            				if (this._firstNode) {
            						this._connectorNode.disconnect(this._firstNode);
            						this._firstNode = null;
            				}
            				if (this._lastNode) {
            						this._lastNode.disconnect(speakers);
            						this._lastNode = null;
            				}
            				this._connectorNode.connect(speakers);
            		}
            		getExternalNodes() {
            				return [
            						this._firstNode,
            						this._lastNode
            				];
            		}
            		_createSource() {
            				if (!this._sound) {
            						return null;
            				}
            				var context = this._manager.context;
            				if (this._sound.buffer) {
            						this.source = context.createBufferSource();
            						this.source.buffer = this._sound.buffer;
            						this.source.connect(this._inputNode);
            						this.source.onended = this._endedHandler;
            						this.source.loopStart = capTime(this._startTime, this.source.buffer.duration);
            						if (this._duration) {
            								this.source.loopEnd = Math.max(this.source.loopStart, capTime(this._startTime + this._duration, this.source.buffer.duration));
            						}
            				}
            				return this.source;
            		}
            		_updateCurrentTime() {
            				this._currentTime = capTime((this._manager.context.currentTime - this._startedAt) * this._pitch + this._currentOffset, this.duration);
            		}
            		_onManagerDestroy() {
            				if (this.source && this._state === STATE_PLAYING) {
            						this.source.stop(0);
            						this.source = null;
            				}
            		}
            		constructor(manager, sound, options){
            				super(), this.source = null;
            				this._manager = manager;
            				this._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;
            				this._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;
            				this._loop = !!(options.loop !== undefined ? options.loop : false);
            				this._sound = sound;
            				this._state = STATE_STOPPED;
            				this._suspended = false;
            				this._suspendEndEvent = 0;
            				this._suspendInstanceEvents = false;
            				this._playWhenLoaded = true;
            				this._startTime = Math.max(0, Number(options.startTime) || 0);
            				this._duration = Math.max(0, Number(options.duration) || 0);
            				this._startOffset = null;
            				this._onPlayCallback = options.onPlay;
            				this._onPauseCallback = options.onPause;
            				this._onResumeCallback = options.onResume;
            				this._onStopCallback = options.onStop;
            				this._onEndCallback = options.onEnd;
            				if (hasAudioContext()) {
            						this._startedAt = 0;
            						this._currentTime = 0;
            						this._currentOffset = 0;
            						this._inputNode = null;
            						this._connectorNode = null;
            						this._firstNode = null;
            						this._lastNode = null;
            						this._waitingContextSuspension = false;
            						this._initializeNodes();
            						this._endedHandler = this._onEnded.bind(this);
            				} else {
            						this._isReady = false;
            						this._loadedMetadataHandler = this._onLoadedMetadata.bind(this);
            						this._timeUpdateHandler = this._onTimeUpdate.bind(this);
            						this._endedHandler = this._onEnded.bind(this);
            						this._createSource();
            				}
            		}
            }
            SoundInstance.EVENT_PLAY = 'play';
            SoundInstance.EVENT_PAUSE = 'pause';
            SoundInstance.EVENT_RESUME = 'resume';
            SoundInstance.EVENT_STOP = 'stop';
            SoundInstance.EVENT_END = 'end';
            if (!hasAudioContext()) {
            		Object.assign(SoundInstance.prototype, {
            				play: function play() {
            						if (this._state !== STATE_STOPPED) {
            								this.stop();
            						}
            						if (!this.source) {
            								if (!this._createSource()) {
            										return false;
            								}
            						}
            						this.volume = this._volume;
            						this.pitch = this._pitch;
            						this.loop = this._loop;
            						this.source.play();
            						this._state = STATE_PLAYING;
            						this._playWhenLoaded = false;
            						this._manager.on('volumechange', this._onManagerVolumeChange, this);
            						this._manager.on('suspend', this._onManagerSuspend, this);
            						this._manager.on('resume', this._onManagerResume, this);
            						this._manager.on('destroy', this._onManagerDestroy, this);
            						if (this._manager.suspended) {
            								this._onManagerSuspend();
            						}
            						if (!this._suspendInstanceEvents) {
            								this._onPlay();
            						}
            						return true;
            				},
            				pause: function pause() {
            						if (!this.source || this._state !== STATE_PLAYING) {
            								return false;
            						}
            						this._suspendEndEvent++;
            						this.source.pause();
            						this._playWhenLoaded = false;
            						this._state = STATE_PAUSED;
            						this._startOffset = null;
            						if (!this._suspendInstanceEvents) {
            								this._onPause();
            						}
            						return true;
            				},
            				resume: function resume() {
            						if (!this.source || this._state !== STATE_PAUSED) {
            								return false;
            						}
            						this._state = STATE_PLAYING;
            						this._playWhenLoaded = false;
            						if (this.source.paused) {
            								this.source.play();
            								if (!this._suspendInstanceEvents) {
            										this._onResume();
            								}
            						}
            						return true;
            				},
            				stop: function stop() {
            						if (!this.source || this._state === STATE_STOPPED) {
            								return false;
            						}
            						this._manager.off('volumechange', this._onManagerVolumeChange, this);
            						this._manager.off('suspend', this._onManagerSuspend, this);
            						this._manager.off('resume', this._onManagerResume, this);
            						this._manager.off('destroy', this._onManagerDestroy, this);
            						this._suspendEndEvent++;
            						this.source.pause();
            						this._playWhenLoaded = false;
            						this._state = STATE_STOPPED;
            						this._startOffset = null;
            						if (!this._suspendInstanceEvents) {
            								this._onStop();
            						}
            						return true;
            				},
            				setExternalNodes: function setExternalNodes() {},
            				clearExternalNodes: function clearExternalNodes() {},
            				getExternalNodes: function getExternalNodes() {
            						return [
            								null,
            								null
            						];
            				},
            				_onLoadedMetadata: function _onLoadedMetadata() {
            						this.source.removeEventListener('loadedmetadata', this._loadedMetadataHandler);
            						this._isReady = true;
            						var offset = capTime(this._startOffset, this.duration);
            						offset = capTime(this._startTime + offset, this._sound.duration);
            						this._startOffset = null;
            						this.source.currentTime = offset;
            				},
            				_createSource: function _createSource() {
            						if (this._sound && this._sound.audio) {
            								this._isReady = false;
            								this.source = this._sound.audio.cloneNode(true);
            								this.source.addEventListener('loadedmetadata', this._loadedMetadataHandler);
            								this.source.addEventListener('timeupdate', this._timeUpdateHandler);
            								this.source.onended = this._endedHandler;
            						}
            						return this.source;
            				},
            				_onTimeUpdate: function _onTimeUpdate() {
            						if (!this._duration) {
            								return;
            						}
            						if (this.source.currentTime > capTime(this._startTime + this._duration, this.source.duration)) {
            								if (this.loop) {
            										this.source.currentTime = capTime(this._startTime, this.source.duration);
            								} else {
            										this.source.removeEventListener('timeupdate', this._timeUpdateHandler);
            										this.source.pause();
            										this._onEnded();
            								}
            						}
            				},
            				_onManagerDestroy: function _onManagerDestroy() {
            						if (this.source) {
            								this.source.pause();
            						}
            				}
            		});
            		Object.defineProperty(SoundInstance.prototype, 'volume', {
            				get: function get() {
            						return this._volume;
            				},
            				set: function set(volume) {
            						volume = math.clamp(volume, 0, 1);
            						this._volume = volume;
            						if (this.source) {
            								this.source.volume = volume * this._manager.volume;
            						}
            				}
            		});
            		Object.defineProperty(SoundInstance.prototype, 'pitch', {
            				get: function get() {
            						return this._pitch;
            				},
            				set: function set(pitch) {
            						this._pitch = Math.max(Number(pitch) || 0, 0.01);
            						if (this.source) {
            								this.source.playbackRate = this._pitch;
            						}
            				}
            		});
            		Object.defineProperty(SoundInstance.prototype, 'sound', {
            				get: function get() {
            						return this._sound;
            				},
            				set: function set(value) {
            						this.stop();
            						this._sound = value;
            				}
            		});
            		Object.defineProperty(SoundInstance.prototype, 'currentTime', {
            				get: function get() {
            						if (this._startOffset !== null) {
            								return this._startOffset;
            						}
            						if (this._state === STATE_STOPPED || !this.source) {
            								return 0;
            						}
            						return this.source.currentTime - this._startTime;
            				},
            				set: function set(value) {
            						if (value < 0) return;
            						this._startOffset = value;
            						if (this.source && this._isReady) {
            								this.source.currentTime = capTime(this._startTime + capTime(value, this.duration), this._sound.duration);
            								this._startOffset = null;
            						}
            				}
            		});
            }
            
            var MAX_DISTANCE = 10000;
            class SoundInstance3d extends SoundInstance {
            		_initializeNodes() {
            				this.gain = this._manager.context.createGain();
            				this.panner = this._manager.context.createPanner();
            				this.panner.connect(this.gain);
            				this._inputNode = this.panner;
            				this._connectorNode = this.gain;
            				this._connectorNode.connect(this._manager.context.destination);
            		}
            		set position(value) {
            				this._position.copy(value);
            				var panner = this.panner;
            				if ('positionX' in panner) {
            						panner.positionX.value = value.x;
            						panner.positionY.value = value.y;
            						panner.positionZ.value = value.z;
            				} else if (panner.setPosition) {
            						panner.setPosition(value.x, value.y, value.z);
            				}
            		}
            		get position() {
            				return this._position;
            		}
            		set velocity(velocity) {
            				this._velocity.copy(velocity);
            		}
            		get velocity() {
            				return this._velocity;
            		}
            		set maxDistance(value) {
            				this.panner.maxDistance = value;
            		}
            		get maxDistance() {
            				return this.panner.maxDistance;
            		}
            		set refDistance(value) {
            				this.panner.refDistance = value;
            		}
            		get refDistance() {
            				return this.panner.refDistance;
            		}
            		set rollOffFactor(value) {
            				this.panner.rolloffFactor = value;
            		}
            		get rollOffFactor() {
            				return this.panner.rolloffFactor;
            		}
            		set distanceModel(value) {
            				this.panner.distanceModel = value;
            		}
            		get distanceModel() {
            				return this.panner.distanceModel;
            		}
            		constructor(manager, sound, options = {}){
            				super(manager, sound, options), this._position = new Vec3(), this._velocity = new Vec3();
            				if (options.position) {
            						this.position = options.position;
            				}
            				this.maxDistance = options.maxDistance !== undefined ? Number(options.maxDistance) : MAX_DISTANCE;
            				this.refDistance = options.refDistance !== undefined ? Number(options.refDistance) : 1;
            				this.rollOffFactor = options.rollOffFactor !== undefined ? Number(options.rollOffFactor) : 1;
            				this.distanceModel = options.distanceModel !== undefined ? options.distanceModel : DISTANCE_LINEAR;
            		}
            }
            if (!hasAudioContext()) {
            		var offset = new Vec3();
            		var fallOff = function fallOff(posOne, posTwo, refDistance, maxDistance, rollOffFactor, distanceModel) {
            				offset = offset.sub2(posOne, posTwo);
            				var distance = offset.length();
            				if (distance < refDistance) {
            						return 1;
            				} else if (distance > maxDistance) {
            						return 0;
            				}
            				var result = 0;
            				if (distanceModel === DISTANCE_LINEAR) {
            						result = 1 - rollOffFactor * (distance - refDistance) / (maxDistance - refDistance);
            				} else if (distanceModel === DISTANCE_INVERSE) {
            						result = refDistance / (refDistance + rollOffFactor * (distance - refDistance));
            				} else if (distanceModel === DISTANCE_EXPONENTIAL) {
            						result = Math.pow(distance / refDistance, -rollOffFactor);
            				}
            				return math.clamp(result, 0, 1);
            		};
            		Object.defineProperty(SoundInstance3d.prototype, 'position', {
            				get: function get() {
            						return this._position;
            				},
            				set: function set(position) {
            						this._position.copy(position);
            						if (this.source) {
            								var listener = this._manager.listener;
            								var lpos = listener.getPosition();
            								var factor = fallOff(lpos, this._position, this.refDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);
            								var v = this.volume;
            								this.source.volume = v * factor * this._manager.volume;
            						}
            				}
            		});
            		Object.defineProperty(SoundInstance3d.prototype, 'maxDistance', {
            				get: function get() {
            						return this._maxDistance;
            				},
            				set: function set(value) {
            						this._maxDistance = value;
            				}
            		});
            		Object.defineProperty(SoundInstance3d.prototype, 'refDistance', {
            				get: function get() {
            						return this._refDistance;
            				},
            				set: function set(value) {
            						this._refDistance = value;
            				}
            		});
            		Object.defineProperty(SoundInstance3d.prototype, 'rollOffFactor', {
            				get: function get() {
            						return this._rollOffFactor;
            				},
            				set: function set(value) {
            						this._rollOffFactor = value;
            				}
            		});
            		Object.defineProperty(SoundInstance3d.prototype, 'distanceModel', {
            				get: function get() {
            						return this._distanceModel;
            				},
            				set: function set(value) {
            						this._distanceModel = value;
            				}
            		});
            }
            
            var BLEND_SUBTRACTIVE = 0;
            var BLEND_ADDITIVE = 1;
            var BLEND_NORMAL = 2;
            var BLEND_NONE = 3;
            var BLEND_PREMULTIPLIED = 4;
            var BLEND_MULTIPLICATIVE = 5;
            var BLEND_ADDITIVEALPHA = 6;
            var BLEND_MULTIPLICATIVE2X = 7;
            var BLEND_SCREEN = 8;
            var BLEND_MIN = 9;
            var BLEND_MAX = 10;
            var blendNames = {
            		[BLEND_SUBTRACTIVE]: 'SUBTRACTIVE',
            		[BLEND_ADDITIVE]: 'ADDITIVE',
            		[BLEND_NORMAL]: 'NORMAL',
            		[BLEND_NONE]: 'NONE',
            		[BLEND_PREMULTIPLIED]: 'PREMULTIPLIED',
            		[BLEND_MULTIPLICATIVE]: 'MULTIPLICATIVE',
            		[BLEND_ADDITIVEALPHA]: 'ADDITIVEALPHA',
            		[BLEND_MULTIPLICATIVE2X]: 'MULTIPLICATIVE2X',
            		[BLEND_SCREEN]: 'SCREEN',
            		[BLEND_MIN]: 'MIN',
            		[BLEND_MAX]: 'MAX'
            };
            var FOG_NONE = 'none';
            var FOG_LINEAR = 'linear';
            var FRESNEL_NONE = 0;
            var FRESNEL_SCHLICK = 2;
            var fresnelNames = {
            		[FRESNEL_NONE]: 'NONE',
            		[FRESNEL_SCHLICK]: 'SCHLICK'
            };
            var LAYER_HUD = 0;
            var LAYER_WORLD = 15;
            var LAYERID_WORLD = 0;
            var LAYERID_DEPTH = 1;
            var LAYERID_SKYBOX = 2;
            var LAYERID_IMMEDIATE = 3;
            var LAYERID_UI = 4;
            var LIGHTTYPE_DIRECTIONAL = 0;
            var LIGHTTYPE_OMNI = 1;
            var LIGHTTYPE_SPOT = 2;
            var lightTypeNames = {
            		[LIGHTTYPE_DIRECTIONAL]: 'DIRECTIONAL',
            		[LIGHTTYPE_OMNI]: 'OMNI',
            		[LIGHTTYPE_SPOT]: 'SPOT'
            };
            var LIGHT_COLOR_DIVIDER = 100;
            var LIGHTSHAPE_PUNCTUAL = 0;
            var LIGHTSHAPE_RECT = 1;
            var LIGHTSHAPE_DISK = 2;
            var LIGHTSHAPE_SPHERE = 3;
            var lightShapeNames = {
            		[LIGHTSHAPE_PUNCTUAL]: 'PUNCTUAL',
            		[LIGHTSHAPE_RECT]: 'RECT',
            		[LIGHTSHAPE_DISK]: 'DISK',
            		[LIGHTSHAPE_SPHERE]: 'SPHERE'
            };
            var LIGHTFALLOFF_LINEAR = 0;
            var LIGHTFALLOFF_INVERSESQUARED = 1;
            var lightFalloffNames = {
            		[LIGHTFALLOFF_LINEAR]: 'LINEAR',
            		[LIGHTFALLOFF_INVERSESQUARED]: 'INVERSESQUARED'
            };
            var SHADOW_PCF3_32F = 0;
            var SHADOW_VSM_16F = 2;
            var SHADOW_VSM_32F = 3;
            var SHADOW_PCF5_32F = 4;
            var SHADOW_PCF1_32F = 5;
            var SHADOW_PCSS_32F = 6;
            var SHADOW_PCF1_16F = 7;
            var SHADOW_PCF3_16F = 8;
            var SHADOW_PCF5_16F = 9;
            var shadowTypeInfo = new Map([
            		[
            				SHADOW_PCF1_32F,
            				{
            						name: 'PCF1_32F',
            						kind: 'PCF1',
            						format: PIXELFORMAT_DEPTH,
            						pcf: true
            				}
            		],
            		[
            				SHADOW_PCF3_32F,
            				{
            						name: 'PCF3_32F',
            						kind: 'PCF3',
            						format: PIXELFORMAT_DEPTH,
            						pcf: true
            				}
            		],
            		[
            				SHADOW_PCF5_32F,
            				{
            						name: 'PCF5_32F',
            						kind: 'PCF5',
            						format: PIXELFORMAT_DEPTH,
            						pcf: true
            				}
            		],
            		[
            				SHADOW_PCF1_16F,
            				{
            						name: 'PCF1_16F',
            						kind: 'PCF1',
            						format: PIXELFORMAT_DEPTH16,
            						pcf: true
            				}
            		],
            		[
            				SHADOW_PCF3_16F,
            				{
            						name: 'PCF3_16F',
            						kind: 'PCF3',
            						format: PIXELFORMAT_DEPTH16,
            						pcf: true
            				}
            		],
            		[
            				SHADOW_PCF5_16F,
            				{
            						name: 'PCF5_16F',
            						kind: 'PCF5',
            						format: PIXELFORMAT_DEPTH16,
            						pcf: true
            				}
            		],
            		[
            				SHADOW_VSM_16F,
            				{
            						name: 'VSM_16F',
            						kind: 'VSM',
            						format: PIXELFORMAT_RGBA16F,
            						vsm: true
            				}
            		],
            		[
            				SHADOW_VSM_32F,
            				{
            						name: 'VSM_32F',
            						kind: 'VSM',
            						format: PIXELFORMAT_RGBA32F,
            						vsm: true
            				}
            		],
            		[
            				SHADOW_PCSS_32F,
            				{
            						name: 'PCSS_32F',
            						kind: 'PCSS',
            						format: PIXELFORMAT_R32F,
            						pcss: true
            				}
            		]
            ]);
            var BLUR_GAUSSIAN = 1;
            var PARTICLESORT_NONE = 0;
            var PARTICLEMODE_GPU = 0;
            var EMITTERSHAPE_BOX = 0;
            var EMITTERSHAPE_SPHERE = 1;
            var PARTICLEORIENTATION_SCREEN = 0;
            var PARTICLEORIENTATION_WORLD = 1;
            var PROJECTION_PERSPECTIVE = 0;
            var PROJECTION_ORTHOGRAPHIC = 1;
            var RENDERSTYLE_SOLID = 0;
            var RENDERSTYLE_WIREFRAME = 1;
            var RENDERSTYLE_POINTS = 2;
            var CUBEPROJ_NONE = 0;
            var CUBEPROJ_BOX = 1;
            var cubemaProjectionNames = {
            		[CUBEPROJ_NONE]: 'NONE',
            		[CUBEPROJ_BOX]: 'BOX'
            };
            var DETAILMODE_MUL = 'mul';
            var GAMMA_NONE = 0;
            var GAMMA_SRGB = 1;
            var gammaNames = {
            		[GAMMA_NONE]: 'NONE',
            		[GAMMA_SRGB]: 'SRGB'
            };
            var TONEMAP_LINEAR = 0;
            var TONEMAP_FILMIC = 1;
            var TONEMAP_HEJL = 2;
            var TONEMAP_ACES = 3;
            var TONEMAP_ACES2 = 4;
            var TONEMAP_NEUTRAL = 5;
            var TONEMAP_NONE = 6;
            var tonemapNames = [
            		'LINEAR',
            		'FILMIC',
            		'HEJL',
            		'ACES',
            		'ACES2',
            		'NEUTRAL',
            		'NONE'
            ];
            var SPECOCC_NONE = 0;
            var SPECOCC_AO = 1;
            var SPECOCC_GLOSSDEPENDENT = 2;
            var specularOcclusionNames = {
            		[SPECOCC_NONE]: 'NONE',
            		[SPECOCC_AO]: 'AO',
            		[SPECOCC_GLOSSDEPENDENT]: 'GLOSSDEPENDENT'
            };
            var REFLECTIONSRC_NONE = 'none';
            var REFLECTIONSRC_ENVATLAS = 'envAtlas';
            var REFLECTIONSRC_ENVATLASHQ = 'envAtlasHQ';
            var REFLECTIONSRC_CUBEMAP = 'cubeMap';
            var REFLECTIONSRC_SPHEREMAP = 'sphereMap';
            var reflectionSrcNames = {
            		[REFLECTIONSRC_NONE]: 'NONE',
            		[REFLECTIONSRC_ENVATLAS]: 'ENVATLAS',
            		[REFLECTIONSRC_ENVATLASHQ]: 'ENVATLASHQ',
            		[REFLECTIONSRC_CUBEMAP]: 'CUBEMAP',
            		[REFLECTIONSRC_SPHEREMAP]: 'SPHEREMAP'
            };
            var AMBIENTSRC_AMBIENTSH = 'ambientSH';
            var AMBIENTSRC_ENVALATLAS = 'envAtlas';
            var AMBIENTSRC_CONSTANT = 'constant';
            var ambientSrcNames = {
            		[AMBIENTSRC_AMBIENTSH]: 'AMBIENTSH',
            		[AMBIENTSRC_ENVALATLAS]: 'ENVALATLAS',
            		[AMBIENTSRC_CONSTANT]: 'CONSTANT'
            };
            var SHADERDEF_NOSHADOW = 1;
            var SHADERDEF_SKIN = 2;
            var SHADERDEF_UV0 = 4;
            var SHADERDEF_UV1 = 8;
            var SHADERDEF_VCOLOR = 16;
            var SHADERDEF_INSTANCING = 32;
            var SHADERDEF_LM = 64;
            var SHADERDEF_DIRLM = 128;
            var SHADERDEF_SCREENSPACE = 256;
            var SHADERDEF_TANGENTS = 512;
            var SHADERDEF_MORPH_POSITION = 1024;
            var SHADERDEF_MORPH_NORMAL = 2048;
            var SHADERDEF_LMAMBIENT = 4096;
            var SHADERDEF_MORPH_TEXTURE_BASED_INT = 8192;
            var SHADERDEF_BATCH = 16384;
            var SHADOWUPDATE_NONE = 0;
            var SHADOWUPDATE_THISFRAME = 1;
            var SHADOWUPDATE_REALTIME = 2;
            var MASK_AFFECT_DYNAMIC = 1;
            var MASK_AFFECT_LIGHTMAPPED = 2;
            var MASK_BAKE = 4;
            var SHADER_FORWARD = 0;
            var SHADER_PREPASS = 1;
            var SHADER_DEPTH = 2;
            var SHADER_PICK = 3;
            var SHADER_SHADOW = 4;
            var SPRITE_RENDERMODE_SIMPLE = 0;
            var SPRITE_RENDERMODE_SLICED = 1;
            var SPRITE_RENDERMODE_TILED = 2;
            var spriteRenderModeNames = {
            		[SPRITE_RENDERMODE_SIMPLE]: 'SIMPLE',
            		[SPRITE_RENDERMODE_SLICED]: 'SLICED',
            		[SPRITE_RENDERMODE_TILED]: 'TILED'
            };
            var BAKE_COLORDIR = 1;
            var VIEW_CENTER = 0;
            var SORTMODE_NONE = 0;
            var SORTMODE_MANUAL = 1;
            var SORTMODE_MATERIALMESH = 2;
            var SORTMODE_BACK2FRONT = 3;
            var SORTMODE_FRONT2BACK = 4;
            var SORTMODE_CUSTOM = 5;
            var ASPECT_AUTO = 0;
            var ASPECT_MANUAL = 1;
            var ORIENTATION_HORIZONTAL = 0;
            var ORIENTATION_VERTICAL = 1;
            var SKYTYPE_INFINITE = 'infinite';
            var SKYTYPE_BOX = 'box';
            var SKYTYPE_DOME = 'dome';
            var DITHER_NONE = 'none';
            var DITHER_BAYER8 = 'bayer8';
            var DITHER_BLUENOISE = 'bluenoise';
            var DITHER_IGNNOISE = 'ignnoise';
            var ditherNames = {
            		[DITHER_NONE]: 'NONE',
            		[DITHER_BAYER8]: 'BAYER8',
            		[DITHER_BLUENOISE]: 'BLUENOISE',
            		[DITHER_IGNNOISE]: 'IGNNOISE'
            };
            var EVENT_PRERENDER = 'prerender';
            var EVENT_POSTRENDER = 'postrender';
            var EVENT_PRERENDER_LAYER = 'prerender:layer';
            var EVENT_POSTRENDER_LAYER = 'postrender:layer';
            var EVENT_PRECULL = 'precull';
            var EVENT_POSTCULL = 'postcull';
            
            class ShaderProcessorOptions {
            		hasUniform(name) {
            				for(var i = 0; i < this.uniformFormats.length; i++){
            						var uniformFormat = this.uniformFormats[i];
            						if (uniformFormat == null ? void 0 : uniformFormat.get(name)) {
            								return true;
            						}
            				}
            				return false;
            		}
            		hasTexture(name) {
            				for(var i = 0; i < this.bindGroupFormats.length; i++){
            						var groupFormat = this.bindGroupFormats[i];
            						if (groupFormat == null ? void 0 : groupFormat.getTexture(name)) {
            								return true;
            						}
            				}
            				return false;
            		}
            		getVertexElement(semantic) {
            				var _this_vertexFormat;
            				return (_this_vertexFormat = this.vertexFormat) == null ? void 0 : _this_vertexFormat.elements.find((element)=>element.name === semantic);
            		}
            		generateKey(device) {
            				var key = JSON.stringify(this.uniformFormats) + JSON.stringify(this.bindGroupFormats);
            				if (device.isWebGPU) {
            						var _this_vertexFormat;
            						key += (_this_vertexFormat = this.vertexFormat) == null ? void 0 : _this_vertexFormat.shaderProcessingHashString;
            				}
            				return key;
            		}
            		constructor(viewUniformFormat, viewBindGroupFormat, vertexFormat){
            				this.uniformFormats = [];
            				this.bindGroupFormats = [];
            				this.uniformFormats[BINDGROUP_VIEW] = viewUniformFormat;
            				this.bindGroupFormats[BINDGROUP_VIEW] = viewBindGroupFormat;
            				this.vertexFormat = vertexFormat;
            		}
            }
            
            var alphaTestPS = "\nuniform float alpha_ref;\nvoid alphaTest(float a) {\n	if (a < alpha_ref) discard;\n}\n";
            
            var ambientPS$1 = '\n#ifdef LIT_AMBIENT_SOURCE == AMBIENTSH\n	uniform vec3 ambientSH[9];\n#endif\n#if LIT_AMBIENT_SOURCE == ENVALATLAS\n	#include "envAtlasPS"\n	#ifndef ENV_ATLAS\n	#define ENV_ATLAS\n	uniform sampler2D texture_envAtlas;\n	#endif\n#endif\nvoid addAmbient(vec3 worldNormal) {\n	#ifdef LIT_AMBIENT_SOURCE == AMBIENTSH\n		vec3 n = cubeMapRotate(worldNormal);\n		vec3 color =\n			ambientSH[0] +\n			ambientSH[1] * n.x +\n			ambientSH[2] * n.y +\n			ambientSH[3] * n.z +\n			ambientSH[4] * n.x * n.z +\n			ambientSH[5] * n.z * n.y +\n			ambientSH[6] * n.y * n.x +\n			ambientSH[7] * (3.0 * n.z * n.z - 1.0) +\n			ambientSH[8] * (n.x * n.x - n.y * n.y);\n		dDiffuseLight += processEnvironment(max(color, vec3(0.0)));\n	#endif\n	#if LIT_AMBIENT_SOURCE == ENVALATLAS\n		vec3 dir = normalize(cubeMapRotate(worldNormal) * vec3(-1.0, 1.0, 1.0));\n		vec2 uv = mapUv(toSphericalUv(dir), vec4(128.0, 256.0 + 128.0, 64.0, 32.0) / atlasSize);\n		vec4 raw = texture2D(texture_envAtlas, uv);\n		vec3 linear = {ambientDecode}(raw);\n		dDiffuseLight += processEnvironment(linear);\n	#endif\n	#if LIT_AMBIENT_SOURCE == CONSTANT\n		dDiffuseLight += light_globalAmbient;\n	#endif\n}\n';
            
            var aoPS = '\n#if defined(STD_AO_TEXTURE) || defined(STD_AO_VERTEX)\n	uniform float material_aoIntensity;\n#endif\n#ifdef STD_AODETAIL_TEXTURE\n	#include "detailModesPS"\n#endif\nvoid getAO() {\n	dAo = 1.0;\n	#ifdef STD_AO_TEXTURE\n		float aoBase = texture2DBias({STD_AO_TEXTURE_NAME}, {STD_AO_TEXTURE_UV}, textureBias).{STD_AO_TEXTURE_CHANNEL};\n		#ifdef STD_AODETAIL_TEXTURE\n			float aoDetail = texture2DBias({STD_AODETAIL_TEXTURE_NAME}, {STD_AODETAIL_TEXTURE_UV}, textureBias).{STD_AODETAIL_TEXTURE_CHANNEL};\n			aoBase = detailMode_{STD_AODETAIL_DETAILMODE}(vec3(aoBase), vec3(aoDetail)).r;\n		#endif\n		dAo *= aoBase;\n	#endif\n	#ifdef STD_AO_VERTEX\n		dAo *= saturate(vVertexColor.{STD_AO_VERTEX_CHANNEL});\n	#endif\n	#if defined(STD_AO_TEXTURE) || defined(STD_AO_VERTEX)\n		dAo = mix(1.0, dAo, material_aoIntensity);\n	#endif\n}\n';
            
            var aoDiffuseOccPS = "\nvoid occludeDiffuse(float ao) {\n	dDiffuseLight *= ao;\n}\n";
            
            var aoSpecOccPS = "\n#if LIT_OCCLUDE_SPECULAR != NONE\n	#ifdef LIT_OCCLUDE_SPECULAR_FLOAT\n		uniform float material_occludeSpecularIntensity;\n	#endif\n#endif\nvoid occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {\n	#if LIT_OCCLUDE_SPECULAR == AO\n		#ifdef LIT_OCCLUDE_SPECULAR_FLOAT\n			float specOcc = mix(1.0, ao, material_occludeSpecularIntensity);\n		#else\n			float specOcc = ao;\n		#endif\n	#endif\n	#if LIT_OCCLUDE_SPECULAR == GLOSSDEPENDENT\n		float specPow = exp2(gloss * 11.0);\n		float specOcc = saturate(pow(dot(worldNormal, viewDir) + ao, 0.01*specPow) - 1.0 + ao);\n		#ifdef LIT_OCCLUDE_SPECULAR_FLOAT\n			specOcc = mix(1.0, specOcc, material_occludeSpecularIntensity);\n		#endif\n	#endif\n	#if LIT_OCCLUDE_SPECULAR != NONE\n		dSpecularLight *= specOcc;\n		dReflection *= specOcc;\n		#ifdef LIT_SHEEN\n			sSpecularLight *= specOcc;\n			sReflection *= specOcc;\n		#endif\n	#endif\n}\n";
            
            var basePS$1 = "\nuniform vec3 view_position;\nuniform vec3 light_globalAmbient;\nfloat square(float x) {\n	return x*x;\n}\nfloat saturate(float x) {\n	return clamp(x, 0.0, 1.0);\n}\nvec3 saturate(vec3 x) {\n	return clamp(x, vec3(0.0), vec3(1.0));\n}\n";
            
            var baseNineSlicedPS = "\n#define NINESLICED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\nvec2 nineSlicedUv;\n";
            
            var baseNineSlicedTiledPS = "\n#define NINESLICED\n#define NINESLICETILED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\nvec2 nineSlicedUv;\n";
            
            var bayerPS = "\nfloat bayer2(vec2 p) {\n	return mod(2.0 * p.y + p.x + 1.0, 4.0);\n}\nfloat bayer4(vec2 p) {\n	vec2 p1 = mod(p, 2.0);\n	vec2 p2 = floor(0.5 * mod(p, 4.0));\n	return 4.0 * bayer2(p1) + bayer2(p2);\n}\nfloat bayer8(vec2 p) {\n	vec2 p1 = mod(p, 2.0);\n	vec2 p2 = floor(0.5 * mod(p, 4.0));\n	vec2 p4 = floor(0.25 * mod(p, 8.0));\n	return 4.0 * (4.0 * bayer2(p1) + bayer2(p2)) + bayer2(p4);\n}\n";
            
            var blurVSMPS = "\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\n#ifdef GAUSS\nuniform float weight[SAMPLES];\n#endif\nvoid main(void) {\n	vec3 moments = vec3(0.0);\n	vec2 uv = vUv0 - pixelOffset * (float(SAMPLES) * 0.5);\n	for (int i=0; i<SAMPLES; i++) {\n		vec4 c = texture2D(source, uv + pixelOffset * float(i));\n		#ifdef GAUSS\n		moments += c.xyz * weight[i];\n		#else\n		moments += c.xyz;\n		#endif\n	}\n	#ifndef GAUSS\n	moments /= float(SAMPLES);\n	#endif\n	gl_FragColor = vec4(moments.x, moments.y, moments.z, 1.0);\n}\n";
            
            var clearCoatPS = "\n#ifdef STD_CLEARCOAT_CONSTANT\nuniform float material_clearCoat;\n#endif\nvoid getClearCoat() {\n	ccSpecularity = 1.0;\n	#ifdef STD_CLEARCOAT_CONSTANT\n	ccSpecularity *= material_clearCoat;\n	#endif\n	#ifdef STD_CLEARCOAT_TEXTURE\n	ccSpecularity *= texture2DBias({STD_CLEARCOAT_TEXTURE_NAME}, {STD_CLEARCOAT_TEXTURE_UV}, textureBias).{STD_CLEARCOAT_TEXTURE_CHANNEL};\n	#endif\n	#ifdef STD_CLEARCOAT_VERTEX\n	ccSpecularity *= saturate(vVertexColor.{STD_CLEARCOAT_VERTEX_CHANNEL});\n	#endif\n}\n";
            
            var clearCoatGlossPS = "\n#ifdef STD_CLEARCOATGLOSS_CONSTANT\nuniform float material_clearCoatGloss;\n#endif\nvoid getClearCoatGlossiness() {\n	ccGlossiness = 1.0;\n	#ifdef STD_CLEARCOATGLOSS_CONSTANT\n	ccGlossiness *= material_clearCoatGloss;\n	#endif\n	#ifdef STD_CLEARCOATGLOSS_TEXTURE\n	ccGlossiness *= texture2DBias({STD_CLEARCOATGLOSS_TEXTURE_NAME}, {STD_CLEARCOATGLOSS_TEXTURE_UV}, textureBias).{STD_CLEARCOATGLOSS_TEXTURE_CHANNEL};\n	#endif\n	#ifdef STD_CLEARCOATGLOSS_VERTEX\n	ccGlossiness *= saturate(vVertexColor.{STD_CLEARCOATGLOSS_VERTEX_CHANNEL});\n	#endif\n	#ifdef STD_CLEARCOATGLOSS_INVERT\n	ccGlossiness = 1.0 - ccGlossiness;\n	#endif\n	ccGlossiness += 0.0000001;\n}\n";
            
            var clearCoatNormalPS = "\n#ifdef STD_CLEARCOATNORMAL_TEXTURE\nuniform float material_clearCoatBumpiness;\n#endif\nvoid getClearCoatNormal() {\n#ifdef STD_CLEARCOATNORMAL_TEXTURE\n	vec3 normalMap = {STD_CLEARCOATNORMAL_TEXTURE_DECODE}(texture2DBias({STD_CLEARCOATNORMAL_TEXTURE_NAME}, {STD_CLEARCOATNORMAL_TEXTURE_UV}, textureBias));\n	normalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_clearCoatBumpiness);\n	ccNormalW = normalize(dTBN * normalMap);\n#else\n	ccNormalW = dVertexNormalW;\n#endif\n}\n";
            
            var clusteredLightUtilsPS = "\nvec2 getCubemapFaceCoordinates(const vec3 dir, out float faceIndex, out vec2 tileOffset)\n{\n	vec3 vAbs = abs(dir);\n	float ma;\n	vec2 uv;\n	if (vAbs.z >= vAbs.x && vAbs.z >= vAbs.y) {\n		faceIndex = dir.z < 0.0 ? 5.0 : 4.0;\n		ma = 0.5 / vAbs.z;\n		uv = vec2(dir.z < 0.0 ? -dir.x : dir.x, -dir.y);\n		tileOffset.x = 2.0;\n		tileOffset.y = dir.z < 0.0 ? 1.0 : 0.0;\n	} else if(vAbs.y >= vAbs.x) {\n		faceIndex = dir.y < 0.0 ? 3.0 : 2.0;\n		ma = 0.5 / vAbs.y;\n		uv = vec2(dir.x, dir.y < 0.0 ? -dir.z : dir.z);\n		tileOffset.x = 1.0;\n		tileOffset.y = dir.y < 0.0 ? 1.0 : 0.0;\n	} else {\n		faceIndex = dir.x < 0.0 ? 1.0 : 0.0;\n		ma = 0.5 / vAbs.x;\n		uv = vec2(dir.x < 0.0 ? dir.z : -dir.z, -dir.y);\n		tileOffset.x = 0.0;\n		tileOffset.y = dir.x < 0.0 ? 1.0 : 0.0;\n	}\n	return uv * ma + 0.5;\n}\nvec2 getCubemapAtlasCoordinates(const vec3 omniAtlasViewport, float shadowEdgePixels, float shadowTextureResolution, const vec3 dir) {\n	float faceIndex;\n	vec2 tileOffset;\n	vec2 uv = getCubemapFaceCoordinates(dir, faceIndex, tileOffset);\n	float atlasFaceSize = omniAtlasViewport.z;\n	float tileSize = shadowTextureResolution * atlasFaceSize;\n	float offset = shadowEdgePixels / tileSize;\n	uv = uv * vec2(1.0 - offset * 2.0) + vec2(offset * 1.0);\n	uv *= atlasFaceSize;\n	uv += tileOffset * atlasFaceSize;\n	uv += omniAtlasViewport.xy;\n	return uv;\n}\n";
            
            var clusteredLightCookiesPS = "\nvec3 _getCookieClustered(TEXTURE_ACCEPT(tex), vec2 uv, float intensity, vec4 cookieChannel) {\n	vec4 pixel = mix(vec4(1.0), texture2DLod(tex, uv, 0.0), intensity);\n	bool isRgb = dot(cookieChannel.rgb, vec3(1.0)) == 3.0;\n	return isRgb ? pixel.rgb : vec3(dot(pixel, cookieChannel));\n}\nvec3 getCookie2DClustered(TEXTURE_ACCEPT(tex), mat4 transform, vec3 worldPosition, float intensity, vec4 cookieChannel) {\n	vec4 projPos = transform * vec4(worldPosition, 1.0);\n	return _getCookieClustered(TEXTURE_PASS(tex), projPos.xy / projPos.w, intensity, cookieChannel);\n}\nvec3 getCookieCubeClustered(TEXTURE_ACCEPT(tex), vec3 dir, float intensity, vec4 cookieChannel, float shadowTextureResolution, float shadowEdgePixels, vec3 omniAtlasViewport) {\n	vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n	return _getCookieClustered(TEXTURE_PASS(tex), uv, intensity, cookieChannel);\n}\n";
            
            var clusteredLightShadowsPS = "\nvec3 _getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n	vec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n	projPos.xyz /= projPos.w;\n	return projPos.xyz;\n}\nvec3 getShadowCoordPerspZbufferNormalOffset(mat4 shadowMatrix, vec4 shadowParams, vec3 normal) {\n	vec3 wPos = vPositionW + normal * shadowParams.y;\n	return _getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);\n}\nvec3 normalOffsetPointShadow(vec4 shadowParams, vec3 lightPos, inout vec3 lightDir, vec3 lightDirNorm, vec3 normal) {\n	float distScale = length(lightDir);\n	vec3 wPos = vPositionW + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;\n	vec3 dir = wPos - lightPos;\n	return dir;\n}\n#if defined(CLUSTER_SHADOW_TYPE_PCF1)\nfloat getShadowOmniClusteredPCF1(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {\n	float shadowTextureResolution = shadowParams.x;\n	vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);\n	float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;\n	return textureShadow(shadowMap, vec3(uv, shadowZ));\n}\n#endif\n#if defined(CLUSTER_SHADOW_TYPE_PCF3)\nfloat getShadowOmniClusteredPCF3(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {\n	float shadowTextureResolution = shadowParams.x;\n	vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);\n	float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;\n	vec3 shadowCoord = vec3(uv, shadowZ);\n	return getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);\n}\n#endif\n#if defined(CLUSTER_SHADOW_TYPE_PCF5)\nfloat getShadowOmniClusteredPCF5(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {\n	float shadowTextureResolution = shadowParams.x;\n	vec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);\n	float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;\n	vec3 shadowCoord = vec3(uv, shadowZ);\n	return getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);\n}\n#endif\n#if defined(CLUSTER_SHADOW_TYPE_PCF1)\nfloat getShadowSpotClusteredPCF1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n	return textureShadow(shadowMap, shadowCoord);\n}\n#endif\n#if defined(CLUSTER_SHADOW_TYPE_PCF3)\nfloat getShadowSpotClusteredPCF3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n	return getShadowSpotPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);\n}\n#endif\n#if defined(CLUSTER_SHADOW_TYPE_PCF5)\nfloat getShadowSpotClusteredPCF5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n	return getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);\n}\n#endif\n";
            
            var clusteredLightPS = '\n#include "lightBufferDefinesPS"\n#include "clusteredLightUtilsPS"\n#ifdef CLUSTER_COOKIES\n	#include "clusteredLightCookiesPS"\n#endif\n#ifdef CLUSTER_SHADOWS\n	#include "clusteredLightShadowsPS"\n#endif\nuniform highp sampler2D clusterWorldTexture;\nuniform highp sampler2D lightsTexture;\n#ifdef CLUSTER_SHADOWS\n	uniform sampler2DShadow shadowAtlasTexture;\n#endif\n#ifdef CLUSTER_COOKIES\n	uniform sampler2D cookieAtlasTexture;\n#endif\nuniform int clusterMaxCells;\nuniform float clusterSkip;\nuniform vec3 clusterCellsCountByBoundsSize;\nuniform vec3 clusterTextureSize;\nuniform vec3 clusterBoundsMin;\nuniform vec3 clusterBoundsDelta;\nuniform vec3 clusterCellsDot;\nuniform vec3 clusterCellsMax;\nuniform vec2 shadowAtlasParams;\nstruct ClusterLightData {\n	uint flags;\n	vec3 halfWidth;\n	bool isSpot;\n	vec3 halfHeight;\n	int lightIndex;\n	vec3 position;\n	uint shape;\n	vec3 direction;\n	bool falloffModeLinear;\n	vec3 color;\n	float shadowIntensity;\n	vec3 omniAtlasViewport;\n	float range;\n	vec4 cookieChannelMask;\n	float biasesData;\n	float shadowBias;\n	float shadowNormalBias;\n	float anglesData;\n	float innerConeAngleCos;\n	float outerConeAngleCos;\n	float cookieIntensity;\n	bool isDynamic;\n	bool isLightmapped;\n};\nmat4 lightProjectionMatrix;\nvec4 sampleLightTextureF(const ClusterLightData clusterLightData, int index) {\n	return texelFetch(lightsTexture, ivec2(index, clusterLightData.lightIndex), 0);\n}\nvoid decodeClusterLightCore(inout ClusterLightData clusterLightData, float lightIndex) {\n	clusterLightData.lightIndex = int(lightIndex);\n	vec4 halfData = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_COLOR_ANGLES_BIAS);\n	clusterLightData.anglesData = halfData.z;\n	clusterLightData.biasesData = halfData.w;\n	vec2 colorRG = unpackHalf2x16(floatBitsToUint(halfData.x));\n	vec2 colorB_ = unpackHalf2x16(floatBitsToUint(halfData.y));\n	clusterLightData.color = vec3(colorRG, colorB_.x) * {LIGHT_COLOR_DIVIDER};\n	vec4 lightPosRange = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_POSITION_RANGE);\n	clusterLightData.position = lightPosRange.xyz;\n	clusterLightData.range = lightPosRange.w;\n	vec4 lightDir_Flags = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_DIRECTION_FLAGS);\n	clusterLightData.direction = lightDir_Flags.xyz;\n	clusterLightData.flags = floatBitsToUint(lightDir_Flags.w);\n	clusterLightData.isSpot = (clusterLightData.flags & (1u << 30u)) != 0u;\n	clusterLightData.shape = (clusterLightData.flags >> 28u) & 0x3u;\n	clusterLightData.falloffModeLinear = (clusterLightData.flags & (1u << 27u)) == 0u;\n	clusterLightData.shadowIntensity = float((clusterLightData.flags >> 0u) & 0xFFu) / 255.0;\n	clusterLightData.cookieIntensity = float((clusterLightData.flags >> 8u) & 0xFFu) / 255.0;\n	clusterLightData.isDynamic = (clusterLightData.flags & (1u << 22u)) != 0u;\n	clusterLightData.isLightmapped = (clusterLightData.flags & (1u << 21u)) != 0u;\n}\nvoid decodeClusterLightSpot(inout ClusterLightData clusterLightData) {\n	vec2 angles = unpackHalf2x16(floatBitsToUint(clusterLightData.anglesData));\n	clusterLightData.innerConeAngleCos = angles.x;\n	clusterLightData.outerConeAngleCos = angles.y;\n}\nvoid decodeClusterLightOmniAtlasViewport(inout ClusterLightData clusterLightData) {\n	clusterLightData.omniAtlasViewport = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_PROJ_MAT_0).xyz;\n}\nvoid decodeClusterLightAreaData(inout ClusterLightData clusterLightData) {\n	clusterLightData.halfWidth = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_AREA_DATA_WIDTH).xyz;\n	clusterLightData.halfHeight = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_AREA_DATA_HEIGHT).xyz;\n}\nvoid decodeClusterLightProjectionMatrixData(inout ClusterLightData clusterLightData) {\n	\n	vec4 m0 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_PROJ_MAT_0);\n	vec4 m1 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_PROJ_MAT_1);\n	vec4 m2 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_PROJ_MAT_2);\n	vec4 m3 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_PROJ_MAT_3);\n	lightProjectionMatrix = mat4(m0, m1, m2, m3);\n}\nvoid decodeClusterLightShadowData(inout ClusterLightData clusterLightData) {\n	\n	vec2 biases = unpackHalf2x16(floatBitsToUint(clusterLightData.biasesData));\n	clusterLightData.shadowBias = biases.x;\n	clusterLightData.shadowNormalBias = biases.y;\n}\nvoid decodeClusterLightCookieData(inout ClusterLightData clusterLightData) {\n	uint cookieFlags = (clusterLightData.flags >> 23u) & 0x0Fu;\n	clusterLightData.cookieChannelMask = vec4(uvec4(cookieFlags) & uvec4(1u, 2u, 4u, 8u));\n	clusterLightData.cookieChannelMask = step(1.0, clusterLightData.cookieChannelMask);\n}\nvoid evaluateLight(\n	ClusterLightData light, \n	vec3 worldNormal, \n	vec3 viewDir, \n	vec3 reflectionDir,\n#if defined(LIT_CLEARCOAT)\n	vec3 clearcoatReflectionDir,\n#endif\n	float gloss, \n	vec3 specularity, \n	vec3 geometricNormal, \n	mat3 tbn, \n#if defined(LIT_IRIDESCENCE)\n	vec3 iridescenceFresnel,\n#endif\n	vec3 clearcoat_worldNormal,\n	float clearcoat_gloss,\n	float sheen_gloss,\n	float iridescence_intensity\n) {\n	vec3 cookieAttenuation = vec3(1.0);\n	float diffuseAttenuation = 1.0;\n	float falloffAttenuation = 1.0;\n	vec3 lightDirW;\n	vec3 lightDirNormW;\n	evalOmniLight(light.position, lightDirW, lightDirNormW);\n	#ifdef CLUSTER_AREALIGHTS\n	if (light.shape != {LIGHTSHAPE_PUNCTUAL}) {\n		decodeClusterLightAreaData(light);\n		if (light.shape == {LIGHTSHAPE_RECT}) {\n			calcRectLightValues(light.position, light.halfWidth, light.halfHeight);\n		} else if (light.shape == {LIGHTSHAPE_DISK}) {\n			calcDiskLightValues(light.position, light.halfWidth, light.halfHeight);\n		} else {\n			calcSphereLightValues(light.position, light.halfWidth, light.halfHeight);\n		}\n		falloffAttenuation = getFalloffWindow(light.range, lightDirW);\n	} else\n	#endif\n	{\n		if (light.falloffModeLinear)\n			falloffAttenuation = getFalloffLinear(light.range, lightDirW);\n		else\n			falloffAttenuation = getFalloffInvSquared(light.range, lightDirW);\n	}\n	if (falloffAttenuation > 0.00001) {\n		#ifdef CLUSTER_AREALIGHTS\n		if (light.shape != {LIGHTSHAPE_PUNCTUAL}) {\n			if (light.shape == {LIGHTSHAPE_RECT}) {\n				diffuseAttenuation = getRectLightDiffuse(worldNormal, viewDir, lightDirW, lightDirNormW) * 16.0;\n			} else if (light.shape == {LIGHTSHAPE_DISK}) {\n				diffuseAttenuation = getDiskLightDiffuse(worldNormal, viewDir, lightDirW, lightDirNormW) * 16.0;\n			} else {\n				diffuseAttenuation = getSphereLightDiffuse(worldNormal, viewDir, lightDirW, lightDirNormW) * 16.0;\n			}\n		} else\n		#endif\n		{\n			falloffAttenuation *= getLightDiffuse(worldNormal, viewDir, lightDirNormW); \n		}\n		if (light.isSpot) {\n			decodeClusterLightSpot(light);\n			falloffAttenuation *= getSpotEffect(light.direction, light.innerConeAngleCos, light.outerConeAngleCos, lightDirNormW);\n		}\n		#if defined(CLUSTER_COOKIES) || defined(CLUSTER_SHADOWS)\n		if (falloffAttenuation > 0.00001) {\n			if (light.shadowIntensity > 0.0 || light.cookieIntensity > 0.0) {\n				if (light.isSpot) {\n					decodeClusterLightProjectionMatrixData(light);\n				} else {\n					decodeClusterLightOmniAtlasViewport(light);\n				}\n				float shadowTextureResolution = shadowAtlasParams.x;\n				float shadowEdgePixels = shadowAtlasParams.y;\n				#ifdef CLUSTER_COOKIES\n				if (light.cookieIntensity > 0.0) {\n					decodeClusterLightCookieData(light);\n					if (light.isSpot) {\n						cookieAttenuation = getCookie2DClustered(TEXTURE_PASS(cookieAtlasTexture), lightProjectionMatrix, vPositionW, light.cookieIntensity, light.cookieChannelMask);\n					} else {\n						cookieAttenuation = getCookieCubeClustered(TEXTURE_PASS(cookieAtlasTexture), lightDirW, light.cookieIntensity, light.cookieChannelMask, shadowTextureResolution, shadowEdgePixels, light.omniAtlasViewport);\n					}\n				}\n				#endif\n				#ifdef CLUSTER_SHADOWS\n				if (light.shadowIntensity > 0.0) {\n					decodeClusterLightShadowData(light);\n					vec4 shadowParams = vec4(shadowTextureResolution, light.shadowNormalBias, light.shadowBias, 1.0 / light.range);\n					if (light.isSpot) {\n						vec3 shadowCoord = getShadowCoordPerspZbufferNormalOffset(lightProjectionMatrix, shadowParams, geometricNormal);\n						\n						#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n							float shadow = getShadowSpotClusteredPCF1(SHADOWMAP_PASS(shadowAtlasTexture), shadowCoord, shadowParams);\n						#elif defined(CLUSTER_SHADOW_TYPE_PCF3)\n							float shadow = getShadowSpotClusteredPCF3(SHADOWMAP_PASS(shadowAtlasTexture), shadowCoord, shadowParams);\n						#elif defined(CLUSTER_SHADOW_TYPE_PCF5)\n							float shadow = getShadowSpotClusteredPCF5(SHADOWMAP_PASS(shadowAtlasTexture), shadowCoord, shadowParams);\n						#elif defined(CLUSTER_SHADOW_TYPE_PCSS)\n							float shadow = getShadowSpotClusteredPCSS(SHADOWMAP_PASS(shadowAtlasTexture), shadowCoord, shadowParams);\n						#endif\n						falloffAttenuation *= mix(1.0, shadow, light.shadowIntensity);\n					} else {\n						vec3 dir = normalOffsetPointShadow(shadowParams, light.position, lightDirW, lightDirNormW, geometricNormal);\n						#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n							float shadow = getShadowOmniClusteredPCF1(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);\n						#elif defined(CLUSTER_SHADOW_TYPE_PCF3)\n							float shadow = getShadowOmniClusteredPCF3(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);\n						#elif defined(CLUSTER_SHADOW_TYPE_PCF5)\n							float shadow = getShadowOmniClusteredPCF5(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);\n						#endif\n						falloffAttenuation *= mix(1.0, shadow, light.shadowIntensity);\n					}\n				}\n				#endif\n			}\n		}\n		#endif\n		#ifdef CLUSTER_AREALIGHTS\n		if (light.shape != {LIGHTSHAPE_PUNCTUAL}) {\n			{\n				vec3 areaDiffuse = (diffuseAttenuation * falloffAttenuation) * light.color * cookieAttenuation;\n				#if defined(LIT_SPECULAR)\n					areaDiffuse = mix(areaDiffuse, vec3(0), dLTCSpecFres);\n				#endif\n				dDiffuseLight += areaDiffuse;\n			}\n			#ifdef LIT_SPECULAR\n				float areaLightSpecular;\n				if (light.shape == {LIGHTSHAPE_RECT}) {\n					areaLightSpecular = getRectLightSpecular(worldNormal, viewDir);\n				} else if (light.shape == {LIGHTSHAPE_DISK}) {\n					areaLightSpecular = getDiskLightSpecular(worldNormal, viewDir);\n				} else {\n					areaLightSpecular = getSphereLightSpecular(worldNormal, viewDir);\n				}\n				dSpecularLight += dLTCSpecFres * areaLightSpecular * falloffAttenuation * light.color * cookieAttenuation;\n				#ifdef LIT_CLEARCOAT\n					float areaLightSpecularCC;\n					if (light.shape == {LIGHTSHAPE_RECT}) {\n						areaLightSpecularCC = getRectLightSpecular(clearcoat_worldNormal, viewDir);\n					} else if (light.shape == {LIGHTSHAPE_DISK}) {\n						areaLightSpecularCC = getDiskLightSpecular(clearcoat_worldNormal, viewDir);\n					} else {\n						areaLightSpecularCC = getSphereLightSpecular(clearcoat_worldNormal, viewDir);\n					}\n					ccSpecularLight += ccLTCSpecFres * areaLightSpecularCC * falloffAttenuation * light.color  * cookieAttenuation;\n				#endif\n			#endif\n		} else\n		#endif\n		{\n			{\n				vec3 punctualDiffuse = falloffAttenuation * light.color * cookieAttenuation;\n				#if defined(CLUSTER_AREALIGHTS)\n				#if defined(LIT_SPECULAR)\n					punctualDiffuse = mix(punctualDiffuse, vec3(0), specularity);\n				#endif\n				#endif\n				dDiffuseLight += punctualDiffuse;\n			}\n   \n			#ifdef LIT_SPECULAR\n				vec3 halfDir = normalize(-lightDirNormW + viewDir);\n				\n				#ifdef LIT_SPECULAR_FRESNEL\n					dSpecularLight += \n						getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, lightDirNormW, gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * \n						getFresnel(\n							dot(viewDir, halfDir), \n							gloss, \n							specularity\n						#if defined(LIT_IRIDESCENCE)\n							, iridescenceFresnel,\n							iridescence_intensity\n						#endif\n							);\n				#else\n					dSpecularLight += getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, lightDirNormW, gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * specularity;\n				#endif\n				#ifdef LIT_CLEARCOAT\n					#ifdef LIT_SPECULAR_FRESNEL\n						ccSpecularLight += getLightSpecular(halfDir, clearcoatReflectionDir, clearcoat_worldNormal, viewDir, lightDirNormW, clearcoat_gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * getFresnelCC(dot(viewDir, halfDir));\n					#else\n						ccSpecularLight += getLightSpecular(halfDir, clearcoatReflectionDir, clearcoat_worldNormal, viewDir, lightDirNormW, clearcoat_gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation; \n					#endif\n				#endif\n				#ifdef LIT_SHEEN\n					sSpecularLight += getLightSpecularSheen(halfDir, worldNormal, viewDir, lightDirNormW, sheen_gloss) * falloffAttenuation * light.color * cookieAttenuation;\n				#endif\n			#endif\n		}\n	}\n	dAtten = falloffAttenuation;\n	dLightDirNormW = lightDirNormW;\n}\nvoid evaluateClusterLight(\n	float lightIndex, \n	vec3 worldNormal, \n	vec3 viewDir, \n	vec3 reflectionDir, \n#if defined(LIT_CLEARCOAT)\n	vec3 clearcoatReflectionDir,\n#endif\n	float gloss, \n	vec3 specularity, \n	vec3 geometricNormal, \n	mat3 tbn, \n#if defined(LIT_IRIDESCENCE)\n	vec3 iridescenceFresnel,\n#endif\n	vec3 clearcoat_worldNormal,\n	float clearcoat_gloss,\n	float sheen_gloss,\n	float iridescence_intensity\n) {\n	ClusterLightData clusterLightData;\n	decodeClusterLightCore(clusterLightData, lightIndex);\n	#ifdef CLUSTER_MESH_DYNAMIC_LIGHTS\n		bool acceptLightMask = clusterLightData.isDynamic;\n	#else\n		bool acceptLightMask = clusterLightData.isLightmapped;\n	#endif\n	if (acceptLightMask)\n		evaluateLight(\n			clusterLightData, \n			worldNormal, \n			viewDir, \n			reflectionDir, \n#if defined(LIT_CLEARCOAT)\n			clearcoatReflectionDir, \n#endif\n			gloss, \n			specularity, \n			geometricNormal, \n			tbn, \n#if defined(LIT_IRIDESCENCE)\n			iridescenceFresnel,\n#endif\n			clearcoat_worldNormal,\n			clearcoat_gloss,\n			sheen_gloss,\n			iridescence_intensity\n		);\n}\nvoid addClusteredLights(\n	vec3 worldNormal, \n	vec3 viewDir, \n	vec3 reflectionDir, \n#if defined(LIT_CLEARCOAT)\n	vec3 clearcoatReflectionDir,\n#endif\n	float gloss, \n	vec3 specularity, \n	vec3 geometricNormal, \n	mat3 tbn, \n#if defined(LIT_IRIDESCENCE)\n	vec3 iridescenceFresnel,\n#endif\n	vec3 clearcoat_worldNormal,\n	float clearcoat_gloss,\n	float sheen_gloss,\n	float iridescence_intensity\n) {\n	if (clusterSkip > 0.5)\n		return;\n	vec3 cellCoords = floor((vPositionW - clusterBoundsMin) * clusterCellsCountByBoundsSize);\n	if (!(any(lessThan(cellCoords, vec3(0.0))) || any(greaterThanEqual(cellCoords, clusterCellsMax)))) {\n		float cellIndex = dot(clusterCellsDot, cellCoords);\n		float clusterV = floor(cellIndex * clusterTextureSize.y);\n		float clusterU = cellIndex - (clusterV * clusterTextureSize.x);\n		for (int lightCellIndex = 0; lightCellIndex < clusterMaxCells; lightCellIndex++) {\n			float lightIndex = texelFetch(clusterWorldTexture, ivec2(int(clusterU) + lightCellIndex, clusterV), 0).x;\n			if (lightIndex <= 0.0)\n					return;\n			evaluateClusterLight(\n				lightIndex * 255.0, \n				worldNormal, \n				viewDir, \n				reflectionDir,\n#if defined(LIT_CLEARCOAT)\n				clearcoatReflectionDir,\n#endif\n				gloss, \n				specularity, \n				geometricNormal, \n				tbn, \n#if defined(LIT_IRIDESCENCE)\n				iridescenceFresnel,\n#endif\n				clearcoat_worldNormal,\n				clearcoat_gloss,\n				sheen_gloss,\n				iridescence_intensity\n			); \n		}\n	}\n}\n';
            
            var combinePS$1 = "\nvec3 combineColor(vec3 albedo, vec3 sheenSpecularity, float clearcoatSpecularity) {\n	vec3 ret = vec3(0);\n#ifdef LIT_OLD_AMBIENT\n	ret += (dDiffuseLight - light_globalAmbient) * albedo + material_ambient * light_globalAmbient;\n#else\n	ret += albedo * dDiffuseLight;\n#endif\n#ifdef LIT_SPECULAR\n	ret += dSpecularLight;\n#endif\n#ifdef LIT_REFLECTIONS\n	ret += dReflection.rgb * dReflection.a;\n#endif\n#ifdef LIT_SHEEN\n	float sheenScaling = 1.0 - max(max(sheenSpecularity.r, sheenSpecularity.g), sheenSpecularity.b) * 0.157;\n	ret = ret * sheenScaling + (sSpecularLight + sReflection.rgb) * sheenSpecularity;\n#endif\n#ifdef LIT_CLEARCOAT\n	float clearCoatScaling = 1.0 - ccFresnel * clearcoatSpecularity;\n	ret = ret * clearCoatScaling + (ccSpecularLight + ccReflection.rgb) * clearcoatSpecularity;\n#endif\n	return ret;\n}\n";
            
            var cookieBlit2DPS$1 = "\n	varying vec2 uv0;\n	uniform sampler2D blitTexture;\n	void main(void) {\n		gl_FragColor = texture2D(blitTexture, uv0);\n	}\n";
            
            var cookieBlitCubePS$1 = "\n	varying vec2 uv0;\n	uniform samplerCube blitTexture;\n	uniform mat4 invViewProj;\n	void main(void) {\n		vec4 projPos = vec4(uv0 * 2.0 - 1.0, 0.5, 1.0);\n		vec4 worldPos = invViewProj * projPos;\n		gl_FragColor = textureCube(blitTexture, worldPos.xyz);\n	}\n";
            
            var cookieBlitVS$1 = "\n	attribute vec2 vertex_position;\n	varying vec2 uv0;\n	void main(void) {\n		gl_Position = vec4(vertex_position, 0.5, 1.0);\n		uv0 = vertex_position.xy * 0.5 + 0.5;\n		#ifndef WEBGPU\n			uv0.y = 1.0 - uv0.y;\n		#endif\n	}\n";
            
            var cookiePS = "\nvec4 getCookie2D(sampler2D tex, mat4 transform, float intensity) {\n	vec4 projPos = transform * vec4(vPositionW, 1.0);\n	projPos.xy /= projPos.w;\n	return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\nvec4 getCookie2DClip(sampler2D tex, mat4 transform, float intensity) {\n	vec4 projPos = transform * vec4(vPositionW, 1.0);\n	projPos.xy /= projPos.w;\n	if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n	return mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\nvec4 getCookie2DXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n	vec4 projPos = transform * vec4(vPositionW, 1.0);\n	projPos.xy /= projPos.w;\n	projPos.xy += cookieOffset;\n	vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n	return mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\nvec4 getCookie2DClipXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n	vec4 projPos = transform * vec4(vPositionW, 1.0);\n	projPos.xy /= projPos.w;\n	projPos.xy += cookieOffset;\n	if (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n	vec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n	return mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\nvec4 getCookieCube(samplerCube tex, mat4 transform, float intensity) {\n	return mix(vec4(1.0), textureCube(tex, dLightDirNormW * mat3(transform)), intensity);\n}\n";
            
            var cubeMapProjectPS = "\n#if LIT_CUBEMAP_PROJECTION == BOX\n	uniform vec3 envBoxMin;\n	uniform vec3 envBoxMax;\n#endif\nvec3 cubeMapProject(vec3 nrdir) {\n	#if LIT_CUBEMAP_PROJECTION == NONE\n		return cubeMapRotate(nrdir);\n	#endif\n	#if LIT_CUBEMAP_PROJECTION == BOX\n		nrdir = cubeMapRotate(nrdir);\n		vec3 rbmax = (envBoxMax - vPositionW) / nrdir;\n		vec3 rbmin = (envBoxMin - vPositionW) / nrdir;\n		vec3 rbminmax;\n		rbminmax.x = nrdir.x>0.0? rbmax.x : rbmin.x;\n		rbminmax.y = nrdir.y>0.0? rbmax.y : rbmin.y;\n		rbminmax.z = nrdir.z>0.0? rbmax.z : rbmin.z;\n		float fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);\n		vec3 posonbox = vPositionW + nrdir * fa;\n		vec3 envBoxPos = (envBoxMin + envBoxMax) * 0.5;\n		return normalize(posonbox - envBoxPos);\n	#endif\n}\n";
            
            var cubeMapRotatePS = "\n#ifdef CUBEMAP_ROTATION\nuniform mat3 cubeMapRotationMatrix;\n#endif\nvec3 cubeMapRotate(vec3 refDir) {\n#ifdef CUBEMAP_ROTATION\n	return refDir * cubeMapRotationMatrix;\n#else\n	return refDir;\n#endif\n}\n";
            
            var debugOutputPS$1 = "\n#ifdef DEBUG_ALBEDO_PASS\ngl_FragColor = vec4(gammaCorrectOutput(dAlbedo), 1.0);\n#endif\n#ifdef DEBUG_UV0_PASS\ngl_FragColor = vec4(litArgs_albedo , 1.0);\n#endif\n#ifdef DEBUG_WORLD_NORMAL_PASS\ngl_FragColor = vec4(litArgs_worldNormal * 0.5 + 0.5, 1.0);\n#endif\n#ifdef DEBUG_OPACITY_PASS\ngl_FragColor = vec4(vec3(litArgs_opacity) , 1.0);\n#endif\n#ifdef DEBUG_SPECULARITY_PASS\ngl_FragColor = vec4(litArgs_specularity, 1.0);\n#endif\n#ifdef DEBUG_GLOSS_PASS\ngl_FragColor = vec4(vec3(litArgs_gloss) , 1.0);\n#endif\n#ifdef DEBUG_METALNESS_PASS\ngl_FragColor = vec4(vec3(litArgs_metalness) , 1.0);\n#endif\n#ifdef DEBUG_AO_PASS\ngl_FragColor = vec4(vec3(litArgs_ao) , 1.0);\n#endif\n#ifdef DEBUG_EMISSION_PASS\ngl_FragColor = vec4(gammaCorrectOutput(litArgs_emission), 1.0);\n#endif\n";
            
            var debugProcessFrontendPS$1 = "\n#ifdef DEBUG_LIGHTING_PASS\nlitArgs_albedo = vec3(0.5);\n#endif\n#ifdef DEBUG_UV0_PASS\n#ifdef VARYING_VUV0\nlitArgs_albedo = vec3(vUv0, 0);\n#else\nlitArgs_albedo = vec3(0);\n#endif\n#endif\n";
            
            var decodePS$1 = "\n#ifndef _DECODE_INCLUDED_\n#define _DECODE_INCLUDED_\nvec3 decodeLinear(vec4 raw) {\n	return raw.rgb;\n}\nfloat decodeGamma(float raw) {\n	return pow(raw, 2.2);\n}\nvec3 decodeGamma(vec3 raw) {\n	return pow(raw, vec3(2.2));\n}\nvec3 decodeGamma(vec4 raw) {\n	return pow(raw.xyz, vec3(2.2));\n}\nvec3 decodeRGBM(vec4 raw) {\n	vec3 color = (8.0 * raw.a) * raw.rgb;\n	return color * color;\n}\nvec3 decodeRGBP(vec4 raw) {\n	vec3 color = raw.rgb * (-raw.a * 7.0 + 8.0);\n	return color * color;\n}\nvec3 decodeRGBE(vec4 raw) {\n	if (raw.a == 0.0) {\n		return vec3(0.0, 0.0, 0.0);\n	} else {\n		return raw.xyz * pow(2.0, raw.w * 255.0 - 128.0);\n	}\n}\nvec4 passThrough(vec4 raw) {\n	return raw;\n}\nvec3 unpackNormalXYZ(vec4 nmap) {\n	return nmap.xyz * 2.0 - 1.0;\n}\nvec3 unpackNormalXY(vec4 nmap) {\n	vec3 normal;\n	normal.xy = nmap.wy * 2.0 - 1.0;\n	normal.z = sqrt(1.0 - clamp(dot(normal.xy, normal.xy), 0.0, 1.0));\n	return normal;\n}\n#endif\n";
            
            var detailModesPS = "\n#ifndef _DETAILMODES_INCLUDED_\n#define _DETAILMODES_INCLUDED_\nvec3 detailMode_mul(vec3 c1, vec3 c2) {\n	return c1 * c2;\n}\nvec3 detailMode_add(vec3 c1, vec3 c2) {\n	return c1 + c2;\n}\nvec3 detailMode_screen(vec3 c1, vec3 c2) {\n	return 1.0 - (1.0 - c1)*(1.0 - c2);\n}\nvec3 detailMode_overlay(vec3 c1, vec3 c2) {\n	return mix(1.0 - 2.0*(1.0 - c1)*(1.0 - c2), 2.0*c1*c2, step(c1, vec3(0.5)));\n}\nvec3 detailMode_min(vec3 c1, vec3 c2) {\n	return min(c1, c2);\n}\nvec3 detailMode_max(vec3 c1, vec3 c2) {\n	return max(c1, c2);\n}\n#endif\n";
            
            var diffusePS = '\nuniform vec3 material_diffuse;\n#ifdef STD_DIFFUSEDETAIL_TEXTURE\n	#include "detailModesPS"\n#endif\nvoid getAlbedo() {\n	dAlbedo = material_diffuse.rgb;\n	#ifdef STD_DIFFUSE_TEXTURE\n		vec3 albedoTexture = {STD_DIFFUSE_TEXTURE_DECODE}(texture2DBias({STD_DIFFUSE_TEXTURE_NAME}, {STD_DIFFUSE_TEXTURE_UV}, textureBias)).{STD_DIFFUSE_TEXTURE_CHANNEL};\n		#ifdef STD_DIFFUSEDETAIL_TEXTURE\n			vec3 albedoDetail = {STD_DIFFUSEDETAIL_TEXTURE_DECODE}(texture2DBias({STD_DIFFUSEDETAIL_TEXTURE_NAME}, {STD_DIFFUSEDETAIL_TEXTURE_UV}, textureBias)).{STD_DIFFUSEDETAIL_TEXTURE_CHANNEL};\n			albedoTexture = detailMode_{STD_DIFFUSEDETAIL_DETAILMODE}(albedoTexture, albedoDetail);\n		#endif\n		dAlbedo *= albedoTexture;\n	#endif\n	#ifdef STD_DIFFUSE_VERTEX\n		dAlbedo *= gammaCorrectInput(saturate(vVertexColor.{STD_DIFFUSE_VERTEX_CHANNEL}));\n	#endif\n}\n';
            
            var emissivePS = "\nuniform vec3 material_emissive;\nuniform float material_emissiveIntensity;\nvoid getEmission() {\n	dEmission = material_emissive * material_emissiveIntensity;\n	#ifdef STD_EMISSIVE_TEXTURE\n	dEmission *= {STD_EMISSIVE_TEXTURE_DECODE}(texture2DBias({STD_EMISSIVE_TEXTURE_NAME}, {STD_EMISSIVE_TEXTURE_UV}, textureBias)).{STD_EMISSIVE_TEXTURE_CHANNEL};\n	#endif\n	#ifdef STD_EMISSIVE_VERTEX\n	dEmission *= gammaCorrectInput(saturate(vVertexColor.{STD_EMISSIVE_VERTEX_CHANNEL}));\n	#endif\n}\n";
            
            var encodePS$1 = "\nvec4 encodeLinear(vec3 source) {\n	return vec4(source, 1.0);\n}\nvec4 encodeGamma(vec3 source) {\n	return vec4(pow(source + 0.0000001, vec3(1.0 / 2.2)), 1.0);\n}\nvec4 encodeRGBM(vec3 source) {\n	vec4 result;\n	result.rgb = pow(source.rgb, vec3(0.5));\n	result.rgb *= 1.0 / 8.0;\n	result.a = saturate( max( max( result.r, result.g ), max( result.b, 1.0 / 255.0 ) ) );\n	result.a = ceil(result.a * 255.0) / 255.0;\n	result.rgb /= result.a;\n	return result;\n}\nvec4 encodeRGBP(vec3 source) {\n	vec3 gamma = pow(source, vec3(0.5));\n	float maxVal = min(8.0, max(1.0, max(gamma.x, max(gamma.y, gamma.z))));\n	float v = 1.0 - ((maxVal - 1.0) / 7.0);\n	v = ceil(v * 255.0) / 255.0;\n	return vec4(gamma / (-v * 7.0 + 8.0), v);	\n}\nvec4 encodeRGBE(vec3 source) {\n	float maxVal = max(source.x, max(source.y, source.z));\n	if (maxVal < 1e-32) {\n		return vec4(0, 0, 0, 0);\n	} else {\n		float e = ceil(log2(maxVal));\n		return vec4(source / pow(2.0, e), (e + 128.0) / 255.0);\n	}\n}\n";
            
            var endPS$1 = "\n	gl_FragColor.rgb = combineColor(litArgs_albedo, litArgs_sheen_specularity, litArgs_clearcoat_specularity);\n	gl_FragColor.rgb += litArgs_emission;\n	gl_FragColor.rgb = addFog(gl_FragColor.rgb);\n	gl_FragColor.rgb = toneMap(gl_FragColor.rgb);\n	gl_FragColor.rgb = gammaCorrectOutput(gl_FragColor.rgb);\n";
            
            var envAtlasPS$1 = "\n#ifndef _ENVATLAS_INCLUDED_\n#define _ENVATLAS_INCLUDED_\nconst float atlasSize = 512.0;\nconst float seamSize = 1.0 / atlasSize;\nvec2 mapUv(vec2 uv, vec4 rect) {\n	return vec2(mix(rect.x + seamSize, rect.x + rect.z - seamSize, uv.x),\n				mix(rect.y + seamSize, rect.y + rect.w - seamSize, uv.y));\n}\nvec2 mapRoughnessUv(vec2 uv, float level) {\n	float t = 1.0 / exp2(level);\n	return mapUv(uv, vec4(0, 1.0 - t, t, t * 0.5));\n}\nvec2 mapShinyUv(vec2 uv, float level) {\n	float t = 1.0 / exp2(level);\n	return mapUv(uv, vec4(1.0 - t, 1.0 - t, t, t * 0.5));\n}\n#endif\n";
            
            var envProcPS$1 = "\n#ifdef LIT_SKYBOX_INTENSITY\n	uniform float skyboxIntensity;\n#endif\nvec3 processEnvironment(vec3 color) {\n	#ifdef LIT_SKYBOX_INTENSITY\n		return color * skyboxIntensity;\n	#else\n		return color;\n	#endif\n}\n";
            
            var falloffInvSquaredPS = "\nfloat getFalloffWindow(float lightRadius, vec3 lightDir) {\n	float sqrDist = dot(lightDir, lightDir);\n	float invRadius = 1.0 / lightRadius;\n	return square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n}\nfloat getFalloffInvSquared(float lightRadius, vec3 lightDir) {\n	float sqrDist = dot(lightDir, lightDir);\n	float falloff = 1.0 / (sqrDist + 1.0);\n	float invRadius = 1.0 / lightRadius;\n	falloff *= 16.0;\n	falloff *= square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n	return falloff;\n}\n";
            
            var falloffLinearPS = "\nfloat getFalloffLinear(float lightRadius, vec3 lightDir) {\n	float d = length(lightDir);\n	return max(((lightRadius - d) / lightRadius), 0.0);\n}\n";
            
            var floatAsUintPS = "\n#ifndef FLOAT_AS_UINT\n#define FLOAT_AS_UINT\nvec4 float2uint(float value) {\n	uint intBits = floatBitsToUint(value);\n	return vec4(\n		float((intBits >> 24u) & 0xFFu) / 255.0,\n		float((intBits >> 16u) & 0xFFu) / 255.0,\n		float((intBits >> 8u) & 0xFFu) / 255.0,\n		float(intBits & 0xFFu) / 255.0\n	);\n}\nfloat uint2float(vec4 value) {\n	uint intBits = \n		(uint(value.r * 255.0) << 24u) |\n		(uint(value.g * 255.0) << 16u) |\n		(uint(value.b * 255.0) << 8u) |\n		uint(value.a * 255.0);\n	return uintBitsToFloat(intBits);\n}\nvec4 float2vec4(float value) {\n	#if defined(CAPS_TEXTURE_FLOAT_RENDERABLE)\n		return vec4(value, 1.0, 1.0, 1.0);\n	#else\n		return float2uint(value);\n	#endif\n}\n#endif\n";
            
            var fogPS$1 = "\nfloat dBlendModeFogFactor = 1.0;\n#if (FOG != NONE)\n	uniform vec3 fog_color;\n	#if (FOG == LINEAR)\n		uniform float fog_start;\n		uniform float fog_end;\n	#else\n		uniform float fog_density;\n	#endif\n#endif\nfloat getFogFactor() {\n	float depth = gl_FragCoord.z / gl_FragCoord.w;\n	float fogFactor = 0.0;\n	#if (FOG == LINEAR)\n		fogFactor = (fog_end - depth) / (fog_end - fog_start);\n	#elif (FOG == EXP)\n		fogFactor = exp(-depth * fog_density);\n	#elif (FOG == EXP2)\n		fogFactor = exp(-depth * depth * fog_density * fog_density);\n	#endif\n	return clamp(fogFactor, 0.0, 1.0);\n}\nvec3 addFog(vec3 color) {\n	#if (FOG != NONE)\n		return mix(fog_color * dBlendModeFogFactor, color, getFogFactor());\n	#endif\n	return color;\n}\n";
            
            var fresnelSchlickPS = "\nvec3 getFresnel(\n		float cosTheta, \n		float gloss, \n		vec3 specularity\n#if defined(LIT_IRIDESCENCE)\n		, vec3 iridescenceFresnel, \n		float iridescenceIntensity\n#endif\n	) {\n	float fresnel = pow(1.0 - max(cosTheta, 0.0), 5.0);\n	float glossSq = gloss * gloss;\n	vec3 ret = specularity + (max(vec3(glossSq), specularity) - specularity) * fresnel;\n#if defined(LIT_IRIDESCENCE)\n	return mix(ret, iridescenceFresnel, iridescenceIntensity);\n#else\n	return ret;\n#endif	\n}\nfloat getFresnelCC(float cosTheta) {\n	float fresnel = pow(1.0 - max(cosTheta, 0.0), 5.0);\n	return 0.04 + (1.0 - 0.04) * fresnel;\n}\n";
            
            var fullscreenQuadPS = "\nvarying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n	gl_FragColor = texture2D(source, vUv0);\n}\n";
            
            var fullscreenQuadVS = "\nattribute vec2 vertex_position;\nvarying vec2 vUv0;\nvoid main(void)\n{\n	gl_Position = vec4(vertex_position, 0.5, 1.0);\n	vUv0 = vertex_position.xy*0.5+0.5;\n}\n";
            
            var gammaPS$1 = '\n#include "decodePS"\n#if (GAMMA == SRGB)\n	float gammaCorrectInput(float color) {\n		return decodeGamma(color);\n	}\n	vec3 gammaCorrectInput(vec3 color) {\n		return decodeGamma(color);\n	}\n	vec4 gammaCorrectInput(vec4 color) {\n		return vec4(decodeGamma(color.xyz), color.w);\n	}\n	vec3 gammaCorrectOutput(vec3 color) {\n		return pow(color + 0.0000001, vec3(1.0 / 2.2));\n	}\n#else\n	float gammaCorrectInput(float color) {\n		return color;\n	}\n	vec3 gammaCorrectInput(vec3 color) {\n		return color;\n	}\n	vec4 gammaCorrectInput(vec4 color) {\n		return color;\n	}\n	vec3 gammaCorrectOutput(vec3 color) {\n		return color;\n	}\n#endif\n';
            
            var glossPS = "\n#ifdef STD_GLOSS_CONSTANT\nuniform float material_gloss;\n#endif\nvoid getGlossiness() {\n	dGlossiness = 1.0;\n	#ifdef STD_GLOSS_CONSTANT\n	dGlossiness *= material_gloss;\n	#endif\n	#ifdef STD_GLOSS_TEXTURE\n	dGlossiness *= texture2DBias({STD_GLOSS_TEXTURE_NAME}, {STD_GLOSS_TEXTURE_UV}, textureBias).{STD_GLOSS_TEXTURE_CHANNEL};\n	#endif\n	#ifdef STD_GLOSS_VERTEX\n	dGlossiness *= saturate(vVertexColor.{STD_GLOSS_VERTEX_CHANNEL});\n	#endif\n	#ifdef STD_GLOSS_INVERT\n	dGlossiness = 1.0 - dGlossiness;\n	#endif\n	dGlossiness += 0.0000001;\n}\n";
            
            var gsplatCenterVS = "\nuniform mat4 matrix_model;\nuniform mat4 matrix_view;\nuniform mat4 matrix_projection;\nbool initCenter(vec3 modelCenter, out SplatCenter center) {\n	mat4 modelView = matrix_view * matrix_model;\n	vec4 centerView = modelView * vec4(modelCenter, 1.0);\n	if (centerView.z > 0.0) {\n		return false;\n	}\n	vec4 centerProj = matrix_projection * centerView;\n#if WEBGPU\n	centerProj.z = clamp(centerProj.z, 0, abs(centerProj.w));\n#else\n	centerProj.z = clamp(centerProj.z, -abs(centerProj.w), abs(centerProj.w));\n#endif\n	center.view = centerView.xyz / centerView.w;\n	center.proj = centerProj;\n	center.projMat00 = matrix_projection[0][0];\n	center.modelView = modelView;\n	return true;\n}\n";
            
            var gsplatColorVS = "\nuniform mediump sampler2D splatColor;\nvec4 readColor(in SplatSource source) {\n	return texelFetch(splatColor, source.uv, 0);\n}\n";
            
            var gsplatCommonVS = '\nstruct SplatSource {\n	uint order;\n	uint id;\n	ivec2 uv;\n	vec2 cornerUV;\n};\nstruct SplatCenter {\n	vec3 view;\n	vec4 proj;\n	mat4 modelView;\n	float projMat00;\n};\nstruct SplatCorner {\n	vec2 offset;\n	vec2 uv;\n	#if GSPLAT_AA\n		float aaFactor;\n	#endif\n};\n#if SH_BANDS > 0\n	#if SH_BANDS == 1\n		#define SH_COEFFS 3\n	#elif SH_BANDS == 2\n		#define SH_COEFFS 8\n	#elif SH_BANDS == 3\n		#define SH_COEFFS 15\n	#endif\n#endif\n#if GSPLAT_COMPRESSED_DATA == true\n	#include "gsplatCompressedDataVS"\n	#include "gsplatCompressedSHVS"\n#elif GSPLAT_SOGS_DATA == true\n	#include "gsplatSogsDataVS"\n	#include "gsplatSogsColorVS"\n	#include "gsplatSogsSHVS"\n#else\n	#include "gsplatDataVS"\n	#include "gsplatColorVS"\n	#include "gsplatSHVS"\n#endif\n#include "gsplatSourceVS"\n#include "gsplatCenterVS"\n#include "gsplatCornerVS"\n#include "gsplatOutputVS"\nvoid clipCorner(inout SplatCorner corner, float alpha) {\n	float clip = min(1.0, sqrt(-log(1.0 / 255.0 / alpha)) / 2.0);\n	corner.offset *= clip;\n	corner.uv *= clip;\n}\n#if SH_BANDS > 0\n#define SH_C1 0.4886025119029199f\n#if SH_BANDS > 1\n	#define SH_C2_0 1.0925484305920792f\n	#define SH_C2_1 -1.0925484305920792f\n	#define SH_C2_2 0.31539156525252005f\n	#define SH_C2_3 -1.0925484305920792f\n	#define SH_C2_4 0.5462742152960396f\n#endif\n#if SH_BANDS > 2\n	#define SH_C3_0 -0.5900435899266435f\n	#define SH_C3_1 2.890611442640554f\n	#define SH_C3_2 -0.4570457994644658f\n	#define SH_C3_3 0.3731763325901154f\n	#define SH_C3_4 -0.4570457994644658f\n	#define SH_C3_5 1.445305721320277f\n	#define SH_C3_6 -0.5900435899266435f\n#endif\nvec3 evalSH(in SplatSource source, in vec3 dir) {\n	vec3 sh[SH_COEFFS];\n	float scale;\n	readSHData(source, sh, scale);\n	float x = dir.x;\n	float y = dir.y;\n	float z = dir.z;\n	vec3 result = SH_C1 * (-sh[0] * y + sh[1] * z - sh[2] * x);\n#if SH_BANDS > 1\n	float xx = x * x;\n	float yy = y * y;\n	float zz = z * z;\n	float xy = x * y;\n	float yz = y * z;\n	float xz = x * z;\n	result +=\n		sh[3] * (SH_C2_0 * xy) *  +\n		sh[4] * (SH_C2_1 * yz) +\n		sh[5] * (SH_C2_2 * (2.0 * zz - xx - yy)) +\n		sh[6] * (SH_C2_3 * xz) +\n		sh[7] * (SH_C2_4 * (xx - yy));\n#endif\n#if SH_BANDS > 2\n	result +=\n		sh[8]  * (SH_C3_0 * y * (3.0 * xx - yy)) +\n		sh[9]  * (SH_C3_1 * xy * z) +\n		sh[10] * (SH_C3_2 * y * (4.0 * zz - xx - yy)) +\n		sh[11] * (SH_C3_3 * z * (2.0 * zz - 3.0 * xx - 3.0 * yy)) +\n		sh[12] * (SH_C3_4 * x * (4.0 * zz - xx - yy)) +\n		sh[13] * (SH_C3_5 * z * (xx - yy)) +\n		sh[14] * (SH_C3_6 * x * (xx - 3.0 * yy));\n#endif\n	return result * scale;\n}\n#endif\n';
            
            var gsplatCompressedDataVS = "\nuniform highp usampler2D packedTexture;\nuniform highp sampler2D chunkTexture;\nvec4 chunkDataA;\nvec4 chunkDataB;\nvec4 chunkDataC;\nvec4 chunkDataD;\nvec4 chunkDataE;\nuvec4 packedData;\nvec3 unpack111011(uint bits) {\n	return vec3(\n		float(bits >> 21u) / 2047.0,\n		float((bits >> 11u) & 0x3ffu) / 1023.0,\n		float(bits & 0x7ffu) / 2047.0\n	);\n}\nvec4 unpack8888(uint bits) {\n	return vec4(\n		float(bits >> 24u) / 255.0,\n		float((bits >> 16u) & 0xffu) / 255.0,\n		float((bits >> 8u) & 0xffu) / 255.0,\n		float(bits & 0xffu) / 255.0\n	);\n}\nconst float norm = 1.0 / (sqrt(2.0) * 0.5);\nvec4 unpackRotation(uint bits) {\n	float a = (float((bits >> 20u) & 0x3ffu) / 1023.0 - 0.5) * norm;\n	float b = (float((bits >> 10u) & 0x3ffu) / 1023.0 - 0.5) * norm;\n	float c = (float(bits & 0x3ffu) / 1023.0 - 0.5) * norm;\n	float m = sqrt(1.0 - (a * a + b * b + c * c));\n	uint mode = bits >> 30u;\n	if (mode == 0u) return vec4(m, a, b, c);\n	if (mode == 1u) return vec4(a, m, b, c);\n	if (mode == 2u) return vec4(a, b, m, c);\n	return vec4(a, b, c, m);\n}\nmat3 quatToMat3(vec4 R) {\n	float x = R.x;\n	float y = R.y;\n	float z = R.z;\n	float w = R.w;\n	return mat3(\n		1.0 - 2.0 * (z * z + w * w),\n			  2.0 * (y * z + x * w),\n			  2.0 * (y * w - x * z),\n			  2.0 * (y * z - x * w),\n		1.0 - 2.0 * (y * y + w * w),\n			  2.0 * (z * w + x * y),\n			  2.0 * (y * w + x * z),\n			  2.0 * (z * w - x * y),\n		1.0 - 2.0 * (y * y + z * z)\n	);\n}\nvec3 readCenter(SplatSource source) {\n	uint w = uint(textureSize(chunkTexture, 0).x) / 5u;\n	uint chunkId = source.id / 256u;\n	ivec2 chunkUV = ivec2((chunkId % w) * 5u, chunkId / w);\n	chunkDataA = texelFetch(chunkTexture, chunkUV, 0);\n	chunkDataB = texelFetch(chunkTexture, chunkUV + ivec2(1, 0), 0);\n	chunkDataC = texelFetch(chunkTexture, chunkUV + ivec2(2, 0), 0);\n	chunkDataD = texelFetch(chunkTexture, chunkUV + ivec2(3, 0), 0);\n	chunkDataE = texelFetch(chunkTexture, chunkUV + ivec2(4, 0), 0);\n	packedData = texelFetch(packedTexture, source.uv, 0);\n	return mix(chunkDataA.xyz, vec3(chunkDataA.w, chunkDataB.xy), unpack111011(packedData.x));\n}\nvec4 readColor(in SplatSource source) {\n	vec4 r = unpack8888(packedData.w);\n	return vec4(mix(chunkDataD.xyz, vec3(chunkDataD.w, chunkDataE.xy), r.rgb), r.w);\n}\nvec4 getRotation() {\n	return unpackRotation(packedData.y);\n}\nvec3 getScale() {\n	return exp(mix(vec3(chunkDataB.zw, chunkDataC.x), chunkDataC.yzw, unpack111011(packedData.z)));\n}\nvoid readCovariance(in SplatSource source, out vec3 covA, out vec3 covB) {\n	mat3 rot = quatToMat3(getRotation());\n	vec3 scale = getScale();\n	mat3 M = transpose(mat3(\n		scale.x * rot[0],\n		scale.y * rot[1],\n		scale.z * rot[2]\n	));\n	covA = vec3(dot(M[0], M[0]), dot(M[0], M[1]), dot(M[0], M[2]));\n	covB = vec3(dot(M[1], M[1]), dot(M[1], M[2]), dot(M[2], M[2]));\n}\n";
            
            var gsplatCompressedSHVS = "\n#if SH_BANDS > 0\nuniform highp usampler2D shTexture0;\nuniform highp usampler2D shTexture1;\nuniform highp usampler2D shTexture2;\nvec4 unpack8888s(in uint bits) {\n	return vec4((uvec4(bits) >> uvec4(0u, 8u, 16u, 24u)) & 0xffu) * (8.0 / 255.0) - 4.0;\n}\nvoid readSHData(in SplatSource source, out vec3 sh[15], out float scale) {\n	uvec4 shData0 = texelFetch(shTexture0, source.uv, 0);\n	uvec4 shData1 = texelFetch(shTexture1, source.uv, 0);\n	uvec4 shData2 = texelFetch(shTexture2, source.uv, 0);\n	vec4 r0 = unpack8888s(shData0.x);\n	vec4 r1 = unpack8888s(shData0.y);\n	vec4 r2 = unpack8888s(shData0.z);\n	vec4 r3 = unpack8888s(shData0.w);\n	vec4 g0 = unpack8888s(shData1.x);\n	vec4 g1 = unpack8888s(shData1.y);\n	vec4 g2 = unpack8888s(shData1.z);\n	vec4 g3 = unpack8888s(shData1.w);\n	vec4 b0 = unpack8888s(shData2.x);\n	vec4 b1 = unpack8888s(shData2.y);\n	vec4 b2 = unpack8888s(shData2.z);\n	vec4 b3 = unpack8888s(shData2.w);\n	sh[0] =  vec3(r0.x, g0.x, b0.x);\n	sh[1] =  vec3(r0.y, g0.y, b0.y);\n	sh[2] =  vec3(r0.z, g0.z, b0.z);\n	sh[3] =  vec3(r0.w, g0.w, b0.w);\n	sh[4] =  vec3(r1.x, g1.x, b1.x);\n	sh[5] =  vec3(r1.y, g1.y, b1.y);\n	sh[6] =  vec3(r1.z, g1.z, b1.z);\n	sh[7] =  vec3(r1.w, g1.w, b1.w);\n	sh[8] =  vec3(r2.x, g2.x, b2.x);\n	sh[9] =  vec3(r2.y, g2.y, b2.y);\n	sh[10] = vec3(r2.z, g2.z, b2.z);\n	sh[11] = vec3(r2.w, g2.w, b2.w);\n	sh[12] = vec3(r3.x, g3.x, b3.x);\n	sh[13] = vec3(r3.y, g3.y, b3.y);\n	sh[14] = vec3(r3.z, g3.z, b3.z);\n	scale = 1.0;\n}\n#endif\n";
            
            var gsplatSogsColorVS = "\nuniform mediump sampler2D sh0;\nuniform mediump sampler2D opacities;\nuniform vec3 sh0_mins;\nuniform vec3 sh0_maxs;\nuniform float opacities_mins;\nuniform float opacities_maxs;\nfloat SH_C0 = 0.28209479177387814;\nvec4 readColor(in SplatSource source) {\n	vec3 clr = mix(sh0_mins, sh0_maxs, texelFetch(sh0, source.uv, 0).xyz);\n	float opacity = mix(opacities_mins, opacities_maxs, texelFetch(opacities, source.uv, 0).x);\n	return vec4(vec3(0.5) + clr * SH_C0, 1.0 / (1.0 + exp(opacity * -1.0)));\n}\n";
            
            var gsplatSogsDataVS = "\nuniform highp sampler2D means_u;\nuniform highp sampler2D means_l;\nuniform highp sampler2D quats;\nuniform highp sampler2D scales;\nuniform vec3 means_mins;\nuniform vec3 means_maxs;\nuniform vec3 quats_mins;\nuniform vec3 quats_maxs;\nuniform vec3 scales_mins;\nuniform vec3 scales_maxs;\nvec3 readCenter(SplatSource source) {\n	vec3 u = texelFetch(means_u, source.uv, 0).xyz;\n	vec3 l = texelFetch(means_l, source.uv, 0).xyz;\n	vec3 n = (l * 255.0 + u * 255.0 * 256.0) / 65535.0;\n	vec3 v = mix(means_mins, means_maxs, n);\n	return sign(v) * (exp(abs(v)) - 1.0);\n}\nmat3 quatToMat3(vec3 R) {\n	float x = R.x;\n	float y = R.y;\n	float z = R.z;\n	float w2 = clamp(1.0 - (x*x + y*y + z*z), 0.0, 1.0);\n	float w  = sqrt(w2);\n	return mat3(\n		1.0 - 2.0 * (z * z + w2),\n			  2.0 * (y * z + x * w),\n			  2.0 * (y * w - x * z),\n			  2.0 * (y * z - x * w),\n		1.0 - 2.0 * (y * y + w2),\n			  2.0 * (z * w + x * y),\n			  2.0 * (y * w + x * z),\n			  2.0 * (z * w - x * y),\n		1.0 - 2.0 * (y * y + z * z)\n	);\n}\nvoid readCovariance(in SplatSource source, out vec3 covA, out vec3 covB) {\n	vec3 quat = mix(quats_mins, quats_maxs, texelFetch(quats, source.uv, 0).xyz);\n	mat3 rot = quatToMat3(quat);\n	vec3 scale = exp(mix(scales_mins, scales_maxs, texelFetch(scales, source.uv, 0).xyz));\n	mat3 M = transpose(mat3(\n		scale.x * rot[0],\n		scale.y * rot[1],\n		scale.z * rot[2]\n	));\n	covA = vec3(dot(M[0], M[0]), dot(M[0], M[1]), dot(M[0], M[2]));\n	covB = vec3(dot(M[1], M[1]), dot(M[1], M[2]), dot(M[2], M[2]));\n}\n";
            
            var gsplatSogsSHVS = "\nuniform highp sampler2D sh_labels_u;\nuniform highp sampler2D sh_labels_l;\nuniform highp sampler2D sh_centroids;\nuniform float shN_mins;\nuniform float shN_maxs;\nvoid readSHData(in SplatSource source, out vec3 sh[15], out float scale) {\n	int tu = int(texelFetch(sh_labels_u, source.uv, 0).x * 255.0 * 256.0);\n	int tl = int(texelFetch(sh_labels_l, source.uv, 0).x * 255.0);\n	int n = tu + tl;\n	int u = (n % 64) * 15;\n	int v = n / 64;\n	for (int i = 0; i < 15; i++) {\n		sh[i] = mix(vec3(shN_mins), vec3(shN_maxs), texelFetch(sh_centroids, ivec2(u + i, v), 0).xyz);\n	}\n	scale = 1.0;\n}\n";
            
            var gsplatCornerVS = "\nuniform vec2 viewport;\nuniform vec4 camera_params;\nbool initCorner(SplatSource source, SplatCenter center, out SplatCorner corner) {\n	vec3 covA, covB;\n	readCovariance(source, covA, covB);\n	mat3 Vrk = mat3(\n		covA.x, covA.y, covA.z, \n		covA.y, covB.x, covB.y,\n		covA.z, covB.y, covB.z\n	);\n	float focal = viewport.x * center.projMat00;\n	vec3 v = camera_params.w == 1.0 ? vec3(0.0, 0.0, 1.0) : center.view.xyz;\n	float J1 = focal / v.z;\n	vec2 J2 = -J1 / v.z * v.xy;\n	mat3 J = mat3(\n		J1, 0.0, J2.x, \n		0.0, J1, J2.y, \n		0.0, 0.0, 0.0\n	);\n	mat3 W = transpose(mat3(center.modelView));\n	mat3 T = W * J;\n	mat3 cov = transpose(T) * Vrk * T;\n	#if GSPLAT_AA\n		float detOrig = cov[0][0] * cov[1][1] - cov[0][1] * cov[0][1];\n		float detBlur = (cov[0][0] + 0.3) * (cov[1][1] + 0.3) - cov[0][1] * cov[0][1];\n		corner.aaFactor = sqrt(max(detOrig / detBlur, 0.0));\n	#endif\n	float diagonal1 = cov[0][0] + 0.3;\n	float offDiagonal = cov[0][1];\n	float diagonal2 = cov[1][1] + 0.3;\n	float mid = 0.5 * (diagonal1 + diagonal2);\n	float radius = length(vec2((diagonal1 - diagonal2) / 2.0, offDiagonal));\n	float lambda1 = mid + radius;\n	float lambda2 = max(mid - radius, 0.1);\n	float l1 = 2.0 * min(sqrt(2.0 * lambda1), 1024.0);\n	float l2 = 2.0 * min(sqrt(2.0 * lambda2), 1024.0);\n	if (l1 < 2.0 && l2 < 2.0) {\n		return false;\n	}\n	vec2 c = center.proj.ww / viewport;\n	if (any(greaterThan(abs(center.proj.xy) - vec2(max(l1, l2)) * c, center.proj.ww))) {\n		return false;\n	}\n	vec2 diagonalVector = normalize(vec2(offDiagonal, lambda1 - diagonal1));\n	vec2 v1 = l1 * diagonalVector;\n	vec2 v2 = l2 * vec2(diagonalVector.y, -diagonalVector.x);\n	corner.offset = (source.cornerUV.x * v1 + source.cornerUV.y * v2) * c;\n	corner.uv = source.cornerUV;\n	return true;\n}\n";
            
            var gsplatDataVS = "\nuniform highp usampler2D transformA;\nuniform highp sampler2D transformB;\nuint tAw;\nvec3 readCenter(SplatSource source) {\n	uvec4 tA = texelFetch(transformA, source.uv, 0);\n	tAw = tA.w;\n	return uintBitsToFloat(tA.xyz);\n}\nmat3 quatToMat3(vec4 R) {\n	float x = R.w;\n	float y = R.x;\n	float z = R.y;\n	float w = R.z;\n	return mat3(\n		1.0 - 2.0 * (z * z + w * w),\n			  2.0 * (y * z + x * w),\n			  2.0 * (y * w - x * z),\n			  2.0 * (y * z - x * w),\n		1.0 - 2.0 * (y * y + w * w),\n			  2.0 * (z * w + x * y),\n			  2.0 * (y * w + x * z),\n			  2.0 * (z * w - x * y),\n		1.0 - 2.0 * (y * y + z * z)\n	);\n}\nvec4 unpackRotation(vec3 packed) {\n	return vec4(packed.xyz, sqrt(max(0.0, 1.0 - dot(packed, packed))));\n}\nvoid readCovariance(in SplatSource source, out vec3 covA, out vec3 covB) {\n	vec4 tB = texelFetch(transformB, source.uv, 0);\n	mat3 rot = quatToMat3(unpackRotation(vec3(unpackHalf2x16(tAw), tB.w)));\n	vec3 scale = tB.xyz;\n	\n	mat3 M = transpose(mat3(\n		scale.x * rot[0],\n		scale.y * rot[1],\n		scale.z * rot[2]\n	));\n	covA = vec3(dot(M[0], M[0]), dot(M[0], M[1]), dot(M[0], M[2]));\n	covB = vec3(dot(M[1], M[1]), dot(M[1], M[2]), dot(M[2], M[2]));\n}\n";
            
            var gsplatOutputVS = '\n#include "tonemappingPS"\n#include "decodePS"\n#include "gammaPS"\nvec3 prepareOutputFromGamma(vec3 gammaColor) {\n	#if TONEMAP == NONE\n		#if GAMMA == NONE\n			return decodeGamma(gammaColor);\n		#else\n			return gammaColor;\n		#endif\n	#else\n		return gammaCorrectOutput(toneMap(decodeGamma(gammaColor)));\n	#endif\n}\n';
            
            var gsplatPS = '\n#ifndef DITHER_NONE\n	#include "bayerPS"\n	#include "opacityDitherPS"\n	varying float id;\n#endif\n#ifdef PICK_PASS\n	#include "pickPS"\n#endif\n#if defined(SHADOW_PASS) || defined(PICK_PASS) || defined(PREPASS_PASS)\n	uniform float alphaClip;\n#endif\n#ifdef PREPASS_PASS\n	varying float vLinearDepth;\n	#include "floatAsUintPS"\n#endif\nvarying mediump vec2 gaussianUV;\nvarying mediump vec4 gaussianColor;\nvoid main(void) {\n	mediump float A = dot(gaussianUV, gaussianUV);\n	if (A > 1.0) {\n		discard;\n	}\n	mediump float alpha = exp(-A * 4.0) * gaussianColor.a;\n	#if defined(SHADOW_PASS) || defined(PICK_PASS) || defined(PREPASS_PASS)\n		if (alpha < alphaClip) {\n			discard;\n		}\n	#endif\n	#ifdef PICK_PASS\n		gl_FragColor = getPickOutput();\n	#elif SHADOW_PASS\n		gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n	#elif PREPASS_PASS\n		gl_FragColor = float2vec4(vLinearDepth);\n	#else\n		if (alpha < 1.0 / 255.0) {\n			discard;\n		}\n		#ifndef DITHER_NONE\n			opacityDither(alpha, id * 0.013);\n		#endif\n		gl_FragColor = vec4(gaussianColor.xyz * alpha, alpha);\n	#endif\n}\n';
            
            var gsplatSHVS = "\n#if SH_BANDS > 0\nvec3 unpack111011s(uint bits) {\n	return vec3((uvec3(bits) >> uvec3(21u, 11u, 0u)) & uvec3(0x7ffu, 0x3ffu, 0x7ffu)) / vec3(2047.0, 1023.0, 2047.0) * 2.0 - 1.0;\n}\nvoid fetchScale(in uvec4 t, out float scale, out vec3 a, out vec3 b, out vec3 c) {\n	scale = uintBitsToFloat(t.x);\n	a = unpack111011s(t.y);\n	b = unpack111011s(t.z);\n	c = unpack111011s(t.w);\n}\nvoid fetch(in uvec4 t, out vec3 a, out vec3 b, out vec3 c, out vec3 d) {\n	a = unpack111011s(t.x);\n	b = unpack111011s(t.y);\n	c = unpack111011s(t.z);\n	d = unpack111011s(t.w);\n}\nvoid fetch(in uint t, out vec3 a) {\n	a = unpack111011s(t);\n}\n#if SH_BANDS == 1\n	uniform highp usampler2D splatSH_1to3;\n	void readSHData(in SplatSource source, out vec3 sh[3], out float scale) {\n		fetchScale(texelFetch(splatSH_1to3, source.uv, 0), scale, sh[0], sh[1], sh[2]);\n	}\n#elif SH_BANDS == 2\n	uniform highp usampler2D splatSH_1to3;\n	uniform highp usampler2D splatSH_4to7;\n	uniform highp usampler2D splatSH_8to11;\n	void readSHData(in SplatSource source, out vec3 sh[8], out float scale) {\n		fetchScale(texelFetch(splatSH_1to3, source.uv, 0), scale, sh[0], sh[1], sh[2]);\n		fetch(texelFetch(splatSH_4to7, source.uv, 0), sh[3], sh[4], sh[5], sh[6]);\n		fetch(texelFetch(splatSH_8to11, source.uv, 0).x, sh[7]);\n	}\n#else\n	uniform highp usampler2D splatSH_1to3;\n	uniform highp usampler2D splatSH_4to7;\n	uniform highp usampler2D splatSH_8to11;\n	uniform highp usampler2D splatSH_12to15;\n	void readSHData(in SplatSource source, out vec3 sh[15], out float scale) {\n		fetchScale(texelFetch(splatSH_1to3, source.uv, 0), scale, sh[0], sh[1], sh[2]);\n		fetch(texelFetch(splatSH_4to7, source.uv, 0), sh[3], sh[4], sh[5], sh[6]);\n		fetch(texelFetch(splatSH_8to11, source.uv, 0), sh[7], sh[8], sh[9], sh[10]);\n		fetch(texelFetch(splatSH_12to15, source.uv, 0), sh[11], sh[12], sh[13], sh[14]);\n	}\n#endif\n#endif\n";
            
            var gsplatSourceVS = "\nattribute vec3 vertex_position;\nattribute uint vertex_id_attrib;\nuniform uint numSplats;\nuniform highp usampler2D splatOrder;\nbool initSource(out SplatSource source) {\n	uint w = uint(textureSize(splatOrder, 0).x);\n	source.order = vertex_id_attrib + uint(vertex_position.z);\n	if (source.order >= numSplats) {\n		return false;\n	}\n	ivec2 orderUV = ivec2(source.order % w, source.order / w);\n	source.id = texelFetch(splatOrder, orderUV, 0).r;\n	source.uv = ivec2(source.id % w, source.id / w);\n	source.cornerUV = vertex_position.xy;\n	return true;\n}\n";
            
            var gsplatVS = '\n#include "gsplatCommonVS"\nvarying mediump vec2 gaussianUV;\nvarying mediump vec4 gaussianColor;\n#ifndef DITHER_NONE\n	varying float id;\n#endif\nmediump vec4 discardVec = vec4(0.0, 0.0, 2.0, 1.0);\n#ifdef PREPASS_PASS\n	varying float vLinearDepth;\n#endif\nvoid main(void) {\n	SplatSource source;\n	if (!initSource(source)) {\n		gl_Position = discardVec;\n		return;\n	}\n	vec3 modelCenter = readCenter(source);\n	SplatCenter center;\n	if (!initCenter(modelCenter, center)) {\n		gl_Position = discardVec;\n		return;\n	}\n	SplatCorner corner;\n	if (!initCorner(source, center, corner)) {\n		gl_Position = discardVec;\n		return;\n	}\n	vec4 clr = readColor(source);\n	#if GSPLAT_AA\n		clr.a *= corner.aaFactor;\n	#endif\n	#if SH_BANDS > 0\n		vec3 dir = normalize(center.view * mat3(center.modelView));\n		clr.xyz += evalSH(source, dir);\n	#endif\n	clipCorner(corner, clr.w);\n	gl_Position = center.proj + vec4(corner.offset, 0, 0);\n	gaussianUV = corner.uv;\n	gaussianColor = vec4(prepareOutputFromGamma(max(clr.xyz, 0.0)), clr.w);\n	#ifndef DITHER_NONE\n		id = float(source.id);\n	#endif\n	#ifdef PREPASS_PASS\n		vLinearDepth = -center.view.z;\n	#endif\n}\n';
            
            var immediateLinePS$1 = '\n		#include "gammaPS"\n		varying vec4 color;\n		void main(void) {\n			gl_FragColor = vec4(gammaCorrectOutput(decodeGamma(color.rgb)), color.a);\n		}\n';
            
            var immediateLineVS$1 = "\n	attribute vec4 vertex_position;\n	attribute vec4 vertex_color;\n	uniform mat4 matrix_model;\n	uniform mat4 matrix_viewProjection;\n	varying vec4 color;\n	void main(void) {\n		color = vertex_color;\n		gl_Position = matrix_viewProjection * matrix_model * vertex_position;\n	}\n";
            
            var iridescenceDiffractionPS = "\nuniform float material_iridescenceRefractionIndex;\n#ifndef PI\n#define PI 3.14159265\n#endif\nfloat iridescence_iorToFresnel(float transmittedIor, float incidentIor) {\n	return pow((transmittedIor - incidentIor) / (transmittedIor + incidentIor), 2.0);\n}\nvec3 iridescence_iorToFresnel(vec3 transmittedIor, float incidentIor) {\n	return pow((transmittedIor - vec3(incidentIor)) / (transmittedIor + vec3(incidentIor)), vec3(2.0));\n}\nvec3 iridescence_fresnelToIor(vec3 f0) {\n	vec3 sqrtF0 = sqrt(f0);\n	return (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);\n}\nvec3 iridescence_sensitivity(float opd, vec3 shift) {\n	float phase = 2.0 * PI * opd * 1.0e-9;\n	const vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);\n	const vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);\n	const vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);\n	vec3 xyz = val * sqrt(2.0 * PI * var) * cos(pos * phase + shift) * exp(-pow(phase, 2.0) * var);\n	xyz.x += 9.7470e-14 * sqrt(2.0 * PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * pow(phase, 2.0));\n	xyz /= vec3(1.0685e-07);\n	const mat3 XYZ_TO_REC709 = mat3(\n		3.2404542, -0.9692660,  0.0556434,\n	   -1.5371385,  1.8760108, -0.2040259,\n	   -0.4985314,  0.0415560,  1.0572252\n	);\n	return XYZ_TO_REC709 * xyz;\n}\nfloat iridescence_fresnel(float cosTheta, float f0) {\n	float x = clamp(1.0 - cosTheta, 0.0, 1.0);\n	float x2 = x * x;\n	float x5 = x * x2 * x2;\n	return f0 + (1.0 - f0) * x5;\n} \nvec3 iridescence_fresnel(float cosTheta, vec3 f0) {\n	float x = clamp(1.0 - cosTheta, 0.0, 1.0);\n	float x2 = x * x;\n	float x5 = x * x2 * x2; \n	return f0 + (vec3(1.0) - f0) * x5;\n}\nvec3 calcIridescence(float outsideIor, float cosTheta, vec3 base_f0, float iridescenceThickness) {\n	float iridescenceIor = mix(outsideIor, material_iridescenceRefractionIndex, smoothstep(0.0, 0.03, iridescenceThickness));\n	float sinTheta2Sq = pow(outsideIor / iridescenceIor, 2.0) * (1.0 - pow(cosTheta, 2.0));\n	float cosTheta2Sq = 1.0 - sinTheta2Sq;\n	if (cosTheta2Sq < 0.0) {\n		return vec3(1.0);\n	}\n	float cosTheta2 = sqrt(cosTheta2Sq);\n	float r0 = iridescence_iorToFresnel(iridescenceIor, outsideIor);\n	float r12 = iridescence_fresnel(cosTheta, r0);\n	float r21 = r12;\n	float t121 = 1.0 - r12;\n	float phi12 = iridescenceIor < outsideIor ? PI : 0.0;\n	float phi21 = PI - phi12;\n	vec3 baseIor = iridescence_fresnelToIor(base_f0 + vec3(0.0001));\n	vec3 r1 = iridescence_iorToFresnel(baseIor, iridescenceIor);\n	vec3 r23 = iridescence_fresnel(cosTheta2, r1);\n	vec3 phi23 = vec3(0.0);\n	if (baseIor[0] < iridescenceIor) phi23[0] = PI;\n	if (baseIor[1] < iridescenceIor) phi23[1] = PI;\n	if (baseIor[2] < iridescenceIor) phi23[2] = PI;\n	float opd = 2.0 * iridescenceIor * iridescenceThickness * cosTheta2;\n	vec3 phi = vec3(phi21) + phi23; \n	vec3 r123Sq = clamp(r12 * r23, 1e-5, 0.9999);\n	vec3 r123 = sqrt(r123Sq);\n	vec3 rs = pow(t121, 2.0) * r23 / (1.0 - r123Sq);\n	vec3 c0 = r12 + rs;\n	vec3 i = c0;\n	vec3 cm = rs - t121;\n	for (int m = 1; m <= 2; m++) {\n		cm *= r123;\n		vec3 sm = 2.0 * iridescence_sensitivity(float(m) * opd, float(m) * phi);\n		i += cm * sm;\n	}\n	return max(i, vec3(0.0));\n}\nvec3 getIridescence(float cosTheta, vec3 specularity, float iridescenceThickness) {\n	return calcIridescence(1.0, cosTheta, specularity, iridescenceThickness);\n}\n";
            
            var iridescencePS = "\n#ifdef STD_IRIDESCENCE_CONSTANT\nuniform float material_iridescence;\n#endif\nvoid getIridescence() {\n	float iridescence = 1.0;\n	#ifdef STD_IRIDESCENCE_CONSTANT\n	iridescence *= material_iridescence;\n	#endif\n	#ifdef STD_IRIDESCENCE_TEXTURE\n	iridescence *= texture2DBias({STD_IRIDESCENCE_TEXTURE_NAME}, {STD_IRIDESCENCE_TEXTURE_UV}, textureBias).{STD_IRIDESCENCE_TEXTURE_CHANNEL};\n	#endif\n	dIridescence = iridescence; \n}\n";
            
            var iridescenceThicknessPS = "\nuniform float material_iridescenceThicknessMax;\n#ifdef STD_IRIDESCENCETHICKNESS_TEXTURE\nuniform float material_iridescenceThicknessMin;\n#endif\nvoid getIridescenceThickness() {\n	#ifdef STD_IRIDESCENCETHICKNESS_TEXTURE\n		float blend = texture2DBias({STD_IRIDESCENCETHICKNESS_TEXTURE_NAME}, {STD_IRIDESCENCETHICKNESS_TEXTURE_UV}, textureBias).{STD_IRIDESCENCETHICKNESS_TEXTURE_CHANNEL};\n		float iridescenceThickness = mix(material_iridescenceThicknessMin, material_iridescenceThicknessMax, blend);\n	#else\n		float iridescenceThickness = material_iridescenceThicknessMax;\n	#endif\n	dIridescenceThickness = iridescenceThickness; \n}\n";
            
            var iorPS = "\n#ifdef STD_IOR_CONSTANT\nuniform float material_refractionIndex;\n#endif\nvoid getIor() {\n#ifdef STD_IOR_CONSTANT\n	dIor = material_refractionIndex;\n#else\n	dIor = 1.0 / 1.5;\n#endif\n}\n";
            
            var lightDeclarationPS = "\n#if defined(LIGHT{i})\n	uniform vec3 light{i}_color;\n	#if LIGHT{i}TYPE == DIRECTIONAL\n		uniform vec3 light{i}_direction;\n	#else\n		#define LIT_CODE_LIGHTS_POINT\n		uniform vec3 light{i}_position;\n		uniform float light{i}_radius;\n		#if LIGHT{i}TYPE == SPOT\n			#define LIT_CODE_LIGHTS_SPOT\n			uniform vec3 light{i}_direction;\n			uniform float light{i}_innerConeAngle;\n			uniform float light{i}_outerConeAngle;\n		#endif\n	#endif\n	#if LIGHT{i}SHAPE != PUNCTUAL\n		#define LIT_CODE_FALLOFF_SQUARED\n		#if LIGHT{i}TYPE == DIRECTIONAL\n			uniform vec3 light{i}_position;\n		#endif\n		uniform vec3 light{i}_halfWidth;\n		uniform vec3 light{i}_halfHeight;\n	#else\n		#if LIGHT{i}FALLOFF == LINEAR\n			#define LIT_CODE_FALLOFF_LINEAR\n		#endif\n		#if LIGHT{i}FALLOFF == INVERSESQUARED\n			#define LIT_CODE_FALLOFF_SQUARED\n		#endif\n	#endif\n	#if defined(LIGHT{i}CASTSHADOW)\n		uniform mat4 light{i}_shadowMatrix;\n		uniform float light{i}_shadowIntensity;\n		uniform vec4 light{i}_shadowParams;\n		#if LIGHT{i}SHADOWTYPE == PCSS_32F\n			uniform float light{i}_shadowSearchArea;\n			uniform vec4 light{i}_cameraParams;\n			#if LIGHT{i}TYPE == DIRECTIONAL\n				uniform vec4 light{i}_softShadowParams;\n			#endif\n		#endif\n		#if LIGHT{i}TYPE == DIRECTIONAL\n			uniform mat4 light{i}_shadowMatrixPalette[4];\n			uniform vec4 light{i}_shadowCascadeDistances;\n			uniform int light{i}_shadowCascadeCount;\n			uniform float light{i}_shadowCascadeBlend;\n		#endif\n		#if LIGHT{i}TYPE == OMNI\n			#if defined(LIGHT{i}SHADOW_PCF)\n				uniform samplerCubeShadow light{i}_shadowMap;\n			#else\n				uniform samplerCube light{i}_shadowMap;\n			#endif\n		#else\n			#if defined(LIGHT{i}SHADOW_PCF)\n				uniform sampler2DShadow light{i}_shadowMap;\n			#else\n				uniform sampler2D light{i}_shadowMap;\n			#endif\n		#endif\n	#endif\n	#if defined(LIGHT{i}COOKIE)\n		#define LIT_CODE_COOKIE\n		#if LIGHT{i}TYPE == OMNI\n			uniform samplerCube light{i}_cookie;\n			uniform float light{i}_cookieIntensity;\n			#if !defined(LIGHT{i}CASTSHADOW)\n				uniform mat4 light{i}_shadowMatrix;\n			#endif\n		#endif\n		#if LIGHT{i}TYPE == SPOT\n			uniform sampler2D light{i}_cookie;\n			uniform float light{i}_cookieIntensity;\n			#if !defined(LIGHT{i}CASTSHADOW)\n				uniform mat4 light{i}_shadowMatrix;\n			#endif\n			#if defined(LIGHT{i}COOKIE_TRANSFORM)\n				uniform vec4 light{i}_cookieMatrix;\n				uniform vec2 light{i}_cookieOffset;\n			#endif\n		#endif\n	#endif\n#endif\n";
            
            var lightDiffuseLambertPS = "\nfloat getLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm) {\n	return max(dot(worldNormal, -lightDirNorm), 0.0);\n}\n";
            
            var lightDirPointPS = "\nvoid evalOmniLight(vec3 lightPosW, out vec3 lightDirW, out vec3 lightDirNormW) {\n	lightDirW = vPositionW - lightPosW;\n	lightDirNormW = normalize(lightDirW);\n}\n";
            
            var lightEvaluationPS = "\n#if defined(LIGHT{i})\n	evaluateLight{i}(\n		#if defined(LIT_IRIDESCENCE)\n			iridescenceFresnel\n		#endif\n	);\n#endif\n";
            
            var lightFunctionLightPS = "\n#if defined(LIGHT{i})\nvoid evaluateLight{i}(\n	#if defined(LIT_IRIDESCENCE)\n		vec3 iridescenceFresnel\n	#endif\n) {\n	vec3 lightColor = light{i}_color;\n	#if LIGHT{i}TYPE == DIRECTIONAL && !defined(LIT_SHADOW_CATCHER)\n		if (all(equal(lightColor, vec3(0.0)))) {\n			return;\n		}\n	#endif\n	#if LIGHT{i}TYPE == DIRECTIONAL\n		dLightDirNormW = light{i}_direction;\n		dAtten = 1.0;\n	#else\n		\n		vec3 lightDirW;\n		evalOmniLight(light{i}_position, lightDirW, dLightDirNormW);\n		#if defined(LIGHT{i}COOKIE)\n			#if LIGHT{i}TYPE == SPOT\n				#ifdef LIGHT{i}COOKIE_FALLOFF\n					#ifdef LIGHT{i}COOKIE_TRANSFORM\n						vec3 cookieAttenuation = getCookie2DXform(light{i}_cookie, light{i}_shadowMatrix, light{i}_cookieIntensity, light{i}_cookieMatrix, light{i}_cookieOffset).{LIGHT{i}COOKIE_CHANNEL};\n					#else\n						vec3 cookieAttenuation = getCookie2D(light{i}_cookie, light{i}_shadowMatrix, light{i}_cookieIntensity).{LIGHT{i}COOKIE_CHANNEL};\n					#endif\n				#else\n					#ifdef LIGHT{i}COOKIE_TRANSFORM\n						vec3 cookieAttenuation = getCookie2DClipXform(light{i}_cookie, light{i}_shadowMatrix, light{i}_cookieIntensity, light{i}_cookieMatrix, light{i}_cookieOffset).{LIGHT{i}COOKIE_CHANNEL};\n					#else\n						vec3 cookieAttenuation = getCookie2DClip(light{i}_cookie, light{i}_shadowMatrix, light{i}_cookieIntensity).{LIGHT{i}COOKIE_CHANNEL};\n					#endif\n				#endif\n			#endif\n			#if LIGHT{i}TYPE == OMNI\n				vec3 cookieAttenuation = getCookieCube(light{i}_cookie, light{i}_shadowMatrix, light{i}_cookieIntensity).{LIGHT{i}COOKIE_CHANNEL};\n			#endif\n			lightColor *= cookieAttenuation;\n		#endif\n		#if LIGHT{i}SHAPE == PUNCTUAL\n			#if LIGHT{i}FALLOFF == LINEAR\n				dAtten = getFalloffLinear(light{i}_radius, lightDirW);\n			#else\n				dAtten = getFalloffInvSquared(light{i}_radius, lightDirW);\n			#endif\n		#else\n			dAtten = getFalloffWindow(light{i}_radius, lightDirW);\n		#endif\n		#if LIGHT{i}TYPE == SPOT\n			#if !defined(LIGHT{i}COOKIE) || defined(LIGHT{i}COOKIE_FALLOFF)\n				dAtten *= getSpotEffect(light{i}_direction, light{i}_innerConeAngle, light{i}_outerConeAngle, dLightDirNormW);\n			#endif\n		#endif\n	#endif\n	if (dAtten < 0.00001) {\n		return;\n	}\n	#if LIGHT{i}SHAPE != PUNCTUAL\n		#if LIGHT{i}SHAPE == RECT\n			calcRectLightValues(light{i}_position, light{i}_halfWidth, light{i}_halfHeight);\n		#elif LIGHT{i}SHAPE == DISK\n			calcDiskLightValues(light{i}_position, light{i}_halfWidth, light{i}_halfHeight);\n		#elif LIGHT{i}SHAPE == SPHERE\n			calcSphereLightValues(light{i}_position, light{i}_halfWidth, light{i}_halfHeight);\n		#endif\n	#endif\n	#if LIGHT{i}SHAPE != PUNCTUAL\n		#if LIGHT{i}TYPE == DIRECTIONAL\n			float attenDiffuse = getLightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirNormW);\n		#else\n			#if LIGHT{i}SHAPE == RECT\n				float attenDiffuse = getRectLightDiffuse(litArgs_worldNormal, dViewDirW, lightDirW, dLightDirNormW) * 16.0;\n			#elif LIGHT{i}SHAPE == DISK\n				float attenDiffuse = getDiskLightDiffuse(litArgs_worldNormal, dViewDirW, lightDirW, dLightDirNormW) * 16.0;\n			#elif LIGHT{i}SHAPE == SPHERE\n				float attenDiffuse = getSphereLightDiffuse(litArgs_worldNormal, dViewDirW, lightDirW, dLightDirNormW) * 16.0;\n			#endif\n		#endif\n	#else\n		dAtten *= getLightDiffuse(litArgs_worldNormal, vec3(0.0), dLightDirNormW);\n	#endif\n	#ifdef LIGHT{i}CASTSHADOW\n		#if LIGHT{i}TYPE == DIRECTIONAL\n			float shadow = getShadow{i}(vec3(0.0));\n		#else\n			float shadow = getShadow{i}(lightDirW);\n		#endif\n		shadow = mix(1.0, shadow, light{i}_shadowIntensity);\n		dAtten *= shadow;\n		#if defined(LIT_SHADOW_CATCHER) && LIGHT{i}TYPE == DIRECTIONAL\n			dShadowCatcher *= shadow;\n		#endif			\n	#endif\n	#if LIGHT{i}SHAPE != PUNCTUAL\n		#ifdef LIT_SPECULAR\n			dDiffuseLight += ((attenDiffuse * dAtten) * lightColor) * (1.0 - dLTCSpecFres);\n		#else\n			dDiffuseLight += (attenDiffuse * dAtten) * lightColor;\n		#endif						\n	#else\n		#if defined(AREA_LIGHTS) && defined(LIT_SPECULAR)\n			dDiffuseLight += (dAtten * lightColor) * (1.0 - litArgs_specularity);\n		#else\n			dDiffuseLight += dAtten * lightColor;\n		#endif\n	#endif\n	#ifdef LIGHT{i}AFFECT_SPECULARITY\n		#if LIGHT{i}SHAPE != PUNCTUAL\n			#ifdef LIT_CLEARCOAT\n				#if LIGHT{i}SHAPE == RECT\n					ccSpecularLight += ccLTCSpecFres * getRectLightSpecular(litArgs_clearcoat_worldNormal, dViewDirW) * dAtten * lightColor;\n				#elif LIGHT{i}SHAPE == DISK\n					ccSpecularLight += ccLTCSpecFres * getDiskLightSpecular(litArgs_clearcoat_worldNormal, dViewDirW) * dAtten * lightColor;\n				#elif LIGHT{i}SHAPE == SPHERE\n					ccSpecularLight += ccLTCSpecFres * getSphereLightSpecular(litArgs_clearcoat_worldNormal, dViewDirW) * dAtten * lightColor;\n				#endif\n			#endif\n			#ifdef LIT_SPECULAR\n				#if LIGHT{i}SHAPE == RECT\n					dSpecularLight += dLTCSpecFres * getRectLightSpecular(litArgs_worldNormal, dViewDirW) * dAtten * lightColor;\n				#elif LIGHT{i}SHAPE == DISK\n					dSpecularLight += dLTCSpecFres * getDiskLightSpecular(litArgs_worldNormal, dViewDirW) * dAtten * lightColor;\n				#elif LIGHT{i}SHAPE == SPHERE\n					dSpecularLight += dLTCSpecFres * getSphereLightSpecular(litArgs_worldNormal, dViewDirW) * dAtten * lightColor;\n				#endif\n			#endif\n		#else\n			#if LIGHT{i}TYPE == DIRECTIONAL && LIT_FRESNEL_MODEL != NONE\n				#define LIGHT{i}FRESNEL\n			#endif\n			#ifdef LIT_SPECULAR\n				vec3 halfDirW = normalize(-dLightDirNormW + dViewDirW);\n			#endif\n			#ifdef LIT_CLEARCOAT\n				vec3 lightspecularCC = getLightSpecular(halfDirW, ccReflDirW, litArgs_clearcoat_worldNormal, dViewDirW, dLightDirNormW, litArgs_clearcoat_gloss, dTBN) * dAtten * lightColor;\n				#ifdef LIGHT{i}FRESNEL\n					lightspecularCC *= getFresnelCC(dot(dViewDirW, halfDirW));\n				#endif\n				ccSpecularLight += lightspecularCC;\n			#endif\n			#ifdef LIT_SHEEN\n				sSpecularLight += getLightSpecularSheen(halfDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_sheen_gloss) * dAtten * lightColor;\n			#endif\n			#ifdef LIT_SPECULAR\n				vec3 lightSpecular = getLightSpecular(halfDirW, dReflDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_gloss, dTBN) * dAtten * lightColor;\n				#ifdef LIGHT{i}FRESNEL\n					#if defined(LIT_IRIDESCENCE)\n						lightSpecular *= getFresnel(dot(dViewDirW, halfDirW), litArgs_gloss, litArgs_specularity, iridescenceFresnel, litArgs_iridescence_intensity);\n					#else\n						lightSpecular *= getFresnel(dot(dViewDirW, halfDirW), litArgs_gloss, litArgs_specularity);\n					#endif\n				#else\n					lightSpecular *= litArgs_specularity;\n				#endif\n				\n				dSpecularLight += lightSpecular;\n			#endif\n		#endif\n	#endif\n}\n#endif\n";
            
            var lightFunctionShadowPS = "\n#ifdef LIGHT{i}CASTSHADOW\n	vec3 getShadowSampleCoord{i}(mat4 shadowTransform, vec4 shadowParams, vec3 worldPosition, vec3 lightPos, inout vec3 lightDir, vec3 lightDirNorm, vec3 normal) {\n		vec3 surfacePosition = worldPosition;\n		#ifdef LIGHT{i}_SHADOW_SAMPLE_POINT\n			#ifdef LIGHT{i}_SHADOW_SAMPLE_NORMAL_OFFSET\n				float distScale = length(lightDir);\n				surfacePosition = surfacePosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;\n				lightDir = surfacePosition - lightPos;\n				return lightDir;\n			#endif\n		#else\n			#ifdef LIGHT{i}_SHADOW_SAMPLE_SOURCE_ZBUFFER\n				#ifdef LIGHT{i}_SHADOW_SAMPLE_NORMAL_OFFSET\n					surfacePosition = surfacePosition + normal * shadowParams.y;\n				#endif\n			#else\n				#ifdef LIGHT{i}_SHADOW_SAMPLE_NORMAL_OFFSET\n					#ifdef LIGHT{i}_SHADOW_SAMPLE_ORTHO\n						float distScale = 1.0;\n					#else\n						float distScale = abs(dot(vPositionW - lightPos, lightDirNorm));\n					#endif\n					surfacePosition = surfacePosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;\n				#endif\n			#endif\n			vec4 positionInShadowSpace = shadowTransform * vec4(surfacePosition, 1.0);\n			#ifdef LIGHT{i}_SHADOW_SAMPLE_ORTHO\n				positionInShadowSpace.z = saturate(positionInShadowSpace.z) - 0.0001;\n			#else\n				#ifdef LIGHT{i}_SHADOW_SAMPLE_SOURCE_ZBUFFER\n					positionInShadowSpace.xyz /= positionInShadowSpace.w;\n				#else\n					positionInShadowSpace.xy /= positionInShadowSpace.w;\n					positionInShadowSpace.z = length(lightDir) * shadowParams.w;\n				#endif\n			#endif\n			surfacePosition = positionInShadowSpace.xyz;\n		#endif\n		return surfacePosition;\n	}\n	float getShadow{i}(vec3 lightDirW) {\n		#ifdef LIGHT{i}_SHADOW_CASCADES\n			int cascadeIndex = getShadowCascadeIndex(light{i}_shadowCascadeDistances, light{i}_shadowCascadeCount);\n			#ifdef LIGHT{i}_SHADOW_CASCADE_BLEND\n				cascadeIndex = ditherShadowCascadeIndex(cascadeIndex, light{i}_shadowCascadeDistances, light{i}_shadowCascadeCount, light{i}_shadowCascadeBlend);\n			#endif\n			mat4 shadowMatrix = light{i}_shadowMatrixPalette[cascadeIndex];\n		#else\n			mat4 shadowMatrix = light{i}_shadowMatrix;\n		#endif\n		#if LIGHT{i}TYPE == DIRECTIONAL\n			vec3 shadowCoord = getShadowSampleCoord{i}(shadowMatrix, light{i}_shadowParams, vPositionW, vec3(0.0), lightDirW, dLightDirNormW, dVertexNormalW);\n		#else\n			vec3 shadowCoord = getShadowSampleCoord{i}(shadowMatrix, light{i}_shadowParams, vPositionW, light{i}_position, lightDirW, dLightDirNormW, dVertexNormalW);\n		#endif\n		#if LIGHT{i}TYPE == DIRECTIONAL\n			shadowCoord = fadeShadow(shadowCoord, light{i}_shadowCascadeDistances);\n		#endif\n		#if LIGHT{i}TYPE == DIRECTIONAL\n			#if LIGHT{i}SHADOWTYPE == VSM_16F\n				return getShadowVSM16(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, 5.54);\n			#endif\n			#if LIGHT{i}SHADOWTYPE == VSM_32F\n				return getShadowVSM32(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, 15.0);\n			#endif\n			#if LIGHT{i}SHADOWTYPE == PCSS_32F\n				#if LIGHT{i}SHAPE != PUNCTUAL\n					vec2 shadowSearchArea = vec2(length(light{i}_halfWidth), length(light{i}_halfHeight)) * light{i}_shadowSearchArea;\n					return getShadowPCSS(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, light{i}_cameraParams, shadowSearchArea, lightDirW);\n				#else\n					return getShadowPCSS(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, light{i}_cameraParams, light{i}_softShadowParams, lightDirW);\n				#endif\n			#endif\n			#if LIGHT{i}SHADOWTYPE == PCF1_16F || LIGHT{i}SHADOWTYPE == PCF1_32F\n				return getShadowPCF1x1(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams);\n			#endif\n			#if LIGHT{i}SHADOWTYPE == PCF3_16F || LIGHT{i}SHADOWTYPE == PCF3_32F\n				return getShadowPCF3x3(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams);\n			#endif\n			#if LIGHT{i}SHADOWTYPE == PCF5_16F || LIGHT{i}SHADOWTYPE == PCF5_32F\n				return getShadowPCF5x5(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams);\n			#endif\n		#endif\n		#if LIGHT{i}TYPE == SPOT\n			#if LIGHT{i}SHADOWTYPE == VSM_16F\n				return getShadowSpotVSM16(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, 5.54, lightDirW);\n			#endif\n			#if LIGHT{i}SHADOWTYPE == VSM_32F\n				return getShadowSpotVSM32(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, 15.0, lightDirW);\n			#endif\n			#if LIGHT{i}SHADOWTYPE == PCSS_32F\n				#if LIGHT{i}SHAPE != PUNCTUAL\n					vec2 shadowSearchArea = vec2(length(light{i}_halfWidth), length(light{i}_halfHeight)) * light{i}_shadowSearchArea;\n				#else\n					vec2 shadowSearchArea = vec2(light{i}_shadowSearchArea);\n				#endif\n				return getShadowSpotPCSS(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, light{i}_cameraParams, shadowSearchArea, lightDirW);\n			#endif\n			#if LIGHT{i}SHADOWTYPE == PCF1_16F || LIGHT{i}SHADOWTYPE == PCF1_32F\n				return getShadowSpotPCF1x1(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams);\n			#endif\n			#if LIGHT{i}SHADOWTYPE == PCF3_16F || LIGHT{i}SHADOWTYPE == PCF3_32F\n				return getShadowSpotPCF3x3(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams);\n			#endif\n			#if LIGHT{i}SHADOWTYPE == PCF5_16F || LIGHT{i}SHADOWTYPE == PCF5_32F\n				return getShadowSpotPCF5x5(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams);\n			#endif\n		#endif\n		#if LIGHT{i}TYPE == OMNI\n			#if LIGHT{i}SHADOWTYPE == PCSS_32F\n				#if LIGHT{i}SHAPE != PUNCTUAL\n					vec2 shadowSearchArea = vec2(length(light{i}_halfWidth), length(light{i}_halfHeight)) * light{i}_shadowSearchArea;\n				#else\n					vec2 shadowSearchArea = vec2(light{i}_shadowSearchArea);\n				#endif\n				return getShadowOmniPCSS(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, light{i}_cameraParams, shadowSearchArea, lightDirW);\n			#endif\n			#if LIGHT{i}SHADOWTYPE == PCF1_16F || LIGHT{i}SHADOWTYPE == PCF1_32F\n				return getShadowOmniPCF1x1(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, lightDirW);\n			#endif\n			#if LIGHT{i}SHADOWTYPE == PCF3_16F || LIGHT{i}SHADOWTYPE == PCF3_32F\n				return getShadowOmniPCF3x3(SHADOWMAP_PASS(light{i}_shadowMap), shadowCoord, light{i}_shadowParams, lightDirW);\n			#endif\n		#endif\n	}\n#endif\n";
            
            var lightingPS$1 = '\n#ifdef LIT_CLUSTERED_LIGHTS\n	#define LIT_CODE_FALLOFF_LINEAR\n	#define LIT_CODE_FALLOFF_SQUARED\n	#define LIT_CODE_LIGHTS_POINT\n	#define LIT_CODE_LIGHTS_SPOT\n#endif\n#ifdef AREA_LIGHTS\n	uniform highp sampler2D areaLightsLutTex1;\n	uniform highp sampler2D areaLightsLutTex2;\n#endif\n#ifdef LIT_LIGHTING\n	#include "lightDiffuseLambertPS"\n	#if defined(AREA_LIGHTS) || defined(LIT_CLUSTERED_AREA_LIGHTS)\n		#include "ltcPS"\n	#endif\n#endif\n#ifdef SHADOW_DIRECTIONAL\n	#include "shadowCascadesPS"\n#endif\n#if defined(SHADOW_KIND_PCF1)\n	#include "shadowPCF1PS"\n#endif\n#if defined(SHADOW_KIND_PCF3)\n	#include "shadowPCF3PS"\n#endif\n#if defined(SHADOW_KIND_PCF5)\n	#include "shadowPCF5PS"\n#endif\n#if defined(SHADOW_KIND_PCSS)\n	#include "linearizeDepthPS"\n	#include "shadowPCSSPS"\n	#include "shadowSoftPS"\n#endif\n#if defined(SHADOW_KIND_VSM)\n	#include "shadowEVSMPS"\n#endif\n#ifdef LIT_CODE_FALLOFF_LINEAR\n	#include "falloffLinearPS"\n#endif\n#ifdef LIT_CODE_FALLOFF_SQUARED\n	#include "falloffInvSquaredPS"\n#endif\n#ifdef LIT_CODE_LIGHTS_POINT\n	#include "lightDirPointPS"\n#endif\n#ifdef LIT_CODE_LIGHTS_SPOT\n	#include "spotPS"\n#endif\n#ifdef LIT_CODE_COOKIE\n	#include "cookiePS"\n#endif\n#ifdef LIT_CLUSTERED_LIGHTS\n	#include "clusteredLightPS"\n#endif\n#ifdef LIGHT_COUNT > 0\n	#include "lightFunctionShadowPS, LIGHT_COUNT"\n	#include "lightFunctionLightPS, LIGHT_COUNT"\n#endif\n';
            
            var lightmapAddPS = "\nvoid addLightMap(\n	vec3 lightmap, \n	vec3 dir, \n	vec3 worldNormal, \n	vec3 viewDir, \n	vec3 reflectionDir, \n	float gloss, \n	vec3 specularity, \n	vec3 vertexNormal, \n	mat3 tbn\n#if defined(LIT_IRIDESCENCE)\n	vec3 iridescenceFresnel, \n	float iridescenceIntensity\n#endif\n) {\n	#if defined(LIT_SPECULAR) && defined(LIT_DIR_LIGHTMAP)\n		if (dot(dir, dir) < 0.0001) {\n				dDiffuseLight += lightmap;\n		} else {\n			float vlight = saturate(dot(dir, -vertexNormal));\n			float flight = saturate(dot(dir, -worldNormal));\n			float nlight = (flight / max(vlight, 0.01)) * 0.5;\n			dDiffuseLight += lightmap * nlight * 2.0;\n			vec3 halfDir = normalize(-dir + viewDir);\n			vec3 specularLight = lightmap * getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dir, gloss, tbn);\n			#ifdef LIT_SPECULAR_FRESNEL\n				specularLight *= \n					getFresnel(dot(viewDir, halfDir), \n					gloss, \n					specularity\n				#if defined(LIT_IRIDESCENCE)\n					, iridescenceFresnel,\n					iridescenceIntensity\n				#endif\n					);\n			#endif\n			dSpecularLight += specularLight;\n		}\n	#else\n		dDiffuseLight += lightmap;\n	#endif\n}\n";
            
            var lightmapPS = "\n#ifdef STD_LIGHTMAP_DIR\n	vec3 dLightmapDir;\n	uniform sampler2D texture_dirLightMap;\n#endif\nvoid getLightMap() {\n	dLightmap = vec3(1.0);\n	#ifdef STD_LIGHT_TEXTURE\n		dLightmap *= {STD_LIGHT_TEXTURE_DECODE}(texture2DBias({STD_LIGHT_TEXTURE_NAME}, {STD_LIGHT_TEXTURE_UV}, textureBias)).{STD_LIGHT_TEXTURE_CHANNEL};\n		#ifdef STD_LIGHTMAP_DIR\n			vec3 dir = texture2DBias(texture_dirLightMap, {STD_LIGHT_TEXTURE_UV}, textureBias).xyz * 2.0 - 1.0;\n			float dirDot = dot(dir, dir);\n			dLightmapDir = (dirDot > 0.001) ? dir / sqrt(dirDot) : vec3(0.0);\n		#endif\n	#endif\n	#ifdef STD_LIGHT_VERTEX\n		dLightmap *= saturate(vVertexColor.{STD_LIGHT_VERTEX_CHANNEL});\n	#endif\n}\n";
            
            var lightSpecularAnisoGGXPS = "\nfloat calcLightSpecular(float gloss, vec3 worldNormal, vec3 viewDir, vec3 h, vec3 lightDirNorm, mat3 tbn) {\n	float PI = 3.141592653589793;\n	float roughness = max((1.0 - gloss) * (1.0 - gloss), 0.001);\n	float anisotropy = material_anisotropy * roughness;\n \n	float at = max((roughness + anisotropy), roughness / 4.0);\n	float ab = max((roughness - anisotropy), roughness / 4.0);\n	float NoH = dot(worldNormal, h);\n	float ToH = dot(tbn[0], h);\n	float BoH = dot(tbn[1], h);\n	float a2 = at * ab;\n	vec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);\n	float v2 = dot(v, v);\n	float w2 = a2 / v2;\n	float D = a2 * w2 * w2 * (1.0 / PI);\n	float ToV = dot(tbn[0], viewDir);\n	float BoV = dot(tbn[1], viewDir);\n	float ToL = dot(tbn[0], -lightDirNorm);\n	float BoL = dot(tbn[1], -lightDirNorm);\n	float NoV = dot(worldNormal, viewDir);\n	float NoL = dot(worldNormal, -lightDirNorm);\n	float lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));\n	float lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));\n	float G = 0.5 / (lambdaV + lambdaL);\n	return D * G;\n}\nfloat getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {\n	return calcLightSpecular(gloss, worldNormal, viewDir, h, lightDirNorm, tbn);\n}\n";
            
            var lightSpecularBlinnPS = "\nfloat calcLightSpecular(float gloss, vec3 worldNormal, vec3 h) {\n	float nh = max( dot( h, worldNormal ), 0.0 );\n	float specPow = exp2(gloss * 11.0);\n	specPow = max(specPow, 0.0001);\n	return pow(nh, specPow) * (specPow + 2.0) / 8.0;\n}\nfloat getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {\n	return calcLightSpecular(gloss, worldNormal, h);\n}\n";
            
            var lightSheenPS = "\nfloat sheenD(vec3 normal, vec3 h, float roughness) {\n	const float PI = 3.141592653589793;\n	float invR = 1.0 / (roughness * roughness);\n	float cos2h = max(dot(normal, h), 0.0);\n	cos2h *= cos2h;\n	float sin2h = max(1.0 - cos2h, 0.0078125);\n	return (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);\n}\nfloat sheenV(vec3 normal, vec3 viewDir, vec3 light) {\n	float NoV = max(dot(normal, viewDir), 0.000001);\n	float NoL = max(dot(normal, light), 0.000001);\n	return 1.0 / (4.0 * (NoL + NoV - NoL * NoV));\n}\nfloat getLightSpecularSheen(vec3 h, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float sheenGloss) {\n	float D = sheenD(worldNormal, h, sheenGloss);\n	float V = sheenV(worldNormal, viewDir, -lightDirNorm);\n	return D * V;\n}\n";
            
            var linearizeDepthPS = "\n#ifndef LINEARIZE_DEPTH\n#define LINEARIZE_DEPTH\nfloat linearizeDepth(float z, vec4 cameraParams) {\n	if (cameraParams.w == 0.0)\n		return (cameraParams.z * cameraParams.y) / (cameraParams.y + z * (cameraParams.z - cameraParams.y));\n	else\n		return cameraParams.z + z * (cameraParams.y - cameraParams.z);\n}\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nfloat linearizeDepth(float z) {\n	return linearizeDepth(z, camera_params);\n}\n#endif\n";
            
            var litForwardBackendPS$1 = '\nvoid evaluateBackend() {\n	#ifdef LIT_SSAO\n		litArgs_ao *= texture2DLod(ssaoTexture, gl_FragCoord.xy * ssaoTextureSizeInv, 0.0).r;\n	#endif\n	#ifdef LIT_NEEDS_NORMAL\n		#ifdef LIT_SPECULAR\n			getReflDir(litArgs_worldNormal, dViewDirW, litArgs_gloss, dTBN);\n		#endif\n		#ifdef LIT_CLEARCOAT\n			ccReflDirW = normalize(-reflect(dViewDirW, litArgs_clearcoat_worldNormal));\n		#endif\n	#endif\n	#ifdef LIT_SPECULAR_OR_REFLECTION\n		#ifdef LIT_METALNESS\n			float f0 = 1.0 / litArgs_ior;\n			f0 = (f0 - 1.0) / (f0 + 1.0);\n			f0 *= f0;\n			litArgs_specularity = getSpecularModulate(litArgs_specularity, litArgs_albedo, litArgs_metalness, f0);\n			litArgs_albedo = getAlbedoModulate(litArgs_albedo, litArgs_metalness);\n		#endif\n		#ifdef LIT_IRIDESCENCE\n			vec3 iridescenceFresnel = getIridescence(saturate(dot(dViewDirW, litArgs_worldNormal)), litArgs_specularity, litArgs_iridescence_thickness);\n		#endif\n	#endif\n	#ifdef LIT_ADD_AMBIENT\n		addAmbient(litArgs_worldNormal);\n		#ifdef LIT_SPECULAR\n			dDiffuseLight = dDiffuseLight * (1.0 - litArgs_specularity);\n		#endif\n		#ifdef LIT_SEPARATE_AMBIENT\n			vec3 dAmbientLight = dDiffuseLight;\n			dDiffuseLight = vec3(0);\n		#endif\n	#endif\n	#ifndef LIT_OLD_AMBIENT\n		dDiffuseLight *= material_ambient;\n	#endif\n	#ifdef LIT_AO\n		#ifndef LIT_OCCLUDE_DIRECT\n			occludeDiffuse(litArgs_ao);\n		#endif\n	#endif\n	#ifdef LIT_LIGHTMAP\n		addLightMap(\n			litArgs_lightmap, \n			litArgs_lightmapDir, \n			litArgs_worldNormal, \n			dViewDirW, \n			dReflDirW, \n			litArgs_gloss, \n			litArgs_specularity, \n			dVertexNormalW,\n			dTBN\n		#if defined(LIT_IRIDESCENCE)\n			, iridescenceFresnel,\n			litArgs_iridescence_intensity\n		#endif\n		);\n	#endif\n	#ifdef LIT_LIGHTING || LIT_REFLECTIONS\n		#ifdef LIT_REFLECTIONS\n			#ifdef LIT_CLEARCOAT\n				addReflectionCC(ccReflDirW, litArgs_clearcoat_gloss);\n			\n				#ifdef LIT_SPECULAR_FRESNEL\n					ccFresnel = getFresnelCC(dot(dViewDirW, litArgs_clearcoat_worldNormal));\n					ccReflection.rgb *= ccFresnel;\n				#else\n					ccFresnel = 0.0;\n				#endif\n			#endif\n			#ifdef LIT_SPECULARITY_FACTOR\n				ccReflection.rgb *= litArgs_specularityFactor;\n			#endif\n			#ifdef LIT_SHEEN\n				addReflectionSheen(litArgs_worldNormal, dViewDirW, litArgs_sheen_gloss);\n			#endif\n			addReflection(dReflDirW, litArgs_gloss);\n			#ifdef LIT_FRESNEL_MODEL\n				dReflection.rgb *= getFresnel(\n					dot(dViewDirW, litArgs_worldNormal), \n					litArgs_gloss, \n					litArgs_specularity\n				#if defined(LIT_IRIDESCENCE)\n					, iridescenceFresnel,\n					litArgs_iridescence_intensity\n				#endif\n					);\n			#else\n				dReflection.rgb *= litArgs_specularity;\n			#endif\n			#ifdef LIT_SPECULARITY_FACTOR\n				dReflection.rgb *= litArgs_specularityFactor;\n			#endif\n		#endif\n		#ifdef AREA_LIGHTS\n			dSpecularLight *= litArgs_specularity;\n			#ifdef LIT_SPECULAR\n				calcLTCLightValues(litArgs_gloss, litArgs_worldNormal, dViewDirW, litArgs_specularity, litArgs_clearcoat_gloss, litArgs_clearcoat_worldNormal, litArgs_clearcoat_specularity);\n			#endif\n		#endif\n		\n		#include "lightEvaluationPS, LIGHT_COUNT"\n		#ifdef LIT_CLUSTERED_LIGHTS\n			addClusteredLights(litArgs_worldNormal, dViewDirW, dReflDirW,\n				#if defined(LIT_CLEARCOAT)\n						ccReflDirW,\n				#endif\n						litArgs_gloss, litArgs_specularity, dVertexNormalW, dTBN, \n				#if defined(LIT_IRIDESCENCE)\n						iridescenceFresnel,\n				#endif\n						litArgs_clearcoat_worldNormal, litArgs_clearcoat_gloss, litArgs_sheen_gloss, litArgs_iridescence_intensity\n			);\n		#endif\n		#ifdef AREA_LIGHTS\n			#ifdef LIT_CLEARCOAT\n				litArgs_clearcoat_specularity = 1.0;\n			#endif\n			#ifdef LIT_SPECULAR\n				litArgs_specularity = vec3(1);\n			#endif\n		#endif\n		#ifdef LIT_REFRACTION\n			addRefraction(\n				litArgs_worldNormal, \n				dViewDirW, \n				litArgs_thickness, \n				litArgs_gloss, \n				litArgs_specularity, \n				litArgs_albedo, \n				litArgs_transmission,\n				litArgs_ior,\n				litArgs_dispersion\n				#if defined(LIT_IRIDESCENCE)\n					, iridescenceFresnel, \n					litArgs_iridescence_intensity\n				#endif\n			);\n		#endif\n	#endif\n	#ifdef LIT_AO\n		#ifdef LIT_OCCLUDE_DIRECT\n			occludeDiffuse(litArgs_ao);\n		#endif\n		#if LIT_OCCLUDE_SPECULAR != NONE\n			occludeSpecular(litArgs_gloss, litArgs_ao, litArgs_worldNormal, dViewDirW);\n		#endif\n	#endif\n	#ifdef LIT_SPECULARITY_FACTOR\n		dSpecularLight *= litArgs_specularityFactor;\n	#endif\n	#if !defined(LIT_OPACITY_FADES_SPECULAR)\n		#if LIT_BLEND_TYPE == NORMAL || LIT_BLEND_TYPE == PREMULTIPLIED\n			float specLum = dot((dSpecularLight + dReflection.rgb * dReflection.a), vec3( 0.2126, 0.7152, 0.0722 ));\n			#ifdef LIT_CLEARCOAT\n				specLum += dot(ccSpecularLight * litArgs_clearcoat_specularity + ccReflection.rgb * litArgs_clearcoat_specularity, vec3( 0.2126, 0.7152, 0.0722 ));\n			#endif\n			litArgs_opacity = clamp(litArgs_opacity + gammaCorrectInput(specLum), 0.0, 1.0);\n		#endif\n		litArgs_opacity *= material_alphaFade;\n	#endif\n	#include "endPS"\n	#include "outputAlphaPS"\n	#ifdef LIT_MSDF\n		gl_FragColor = applyMsdf(gl_FragColor);\n	#endif\n	#include "outputPS"\n	#include "debugOutputPS"\n	#ifdef LIT_SHADOW_CATCHER\n		gl_FragColor.rgb = vec3(dShadowCatcher);\n	#endif\n}\n';
            
            var litForwardDeclarationPS$1 = '\nvec3 sReflection;\nvec3 dVertexNormalW;\nvec3 dTangentW;\nvec3 dBinormalW;\nvec3 dViewDirW;\nvec3 dReflDirW;\nvec3 ccReflDirW;\nvec3 dLightDirNormW;\nfloat dAtten;\nmat3 dTBN;\nvec4 dReflection;\nvec3 dDiffuseLight;\nvec3 dSpecularLight;\nfloat ccFresnel;\nvec3 ccReflection;\nvec3 ccSpecularLight;\nfloat ccSpecularityNoFres;\nvec3 sSpecularLight;\n#ifdef LIT_DISPERSION\n	uniform float material_dispersion;\n#endif\n#ifndef LIT_OPACITY_FADES_SPECULAR\n	uniform float material_alphaFade;\n#endif\n#ifdef LIT_SSAO\n	uniform sampler2D ssaoTexture;\n	uniform vec2 ssaoTextureSizeInv;\n#endif\n#ifdef LIT_SHADOW_CATCHER\n	float dShadowCatcher = 1.0;\n#endif\n#if LIGHT_COUNT > 0\n	#include "lightDeclarationPS, LIGHT_COUNT"\n#endif\n#ifdef LIT_SPECULAR\n	#if LIT_FRESNEL_MODEL == NONE && !defined(LIT_REFLECTIONS) && !defined(LIT_DIFFUSE_MAP) \n		#define LIT_OLD_AMBIENT\n	#endif\n#endif\n';
            
            var litForwardMainPS$1 = '\nvoid main(void) {\n	dReflection = vec4(0);\n	#ifdef LIT_CLEARCOAT\n		ccSpecularLight = vec3(0);\n		ccReflection = vec3(0);\n	#endif\n	#if LIT_NONE_SLICE_MODE == SLICED\n		#include "startNineSlicedPS"\n	#elif LIT_NONE_SLICE_MODE == TILED\n		#include "startNineSlicedTiledPS"\n	#endif\n	#ifdef LIT_NEEDS_NORMAL\n		dVertexNormalW = normalize(vNormalW);\n		#ifdef LIT_TANGENTS\n			#if defined(LIT_HEIGHTS) || defined(LIT_USE_NORMALS) || defined(LIT_USE_CLEARCOAT_NORMALS)\n				dTangentW = vTangentW;\n				dBinormalW = vBinormalW;\n			#endif\n		#endif\n		getViewDir();\n		#ifdef LIT_TBN\n			getTBN(dTangentW, dBinormalW, dVertexNormalW);\n			#ifdef LIT_TWO_SIDED_LIGHTING\n				handleTwoSidedLighting();\n			#endif\n		#endif\n	#endif\n	evaluateFrontend();\n	#include "debugProcessFrontendPS"\n	evaluateBackend();\n}\n';
            
            var litForwardPostCodePS$1 = '\n#ifdef LIT_NEEDS_NORMAL\n	#include "cubeMapRotatePS"\n	#include "cubeMapProjectPS"\n	#include "envProcPS"\n#endif\n#ifdef LIT_SPECULAR_OR_REFLECTION\n	#ifdef LIT_METALNESS\n		#include "metalnessModulatePS"\n	#endif\n	#if LIT_FRESNEL_MODEL == SCHLICK\n		#include "fresnelSchlickPS"\n	#endif\n	#ifdef LIT_IRIDESCENCE\n		#include "iridescenceDiffractionPS"\n	#endif\n#endif\n#ifdef LIT_AO\n	#include "aoDiffuseOccPS"\n	#include "aoSpecOccPS"\n#endif\n#if LIT_REFLECTION_SOURCE == ENVATLASHQ\n	#include "envAtlasPS"\n	#include "reflectionEnvHQPS"\n#elif LIT_REFLECTION_SOURCE == ENVATLAS\n	#include "envAtlasPS"\n	#include "reflectionEnvPS"\n#elif LIT_REFLECTION_SOURCE == CUBEMAP\n	#include "reflectionCubePS"\n#elif LIT_REFLECTION_SOURCE == SPHEREMAP\n	#include "reflectionSpherePS"\n#endif\n#ifdef LIT_REFLECTIONS\n	#ifdef LIT_CLEARCOAT\n		#include "reflectionCCPS"\n	#endif\n	#ifdef LIT_SHEEN\n		#include "reflectionSheenPS"\n	#endif\n#endif\n#ifdef LIT_REFRACTION\n	#if defined(LIT_DYNAMIC_REFRACTION)\n		#include "refractionDynamicPS"\n	#elif defined(LIT_REFLECTIONS)\n		#include "refractionCubePS"\n	#endif\n#endif\n#ifdef LIT_SHEEN\n	#include "lightSheenPS"\n#endif\n#ifdef LIT_GGX_SPECULAR\n	uniform float material_anisotropy;\n#endif\nuniform vec3 material_ambient;\n#ifdef LIT_SPECULAR\n	#ifdef LIT_LIGHTING\n		#ifdef LIT_GGX_SPECULAR\n			#include "lightSpecularAnisoGGXPS"\n		#else\n			#include "lightSpecularBlinnPS"\n		#endif\n	#endif\n#endif\n#include "combinePS"\n#ifdef LIT_LIGHTMAP\n	#include "lightmapAddPS"\n#endif\n#ifdef LIT_ADD_AMBIENT\n	#include "ambientPS"\n#endif\n#ifdef LIT_MSDF\n	#include "msdfPS"\n#endif\n#ifdef LIT_NEEDS_NORMAL\n	#include "viewDirPS"\n	#ifdef LIT_SPECULAR\n		#ifdef LIT_GGX_SPECULAR\n			#include "reflDirAnisoPS"\n		#else\n			#include "reflDirPS"\n		#endif\n	#endif\n#endif\n#include "lightingPS"\n';
            
            var litForwardPreCodePS$1 = '\n#include "basePS"\n#include "sphericalPS"\n#include "decodePS"\n#include "gammaPS"\n#include "tonemappingPS"\n#include "fogPS"\n#if LIT_NONE_SLICE_MODE == SLICED\n	#include "baseNineSlicedPS"\n#elif LIT_NONE_SLICE_MODE == TILED\n	#include "baseNineSlicedTiledPS"\n#endif\n#ifdef LIT_TBN\n	#include "TBNPS"\n	#ifdef LIT_TWO_SIDED_LIGHTING\n		#include "twoSidedLightingPS"\n	#endif\n#endif\n';
            
            var litMainVS$1 = '\n#ifdef VERTEX_COLOR\n	attribute vec4 vertex_color;\n#endif\n#ifdef NINESLICED\n	varying vec2 vMask;\n	varying vec2 vTiledUv;\n	uniform mediump vec4 innerOffset;\n	uniform mediump vec2 outerScale;\n	uniform mediump vec4 atlasRect;\n#endif\nvec3 dPositionW;\nmat4 dModelMatrix;\n#include "transformCoreVS"\n#ifdef UV0\n	attribute vec2 vertex_texCoord0;\n	#include "uv0VS"\n#endif\n#ifdef UV1\n	attribute vec2 vertex_texCoord1;\n	#include "uv1VS"\n#endif\n#ifdef LINEAR_DEPTH\n	#ifndef VIEWMATRIX\n	#define VIEWMATRIX\n		uniform mat4 matrix_view;\n	#endif\n#endif\n#include "transformVS"\n#ifdef NORMALS\n	#include "normalCoreVS"\n	#include "normalVS"\n#endif\n#ifdef TANGENTS\n	attribute vec4 vertex_tangent;\n	#include "tangentBinormalVS"\n#endif\n#include "uvTransformUniformsPS, UV_TRANSFORMS_COUNT"\n#ifdef MSDF\n	#include "msdfVS"\n#endif\nvoid main(void) {\n	gl_Position = getPosition();\n	vPositionW = getWorldPosition();\n	#ifdef NORMALS\n		vNormalW = getNormal();\n	#endif\n	#ifdef TANGENTS\n		vTangentW = getTangent();\n		vBinormalW = getBinormal();\n	#elif defined(GGX_SPECULAR)\n		vObjectSpaceUpW = normalize(dNormalMatrix * vec3(0, 1, 0));\n	#endif\n	#ifdef UV0\n		vec2 uv0 = getUv0();\n		#ifdef UV0_UNMODIFIED\n			vUv0 = uv0;\n		#endif\n	#endif\n	#ifdef UV1\n		vec2 uv1 = getUv1();\n		#ifdef UV1_UNMODIFIED\n			vUv1 = uv1;\n		#endif\n	#endif\n	#include "uvTransformVS, UV_TRANSFORMS_COUNT"\n	#ifdef VERTEX_COLOR\n		vVertexColor = vertex_color;\n	#endif\n	#ifdef LINEAR_DEPTH\n		vLinearDepth = -(matrix_view * vec4(vPositionW, 1.0)).z;\n	#endif\n	#ifdef MSDF\n		unpackMsdfParams();\n	#endif\n}\n';
            
            var litOtherMainPS = '\n#ifdef PICK_PASS\n	#include "pickPS"\n#endif\n#ifdef PREPASS_PASS\n	#include "floatAsUintPS"\n#endif\nvoid main(void) {\n	evaluateFrontend();\n	#ifdef PICK_PASS\n		gl_FragColor = getPickOutput();\n	#endif\n	#ifdef DEPTH_PASS\n		gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n	#endif\n	#ifdef PREPASS_PASS\n		gl_FragColor = float2vec4(vLinearDepth);\n	#endif\n}\n';
            
            var litShaderArgsPS$1 = "\nvec3 litArgs_albedo;\nfloat litArgs_opacity;\nvec3 litArgs_emission;\nvec3 litArgs_worldNormal;\nfloat litArgs_ao;\nvec3 litArgs_lightmap;\nvec3 litArgs_lightmapDir;\nfloat litArgs_metalness;\nvec3 litArgs_specularity;\nfloat litArgs_specularityFactor;\nfloat litArgs_gloss;\nfloat litArgs_sheen_gloss;\nvec3 litArgs_sheen_specularity;\nfloat litArgs_transmission;\nfloat litArgs_thickness;\nfloat litArgs_ior;\nfloat litArgs_dispersion;\nfloat litArgs_iridescence_intensity;\nfloat litArgs_iridescence_thickness;\nvec3 litArgs_clearcoat_worldNormal;\nfloat litArgs_clearcoat_specularity;\nfloat litArgs_clearcoat_gloss;\n";
            
            var litShaderCorePS$1 = '\n	#if LIT_NONE_SLICE_MODE == TILED\n		const float textureBias = -1000.0;\n	#else\n		uniform float textureBias;\n	#endif\n	#include "litShaderArgsPS"\n';
            
            var litShadowMainPS = '\n#if LIGHT_TYPE != DIRECTIONAL\n	uniform vec3 view_position;\n	uniform float light_radius;\n#endif\n#if SHADOW_TYPE == PCSS_32F\n	#include "linearizeDepthPS"\n#endif\nvoid main(void) {\n	evaluateFrontend();\n	#ifdef PERSPECTIVE_DEPTH\n		float depth = gl_FragCoord.z;\n		#if SHADOW_TYPE == PCSS_32F\n			#if LIGHT_TYPE != DIRECTIONAL\n				depth = linearizeDepth(depth, camera_params);\n			#endif\n		#endif\n	#else\n		float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);\n		#define MODIFIED_DEPTH\n	#endif\n	#if SHADOW_TYPE == VSM_16F || SHADOW_TYPE == VSM_32F\n		#if SHADOW_TYPE == VSM_32F\n			float exponent = 15.0;\n		#else\n			float exponent = 5.54;\n		#endif\n		depth = 2.0 * depth - 1.0;\n		depth =  exp(exponent * depth);\n		gl_FragColor = vec4(depth, depth*depth, 1.0, 1.0);\n	#else\n		#if SHADOW_TYPE == PCSS_32F\n			gl_FragColor.r = depth;\n		#else\n			#ifdef MODIFIED_DEPTH\n				gl_FragDepth = depth;\n			#endif\n			gl_FragColor = vec4(1.0);\n		#endif\n	#endif\n}\n';
            
            var ltcPS = "\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nstruct Coords {\n	vec3 coord0;\n	vec3 coord1;\n	vec3 coord2;\n	vec3 coord3;\n};\nfloat LTC_EvaluateRect( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in Coords rectCoords) {\n	vec3 v1 = rectCoords.coord1 - rectCoords.coord0;\n	vec3 v2 = rectCoords.coord3 - rectCoords.coord0;\n	\n	vec3 lightNormal = cross( v1, v2 );\n	float factor = sign(-dot( lightNormal, P - rectCoords.coord0 ));\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 =  factor * cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords.coord0 - P );\n	coords[ 1 ] = mat * ( rectCoords.coord1 - P );\n	coords[ 2 ] = mat * ( rectCoords.coord2 - P );\n	coords[ 3 ] = mat * ( rectCoords.coord3 - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return result;\n}\nCoords dLTCCoords;\nCoords getLTCLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\n	Coords coords;\n	coords.coord0 = lightPos + halfWidth - halfHeight;\n	coords.coord1 = lightPos - halfWidth - halfHeight;\n	coords.coord2 = lightPos - halfWidth + halfHeight;\n	coords.coord3 = lightPos + halfWidth + halfHeight;\n	return coords;\n}\nfloat dSphereRadius;\nCoords getSphereLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\n	dSphereRadius = max(length(halfWidth), length(halfHeight));\n	vec3 f = reflect(normalize(lightPos - view_position), vNormalW);\n	vec3 w = normalize(cross(f, halfHeight));\n	vec3 h = normalize(cross(f, w));\n	return getLTCLightCoords(lightPos, w * dSphereRadius, h * dSphereRadius);\n}\nvec2 dLTCUV;\n#ifdef LIT_CLEARCOAT\nvec2 ccLTCUV;\n#endif\nvec2 getLTCLightUV(float gloss, vec3 worldNormal, vec3 viewDir)\n{\n	float roughness = max((1.0 - gloss) * (1.0 - gloss), 0.001);\n	return LTC_Uv( worldNormal, viewDir, roughness );\n}\nvec3 dLTCSpecFres;\n#ifdef LIT_CLEARCOAT\nvec3 ccLTCSpecFres;\n#endif\nvec3 getLTCLightSpecFres(vec2 uv, vec3 specularity)\n{\n	vec4 t2 = texture2DLod(areaLightsLutTex2, uv, 0.0);\n	return specularity * t2.x + ( vec3( 1.0 ) - specularity) * t2.y;\n}\nvoid calcLTCLightValues(float gloss, vec3 worldNormal, vec3 viewDir, vec3 specularity, float clearcoatGloss, vec3 clearcoatWorldNormal, float clearcoatSpecularity)\n{\n	dLTCUV = getLTCLightUV(gloss, worldNormal, viewDir);\n	dLTCSpecFres = getLTCLightSpecFres(dLTCUV, specularity); \n#ifdef LIT_CLEARCOAT\n	ccLTCUV = getLTCLightUV(clearcoatGloss, clearcoatWorldNormal, viewDir);\n	ccLTCSpecFres = getLTCLightSpecFres(ccLTCUV, vec3(clearcoatSpecularity));\n#endif\n}\nvoid calcRectLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n	dLTCCoords = getLTCLightCoords(lightPos, halfWidth, halfHeight);\n}\nvoid calcDiskLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n	calcRectLightValues(lightPos, halfWidth, halfHeight);\n}\nvoid calcSphereLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n	dLTCCoords = getSphereLightCoords(lightPos, halfWidth, halfHeight);\n}\nvec3 SolveCubic(vec4 Coefficient)\n{\n	float pi = 3.14159;\n	Coefficient.xyz /= Coefficient.w;\n	Coefficient.yz /= 3.0;\n	float A = Coefficient.w;\n	float B = Coefficient.z;\n	float C = Coefficient.y;\n	float D = Coefficient.x;\n	vec3 Delta = vec3(\n		-Coefficient.z * Coefficient.z + Coefficient.y,\n		-Coefficient.y * Coefficient.z + Coefficient.x,\n		dot(vec2(Coefficient.z, -Coefficient.y), Coefficient.xy)\n	);\n	float Discriminant = dot(vec2(4.0 * Delta.x, -Delta.y), Delta.zy);\n	vec3 RootsA, RootsD;\n	vec2 xlc, xsc;\n	{\n		float A_a = 1.0;\n		float C_a = Delta.x;\n		float D_a = -2.0 * B * Delta.x + Delta.y;\n		float Theta = atan(sqrt(Discriminant), -D_a) / 3.0;\n		float x_1a = 2.0 * sqrt(-C_a) * cos(Theta);\n		float x_3a = 2.0 * sqrt(-C_a) * cos(Theta + (2.0 / 3.0) * pi);\n		float xl;\n		if ((x_1a + x_3a) > 2.0 * B)\n			xl = x_1a;\n		else\n			xl = x_3a;\n		xlc = vec2(xl - B, A);\n	}\n	{\n		float A_d = D;\n		float C_d = Delta.z;\n		float D_d = -D * Delta.y + 2.0 * C * Delta.z;\n		float Theta = atan(D * sqrt(Discriminant), -D_d) / 3.0;\n		float x_1d = 2.0 * sqrt(-C_d) * cos(Theta);\n		float x_3d = 2.0 * sqrt(-C_d) * cos(Theta + (2.0 / 3.0) * pi);\n		float xs;\n		if (x_1d + x_3d < 2.0 * C)\n			xs = x_1d;\n		else\n			xs = x_3d;\n		xsc = vec2(-D, xs + C);\n	}\n	float E =  xlc.y * xsc.y;\n	float F = -xlc.x * xsc.y - xlc.y * xsc.x;\n	float G =  xlc.x * xsc.x;\n	vec2 xmc = vec2(C * F - B * G, -B * F + C * E);\n	vec3 Root = vec3(xsc.x / xsc.y, xmc.x / xmc.y, xlc.x / xlc.y);\n	if (Root.x < Root.y && Root.x < Root.z)\n		Root.xyz = Root.yxz;\n	else if (Root.z < Root.x && Root.z < Root.y)\n		Root.xyz = Root.xzy;\n	return Root;\n}\nfloat LTC_EvaluateDisk(vec3 N, vec3 V, vec3 P, mat3 Minv, Coords points)\n{\n	vec3 T1, T2;\n	T1 = normalize(V - N * dot(V, N));\n	T2 = cross(N, T1);\n	mat3 R = transposeMat3( mat3( T1, T2, N ) );\n	vec3 L_[ 3 ];\n	L_[ 0 ] = R * ( points.coord0 - P );\n	L_[ 1 ] = R * ( points.coord1 - P );\n	L_[ 2 ] = R * ( points.coord2 - P );\n	vec3 Lo_i = vec3(0);\n	vec3 C  = 0.5 * (L_[0] + L_[2]);\n	vec3 V1 = 0.5 * (L_[1] - L_[2]);\n	vec3 V2 = 0.5 * (L_[1] - L_[0]);\n	C  = Minv * C;\n	V1 = Minv * V1;\n	V2 = Minv * V2;\n	float a, b;\n	float d11 = dot(V1, V1);\n	float d22 = dot(V2, V2);\n	float d12 = dot(V1, V2);\n	if (abs(d12) / sqrt(d11 * d22) > 0.0001)\n	{\n		float tr = d11 + d22;\n		float det = -d12 * d12 + d11 * d22;\n		det = sqrt(det);\n		float u = 0.5 * sqrt(tr - 2.0 * det);\n		float v = 0.5 * sqrt(tr + 2.0 * det);\n		float e_max = (u + v) * (u + v);\n		float e_min = (u - v) * (u - v);\n		vec3 V1_, V2_;\n		if (d11 > d22)\n		{\n			V1_ = d12 * V1 + (e_max - d11) * V2;\n			V2_ = d12 * V1 + (e_min - d11) * V2;\n		}\n		else\n		{\n			V1_ = d12*V2 + (e_max - d22)*V1;\n			V2_ = d12*V2 + (e_min - d22)*V1;\n		}\n		a = 1.0 / e_max;\n		b = 1.0 / e_min;\n		V1 = normalize(V1_);\n		V2 = normalize(V2_);\n	}\n	else\n	{\n		a = 1.0 / dot(V1, V1);\n		b = 1.0 / dot(V2, V2);\n		V1 *= sqrt(a);\n		V2 *= sqrt(b);\n	}\n	vec3 V3 = normalize(cross(V1, V2));\n	if (dot(C, V3) < 0.0)\n		V3 *= -1.0;\n	float L  = dot(V3, C);\n	float x0 = dot(V1, C) / L;\n	float y0 = dot(V2, C) / L;\n	float E1 = inversesqrt(a);\n	float E2 = inversesqrt(b);\n	a *= L * L;\n	b *= L * L;\n	float c0 = a * b;\n	float c1 = a * b * (1.0 + x0 * x0 + y0 * y0) - a - b;\n	float c2 = 1.0 - a * (1.0 + x0 * x0) - b * (1.0 + y0 * y0);\n	float c3 = 1.0;\n	vec3 roots = SolveCubic(vec4(c0, c1, c2, c3));\n	float e1 = roots.x;\n	float e2 = roots.y;\n	float e3 = roots.z;\n	vec3 avgDir = vec3(a * x0 / (a - e2), b * y0 / (b - e2), 1.0);\n	mat3 rotate = mat3(V1, V2, V3);\n	avgDir = rotate * avgDir;\n	avgDir = normalize(avgDir);\n	float L1 = sqrt(-e2 / e3);\n	float L2 = sqrt(-e2 / e1);\n	float formFactor = max(0.0, L1 * L2 * inversesqrt((1.0 + L1 * L1) * (1.0 + L2 * L2)));\n	\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	vec2 uv = vec2(avgDir.z * 0.5 + 0.5, formFactor);\n	uv = uv*LUT_SCALE + LUT_BIAS;\n	float scale = texture2DLod(areaLightsLutTex2, uv, 0.0).w;\n	return formFactor*scale;\n}\nfloat FixNan(float value) {\n	#ifdef WEBGPU\n		return value != value ? 0.0 : value;\n	#else\n		return isnan(value) ? 0.0 : value;\n	#endif\n}\nfloat getRectLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {\n	return LTC_EvaluateRect( worldNormal, viewDir, vPositionW, mat3( 1.0 ), dLTCCoords );\n}\nfloat getDiskLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {\n	return FixNan(LTC_EvaluateDisk( worldNormal, viewDir, vPositionW, mat3( 1.0 ), dLTCCoords ));\n}\nfloat getSphereLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {\n	float falloff = dSphereRadius / (dot(lightDir, lightDir) + dSphereRadius);\n	return FixNan(getLightDiffuse(worldNormal, viewDir, lightDirNorm) * falloff);\n}\nmat3 getLTCLightInvMat(vec2 uv)\n{\n	vec4 t1 = texture2DLod(areaLightsLutTex1, uv, 0.0);\n	return mat3(\n		vec3( t1.x, 0, t1.y ),\n		vec3(	0, 1,	0 ),\n		vec3( t1.z, 0, t1.w )\n	);\n}\nfloat calcRectLightSpecular(vec3 worldNormal, vec3 viewDir, vec2 uv) {\n	mat3 mInv = getLTCLightInvMat(uv);\n	return LTC_EvaluateRect( worldNormal, viewDir, vPositionW, mInv, dLTCCoords );\n}\nfloat getRectLightSpecular(vec3 worldNormal, vec3 viewDir) {\n	return calcRectLightSpecular(worldNormal, viewDir, dLTCUV);\n}\nfloat calcDiskLightSpecular(vec3 worldNormal, vec3 viewDir, vec2 uv) {\n	mat3 mInv = getLTCLightInvMat(uv);\n	return LTC_EvaluateDisk( worldNormal, viewDir, vPositionW, mInv, dLTCCoords );\n}\nfloat getDiskLightSpecular(vec3 worldNormal, vec3 viewDir) {\n	return calcDiskLightSpecular(worldNormal, viewDir, dLTCUV);\n}\nfloat getSphereLightSpecular(vec3 worldNormal, vec3 viewDir) {\n	return calcDiskLightSpecular(worldNormal, viewDir, dLTCUV);\n}\n";
            
            var metalnessPS = "\n#ifdef STD_METALNESS_CONSTANT\nuniform float material_metalness;\n#endif\nvoid getMetalness() {\n	float metalness = 1.0;\n	#ifdef STD_METALNESS_CONSTANT\n	metalness *= material_metalness;\n	#endif\n	#ifdef STD_METALNESS_TEXTURE\n	metalness *= texture2DBias({STD_METALNESS_TEXTURE_NAME}, {STD_METALNESS_TEXTURE_UV}, textureBias).{STD_METALNESS_TEXTURE_CHANNEL};\n	#endif\n	#ifdef STD_METALNESS_VERTEX\n	metalness *= saturate(vVertexColor.{STD_METALNESS_VERTEX_CHANNEL});\n	#endif\n	dMetalness = metalness;\n}\n";
            
            var msdfPS = "\nuniform sampler2D texture_msdfMap;\nfloat median(float r, float g, float b) {\n	return max(min(r, g), min(max(r, g), b));\n}\nfloat map (float min, float max, float v) {\n	return (v - min) / (max - min);\n}\nuniform float font_sdfIntensity;\nuniform float font_pxrange;\nuniform float font_textureWidth;\n#ifndef LIT_MSDF_TEXT_ATTRIBUTE\n	uniform vec4 outline_color;\n	uniform float outline_thickness;\n	uniform vec4 shadow_color;\n	uniform vec2 shadow_offset;\n#else\n	varying vec4 outline_color;\n	varying float outline_thickness;\n	varying vec4 shadow_color;\n	varying vec2 shadow_offset;\n#endif\nvec4 applyMsdf(vec4 color) {\n	color.rgb = gammaCorrectInput(color.rgb);\n	vec3 tsample = texture2D(texture_msdfMap, vUv0).rgb;\n	vec2 uvShdw = vUv0 - shadow_offset;\n	vec3 ssample = texture2D(texture_msdfMap, uvShdw).rgb;\n	float sigDist = median(tsample.r, tsample.g, tsample.b);\n	float sigDistShdw = median(ssample.r, ssample.g, ssample.b);\n	float smoothingMax = 0.2;\n	vec2 w = fwidth(vUv0);\n	float smoothing = clamp(w.x * font_textureWidth / font_pxrange, 0.0, smoothingMax);\n	float mapMin = 0.05;\n	float mapMax = clamp(1.0 - font_sdfIntensity, mapMin, 1.0);\n	float sigDistInner = map(mapMin, mapMax, sigDist);\n	float sigDistOutline = map(mapMin, mapMax, sigDist + outline_thickness);\n	sigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thickness);\n	float center = 0.5;\n	float inside = smoothstep(center-smoothing, center+smoothing, sigDistInner);\n	float outline = smoothstep(center-smoothing, center+smoothing, sigDistOutline);\n	float shadow = smoothstep(center-smoothing, center+smoothing, sigDistShdw);\n	vec4 tcolor = (outline > inside) ? outline * vec4(outline_color.a * outline_color.rgb, outline_color.a) : vec4(0.0);\n	tcolor = mix(tcolor, color, inside);\n	vec4 scolor = (shadow > outline) ? shadow * vec4(shadow_color.a * shadow_color.rgb, shadow_color.a) : tcolor;\n	tcolor = mix(scolor, tcolor, outline);\n	tcolor.rgb = gammaCorrectOutput(tcolor.rgb);\n	\n	return tcolor;\n}\n";
            
            var metalnessModulatePS = "\nvec3 getSpecularModulate(in vec3 specularity, in vec3 albedo, in float metalness, in float f0) {\n	vec3 dielectricF0 = f0 * specularity;\n	return mix(dielectricF0, albedo, metalness);\n}\nvec3 getAlbedoModulate(in vec3 albedo, in float metalness) {\n	return albedo * (1.0 - metalness);\n}\n";
            
            var morphEvaluationPS$1 = "\n	color.xyz += morphFactor[{i}] * texture2DLod(morphBlendTex{i}, uv0, 0.0).xyz;\n";
            
            var morphDeclarationPS$1 = "\n	uniform highp sampler2D morphBlendTex{i};\n";
            
            var morphPS$1 = '\n	varying vec2 uv0;\n	#include "morphDeclarationPS, MORPH_TEXTURE_COUNT"\n	#if MORPH_TEXTURE_COUNT > 0\n		uniform highp float morphFactor[{MORPH_TEXTURE_COUNT}];\n	#endif\n	#ifdef MORPH_INT\n		uniform vec3 aabbSize;\n		uniform vec3 aabbMin;\n	#endif\n	void main (void) {\n		highp vec4 color = vec4(0, 0, 0, 1);\n		#include "morphEvaluationPS, MORPH_TEXTURE_COUNT"\n		#ifdef MORPH_INT\n			color.xyz = (color.xyz - aabbMin) / aabbSize * 65535.0;\n			gl_FragColor = uvec4(color);\n		#else\n			gl_FragColor = color;\n		#endif\n	}\n';
            
            var morphVS$1 = "\n	attribute vec2 vertex_position;\n	varying vec2 uv0;\n	void main(void) {\n		gl_Position = vec4(vertex_position, 0.5, 1.0);\n		uv0 = vertex_position.xy * 0.5 + 0.5;\n	}\n";
            
            var msdfVS = "\nattribute vec3 vertex_outlineParameters;\nattribute vec3 vertex_shadowParameters;\nvarying vec4 outline_color;\nvarying float outline_thickness;\nvarying vec4 shadow_color;\nvarying vec2 shadow_offset;\nvoid unpackMsdfParams() {\n	vec3 little = mod(vertex_outlineParameters, 256.);\n	vec3 big = (vertex_outlineParameters - little) / 256.;\n	outline_color.rb = little.xy / 255.;\n	outline_color.ga = big.xy / 255.;\n	outline_thickness = little.z / 255. * 0.2;\n	little = mod(vertex_shadowParameters, 256.);\n	big = (vertex_shadowParameters - little) / 256.;\n	shadow_color.rb = little.xy / 255.;\n	shadow_color.ga = big.xy / 255.;\n	shadow_offset = (vec2(little.z, big.z) / 127. - 1.) * 0.005;\n}\n";
            
            var normalVS = "\nmat3 dNormalMatrix;\nvec3 getNormal() {\n	dNormalMatrix = getNormalMatrix(dModelMatrix);\n	vec3 localNormal = getLocalNormal(vertex_normal);\n	return normalize(dNormalMatrix * localNormal);\n}\n";
            
            var normalCoreVS$1 = "\nattribute vec3 vertex_normal;\n#ifdef MORPHING_NORMAL\n	#ifdef MORPHING_INT\n		uniform highp usampler2D morphNormalTex;\n	#else\n		uniform highp sampler2D morphNormalTex;\n	#endif\n#endif\nvec3 getLocalNormal(vec3 vertexNormal) {\n	vec3 localNormal = vertex_normal;\n	#ifdef MORPHING_NORMAL\n		ivec2 morphUV = getTextureMorphCoords();\n		#ifdef MORPHING_INT\n			vec3 morphNormal = vec3(texelFetch(morphNormalTex, ivec2(morphUV), 0).xyz) / 65535.0 * 2.0 - 1.0;\n		#else\n			vec3 morphNormal = texelFetch(morphNormalTex, ivec2(morphUV), 0).xyz;\n		#endif\n		localNormal += morphNormal;\n	#endif\n	return localNormal;\n}\n#ifdef SKIN\n	mat3 getNormalMatrix(mat4 modelMatrix) {\n		return mat3(modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz);\n	}\n#elif defined(INSTANCING)\n	mat3 getNormalMatrix(mat4 modelMatrix) {\n		return mat3(modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz);\n	}\n#else\n	mat3 getNormalMatrix(mat4 modelMatrix) {\n		return matrix_normal;\n	}\n#endif\n";
            
            var normalMapPS = "\n#ifdef STD_NORMAL_TEXTURE\nuniform float material_bumpiness;\n#endif\n#ifdef STD_NORMALDETAIL_TEXTURE\nuniform float material_normalDetailMapBumpiness;\nvec3 blendNormals(vec3 n1, vec3 n2) {\n	n1 += vec3(0, 0, 1);\n	n2 *= vec3(-1, -1, 1);\n	return n1 * dot(n1, n2) / n1.z - n2;\n}\n#endif\nvoid getNormal() {\n#ifdef STD_NORMAL_TEXTURE\n	vec3 normalMap = {STD_NORMAL_TEXTURE_DECODE}(texture2DBias({STD_NORMAL_TEXTURE_NAME}, {STD_NORMAL_TEXTURE_UV}, textureBias));\n	normalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness);\n	#ifdef STD_NORMALDETAIL_TEXTURE\n		vec3 normalDetailMap = {STD_NORMALDETAIL_TEXTURE_DECODE}(texture2DBias({STD_NORMALDETAIL_TEXTURE_NAME}, {STD_NORMALDETAIL_TEXTURE_UV}, textureBias));\n		normalDetailMap = mix(vec3(0.0, 0.0, 1.0), normalDetailMap, material_normalDetailMapBumpiness);\n		normalMap = blendNormals(normalMap, normalDetailMap);\n	#endif\n	dNormalW = normalize(dTBN * normalMap);\n#else\n	dNormalW = dVertexNormalW;\n#endif\n}\n";
            
            var opacityPS = "\nuniform float material_opacity;\nvoid getOpacity() {\n	dAlpha = material_opacity;\n	#ifdef STD_OPACITY_TEXTURE\n	dAlpha *= texture2DBias({STD_OPACITY_TEXTURE_NAME}, {STD_OPACITY_TEXTURE_UV}, textureBias).{STD_OPACITY_TEXTURE_CHANNEL};\n	#endif\n	#ifdef STD_OPACITY_VERTEX\n	dAlpha *= clamp(vVertexColor.{STD_OPACITY_VERTEX_CHANNEL}, 0.0, 1.0);\n	#endif\n}\n";
            
            var opacityDitherPS = '\n#if STD_OPACITY_DITHER == BAYER8\n	#include "bayerPS"\n#endif\nuniform vec4 blueNoiseJitter;\n#if STD_OPACITY_DITHER == BLUENOISE\n	uniform sampler2D blueNoiseTex32;\n#endif\nvoid opacityDither(float alpha, float id) {\n	#if STD_OPACITY_DITHER == BAYER8\n		float noise = bayer8(floor(mod(gl_FragCoord.xy + blueNoiseJitter.xy + id, 8.0))) / 64.0;\n	#else\n		#if STD_OPACITY_DITHER == BLUENOISE\n			vec2 uv = fract(gl_FragCoord.xy / 32.0 + blueNoiseJitter.xy + id);\n			float noise = texture2DLod(blueNoiseTex32, uv, 0.0).y;\n		#endif\n		#if STD_OPACITY_DITHER == IGNNOISE\n			vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);\n			float noise = fract(magic.z * fract(dot(gl_FragCoord.xy + blueNoiseJitter.xy + id, magic.xy)));\n		#endif\n	#endif\n	noise = pow(noise, 2.2);\n	if (alpha < noise)\n		discard;\n}\n';
            
            var outputPS$1 = "\n";
            
            var outputAlphaPS$1 = "\n#if LIT_BLEND_TYPE == NORMAL || LIT_BLEND_TYPE == ADDITIVEALPHA || defined(LIT_ALPHA_TO_COVERAGE)\n	gl_FragColor.a = litArgs_opacity;\n#elif LIT_BLEND_TYPE == PREMULTIPLIED\n	gl_FragColor.rgb *= litArgs_opacity;\n	gl_FragColor.a = litArgs_opacity;\n#else\n	gl_FragColor.a = 1.0;\n#endif\n";
            
            var outputTex2DPS = "\nvarying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n	gl_FragColor = texture2D(source, vUv0);\n}\n";
            
            var sheenPS = "\nuniform vec3 material_sheen;\nvoid getSheen() {\n	vec3 sheenColor = material_sheen;\n	#ifdef STD_SHEEN_TEXTURE\n	sheenColor *= {STD_SHEEN_TEXTURE_DECODE}(texture2DBias({STD_SHEEN_TEXTURE_NAME}, {STD_SHEEN_TEXTURE_UV}, textureBias)).{STD_SHEEN_TEXTURE_CHANNEL};\n	#endif\n	#ifdef STD_SHEEN_VERTEX\n	sheenColor *= saturate(vVertexColor.{STD_SHEEN_VERTEX_CHANNEL});\n	#endif\n	sSpecularity = sheenColor;\n}\n";
            
            var sheenGlossPS = "\nuniform float material_sheenGloss;\nvoid getSheenGlossiness() {\n	float sheenGlossiness = material_sheenGloss;\n	#ifdef STD_SHEENGLOSS_TEXTURE\n	sheenGlossiness *= texture2DBias({STD_SHEENGLOSS_TEXTURE_NAME}, {STD_SHEENGLOSS_TEXTURE_UV}, textureBias).{STD_SHEENGLOSS_TEXTURE_CHANNEL};\n	#endif\n	#ifdef STD_SHEENGLOSS_VERTEX\n	sheenGlossiness *= saturate(vVertexColor.{STD_SHEENGLOSS_VERTEX_CHANNEL});\n	#endif\n	#ifdef STD_SHEENGLOSS_INVERT\n	sheenGlossiness = 1.0 - sheenGlossiness;\n	#endif\n	sGlossiness = sheenGlossiness + 0.0000001;\n}\n";
            
            var parallaxPS = "\nuniform float material_heightMapFactor;\nvoid getParallax() {\n	float parallaxScale = material_heightMapFactor;\n	float height = texture2DBias({STD_HEIGHT_TEXTURE_NAME}, {STD_HEIGHT_TEXTURE_UV}, textureBias).{STD_HEIGHT_TEXTURE_CHANNEL};\n	height = height * parallaxScale - parallaxScale*0.5;\n	vec3 viewDirT = dViewDirW * dTBN;\n	viewDirT.z += 0.42;\n	dUvOffset = height * (viewDirT.xy / viewDirT.z);\n}\n";
            
            var particlePS = "\nvarying vec4 texCoordsAlphaLife;\nuniform sampler2D colorMap;\nuniform sampler2D colorParam;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nuniform float softening;\nuniform float colorMult;\nfloat saturate(float x) {\n	return clamp(x, 0.0, 1.0);\n}\nvoid main(void) {\n	vec4 tex  = texture2D(colorMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y));\n	vec4 ramp = texture2D(colorParam, vec2(texCoordsAlphaLife.w, 0.0));\n	ramp.rgb *= colorMult;\n	ramp.a += texCoordsAlphaLife.z;\n	vec3 rgb = tex.rgb * ramp.rgb;\n	float a  = tex.a * ramp.a;\n";
            
            var particleVS = "\nvec3 unpack3NFloats(float src) {\n	float r = fract(src);\n	float g = fract(src * 256.0);\n	float b = fract(src * 65536.0);\n	return vec3(r, g, b);\n}\nfloat saturate(float x) {\n	return clamp(x, 0.0, 1.0);\n}\nvec4 tex1Dlod_lerp(TEXTURE_ACCEPT_HIGHP(tex), vec2 tc) {\n	return mix( texture2D(tex,tc), texture2D(tex,tc + graphSampleSize), fract(tc.x*graphNumSamples) );\n}\nvec4 tex1Dlod_lerp(TEXTURE_ACCEPT_HIGHP(tex), vec2 tc, out vec3 w) {\n	vec4 a = texture2D(tex,tc);\n	vec4 b = texture2D(tex,tc + graphSampleSize);\n	float c = fract(tc.x*graphNumSamples);\n	vec3 unpackedA = unpack3NFloats(a.w);\n	vec3 unpackedB = unpack3NFloats(b.w);\n	w = mix(unpackedA, unpackedB, c);\n	return mix(a, b, c);\n}\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix) {\n	float c = cos(pRotation);\n	float s = sin(pRotation);\n	mat2 m = mat2(c, -s, s, c);\n	rotMatrix = m;\n	return m * quadXY;\n}\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY) {\n	#ifdef SCREEN_SPACE\n		vec3 pos = vec3(-1, 0, 0) * quadXY.x + vec3(0, -1, 0) * quadXY.y;\n	#else\n		vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n	#endif\n	return pos;\n}\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY) {\n	vec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n	return pos;\n}\nvec2 safeNormalize(vec2 v) {\n	float l = length(v);\n	return (l > 1e-06) ? v / l : v;\n}\nvoid main(void) {\n	vec3 meshLocalPos = particle_vertexData.xyz;\n	float id = floor(particle_vertexData.w);\n	float rndFactor = fract(sin(id + 1.0 + seed));\n	vec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n	float uv = id / numParticlesPot;\n	readInput(uv);\n#ifdef LOCAL_SPACE\n	inVel = mat3(matrix_model) * inVel;\n#endif\n	vec2 velocityV = safeNormalize((mat3(matrix_view) * inVel).xy);\n	float particleLifetime = lifetime;\n	if (inLife <= 0.0 || inLife > particleLifetime || !inShow) meshLocalPos = vec3(0.0);\n	vec2 quadXY = meshLocalPos.xy;\n	float nlife = clamp(inLife / particleLifetime, 0.0, 1.0);\n	vec3 paramDiv;\n	vec4 params = tex1Dlod_lerp(TEXTURE_PASS(internalTex2), vec2(nlife, 0), paramDiv);\n	float scale = params.y;\n	float scaleDiv = paramDiv.x;\n	float alphaDiv = paramDiv.z;\n	scale += (scaleDiv * 2.0 - 1.0) * scaleDivMult * fract(rndFactor*10000.0);\n#ifndef USE_MESH\n	texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#else\n	texCoordsAlphaLife = vec4(particle_uv, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#endif\n	vec3 particlePos = inPos;\n	vec3 particlePosMoved = vec3(0.0);\n	mat2 rotMatrix;\n";
            
            var particleAnimFrameClampVS = "\n	float animFrame = min(floor(texCoordsAlphaLife.w * animTexParams.y) + animTexParams.x, animTexParams.z);\n";
            
            var particleAnimFrameLoopVS = "\n	float animFrame = floor(mod(texCoordsAlphaLife.w * animTexParams.y + animTexParams.x, animTexParams.z + 1.0));\n";
            
            var particleAnimTexVS = "\n	float animationIndex;\n	if (animTexIndexParams.y == 1.0) {\n		animationIndex = floor((animTexParams.w + 1.0) * rndFactor3.z) * (animTexParams.z + 1.0);\n	} else {\n		animationIndex = animTexIndexParams.x * (animTexParams.z + 1.0);\n	}\n	float atlasX = (animationIndex + animFrame) * animTexTilesParams.x;\n	float atlasY = 1.0 - floor(atlasX + 1.0) * animTexTilesParams.y;\n	atlasX = fract(atlasX);\n	texCoordsAlphaLife.xy *= animTexTilesParams.xy;\n	texCoordsAlphaLife.xy += vec2(atlasX, atlasY);\n";
            
            var particleInputFloatPS = "\nvoid readInput(float uv) {\n	vec4 tex = texture2D(particleTexIN, vec2(uv, 0.25));\n	vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.75));\n	inPos = tex.xyz;\n	inVel = tex2.xyz;\n	inAngle = (tex.w < 0.0? -tex.w : tex.w) - 1000.0;\n	inShow = tex.w >= 0.0;\n	inLife = tex2.w;\n}\n";
            
            var particleInputRgba8PS = "\n#define PI2 6.283185307179586\nuniform vec3 inBoundsSize;\nuniform vec3 inBoundsCenter;\nuniform float maxVel;\nfloat decodeFloatRG(vec2 rg) {\n	return rg.y*(1.0/255.0) + rg.x;\n}\nfloat decodeFloatRGBA( vec4 rgba ) {\n  return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\n}\nvoid readInput(float uv) {\n	vec4 tex0 = texture2D(particleTexIN, vec2(uv, 0.125));\n	vec4 tex1 = texture2D(particleTexIN, vec2(uv, 0.375));\n	vec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.625));\n	vec4 tex3 = texture2D(particleTexIN, vec2(uv, 0.875));\n	inPos = vec3(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));\n	inPos = (inPos - vec3(0.5)) * inBoundsSize + inBoundsCenter;\n	inVel = tex2.xyz;\n	inVel = (inVel - vec3(0.5)) * maxVel;\n	inAngle = decodeFloatRG(tex1.ba) * PI2;\n	inShow = tex2.a > 0.5;\n	inLife = decodeFloatRGBA(tex3);\n	float maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n	float maxPosLife = lifetime+1.0;\n	inLife = inLife * (maxNegLife + maxPosLife) - maxNegLife;\n}\n";
            
            var particleOutputFloatPS = "\nvoid writeOutput() {\n	if (gl_FragCoord.y<1.0) {\n		gl_FragColor = vec4(outPos, (outAngle + 1000.0) * visMode);\n	} else {\n		gl_FragColor = vec4(outVel, outLife);\n	}\n}\n";
            
            var particleOutputRgba8PS = "\nuniform vec3 outBoundsMul;\nuniform vec3 outBoundsAdd;\nvec2 encodeFloatRG( float v ) {\n	vec2 enc = vec2(1.0, 255.0) * v;\n	enc = fract(enc);\n	enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n	return enc;\n}\nvec4 encodeFloatRGBA( float v ) {\n	vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;\n	enc = fract(enc);\n	enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n	return enc;\n}\nvoid writeOutput() {\n	outPos = outPos * outBoundsMul + outBoundsAdd;\n	outAngle = fract(outAngle / PI2);\n	outVel = (outVel / maxVel) + vec3(0.5);\n	float maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n	float maxPosLife = lifetime+1.0;\n	outLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);\n	if (gl_FragCoord.y < 1.0) {\n		gl_FragColor = vec4(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));\n	} else if (gl_FragCoord.y < 2.0) {\n		gl_FragColor = vec4(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));\n	} else if (gl_FragCoord.y < 3.0) {\n		gl_FragColor = vec4(outVel, visMode*0.5+0.5);\n	} else {\n		gl_FragColor = encodeFloatRGBA(outLife);\n	}\n}\n";
            
            var particleUpdaterAABBPS = "\nuniform mat3 spawnBounds;\nuniform vec3 spawnPosInnerRatio;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n	vec3 pos = inBounds - vec3(0.5);\n	vec3 posAbs = abs(pos);\n	vec3 maxPos = vec3(max(posAbs.x, max(posAbs.y, posAbs.z)));\n	vec3 edge = maxPos + (vec3(0.5) - maxPos) * spawnPosInnerRatio;\n	pos.x = edge.x * (maxPos.x == posAbs.x ? sign(pos.x) : 2.0 * pos.x);\n	pos.y = edge.y * (maxPos.y == posAbs.y ? sign(pos.y) : 2.0 * pos.y);\n	pos.z = edge.z * (maxPos.z == posAbs.z ? sign(pos.z) : 2.0 * pos.z);\n#ifndef LOCAL_SPACE\n	return emitterPos + spawnBounds * pos;\n#else\n	return spawnBounds * pos;\n#endif\n}\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n	localVelocity -= vec3(0, 0, initialVelocity);\n}\n";
            
            var particleUpdaterEndPS = "\n	writeOutput();\n}\n";
            
            var particleUpdaterInitPS = "\nvarying vec2 vUv0;\nuniform highp sampler2D particleTexIN;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\nuniform highp sampler2D internalTex3;\nuniform mat3 emitterMatrix;\nuniform mat3 emitterMatrixInv;\nuniform vec3 emitterScale;\nuniform vec3 emitterPos;\nuniform vec3 frameRandom;\nuniform vec3 localVelocityDivMult;\nuniform vec3 velocityDivMult;\nuniform float delta;\nuniform float rate;\nuniform float rateDiv;\nuniform float lifetime;\nuniform float numParticles;\nuniform float rotSpeedDivMult;\nuniform float radialSpeedDivMult;\nuniform float seed;\nuniform float startAngle;\nuniform float startAngle2;\nuniform float initialVelocity;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\nfloat visMode;\nvec3 outPos;\nvec3 outVel;\nfloat outAngle;\nbool outShow;\nfloat outLife;\n";
            
            var particleUpdaterNoRespawnPS = "\n	if (outLife >= lifetime) {\n		outLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n		visMode = -1.0;\n	}\n";
            
            var particleUpdaterOnStopPS = "\n	visMode = outLife < 0.0? -1.0: visMode;\n";
            
            var particleUpdaterRespawnPS = "\n	if (outLife >= lifetime) {\n		outLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n		visMode = 1.0;\n	}\n	visMode = outLife < 0.0? 1.0: visMode;\n";
            
            var particleUpdaterSpherePS = "\nuniform float spawnBoundsSphere;\nuniform float spawnBoundsSphereInnerRatio;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n	float rnd4 = fract(rndFactor * 1000.0);\n	vec3 norm = normalize(inBounds.xyz - vec3(0.5));\n	float r = rnd4 * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;\n#ifndef LOCAL_SPACE\n	return emitterPos + norm * r * spawnBoundsSphere;\n#else\n	return norm * r * spawnBoundsSphere;\n#endif\n}\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n	localVelocity += normalize(inBounds - vec3(0.5)) * initialVelocity;\n}\n";
            
            var particleUpdaterStartPS = "\nfloat saturate(float x) {\n	return clamp(x, 0.0, 1.0);\n}\nvec3 unpack3NFloats(float src) {\n	float r = fract(src);\n	float g = fract(src * 256.0);\n	float b = fract(src * 65536.0);\n	return vec3(r, g, b);\n}\nvec3 tex1Dlod_lerp(TEXTURE_ACCEPT_HIGHP(tex), vec2 tc, out vec3 w) {\n	vec4 a = texture2D(tex, tc);\n	vec4 b = texture2D(tex, tc + graphSampleSize);\n	float c = fract(tc.x * graphNumSamples);\n	vec3 unpackedA = unpack3NFloats(a.w);\n	vec3 unpackedB = unpack3NFloats(b.w);\n	w = mix(unpackedA, unpackedB, c);\n	return mix(a.xyz, b.xyz, c);\n}\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\nvec4 hash41(float p) {\n	vec4 p4 = fract(vec4(p) * HASHSCALE4);\n	p4 += dot(p4, p4.wzxy+19.19);\n	return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\nvoid main(void) {\n	if (gl_FragCoord.x > numParticles) discard;\n	readInput(vUv0.x);\n	visMode = inShow? 1.0 : -1.0;\n	vec4 rndFactor = hash41(gl_FragCoord.x + seed);\n	float particleRate = rate + rateDiv * rndFactor.x;\n	outLife = inLife + delta;\n	float nlife = clamp(outLife / lifetime, 0.0, 1.0);\n	vec3 localVelocityDiv;\n	vec3 velocityDiv;\n	vec3 paramDiv;\n	vec3 localVelocity = tex1Dlod_lerp(TEXTURE_PASS(internalTex0), vec2(nlife, 0), localVelocityDiv);\n	vec3 velocity =	  tex1Dlod_lerp(TEXTURE_PASS(internalTex1), vec2(nlife, 0), velocityDiv);\n	vec3 params =		tex1Dlod_lerp(TEXTURE_PASS(internalTex2), vec2(nlife, 0), paramDiv);\n	float rotSpeed = params.x;\n	float rotSpeedDiv = paramDiv.y;\n	vec3 radialParams = tex1Dlod_lerp(TEXTURE_PASS(internalTex3), vec2(nlife, 0), paramDiv);\n	float radialSpeed = radialParams.x;\n	float radialSpeedDiv = radialParams.y;\n	bool respawn = inLife <= 0.0 || outLife >= lifetime;\n	inPos = respawn ? calcSpawnPosition(rndFactor.xyz, rndFactor.x) : inPos;\n	inAngle = respawn ? mix(startAngle, startAngle2, rndFactor.x) : inAngle;\n#ifndef LOCAL_SPACE\n	vec3 radialVel = inPos - emitterPos;\n#else\n	vec3 radialVel = inPos;\n#endif\n	radialVel = (dot(radialVel, radialVel) > 1.0E-8) ? radialSpeed * normalize(radialVel) : vec3(0.0);\n	radialVel += (radialSpeedDiv * vec3(2.0) - vec3(1.0)) * radialSpeedDivMult * rndFactor.xyz;\n	localVelocity +=	(localVelocityDiv * vec3(2.0) - vec3(1.0)) * localVelocityDivMult * rndFactor.xyz;\n	velocity +=		 (velocityDiv * vec3(2.0) - vec3(1.0)) * velocityDivMult * rndFactor.xyz;\n	rotSpeed +=		 (rotSpeedDiv * 2.0 - 1.0) * rotSpeedDivMult * rndFactor.y;\n	addInitialVelocity(localVelocity, rndFactor.xyz);\n#ifndef LOCAL_SPACE\n	outVel = emitterMatrix * localVelocity + (radialVel + velocity) * emitterScale;\n#else\n	outVel = (localVelocity + radialVel) / emitterScale + emitterMatrixInv * velocity;\n#endif\n	outPos = inPos + outVel * delta;\n	outAngle = inAngle + rotSpeed * delta;\n";
            
            var particle_billboardVS = "\n	quadXY = rotate(quadXY, inAngle, rotMatrix);\n	vec3 localPos = billboard(particlePos, quadXY);\n";
            
            var particle_blendAddPS = "\n	dBlendModeFogFactor = 0.0;\n	rgb *= saturate(gammaCorrectInput(max(a, 0.0)));\n	if ((rgb.r + rgb.g + rgb.b) < 0.000001) discard;\n";
            
            var particle_blendMultiplyPS = "\n	rgb = mix(vec3(1.0), rgb, vec3(a));\n	if (rgb.r + rgb.g + rgb.b > 2.99) discard;\n";
            
            var particle_blendNormalPS = "\n	if (a < 0.01) discard;\n";
            
            var particle_cpuVS = "\nattribute vec4 particle_vertexData;\nattribute vec4 particle_vertexData2;\nattribute vec4 particle_vertexData3;\nattribute float particle_vertexData4;\n#ifndef USE_MESH\nattribute vec2 particle_vertexData5;\n#else\nattribute vec4 particle_vertexData5;\n#endif\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\nuniform float numParticles;\nuniform float lifetime;\nuniform float stretch;\nuniform float seed;\nuniform vec3 wrapBounds;\nuniform vec3 emitterScale;\nuniform vec3 faceTangent;\nuniform vec3 faceBinorm;\n#ifdef PARTICLE_GPU\n	uniform highp sampler2D internalTex0;\n	uniform highp sampler2D internalTex1;\n	uniform highp sampler2D internalTex2;\n#endif\nuniform vec3 emitterPos;\nvarying vec4 texCoordsAlphaLife;\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix)\n{\n	float c = cos(pRotation);\n	float s = sin(pRotation);\n	mat2 m = mat2(c, -s, s, c);\n	rotMatrix = m;\n	return m * quadXY;\n}\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY)\n{\n	vec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n	return pos;\n}\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY)\n{\n	vec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n	return pos;\n}\nvoid main(void)\n{\n	vec3 particlePos = particle_vertexData.xyz;\n	vec3 inPos = particlePos;\n	vec3 vertPos = particle_vertexData3.xyz;\n	vec3 inVel = vec3(particle_vertexData2.w, particle_vertexData3.w, particle_vertexData5.x);\n	float id = floor(particle_vertexData4);\n	float rndFactor = fract(sin(id + 1.0 + seed));\n	vec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n#ifdef LOCAL_SPACE\n	inVel = mat3(matrix_model) * inVel;\n#endif\n	vec2 velocityV = normalize((mat3(matrix_view) * inVel).xy);\n	vec2 quadXY = vertPos.xy;\n#ifdef USE_MESH\n	texCoordsAlphaLife = vec4(particle_vertexData5.zw, particle_vertexData2.z, particle_vertexData.w);\n#else\n	texCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, particle_vertexData2.z, particle_vertexData.w);\n#endif\n	mat2 rotMatrix;\n	float inAngle = particle_vertexData2.x;\n	vec3 particlePosMoved = vec3(0.0);\n	vec3 meshLocalPos = particle_vertexData3.xyz;\n";
            
            var particle_cpu_endVS = "\n	localPos *= particle_vertexData2.y * emitterScale;\n	localPos += particlePos;\n	gl_Position = matrix_viewProjection * vec4(localPos, 1.0);\n";
            
            var particle_customFaceVS = "\n	quadXY = rotate(quadXY, inAngle, rotMatrix);\n	vec3 localPos = customFace(particlePos, quadXY);\n";
            
            var particle_endPS = "\n	rgb = addFog(rgb);\n	rgb = toneMap(rgb);\n	rgb = gammaCorrectOutput(rgb);\n	gl_FragColor = vec4(rgb, a);\n}\n";
            
            var particle_endVS = "\n	localPos *= scale * emitterScale;\n	localPos += particlePos;\n	#ifdef SCREEN_SPACE\n	gl_Position = vec4(localPos.x, localPos.y, 0.0, 1.0);\n	#else\n	gl_Position = matrix_viewProjection * vec4(localPos.xyz, 1.0);\n	#endif\n";
            
            var particle_halflambertPS = "\n	vec3 negNormal = normal*0.5+0.5;\n	vec3 posNormal = -normal*0.5+0.5;\n	negNormal *= negNormal;\n	posNormal *= posNormal;\n";
            
            var particle_initVS = "\nattribute vec4 particle_vertexData;\n#ifdef USE_MESH\nattribute vec2 particle_uv;\n#endif\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform float numParticles;\nuniform float numParticlesPot;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nuniform float stretch;\nuniform vec3 wrapBounds;\nuniform vec3 emitterScale;\nuniform vec3 emitterPos;\nuniform vec3 faceTangent;\nuniform vec3 faceBinorm;\nuniform float rate;\nuniform float rateDiv;\nuniform float lifetime;\nuniform float deltaRandomnessStatic;\nuniform float scaleDivMult;\nuniform float alphaDivMult;\nuniform float seed;\nuniform float delta;\nuniform sampler2D particleTexOUT;\nuniform sampler2D particleTexIN;\n#ifdef PARTICLE_GPU\n	uniform highp sampler2D internalTex0;\n	uniform highp sampler2D internalTex1;\n	uniform highp sampler2D internalTex2;\n#endif\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nvarying vec4 texCoordsAlphaLife;\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\n";
            
            var particle_lambertPS = "\n	vec3 negNormal = max(normal, vec3(0.0));\n	vec3 posNormal = max(-normal, vec3(0.0));\n";
            
            var particle_lightingPS = "\n	vec3 light = negNormal.x*lightCube[0] + posNormal.x*lightCube[1] +\n						negNormal.y*lightCube[2] + posNormal.y*lightCube[3] +\n						negNormal.z*lightCube[4] + posNormal.z*lightCube[5];\n	rgb *= light;\n";
            
            var particle_localShiftVS = "\n	particlePos = (matrix_model * vec4(particlePos, 1.0)).xyz;\n";
            
            var particle_meshVS = "\n	vec3 localPos = meshLocalPos;\n	localPos.xy = rotate(localPos.xy, inAngle, rotMatrix);\n	localPos.yz = rotate(localPos.yz, inAngle, rotMatrix);\n	billboard(particlePos, quadXY);\n";
            
            var particle_normalVS = "\n	Normal = normalize(localPos + matrix_viewInverse[2].xyz);\n";
            
            var particle_normalMapPS = "\n	vec3 normalMap = normalize(texture2D(normalMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)).xyz * 2.0 - 1.0);\n	vec3 normal = ParticleMat * normalMap;\n";
            
            var particle_pointAlongVS = "\n	inAngle = atan(velocityV.x, velocityV.y);\n";
            
            var particle_simulationPS = '\n	#include "particleUpdaterInitPS"\n	#ifdef PACK8\n		#include "particleInputRgba8PS"\n		#include "particleOutputRgba8PS"\n	#else\n		#include "particleInputFloatPS"\n		#include "particleOutputFloatPS"\n	#endif\n	#ifdef EMITTERSHAPE_BOX\n		#include "particleUpdaterAABBPS"\n	#else\n		#include "particleUpdaterSpherePS"\n	#endif\n	#include "particleUpdaterStartPS"\n	#ifdef RESPAWN\n		#include "particleUpdaterRespawnPS"\n	#endif\n	#ifdef NO_RESPAWN\n		#include "particleUpdaterNoRespawnPS"\n	#endif\n	#ifdef ON_STOP\n		#include "particleUpdaterOnStopPS"\n	#endif\n	#include "particleUpdaterEndPS"\n';
            
            var particle_shaderPS = '\n	#if NORMAL != NONE\n		#if NORMAL == VERTEX\n			varying vec3 Normal;\n		#endif\n		#if NORMAL == MAP\n			varying mat3 ParticleMat;\n		#endif\n		uniform vec3 lightCube[6];\n	#endif\n	#ifdef SOFT\n		varying float vDepth;\n		#include "screenDepthPS"\n	#endif\n	#include "gammaPS"\n	#include "tonemappingPS"\n	#include "fogPS"\n	#if NORMAL == MAP\n		uniform sampler2D normalMap;\n	#endif\n	#include "particlePS"\n	#ifdef SOFT\n		#include "particle_softPS"\n	#endif\n	#if NORMAL == VERTEX\n		vec3 normal = Normal;\n	#endif\n	#if NORMAL == MAP\n		#include "particle_normalMapPS"\n	#endif\n	#if NORMAL != NONE\n		#ifdef HALF_LAMBERT\n			#include "particle_halflambertPS"\n		#else\n			#include "particle_lambertPS"\n		#endif\n		#include "particle_lightingPS"\n	#endif\n	#if BLEND == NORMAL\n		#include "particle_blendNormalPS"\n	#elif BLEND == ADDITIVE\n		#include "particle_blendAddPS"\n	#elif BLEND == MULTIPLICATIVE\n		#include "particle_blendMultiplyPS"\n	#endif\n	#include "particle_endPS"\n';
            
            var particle_shaderVS = '\n	#ifdef ANIMTEX\n		uniform vec2 animTexTilesParams;\n		uniform vec4 animTexParams;\n		uniform vec2 animTexIndexParams;\n	#endif\n	#if NORMAL == MAP\n		varying mat3 ParticleMat;\n	#endif\n	#if NORMAL == VERTEX\n		varying vec3 Normal;\n	#endif\n	#ifdef SOFT\n		varying float vDepth;\n	#endif\n	#ifdef PARTICLE_GPU\n		#include "particle_initVS"\n		#ifdef PACK8\n			#include "particleInputRgba8PS"\n		#else\n			#include  "particleInputFloatPS"\n		#endif\n		#ifdef SOFT\n			#include "screenDepthPS"\n		#endif\n		#include "particleVS"\n	#else\n		#ifdef SOFT\n			#include "screenDepthPS"\n		#endif\n		#include "particle_cpuVS"\n	#endif\n	#ifdef LOCAL_SPACE\n		#include "particle_localShiftVS"\n	#endif\n	#ifdef ANIMTEX\n		#ifdef ANIMTEX_LOOP\n			#include "particleAnimFrameLoopVS"\n		#else\n			#include "particleAnimFrameClampVS"\n		#endif\n		#include "particleAnimTexVS"\n	#endif\n	#ifdef PARTICLE_GPU\n		#ifdef WRAP\n			#include "particle_wrapVS"\n		#endif\n	#endif\n	#ifdef ALIGN_TO_MOTION\n		#include "particle_pointAlongVS"\n	#endif\n	#ifdef USE_MESH\n		#include "particle_meshVS"\n	#else\n		#ifdef CUSTOM_FACE\n			#include "particle_customFaceVS"\n		#else\n			#include "particle_billboardVS"\n		#endif\n	#endif\n	#if NORMAL == VERTEX\n		#include "particle_normalVS"\n	#endif\n	#if NORMAL == MAP\n		#include "particle_TBNVS"\n	#endif\n	#ifdef STRETCH\n		#include "particle_stretchVS"\n	#endif\n	#ifdef PARTICLE_GPU\n		#include "particle_endVS"\n	#else\n		#include "particle_cpu_endVS"\n	#endif\n	#ifdef SOFT\n		#include "particle_softVS"\n	#endif\n	}\n';
            
            var particle_softPS = "\n	float depth = getLinearScreenDepth();\n	float particleDepth = vDepth;\n	float depthDiff = saturate(abs(particleDepth - depth) * softening);\n	a *= depthDiff;\n";
            
            var particle_softVS = "\n	vDepth = getLinearDepth(localPos);\n";
            
            var particle_stretchVS = "\n	vec3 moveDir = inVel * stretch;\n	vec3 posPrev = particlePos - moveDir;\n	posPrev += particlePosMoved;\n	vec2 centerToVertexV = normalize((mat3(matrix_view) * localPos).xy);\n	float interpolation = dot(-velocityV, centerToVertexV) * 0.5 + 0.5;\n	particlePos = mix(particlePos, posPrev, interpolation);\n";
            
            var particle_TBNVS = "\n	mat3 rot3 = mat3(rotMatrix[0][0], rotMatrix[0][1], 0.0, rotMatrix[1][0], rotMatrix[1][1], 0.0, 0.0, 0.0, 1.0);\n	ParticleMat = mat3(-matrix_viewInverse[0].xyz, -matrix_viewInverse[1].xyz, matrix_viewInverse[2].xyz) * rot3;\n";
            
            var particle_wrapVS = "\n	vec3 origParticlePos = particlePos;\n	particlePos -= matrix_model[3].xyz;\n	particlePos = mod(particlePos, wrapBounds) - wrapBounds * 0.5;\n	particlePos += matrix_model[3].xyz;\n	particlePosMoved = particlePos - origParticlePos;\n";
            
            var pickPS = "\nuniform uint meshInstanceId;\nvec4 getPickOutput() {\n	const vec4 inv = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n	const uvec4 shifts = uvec4(16, 8, 0, 24);\n	uvec4 col = (uvec4(meshInstanceId) >> shifts) & uvec4(0xff);\n	return vec4(col) * inv;\n}\n";
            
            var reflDirPS = "\nvoid getReflDir(vec3 worldNormal, vec3 viewDir, float gloss, mat3 tbn) {\n	dReflDirW = normalize(-reflect(viewDir, worldNormal));\n}\n";
            
            var reflDirAnisoPS = "\nvoid getReflDir(vec3 worldNormal, vec3 viewDir, float gloss, mat3 tbn) {\n	float roughness = sqrt(1.0 - min(gloss, 1.0));\n	float anisotropy = material_anisotropy * roughness;\n	vec3 anisotropicDirection = anisotropy >= 0.0 ? tbn[1] : tbn[0];\n	vec3 anisotropicTangent = cross(anisotropicDirection, viewDir);\n	vec3 anisotropicNormal = cross(anisotropicTangent, anisotropicDirection);\n	vec3 bentNormal = normalize(mix(normalize(worldNormal), normalize(anisotropicNormal), anisotropy));\n	dReflDirW = reflect(-viewDir, bentNormal);\n}\n";
            
            var reflectionCCPS = "\n#ifdef LIT_CLEARCOAT\nvoid addReflectionCC(vec3 reflDir, float gloss) {\n	ccReflection += calcReflection(reflDir, gloss);\n}\n#endif\n";
            
            var reflectionCubePS = "\nuniform samplerCube texture_cubeMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 reflDir, float gloss) {\n	vec3 lookupVec = cubeMapProject(reflDir);\n	lookupVec.x *= -1.0;\n	return {reflectionDecode}(textureCube(texture_cubeMap, lookupVec));\n}\nvoid addReflection(vec3 reflDir, float gloss) {   \n	dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);\n}\n";
            
            var reflectionEnvHQPS = "\n#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\nuniform samplerCube texture_cubeMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 reflDir, float gloss) {\n	vec3 dir = cubeMapProject(reflDir) * vec3(-1.0, 1.0, 1.0);\n	vec2 uv = toSphericalUv(dir);\n	float level = saturate(1.0 - gloss) * 5.0;\n	float ilevel = floor(level);\n	float flevel = level - ilevel;\n	vec3 sharp = {reflectionCubemapDecode}(textureCube(texture_cubeMap, dir));\n	vec3 roughA = {reflectionDecode}(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel)));\n	vec3 roughB = {reflectionDecode}(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));\n	return processEnvironment(mix(sharp, mix(roughA, roughB, flevel), min(level, 1.0)));\n}\nvoid addReflection(vec3 reflDir, float gloss) {   \n	dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);\n}\n";
            
            var reflectionEnvPS = "\n#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\nuniform float material_reflectivity;\nfloat shinyMipLevel(vec2 uv) {\n	vec2 dx = dFdx(uv);\n	vec2 dy = dFdy(uv);\n	vec2 uv2 = vec2(fract(uv.x + 0.5), uv.y);\n	vec2 dx2 = dFdx(uv2);\n	vec2 dy2 = dFdy(uv2);\n	float maxd = min(max(dot(dx, dx), dot(dy, dy)), max(dot(dx2, dx2), dot(dy2, dy2)));\n	return clamp(0.5 * log2(maxd) - 1.0 + textureBias, 0.0, 5.0);\n}\nvec3 calcReflection(vec3 reflDir, float gloss) {\n	vec3 dir = cubeMapProject(reflDir) * vec3(-1.0, 1.0, 1.0);\n	vec2 uv = toSphericalUv(dir);\n	float level = saturate(1.0 - gloss) * 5.0;\n	float ilevel = floor(level);\n	float level2 = shinyMipLevel(uv * atlasSize);\n	float ilevel2 = floor(level2);\n	vec2 uv0, uv1;\n	float weight;\n	if (ilevel == 0.0) {\n		uv0 = mapShinyUv(uv, ilevel2);\n		uv1 = mapShinyUv(uv, ilevel2 + 1.0);\n		weight = level2 - ilevel2;\n	} else {\n		uv0 = uv1 = mapRoughnessUv(uv, ilevel);\n		weight = 0.0;\n	}\n	vec3 linearA = {reflectionDecode}(texture2D(texture_envAtlas, uv0));\n	vec3 linearB = {reflectionDecode}(texture2D(texture_envAtlas, uv1));\n	vec3 linear0 = mix(linearA, linearB, weight);\n	vec3 linear1 = {reflectionDecode}(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));\n	return processEnvironment(mix(linear0, linear1, level - ilevel));\n}\nvoid addReflection(vec3 reflDir, float gloss) {   \n	dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);\n}\n";
            
            var reflectionSpherePS = "\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 reflDir, float gloss) {\n	vec3 reflDirV = (mat3(matrix_view) * reflDir).xyz;\n	float m = 2.0 * sqrt( dot(reflDirV.xy, reflDirV.xy) + (reflDirV.z+1.0)*(reflDirV.z+1.0) );\n	vec2 sphereMapUv = reflDirV.xy / m + 0.5;\n	return {reflectionDecode}(texture2D(texture_sphereMap, sphereMapUv));\n}\nvoid addReflection(vec3 reflDir, float gloss) {   \n	dReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);\n}\n";
            
            var reflectionSheenPS = "\nvoid addReflectionSheen(vec3 worldNormal, vec3 viewDir, float gloss) {\n	float NoV = dot(worldNormal, viewDir);\n	float alphaG = gloss * gloss;\n	float a = gloss < 0.25 ? -339.2 * alphaG + 161.4 * gloss - 25.9 : -8.48 * alphaG + 14.3 * gloss - 9.95;\n	float b = gloss < 0.25 ? 44.0 * alphaG - 23.7 * gloss + 3.26 : 1.97 * alphaG - 3.27 * gloss + 0.72;\n	float DG = exp( a * NoV + b ) + ( gloss < 0.25 ? 0.0 : 0.1 * ( gloss - 0.25 ) );\n	sReflection += calcReflection(worldNormal, 0.0) * saturate(DG);\n}\n";
            
            var refractionCubePS = "\nvec3 refract2(vec3 viewVec, vec3 normal, float IOR) {\n	float vn = dot(viewVec, normal);\n	float k = 1.0 - IOR * IOR * (1.0 - vn * vn);\n	vec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * normal;\n	return refrVec;\n}\nvoid addRefraction(\n	vec3 worldNormal, \n	vec3 viewDir, \n	float thickness, \n	float gloss, \n	vec3 specularity, \n	vec3 albedo, \n	float transmission,\n	float refractionIndex,\n	float dispersion\n#if defined(LIT_IRIDESCENCE)\n	, vec3 iridescenceFresnel,\n	float iridescenceIntensity\n#endif \n) {\n	vec4 tmpRefl = dReflection;\n	vec3 reflectionDir = refract2(-viewDir, worldNormal, refractionIndex);\n	dReflection = vec4(0);\n	addReflection(reflectionDir, gloss);\n	dDiffuseLight = mix(dDiffuseLight, dReflection.rgb * albedo, transmission);\n	dReflection = tmpRefl;\n}\n";
            
            var refractionDynamicPS = "\nuniform float material_invAttenuationDistance;\nuniform vec3 material_attenuation;\nvec3 evalRefractionColor(vec3 refractionVector, float gloss, float refractionIndex) {\n	vec4 pointOfRefraction = vec4(vPositionW + refractionVector, 1.0);\n	vec4 projectionPoint = matrix_viewProjection * pointOfRefraction;\n	vec2 uv = getGrabScreenPos(projectionPoint);\n	float iorToRoughness = (1.0 - gloss) * clamp((1.0 / refractionIndex) * 2.0 - 2.0, 0.0, 1.0);\n	float refractionLod = log2(uScreenSize.x) * iorToRoughness;\n	vec3 refraction = texture2DLod(uSceneColorMap, uv, refractionLod).rgb;\n	return refraction;\n}\nvoid addRefraction(\n	vec3 worldNormal, \n	vec3 viewDir, \n	float thickness, \n	float gloss, \n	vec3 specularity, \n	vec3 albedo, \n	float transmission,\n	float refractionIndex,\n	float dispersion\n#if defined(LIT_IRIDESCENCE)\n	, vec3 iridescenceFresnel,\n	float iridescenceIntensity\n#endif\n) {\n	vec3 modelScale;\n	modelScale.x = length(vec3(matrix_model[0].xyz));\n	modelScale.y = length(vec3(matrix_model[1].xyz));\n	modelScale.z = length(vec3(matrix_model[2].xyz));\n	vec3 scale = thickness * modelScale;\n	vec3 refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndex)) * scale;\n	vec3 refraction = evalRefractionColor(refractionVector, gloss, refractionIndex);\n	#ifdef LIT_DISPERSION\n		float halfSpread = (1.0 / refractionIndex - 1.0) * 0.025 * dispersion;\n		float refractionIndexR = refractionIndex - halfSpread;\n		refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndexR)) * scale;\n		refraction.r = evalRefractionColor(refractionVector, gloss, refractionIndexR).r;\n		float refractionIndexB = refractionIndex + halfSpread;\n		refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndexB)) * scale;\n		refraction.b = evalRefractionColor(refractionVector, gloss, refractionIndexB).b;\n	#endif\n	vec3 transmittance;\n	if (material_invAttenuationDistance != 0.0)\n	{\n		vec3 attenuation = -log(material_attenuation) * material_invAttenuationDistance;\n		transmittance = exp(-attenuation * length(refractionVector));\n	}\n	else\n	{\n		transmittance = refraction;\n	}\n	vec3 fresnel = vec3(1.0) - \n		getFresnel(\n			dot(viewDir, worldNormal), \n			gloss, \n			specularity\n		#if defined(LIT_IRIDESCENCE)\n			, iridescenceFresnel,\n			iridescenceIntensity\n		#endif\n		);\n	dDiffuseLight = mix(dDiffuseLight, refraction * transmittance * fresnel, transmission);\n}\n";
            
            var reprojectPS$1 = '\nvarying vec2 vUv0;\n#ifdef CUBEMAP_SOURCE\n	uniform samplerCube sourceCube;\n#else\n	uniform sampler2D sourceTex;\n#endif\n#ifdef USE_SAMPLES_TEX\n	uniform sampler2D samplesTex;\n	uniform vec2 samplesTexInverseSize;\n#endif\nuniform vec3 params;\nfloat targetFace() { return params.x; }\nfloat targetTotalPixels() { return params.y; }\nfloat sourceTotalPixels() { return params.z; }\nfloat PI = 3.141592653589793;\nfloat saturate(float x) {\n	return clamp(x, 0.0, 1.0);\n}\n#include "decodePS"\n#include "encodePS"\nvec3 modifySeams(vec3 dir, float scale) {\n	vec3 adir = abs(dir);\n	float M = max(max(adir.x, adir.y), adir.z);\n	return dir / M * vec3(\n		adir.x == M ? 1.0 : scale,\n		adir.y == M ? 1.0 : scale,\n		adir.z == M ? 1.0 : scale\n	);\n}\nvec2 toSpherical(vec3 dir) {\n	return vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));\n}\nvec3 fromSpherical(vec2 uv) {\n	return vec3(cos(uv.y) * sin(uv.x),\n				sin(uv.y),\n				cos(uv.y) * cos(uv.x));\n}\nvec3 getDirectionEquirect() {\n	return fromSpherical((vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0) * vec2(PI, PI * 0.5));\n}\nfloat signNotZero(float k){\n	return(k >= 0.0) ? 1.0 : -1.0;\n}\nvec2 signNotZero(vec2 v) {\n	return vec2(signNotZero(v.x), signNotZero(v.y));\n}\nvec3 octDecode(vec2 o) {\n	vec3 v = vec3(o.x, 1.0 - abs(o.x) - abs(o.y), o.y);\n	if (v.y < 0.0) {\n		v.xz = (1.0 - abs(v.zx)) * signNotZero(v.xz);\n	}\n	return normalize(v);\n}\nvec3 getDirectionOctahedral() {\n	return octDecode(vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0);\n}\nvec2 octEncode(in vec3 v) {\n	float l1norm = abs(v.x) + abs(v.y) + abs(v.z);\n	vec2 result = v.xz * (1.0 / l1norm);\n	if (v.y < 0.0) {\n		result = (1.0 - abs(result.yx)) * signNotZero(result.xy);\n	}\n	return result;\n}\n#ifdef CUBEMAP_SOURCE\n	vec4 sampleCubemap(vec3 dir) {\n		return textureCube(sourceCube, modifySeams(dir, 1.0));\n	}\n	vec4 sampleCubemap(vec2 sph) {\n		return sampleCubemap(fromSpherical(sph));\n	}\n	vec4 sampleCubemap(vec3 dir, float mipLevel) {\n		return textureCubeLod(sourceCube, modifySeams(dir, 1.0), mipLevel);\n	}\n	vec4 sampleCubemap(vec2 sph, float mipLevel) {\n		return sampleCubemap(fromSpherical(sph), mipLevel);\n	}\n#else\n	vec4 sampleEquirect(vec2 sph) {\n		vec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;\n		return texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n	}\n	vec4 sampleEquirect(vec3 dir) {\n		return sampleEquirect(toSpherical(dir));\n	}\n	vec4 sampleEquirect(vec2 sph, float mipLevel) {\n		vec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;\n		return texture2DLod(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);\n	}\n	vec4 sampleEquirect(vec3 dir, float mipLevel) {\n		return sampleEquirect(toSpherical(dir), mipLevel);\n	}\n	vec4 sampleOctahedral(vec3 dir) {\n		vec2 uv = octEncode(dir) * 0.5 + 0.5;\n		return texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n	}\n	vec4 sampleOctahedral(vec2 sph) {\n		return sampleOctahedral(fromSpherical(sph));\n	}\n	vec4 sampleOctahedral(vec3 dir, float mipLevel) {\n		vec2 uv = octEncode(dir) * 0.5 + 0.5;\n		return texture2DLod(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);\n	}\n	vec4 sampleOctahedral(vec2 sph, float mipLevel) {\n		return sampleOctahedral(fromSpherical(sph), mipLevel);\n	}\n#endif\nvec3 getDirectionCubemap() {\n	vec2 st = vUv0 * 2.0 - 1.0;\n	float face = targetFace();\n	vec3 vec;\n	if (face == 0.0) {\n		vec = vec3(1, -st.y, -st.x);\n	} else if (face == 1.0) {\n		vec = vec3(-1, -st.y, st.x);\n	} else if (face == 2.0) {\n		vec = vec3(st.x, 1, st.y);\n	} else if (face == 3.0) {\n		vec = vec3(st.x, -1, -st.y);\n	} else if (face == 4.0) {\n		vec = vec3(st.x, -st.y, 1);\n	} else {\n		vec = vec3(-st.x, -st.y, -1);\n	}\n	return normalize(modifySeams(vec, 1.0));\n}\nmat3 matrixFromVector(vec3 n) {\n	float a = 1.0 / (1.0 + n.z);\n	float b = -n.x * n.y * a;\n	vec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n	vec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n	return mat3(b1, b2, n);\n}\nmat3 matrixFromVectorSlow(vec3 n) {\n	vec3 up = (1.0 - abs(n.y) <= 0.0000001) ? vec3(0.0, 0.0, n.y > 0.0 ? 1.0 : -1.0) : vec3(0.0, 1.0, 0.0);\n	vec3 x = normalize(cross(up, n));\n	vec3 y = cross(n, x);\n	return mat3(x, y, n);\n}\nvec4 reproject() {\n	if ({NUM_SAMPLES} <= 1) {\n		return {ENCODE_FUNC}({DECODE_FUNC}({SOURCE_FUNC}({TARGET_FUNC}())));\n	} else {\n		vec3 t = {TARGET_FUNC}();\n		vec3 tu = dFdx(t);\n		vec3 tv = dFdy(t);\n		vec3 result = vec3(0.0);\n		for (float u = 0.0; u < {NUM_SAMPLES_SQRT}; ++u) {\n			for (float v = 0.0; v < {NUM_SAMPLES_SQRT}; ++v) {\n				result += {DECODE_FUNC}({SOURCE_FUNC}(normalize(t +\n															tu * (u / {NUM_SAMPLES_SQRT} - 0.5) +\n															tv * (v / {NUM_SAMPLES_SQRT} - 0.5))));\n			}\n		}\n		return {ENCODE_FUNC}(result / ({NUM_SAMPLES_SQRT} * {NUM_SAMPLES_SQRT}));\n	}\n}\nvec4 unpackFloat = vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);\n#ifdef USE_SAMPLES_TEX\n	void unpackSample(int i, out vec3 L, out float mipLevel) {\n		float u = (float(i * 4) + 0.5) * samplesTexInverseSize.x;\n		float v = (floor(u) + 0.5) * samplesTexInverseSize.y;\n		vec4 raw;\n		raw.x = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n		raw.y = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n		raw.z = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n		raw.w = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat);\n		L.xyz = raw.xyz * 2.0 - 1.0;\n		mipLevel = raw.w * 8.0;\n	}\n	vec4 prefilterSamples() {\n		mat3 vecSpace = matrixFromVectorSlow({TARGET_FUNC}());\n		vec3 L;\n		float mipLevel;\n		vec3 result = vec3(0.0);\n		float totalWeight = 0.0;\n		for (int i = 0; i < {NUM_SAMPLES}; ++i) {\n			unpackSample(i, L, mipLevel);\n			result += {DECODE_FUNC}({SOURCE_FUNC}(vecSpace * L, mipLevel)) * L.z;\n			totalWeight += L.z;\n		}\n		return {ENCODE_FUNC}(result / totalWeight);\n	}\n	vec4 prefilterSamplesUnweighted() {\n		mat3 vecSpace = matrixFromVectorSlow({TARGET_FUNC}());\n		vec3 L;\n		float mipLevel;\n		vec3 result = vec3(0.0);\n		float totalWeight = 0.0;\n		for (int i = 0; i < {NUM_SAMPLES}; ++i) {\n			unpackSample(i, L, mipLevel);\n			result += {DECODE_FUNC}({SOURCE_FUNC}(vecSpace * L, mipLevel));\n		}\n		return {ENCODE_FUNC}(result / float({NUM_SAMPLES}));\n	}\n#endif\nvoid main(void) {\n	gl_FragColor = {PROCESS_FUNC}();\n}\n';
            
            var reprojectVS$1 = "\nattribute vec2 vertex_position;\nuniform vec4 uvMod;\nvarying vec2 vUv0;\nvoid main(void) {\n	gl_Position = vec4(vertex_position, 0.5, 1.0);\n	vUv0 = getImageEffectUV((vertex_position.xy * 0.5 + 0.5) * uvMod.xy + uvMod.zw);\n}\n";
            
            var sampleCatmullRomPS = "\nvec4 SampleTextureCatmullRom(TEXTURE_ACCEPT(tex), vec2 uv, vec2 texSize) {\n	vec2 samplePos = uv * texSize;\n	vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n	vec2 f = samplePos - texPos1;\n	vec2 w0 = f * (-0.5 + f * (1.0 - 0.5 * f));\n	vec2 w1 = 1.0 + f * f * (-2.5 + 1.5 * f);\n	vec2 w2 = f * (0.5 + f * (2.0 - 1.5 * f));\n	vec2 w3 = f * f * (-0.5 + 0.5 * f);\n	vec2 w12 = w1 + w2;\n	vec2 offset12 = w2 / (w1 + w2);\n	vec2 texPos0 = (texPos1 - 1.0) / texSize;\n	vec2 texPos3 = (texPos1 + 2.0) / texSize;\n	vec2 texPos12 = (texPos1 + offset12) / texSize;\n	vec4 result = vec4(0.0);\n	result += texture2DLod(tex, vec2(texPos0.x, texPos0.y), 0.0) * w0.x * w0.y;\n	result += texture2DLod(tex, vec2(texPos12.x, texPos0.y), 0.0) * w12.x * w0.y;\n	result += texture2DLod(tex, vec2(texPos3.x, texPos0.y), 0.0) * w3.x * w0.y;\n	result += texture2DLod(tex, vec2(texPos0.x, texPos12.y), 0.0) * w0.x * w12.y;\n	result += texture2DLod(tex, vec2(texPos12.x, texPos12.y), 0.0) * w12.x * w12.y;\n	result += texture2DLod(tex, vec2(texPos3.x, texPos12.y), 0.0) * w3.x * w12.y;\n	result += texture2DLod(tex, vec2(texPos0.x, texPos3.y), 0.0) * w0.x * w3.y;\n	result += texture2DLod(tex, vec2(texPos12.x, texPos3.y), 0.0) * w12.x * w3.y;\n	result += texture2DLod(tex, vec2(texPos3.x, texPos3.y), 0.0) * w3.x * w3.y;\n	return result;\n}\n";
            
            var screenDepthPS = "\nuniform highp sampler2D uSceneDepthMap;\n#ifndef SCREENSIZE\n#define SCREENSIZE\nuniform vec4 uScreenSize;\n#endif\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n#ifndef LINEARIZE_DEPTH\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\n#define LINEARIZE_DEPTH\nfloat linearizeDepth(float z) {\n	if (camera_params.w == 0.0)\n		return (camera_params.z * camera_params.y) / (camera_params.y + z * (camera_params.z - camera_params.y));\n	else\n		return camera_params.z + z * (camera_params.y - camera_params.z);\n}\n#endif\nfloat delinearizeDepth(float linearDepth) {\n	if (camera_params.w == 0.0) {\n		return (camera_params.y * (camera_params.z - linearDepth)) / (linearDepth * (camera_params.z - camera_params.y));\n	} else {\n		return (linearDepth - camera_params.z) / (camera_params.y - camera_params.z);\n	}\n}\nfloat getLinearScreenDepth(vec2 uv) {\n	#ifdef SCENE_DEPTHMAP_LINEAR\n		#ifdef SCENE_DEPTHMAP_FLOAT\n			return texture2D(uSceneDepthMap, uv).r;\n		#else\n			ivec2 textureSize = textureSize(uSceneDepthMap, 0);\n			ivec2 texel = ivec2(uv * vec2(textureSize));\n			vec4 data = texelFetch(uSceneDepthMap, texel, 0);\n			uint intBits = \n				(uint(data.r * 255.0) << 24u) |\n				(uint(data.g * 255.0) << 16u) |\n				(uint(data.b * 255.0) << 8u) |\n				uint(data.a * 255.0);\n			return uintBitsToFloat(intBits);\n		#endif\n	#else\n		return linearizeDepth(texture2D(uSceneDepthMap, uv).r);\n	#endif\n}\n#ifndef VERTEXSHADER\nfloat getLinearScreenDepth() {\n	vec2 uv = gl_FragCoord.xy * uScreenSize.zw;\n	return getLinearScreenDepth(uv);\n}\n#endif\nfloat getLinearDepth(vec3 pos) {\n	return -(matrix_view * vec4(pos, 1.0)).z;\n}\n";
            
            var shadowCascadesPS = "\nint getShadowCascadeIndex(vec4 shadowCascadeDistances, int shadowCascadeCount) {\n	float depth = 1.0 / gl_FragCoord.w;\n	vec4 comparisons = step(shadowCascadeDistances, vec4(depth));\n	int cascadeIndex = int(dot(comparisons, vec4(1.0)));\n	return min(cascadeIndex, shadowCascadeCount - 1);\n}\nint ditherShadowCascadeIndex(int cascadeIndex, vec4 shadowCascadeDistances, int shadowCascadeCount, float blendFactor) {\n \n	if (cascadeIndex < shadowCascadeCount - 1) {\n		float currentRangeEnd = shadowCascadeDistances[cascadeIndex];\n		float transitionStart = blendFactor * currentRangeEnd;\n		float depth = 1.0 / gl_FragCoord.w;\n		if (depth > transitionStart) {\n			float transitionFactor = smoothstep(transitionStart, currentRangeEnd, depth);\n			float dither = fract(sin(dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453);\n			if (dither < transitionFactor) {\n				cascadeIndex += 1;\n			}\n		}\n	}\n	return cascadeIndex;\n}\nvec3 fadeShadow(vec3 shadowCoord, vec4 shadowCascadeDistances) {				  \n	float depth = 1.0 / gl_FragCoord.w;\n	if (depth > shadowCascadeDistances.w) {\n		shadowCoord.z = -9999999.0;\n	}\n	return shadowCoord;\n}\n";
            
            var shadowEVSMPS = "\nfloat linstep(float a, float b, float v) {\n	return saturate((v - a) / (b - a));\n}\nfloat reduceLightBleeding(float pMax, float amount) {\n   return linstep(amount, 1.0, pMax);\n}\nfloat chebyshevUpperBound(vec2 moments, float mean, float minVariance, float lightBleedingReduction) {\n	float variance = moments.y - (moments.x * moments.x);\n	variance = max(variance, minVariance);\n	float d = mean - moments.x;\n	float pMax = variance / (variance + (d * d));\n	pMax = reduceLightBleeding(pMax, lightBleedingReduction);\n	return (mean <= moments.x ? 1.0 : pMax);\n}\nfloat calculateEVSM(vec3 moments, float Z, float vsmBias, float exponent) {\n	Z = 2.0 * Z - 1.0;\n	float warpedDepth = exp(exponent * Z);\n	moments.xy += vec2(warpedDepth, warpedDepth*warpedDepth) * (1.0 - moments.z);\n	float VSMBias = vsmBias;\n	float depthScale = VSMBias * exponent * warpedDepth;\n	float minVariance1 = depthScale * depthScale;\n	return chebyshevUpperBound(moments.xy, warpedDepth, minVariance1, 0.1);\n}\nfloat VSM16(TEXTURE_ACCEPT(tex), vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n	vec3 moments = texture2DLod(tex, texCoords, 0.0).xyz;\n	return calculateEVSM(moments, Z, vsmBias, exponent);\n}\nfloat getShadowVSM16(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent) {\n	return VSM16(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, exponent);\n}\nfloat getShadowSpotVSM16(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {\n	return VSM16(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\nfloat VSM32(TEXTURE_ACCEPT(tex), vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n	#ifdef CAPS_TEXTURE_FLOAT_FILTERABLE\n		vec3 moments = texture2DLod(tex, texCoords, 0.0).xyz;\n	#else\n		float pixelSize = 1.0 / resolution;\n		texCoords -= vec2(pixelSize);\n		vec3 s00 = texture2DLod(tex, texCoords, 0.0).xyz;\n		vec3 s10 = texture2DLod(tex, texCoords + vec2(pixelSize, 0), 0.0).xyz;\n		vec3 s01 = texture2DLod(tex, texCoords + vec2(0, pixelSize), 0.0).xyz;\n		vec3 s11 = texture2DLod(tex, texCoords + vec2(pixelSize), 0.0).xyz;\n		vec2 fr = fract(texCoords * resolution);\n		vec3 h0 = mix(s00, s10, fr.x);\n		vec3 h1 = mix(s01, s11, fr.x);\n		vec3 moments = mix(h0, h1, fr.y);\n	#endif\n	return calculateEVSM(moments, Z, vsmBias, exponent);\n}\nfloat getShadowVSM32(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent) {\n	return VSM32(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, exponent);\n}\nfloat getShadowSpotVSM32(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {\n	return VSM32(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n";
            
            var shadowPCF1PS = "\nfloat getShadowPCF1x1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n	return textureShadow(shadowMap, shadowCoord);\n}\nfloat getShadowSpotPCF1x1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n	return textureShadow(shadowMap, shadowCoord);\n}\n#ifndef WEBGPU\nfloat getShadowOmniPCF1x1(samplerCubeShadow shadowMap, vec3 shadowCoord, vec4 shadowParams, vec3 lightDir) {\n	float shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;\n	return texture(shadowMap, vec4(lightDir, shadowZ));\n}\n#endif\n";
            
            var shadowPCF3PS = "\nfloat _getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec3 shadowParams) {\n	float z = shadowCoord.z;\n	vec2 uv = shadowCoord.xy * shadowParams.x;\n	float shadowMapSizeInv = 1.0 / shadowParams.x;\n	vec2 base_uv = floor(uv + 0.5);\n	float s = (uv.x + 0.5 - base_uv.x);\n	float t = (uv.y + 0.5 - base_uv.y);\n	base_uv -= vec2(0.5);\n	base_uv *= shadowMapSizeInv;\n	float sum = 0.0;\n	float uw0 = (3.0 - 2.0 * s);\n	float uw1 = (1.0 + 2.0 * s);\n	float u0 = (2.0 - s) / uw0 - 1.0;\n	float u1 = s / uw1 + 1.0;\n	float vw0 = (3.0 - 2.0 * t);\n	float vw1 = (1.0 + 2.0 * t);\n	float v0 = (2.0 - t) / vw0 - 1.0;\n	float v1 = t / vw1 + 1.0;\n	u0 = u0 * shadowMapSizeInv + base_uv.x;\n	v0 = v0 * shadowMapSizeInv + base_uv.y;\n	u1 = u1 * shadowMapSizeInv + base_uv.x;\n	v1 = v1 * shadowMapSizeInv + base_uv.y;\n	sum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));\n	sum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));\n	sum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));\n	sum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));\n	sum *= 1.0f / 16.0;\n	return sum;\n}\nfloat getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n	return _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);\n}\nfloat getShadowSpotPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n	return _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);\n}\n#ifndef WEBGPU\nfloat getShadowOmniPCF3x3(samplerCubeShadow shadowMap, vec4 shadowParams, vec3 dir) {\n	\n	float shadowZ = length(dir) * shadowParams.w + shadowParams.z;\n	float z = 1.0 / float(textureSize(shadowMap, 0));\n	vec3 tc = normalize(dir);\n	mediump vec4 shadows;\n	shadows.x = texture(shadowMap, vec4(tc + vec3( z, z, z), shadowZ));\n	shadows.y = texture(shadowMap, vec4(tc + vec3(-z,-z, z), shadowZ));\n	shadows.z = texture(shadowMap, vec4(tc + vec3(-z, z,-z), shadowZ));\n	shadows.w = texture(shadowMap, vec4(tc + vec3( z,-z,-z), shadowZ));\n	return dot(shadows, vec4(0.25));\n}\nfloat getShadowOmniPCF3x3(samplerCubeShadow shadowMap, vec3 shadowCoord, vec4 shadowParams, vec3 lightDir) {\n	return getShadowOmniPCF3x3(shadowMap, shadowParams, lightDir);\n}\n#endif\n";
            
            var shadowPCF5PS = "\nfloat _getShadowPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec3 shadowParams) {\n	float z = shadowCoord.z;\n	vec2 uv = shadowCoord.xy * shadowParams.x;\n	float shadowMapSizeInv = 1.0 / shadowParams.x;\n	vec2 base_uv = floor(uv + 0.5);\n	float s = (uv.x + 0.5 - base_uv.x);\n	float t = (uv.y + 0.5 - base_uv.y);\n	base_uv -= vec2(0.5);\n	base_uv *= shadowMapSizeInv;\n	float uw0 = (4.0 - 3.0 * s);\n	float uw1 = 7.0;\n	float uw2 = (1.0 + 3.0 * s);\n	float u0 = (3.0 - 2.0 * s) / uw0 - 2.0;\n	float u1 = (3.0 + s) / uw1;\n	float u2 = s / uw2 + 2.0;\n	float vw0 = (4.0 - 3.0 * t);\n	float vw1 = 7.0;\n	float vw2 = (1.0 + 3.0 * t);\n	float v0 = (3.0 - 2.0 * t) / vw0 - 2.0;\n	float v1 = (3.0 + t) / vw1;\n	float v2 = t / vw2 + 2.0;\n	float sum = 0.0;\n	u0 = u0 * shadowMapSizeInv + base_uv.x;\n	v0 = v0 * shadowMapSizeInv + base_uv.y;\n	u1 = u1 * shadowMapSizeInv + base_uv.x;\n	v1 = v1 * shadowMapSizeInv + base_uv.y;\n	u2 = u2 * shadowMapSizeInv + base_uv.x;\n	v2 = v2 * shadowMapSizeInv + base_uv.y;\n	sum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));\n	sum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));\n	sum += uw2 * vw0 * textureShadow(shadowMap, vec3(u2, v0, z));\n	sum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));\n	sum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));\n	sum += uw2 * vw1 * textureShadow(shadowMap, vec3(u2, v1, z));\n	sum += uw0 * vw2 * textureShadow(shadowMap, vec3(u0, v2, z));\n	sum += uw1 * vw2 * textureShadow(shadowMap, vec3(u1, v2, z));\n	sum += uw2 * vw2 * textureShadow(shadowMap, vec3(u2, v2, z));\n	sum *= 1.0f / 144.0;\n	sum = saturate(sum);\n	return sum;\n}\nfloat getShadowPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n	return _getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);\n}\nfloat getShadowSpotPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n	return _getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);\n}\n";
            
            var shadowPCSSPS = "\n#define PCSS_SAMPLE_COUNT 16\nuniform float pcssDiskSamples[PCSS_SAMPLE_COUNT];\nuniform float pcssSphereSamples[PCSS_SAMPLE_COUNT];\nvec2 vogelDisk(int sampleIndex, float count, float phi, float r) {\n	const float GoldenAngle = 2.4;\n	float theta = float(sampleIndex) * GoldenAngle + phi;\n	float sine = sin(theta);\n	float cosine = cos(theta);\n	return vec2(r * cosine, r * sine);\n}\nvec3 vogelSphere(int sampleIndex, float count, float phi, float r) {\n	const float GoldenAngle = 2.4;\n	float theta = float(sampleIndex) * GoldenAngle + phi;\n	float weight = float(sampleIndex) / count;\n	return vec3(cos(theta) * r, weight, sin(theta) * r);\n}\nfloat noise(vec2 screenPos) {\n	const float PHI = 1.61803398874989484820459;\n	return fract(sin(dot(screenPos * PHI, screenPos)) * screenPos.x);\n}\nfloat viewSpaceDepth(float depth, mat4 invProjection) {\n	float z = depth * 2.0 - 1.0;\n	vec4 clipSpace = vec4(0.0, 0.0, z, 1.0);\n	vec4 viewSpace = invProjection * clipSpace;\n	return viewSpace.z;\n}\nfloat PCSSBlockerDistance(TEXTURE_ACCEPT(shadowMap), vec2 sampleCoords[PCSS_SAMPLE_COUNT], vec2 shadowCoords, vec2 searchSize, float z, vec4 cameraParams) {\n	float blockers = 0.0;\n	float averageBlocker = 0.0;\n	for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n		vec2 offset = sampleCoords[i] * searchSize;\n		vec2 sampleUV = shadowCoords + offset;\n		float blocker = texture2DLod(shadowMap, sampleUV, 0.0).r;\n		float isBlocking = step(blocker, z);\n		blockers += isBlocking;\n		averageBlocker += blocker * isBlocking;\n	}\n	if (blockers > 0.0)\n		return averageBlocker / blockers;\n	return -1.0;\n}\nfloat PCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoords, vec4 cameraParams, vec2 shadowSearchArea) {\n	float receiverDepth = linearizeDepth(shadowCoords.z, cameraParams);\n	vec2 samplePoints[PCSS_SAMPLE_COUNT];\n	const float PI = 3.141592653589793;\n	float noise = noise( gl_FragCoord.xy ) * 2.0 * PI;\n	for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n		float pcssPresample = pcssDiskSamples[i];\n		samplePoints[i] = vogelDisk(i, float(PCSS_SAMPLE_COUNT), noise, pcssPresample);\n	}\n	float averageBlocker = PCSSBlockerDistance(TEXTURE_PASS(shadowMap), samplePoints, shadowCoords.xy, shadowSearchArea, receiverDepth, cameraParams);\n	if (averageBlocker == -1.0) {\n		return 1.0;\n	} else {\n		float depthDifference = (receiverDepth - averageBlocker) / 3.0;\n		vec2 filterRadius = depthDifference * shadowSearchArea;\n		float shadow = 0.0;\n		for (int i = 0; i < PCSS_SAMPLE_COUNT; i ++)\n		{\n			vec2 sampleUV = samplePoints[i] * filterRadius;\n			sampleUV = shadowCoords.xy + sampleUV;\n			float depth = texture2DLod(shadowMap, sampleUV, 0.0).r;\n			shadow += step(receiverDepth, depth);\n		}\n		return shadow / float(PCSS_SAMPLE_COUNT);\n	} \n}\n#ifndef WEBGPU\nfloat PCSSCubeBlockerDistance(samplerCube shadowMap, vec3 lightDirNorm, vec3 samplePoints[PCSS_SAMPLE_COUNT], float z, float shadowSearchArea) {\n	float blockers = 0.0;\n	float averageBlocker = 0.0;\n	for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n		vec3 sampleDir = lightDirNorm + samplePoints[i] * shadowSearchArea;\n		sampleDir = normalize(sampleDir);\n		float blocker = textureCubeLod(shadowMap, sampleDir, 0.0).r;\n		float isBlocking = step(blocker, z);\n		blockers += isBlocking;\n		averageBlocker += blocker * isBlocking;\n	}\n	if (blockers > 0.0)\n		return averageBlocker / blockers;\n	return -1.0;\n}\nfloat PCSSCube(samplerCube shadowMap, vec4 shadowParams, vec3 shadowCoords, vec4 cameraParams, float shadowSearchArea, vec3 lightDir) {\n	\n	vec3 samplePoints[PCSS_SAMPLE_COUNT];\n	const float PI = 3.141592653589793;\n	float noise = noise( gl_FragCoord.xy ) * 2.0 * PI;\n	for (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n		float r = pcssSphereSamples[i];\n		samplePoints[i] = vogelSphere(i, float(PCSS_SAMPLE_COUNT), noise, r);\n	}\n	float receiverDepth = length(lightDir) * shadowParams.w + shadowParams.z;\n	vec3 lightDirNorm = normalize(lightDir);\n	\n	float averageBlocker = PCSSCubeBlockerDistance(shadowMap, lightDirNorm, samplePoints, receiverDepth, shadowSearchArea);\n	if (averageBlocker == -1.0) {\n		return 1.0;\n	} else {\n		float filterRadius = ((receiverDepth - averageBlocker) / averageBlocker) * shadowSearchArea;\n		float shadow = 0.0;\n		for (int i = 0; i < PCSS_SAMPLE_COUNT; i++)\n		{\n			vec3 offset = samplePoints[i] * filterRadius;\n			vec3 sampleDir = lightDirNorm + offset;\n			sampleDir = normalize(sampleDir);\n			float depth = textureCubeLod(shadowMap, sampleDir, 0.0).r;\n			shadow += step(receiverDepth, depth);\n		}\n		return shadow / float(PCSS_SAMPLE_COUNT);\n	}\n}\nfloat getShadowOmniPCSS(samplerCube shadowMap, vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {\n	return PCSSCube(shadowMap, shadowParams, shadowCoord, cameraParams, shadowSearchArea.x, lightDir);\n}\n#endif\nfloat getShadowSpotPCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {\n	return PCSS(TEXTURE_PASS(shadowMap), shadowCoord, cameraParams, shadowSearchArea);\n}\n";
            
            var shadowSoftPS = "\nhighp float fractSinRand( const in vec2 uv ) {\n	const float PI = 3.141592653589793;\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot(uv.xy, vec2(a, b)), sn = mod(dt, PI);\n	return fract(sin(sn) * c);\n}\nstruct VogelDiskData {\n	float invNumSamples;\n	float initialAngle;\n	float currentPointId;\n};\nvoid prepareDiskConstants(out VogelDiskData data, int sampleCount, int numRings, float randomSeed) {\n	const float pi2 = 6.28318530718;\n	data.invNumSamples = 1.0 / float(sampleCount);\n	data.initialAngle = randomSeed * pi2;\n	data.currentPointId = 0.0;\n}\n#define GOLDEN_ANGLE 2.399963\nvec2 generateDiskSample(inout VogelDiskData data) {\n	float r = sqrt((data.currentPointId + 0.5) * data.invNumSamples);\n	float theta = data.currentPointId * GOLDEN_ANGLE + data.initialAngle;\n	vec2 offset = vec2(cos(theta), sin(theta)) * pow(r, 1.33);\n	data.currentPointId += 1.0;\n	return offset;\n}\nvoid PCSSFindBlocker(TEXTURE_ACCEPT(shadowMap), out float avgBlockerDepth, out int numBlockers,\n	vec2 shadowCoords, float z, int shadowBlockerSamples, float penumbraSize, float invShadowMapSize, float randomSeed) {\n	VogelDiskData diskData;\n	prepareDiskConstants(diskData, shadowBlockerSamples, 11, randomSeed);\n	float searchWidth = penumbraSize * invShadowMapSize;\n	float blockerSum = 0.0;\n	numBlockers = 0;\n	for( int i = 0; i < shadowBlockerSamples; ++i ) {\n		vec2 diskUV = generateDiskSample(diskData);\n		vec2 sampleUV = shadowCoords + diskUV * searchWidth;\n		float shadowMapDepth = texture2DLod(shadowMap, sampleUV, 0.0).r;\n		if ( shadowMapDepth < z ) {\n			blockerSum += shadowMapDepth;\n			numBlockers++;\n		}\n	}\n	avgBlockerDepth = blockerSum / float(numBlockers);\n}\nfloat PCSSFilter(TEXTURE_ACCEPT(shadowMap), vec2 uv, float receiverDepth, int shadowSamples, float filterRadius, float randomSeed) {\n	VogelDiskData diskData;\n	prepareDiskConstants(diskData, shadowSamples, 11, randomSeed);\n	float sum = 0.0;\n	for (int i = 0; i < shadowSamples; i++) {\n		vec2 offsetUV = generateDiskSample(diskData) * filterRadius;\n		float depth = texture2DLod(shadowMap, uv + offsetUV, 0.0).r;\n		sum += step(receiverDepth, depth);\n	}\n	return sum / float(shadowSamples);\n}\nfloat getPenumbra(float dblocker, float dreceiver, float penumbraSize, float penumbraFalloff) {\n	float dist = dreceiver - dblocker;\n	float penumbra = 1.0 - pow(1.0 - dist, penumbraFalloff);\n	return penumbra * penumbraSize;\n}\nfloat PCSSDirectional(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoords, vec4 cameraParams, vec4 softShadowParams) {\n	float receiverDepth = shadowCoords.z;\n	float randomSeed = fractSinRand(gl_FragCoord.xy);\n	int shadowSamples = int(softShadowParams.x);\n	int shadowBlockerSamples = int(softShadowParams.y);\n	float penumbraSize = softShadowParams.z;\n	float penumbraFalloff = softShadowParams.w;\n	int shadowMapSize = textureSize(shadowMap, 0).x;\n	float invShadowMapSize = 1.0 / float(shadowMapSize);\n	invShadowMapSize *= float(shadowMapSize) / 2048.0;\n	float penumbra;\n	if (shadowBlockerSamples > 0) {\n		float avgBlockerDepth = 0.0;\n		int numBlockers = 0;\n		PCSSFindBlocker(TEXTURE_PASS(shadowMap), avgBlockerDepth, numBlockers, shadowCoords.xy, receiverDepth, shadowBlockerSamples, penumbraSize, invShadowMapSize, randomSeed);\n		if (numBlockers < 1)\n			return 1.0f;\n		penumbra = getPenumbra(avgBlockerDepth, shadowCoords.z, penumbraSize, penumbraFalloff);\n	} else {\n		penumbra = penumbraSize;\n	}\n	float filterRadius = penumbra * invShadowMapSize;\n	return PCSSFilter(TEXTURE_PASS(shadowMap), shadowCoords.xy, receiverDepth, shadowSamples, filterRadius, randomSeed);\n}\nfloat getShadowPCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec4 softShadowParams, vec3 lightDir) {\n	return PCSSDirectional(TEXTURE_PASS(shadowMap), shadowCoord, cameraParams, softShadowParams);\n}\n";
            
            var skinBatchVS = "\nattribute float vertex_boneIndices;\nuniform highp sampler2D texture_poseMap;\nmat4 getBoneMatrix(const in float indexFloat) {\n	int width = textureSize(texture_poseMap, 0).x;\n	int index = int(indexFloat + 0.5) * 3;\n	int iy = index / width;\n	int ix = index % width;\n	vec4 v1 = texelFetch(texture_poseMap, ivec2(ix + 0, iy), 0);\n	vec4 v2 = texelFetch(texture_poseMap, ivec2(ix + 1, iy), 0);\n	vec4 v3 = texelFetch(texture_poseMap, ivec2(ix + 2, iy), 0);\n	return mat4(\n		v1.x, v2.x, v3.x, 0,\n		v1.y, v2.y, v3.y, 0,\n		v1.z, v2.z, v3.z, 0,\n		v1.w, v2.w, v3.w, 1\n	);\n}\n";
            
            var skinVS$1 = "\nattribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\nuniform highp sampler2D texture_poseMap;\nvoid getBoneMatrix(const in int width, const in int index, out vec4 v1, out vec4 v2, out vec4 v3) {\n	int v = index / width;\n	int u = index % width;\n	v1 = texelFetch(texture_poseMap, ivec2(u + 0, v), 0);\n	v2 = texelFetch(texture_poseMap, ivec2(u + 1, v), 0);\n	v3 = texelFetch(texture_poseMap, ivec2(u + 2, v), 0);\n}\nmat4 getSkinMatrix(const in vec4 indicesFloat, const in vec4 weights) {\n	int width = textureSize(texture_poseMap, 0).x;\n	ivec4 indices = ivec4(indicesFloat + 0.5) * 3;\n	vec4 a1, a2, a3;\n	getBoneMatrix(width, indices.x, a1, a2, a3);\n	vec4 b1, b2, b3;\n	getBoneMatrix(width, indices.y, b1, b2, b3);\n	vec4 c1, c2, c3;\n	getBoneMatrix(width, indices.z, c1, c2, c3);\n	vec4 d1, d2, d3;\n	getBoneMatrix(width, indices.w, d1, d2, d3);\n	vec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\n	vec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\n	vec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\n	float one = dot(weights, vec4(1.0));\n	return mat4(\n		v1.x, v2.x, v3.x, 0,\n		v1.y, v2.y, v3.y, 0,\n		v1.z, v2.z, v3.z, 0,\n		v1.w, v2.w, v3.w, one\n	);\n}\n";
            
            var skyboxPS$1 = '\n	#define LIT_SKYBOX_INTENSITY\n	#include "envProcPS"\n	#include "gammaPS"\n	#include "tonemappingPS"\n	varying vec3 vViewDir;\n	uniform float skyboxHighlightMultiplier;\n	#ifdef SKY_CUBEMAP\n		uniform samplerCube texture_cubeMap;\n		#ifdef SKYMESH\n			varying vec3 vWorldPos;\n			uniform mat3 cubeMapRotationMatrix;\n			uniform vec3 projectedSkydomeCenter;\n		#endif\n	#else\n		#include "sphericalPS"\n		#include "envAtlasPS"\n		uniform sampler2D texture_envAtlas;\n		uniform float mipLevel;\n	#endif\n	void main(void) {\n		#ifdef SKY_CUBEMAP\n			#ifdef SKYMESH\n				vec3 envDir = normalize(vWorldPos - projectedSkydomeCenter);\n				vec3 dir = envDir * cubeMapRotationMatrix;\n			#else\n				vec3 dir = vViewDir;\n			#endif\n			dir.x *= -1.0;\n			vec3 linear = {SKYBOX_DECODE_FNC}(textureCube(texture_cubeMap, dir));\n		#else\n			vec3 dir = vViewDir * vec3(-1.0, 1.0, 1.0);\n			vec2 uv = toSphericalUv(normalize(dir));\n			vec3 linear = {SKYBOX_DECODE_FNC}(texture2D(texture_envAtlas, mapRoughnessUv(uv, mipLevel)));\n		#endif\n		if (any(greaterThanEqual(linear, vec3(64.0)))) {\n			linear *= skyboxHighlightMultiplier;\n		}\n		gl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);\n	}\n';
            
            var skyboxVS$1 = "\nattribute vec4 aPosition;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform mat4 matrix_projectionSkybox;\nuniform mat3 cubeMapRotationMatrix;\nvarying vec3 vViewDir;\n#ifdef SKYMESH\n	uniform mat4 matrix_model;\n	varying vec3 vWorldPos;\n#endif\nvoid main(void) {\n	mat4 view = matrix_view;\n	#ifdef SKYMESH\n		vec4 worldPos = matrix_model * aPosition;\n		vWorldPos = worldPos.xyz;\n		gl_Position = matrix_projectionSkybox * (view * worldPos);\n	#else\n		view[3][0] = view[3][1] = view[3][2] = 0.0;\n		gl_Position = matrix_projectionSkybox * (view * aPosition);\n		vViewDir = aPosition.xyz * cubeMapRotationMatrix;\n	#endif\n	gl_Position.z = gl_Position.w - 1.0e-7;\n}\n";
            
            var specularPS = "\n#ifdef STD_SPECULAR_CONSTANT\nuniform vec3 material_specular;\n#endif\nvoid getSpecularity() {\n	vec3 specularColor = vec3(1,1,1);\n	#ifdef STD_SPECULAR_CONSTANT\n	specularColor *= material_specular;\n	#endif\n	#ifdef STD_SPECULAR_TEXTURE\n	specularColor *= {STD_SPECULAR_TEXTURE_DECODE}(texture2DBias({STD_SPECULAR_TEXTURE_NAME}, {STD_SPECULAR_TEXTURE_UV}, textureBias)).{STD_SPECULAR_TEXTURE_CHANNEL};\n	#endif\n	#ifdef STD_SPECULAR_VERTEX\n	specularColor *= saturate(vVertexColor.{STD_SPECULAR_VERTEX_CHANNEL});\n	#endif\n	dSpecularity = specularColor;\n}\n";
            
            var sphericalPS$1 = "\nvec2 toSpherical(vec3 dir) {\n	return vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));\n}\nvec2 toSphericalUv(vec3 dir) {\n	const float PI = 3.141592653589793;\n	vec2 uv = toSpherical(dir) / vec2(PI * 2.0, PI) + 0.5;\n	return vec2(uv.x, 1.0 - uv.y);\n}\n";
            
            var specularityFactorPS = "\n#ifdef STD_SPECULARITYFACTOR_CONSTANT\nuniform float material_specularityFactor;\n#endif\nvoid getSpecularityFactor() {\n	float specularityFactor = 1.0;\n	#ifdef STD_SPECULARITYFACTOR_CONSTANT\n	specularityFactor *= material_specularityFactor;\n	#endif\n	#ifdef STD_SPECULARITYFACTOR_TEXTURE\n	specularityFactor *= texture2DBias({STD_SPECULARITYFACTOR_TEXTURE_NAME}, {STD_SPECULARITYFACTOR_TEXTURE_UV}, textureBias).{STD_SPECULARITYFACTOR_TEXTURE_CHANNEL};\n	#endif\n	#ifdef STD_SPECULARITYFACTOR_VERTEX\n	specularityFactor *= saturate(vVertexColor.{STD_SPECULARITYFACTOR_VERTEX_CHANNEL});\n	#endif\n	dSpecularityFactor = specularityFactor;\n}\n";
            
            var spotPS = "\nfloat getSpotEffect(vec3 lightSpotDir, float lightInnerConeAngle, float lightOuterConeAngle, vec3 lightDirNorm) {\n	float cosAngle = dot(lightDirNorm, lightSpotDir);\n	return smoothstep(lightOuterConeAngle, lightInnerConeAngle, cosAngle);\n}\n";
            
            var startNineSlicedPS = "\n	nineSlicedUv = vUv0;\n	nineSlicedUv.y = 1.0 - nineSlicedUv.y;\n";
            
            var startNineSlicedTiledPS = "\n	vec2 tileMask = step(vMask, vec2(0.99999));\n	vec2 tileSize = 0.5 * (innerOffset.xy + innerOffset.zw);\n	vec2 tileScale = vec2(1.0) / (vec2(1.0) - tileSize);\n	vec2 clampedUv = mix(innerOffset.xy * 0.5, vec2(1.0) - innerOffset.zw * 0.5, fract((vTiledUv - tileSize) * tileScale));\n	clampedUv = clampedUv * atlasRect.zw + atlasRect.xy;\n	nineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);\n	nineSlicedUv.y = 1.0 - nineSlicedUv.y;\n	\n";
            
            var stdDeclarationPS = '\n	float dAlpha = 1.0;\n	#if defined(LIT_ALPHA_TEST)\n		#include "alphaTestPS"\n	#endif\n	#if STD_OPACITY_DITHER != NONE\n		#include "opacityDitherPS"\n	#endif\n	#ifdef FORWARD_PASS\n		vec3 dAlbedo;\n		vec3 dNormalW;\n		vec3 dSpecularity = vec3(0.0);\n		float dGlossiness = 0.0;\n		#ifdef LIT_REFRACTION\n			float dTransmission;\n			float dThickness;\n		#endif\n		#ifdef LIT_SCENE_COLOR\n			uniform sampler2D uSceneColorMap;\n		#endif\n		#ifdef LIT_SCREEN_SIZE\n			uniform vec4 uScreenSize;\n		#endif\n		#ifdef LIT_TRANSFORMS\n			uniform mat4 matrix_viewProjection;\n			uniform mat4 matrix_model;\n		#endif\n		#ifdef STD_HEIGHT_MAP\n			vec2 dUvOffset;\n			#ifdef STD_DIFFUSE_TEXTURE_ALLOCATE\n				uniform sampler2D texture_heightMap;\n			#endif\n		#endif\n		#ifdef STD_DIFFUSE_TEXTURE_ALLOCATE\n			uniform sampler2D texture_diffuseMap;\n		#endif\n		#ifdef STD_DIFFUSEDETAIL_TEXTURE_ALLOCATE\n			uniform sampler2D texture_diffuseDetailMap;\n		#endif\n		#ifdef STD_NORMAL_TEXTURE_ALLOCATE\n			uniform sampler2D texture_normalMap;\n		#endif\n		#ifdef STD_NORMALDETAIL_TEXTURE_ALLOCATE\n			uniform sampler2D texture_normalDetailMap;\n		#endif\n		#ifdef STD_THICKNESS_TEXTURE_ALLOCATE\n			uniform sampler2D texture_thicknessMap;\n		#endif\n		#ifdef STD_REFRACTION_TEXTURE_ALLOCATE\n			uniform sampler2D texture_refractionMap;\n		#endif\n		#ifdef LIT_IRIDESCENCE\n			float dIridescence;\n			float dIridescenceThickness;\n			#ifdef STD_IRIDESCENCE_THICKNESS_TEXTURE_ALLOCATE\n				uniform sampler2D texture_iridescenceThicknessMap;\n			#endif\n			#ifdef STD_IRIDESCENCE_TEXTURE_ALLOCATE\n				uniform sampler2D texture_iridescenceMap;\n			#endif\n		#endif\n		#ifdef LIT_CLEARCOAT\n			float ccSpecularity;\n			float ccGlossiness;\n			vec3 ccNormalW;\n		#endif\n		#ifdef LIT_SPECULAR_OR_REFLECTION\n			#ifdef LIT_SHEEN\n				vec3 sSpecularity;\n				float sGlossiness;\n				#ifdef STD_SHEEN_TEXTURE_ALLOCATE\n					uniform sampler2D texture_sheenMap;\n				#endif\n				#ifdef STD_SHEENGLOSS_TEXTURE_ALLOCATE\n					uniform sampler2D texture_sheenGlossMap;\n				#endif\n			#endif\n			#ifdef LIT_METALNESS\n				float dMetalness;\n				float dIor;\n				#ifdef STD_METALNESS_TEXTURE_ALLOCATE\n					uniform sampler2D texture_metalnessMap;\n				#endif\n			#endif\n			#ifdef LIT_SPECULARITY_FACTOR\n				float dSpecularityFactor;\n				#ifdef STD_SPECULARITYFACTOR_TEXTURE_ALLOCATE\n					uniform sampler2D texture_specularityFactorMap;\n				#endif\n			#endif\n			#ifdef STD_SPECULAR_COLOR\n				#ifdef STD_SPECULAR_TEXTURE_ALLOCATE\n					uniform sampler2D texture_specularMap;\n				#endif\n			#endif\n			#ifdef STD_GLOSS_TEXTURE_ALLOCATE\n				uniform sampler2D texture_glossMap;\n			#endif\n		#endif\n		#ifdef STD_AO\n			float dAo;\n			#ifdef STD_AO_TEXTURE_ALLOCATE\n				uniform sampler2D texture_aoMap;\n			#endif\n			#ifdef STD_AODETAIL_TEXTURE_ALLOCATE\n				uniform sampler2D texture_aoDetailMap;\n			#endif\n		#endif\n		vec3 dEmission;\n		#ifdef STD_EMISSIVE_TEXTURE_ALLOCATE\n			uniform sampler2D texture_emissiveMap;\n		#endif\n		#ifdef LIT_CLEARCOAT\n			#ifdef STD_CLEARCOAT_TEXTURE_ALLOCATE\n				uniform sampler2D texture_clearCoatMap;\n			#endif\n			#ifdef STD_CLEARCOATGLOSS_TEXTURE_ALLOCATE\n				uniform sampler2D texture_clearCoatGlossMap;\n			#endif\n			#ifdef STD_CLEARCOATNORMAL_TEXTURE_ALLOCATE\n				uniform sampler2D texture_clearCoatNormalMap;\n			#endif\n		#endif\n		#if defined(STD_LIGHTMAP) || defined(STD_LIGHT_VERTEX_COLOR)\n			vec3 dLightmap;\n			#ifdef STD_LIGHT_TEXTURE_ALLOCATE\n				uniform sampler2D texture_lightMap;\n			#endif\n		#endif\n	#endif\n	#include "litShaderCorePS"\n';
            
            var stdFrontEndPS = '\n	#if LIT_BLEND_TYPE != NONE || defined(LIT_ALPHA_TEST) || defined(LIT_ALPHA_TO_COVERAGE) || STD_OPACITY_DITHER != NONE\n		#ifdef STD_OPACITY_TEXTURE_ALLOCATE\n			uniform sampler2D texture_opacityMap;\n		#endif\n		#include "opacityPS"\n	#endif\n	#ifdef FORWARD_PASS\n		#ifdef STD_HEIGHT_MAP\n			#include "parallaxPS"\n		#endif\n		#include  "diffusePS"\n		#ifdef LIT_NEEDS_NORMAL\n			#include "normalMapPS"\n		#endif\n		#ifdef LIT_REFRACTION\n			#include "transmissionPS"\n			#include "thicknessPS"\n		#endif\n		#ifdef LIT_IRIDESCENCE\n			#include "iridescencePS"\n			#include "iridescenceThicknessPS"\n		#endif\n		#ifdef LIT_SPECULAR_OR_REFLECTION\n			#ifdef LIT_SHEEN\n				#include "sheenPS"\n				#include "sheenGlossPS"\n			#endif\n			#ifdef LIT_METALNESS\n				#include "metalnessPS"\n				#include "iorPS"\n			#endif\n			#ifdef LIT_SPECULARITY_FACTOR\n				#include "specularityFactorPS"\n			#endif\n			#ifdef STD_SPECULAR_COLOR\n				#include "specularPS"\n			#else\n				void getSpecularity() { \n					dSpecularity = vec3(1);\n				}\n			#endif\n			#include "glossPS"\n		#endif\n		#ifdef STD_AO\n			#include "aoPS"\n		#endif\n		#include "emissivePS"\n		#ifdef LIT_CLEARCOAT\n			#include "clearCoatPS"\n			#include "clearCoatGlossPS"\n			#include "clearCoatNormalPS"\n		#endif\n		#if defined(STD_LIGHTMAP) || defined(STD_LIGHT_VERTEX_COLOR)\n			#include "lightmapPS"\n		#endif\n	#endif\n	void evaluateFrontend() {\n		#if LIT_BLEND_TYPE != NONE || defined(LIT_ALPHA_TEST) || defined(LIT_ALPHA_TO_COVERAGE) || STD_OPACITY_DITHER != NONE\n			getOpacity();\n			#if defined(LIT_ALPHA_TEST)\n				alphaTest(dAlpha);\n			#endif\n			#if STD_OPACITY_DITHER != NONE\n				opacityDither(dAlpha, 0.0);\n			#endif\n			litArgs_opacity = dAlpha;\n		#endif\n		#ifdef FORWARD_PASS\n			#ifdef STD_HEIGHT_MAP\n				getParallax();\n			#endif\n			getAlbedo();\n			litArgs_albedo = dAlbedo;\n			#ifdef LIT_NEEDS_NORMAL\n				getNormal();\n				litArgs_worldNormal = dNormalW;\n			#endif\n			#ifdef LIT_REFRACTION\n				getRefraction();\n				litArgs_transmission = dTransmission;\n				getThickness();\n				litArgs_thickness = dThickness;\n				#ifdef LIT_DISPERSION\n					litArgs_dispersion = material_dispersion;\n				#endif\n			#endif\n			#ifdef LIT_IRIDESCENCE\n				getIridescence();\n				getIridescenceThickness();\n				litArgs_iridescence_intensity = dIridescence;\n				litArgs_iridescence_thickness = dIridescenceThickness;\n			#endif\n			#ifdef LIT_SPECULAR_OR_REFLECTION\n				#ifdef LIT_SHEEN\n					getSheen();\n					litArgs_sheen_specularity = sSpecularity;\n					getSheenGlossiness();\n					litArgs_sheen_gloss = sGlossiness;\n				#endif\n				#ifdef LIT_METALNESS\n					getMetalness();\n					litArgs_metalness = dMetalness;\n					getIor();\n					litArgs_ior = dIor;\n				#endif\n				#ifdef LIT_SPECULARITY_FACTOR\n					getSpecularityFactor();\n					litArgs_specularityFactor = dSpecularityFactor;\n				#endif\n				getGlossiness();\n				getSpecularity();\n				litArgs_specularity = dSpecularity;\n				litArgs_gloss = dGlossiness;\n			#endif\n			#ifdef STD_AO\n				getAO();\n				litArgs_ao = dAo;\n			#endif\n			getEmission();\n			litArgs_emission = dEmission;\n			#ifdef LIT_CLEARCOAT\n				getClearCoat();\n				getClearCoatGlossiness();\n				getClearCoatNormal();\n				litArgs_clearcoat_specularity = ccSpecularity;\n				litArgs_clearcoat_gloss = ccGlossiness;\n				litArgs_clearcoat_worldNormal = ccNormalW;\n			#endif\n			#if defined(STD_LIGHTMAP) || defined(STD_LIGHT_VERTEX_COLOR)\n				getLightMap();\n				litArgs_lightmap = dLightmap;\n				#ifdef STD_LIGHTMAP_DIR\n					litArgs_lightmapDir = dLightmapDir;\n				#endif\n			#endif\n		#endif\n	}\n';
            
            var tangentBinormalVS = "\nvec3 getTangent() {\n	return normalize(dNormalMatrix * vertex_tangent.xyz);\n}\nvec3 getBinormal() {\n	return cross(vNormalW, vTangentW) * vertex_tangent.w;\n}\n";
            
            var TBNPS = "\n#ifdef LIT_TANGENTS\n	#define TBN_TANGENTS\n#else\n	#if defined(LIT_USE_NORMALS) || defined(LIT_USE_CLEARCOAT_NORMALS)\n		#define TBN_DERIVATIVES\n	#endif\n#endif\n#if defined(TBN_DERIVATIVES)\n	uniform float tbnBasis;\n#endif\nvoid getTBN(vec3 tangent, vec3 binormal, vec3 normal) {\n	#ifdef TBN_TANGENTS\n		dTBN = mat3(normalize(tangent), normalize(binormal), normalize(normal));\n	#elif defined(TBN_DERIVATIVES)\n		vec2 uv = {lightingUv};\n		vec3 dp1 = dFdx( vPositionW );\n		vec3 dp2 = dFdy( vPositionW );\n		vec2 duv1 = dFdx( uv );\n		vec2 duv2 = dFdy( uv );\n		vec3 dp2perp = cross( dp2, normal );\n		vec3 dp1perp = cross( normal, dp1 );\n		vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n		vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n		float denom = max( dot(T,T), dot(B,B) );\n		float invmax = (denom == 0.0) ? 0.0 : tbnBasis / sqrt( denom );\n		dTBN = mat3(T * invmax, -B * invmax, normal );\n	#else\n		vec3 B = cross(normal, vObjectSpaceUpW);\n		vec3 T = cross(normal, B);\n		if (dot(B,B)==0.0)\n		{\n			float major=max(max(normal.x, normal.y), normal.z);\n			if (normal.x == major)\n			{\n				B = cross(normal, vec3(0,1,0));\n				T = cross(normal, B);\n			}\n			else if (normal.y == major)\n			{\n				B = cross(normal, vec3(0,0,1));\n				T = cross(normal, B);\n			}\n			else if (normal.z == major)\n			{\n				B = cross(normal, vec3(1,0,0));\n				T = cross(normal, B);\n			}\n		}\n		dTBN = mat3(normalize(T), normalize(B), normalize(normal));\n	#endif\n}\n";
            
            var thicknessPS = "\n#ifdef STD_THICKNESS_CONSTANT\nuniform float material_thickness;\n#endif\nvoid getThickness() {\n	dThickness = 1.0;\n	#ifdef STD_THICKNESS_CONSTANT\n	dThickness *= material_thickness;\n	#endif\n	#ifdef STD_THICKNESS_TEXTURE\n	dThickness *= texture2DBias({STD_THICKNESS_TEXTURE_NAME}, {STD_THICKNESS_TEXTURE_UV}, textureBias).{STD_THICKNESS_TEXTURE_CHANNEL};\n	#endif\n	#ifdef STD_THICKNESS_VERTEX\n	dThickness *= saturate(vVertexColor.{STD_THICKNESS_VERTEX_CHANNEL});\n	#endif\n}\n";
            
            var tonemappingPS$1 = '\n#if (TONEMAP == NONE)\n	#include "tonemappingNonePS"\n#elif TONEMAP == FILMIC\n	#include "tonemappingFilmicPS"\n#elif TONEMAP == LINEAR\n	#include "tonemappingLinearPS"\n#elif TONEMAP == HEJL\n	#include "tonemappingHejlPS"\n#elif TONEMAP == ACES\n	#include "tonemappingAcesPS"\n#elif TONEMAP == ACES2\n	#include "tonemappingAces2PS"\n#elif TONEMAP == NEUTRAL\n	#include "tonemappingNeutralPS"\n#endif\n';
            
            var tonemappingAcesPS$1 = "\nuniform float exposure;\nvec3 toneMap(vec3 color) {\n	float tA = 2.51;\n	float tB = 0.03;\n	float tC = 2.43;\n	float tD = 0.59;\n	float tE = 0.14;\n	vec3 x = color * exposure;\n	return (x*(tA*x+tB))/(x*(tC*x+tD)+tE);\n}\n";
            
            var tonemappingAces2PS$1 = "\nuniform float exposure;\nconst mat3 ACESInputMat = mat3(\n	0.59719, 0.35458, 0.04823,\n	0.07600, 0.90834, 0.01566,\n	0.02840, 0.13383, 0.83777\n);\nconst mat3 ACESOutputMat = mat3(\n	 1.60475, -0.53108, -0.07367,\n	-0.10208,  1.10813, -0.00605,\n	-0.00327, -0.07276,  1.07602\n);\nvec3 RRTAndODTFit(vec3 v) {\n	vec3 a = v * (v + 0.0245786) - 0.000090537;\n	vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n	return a / b;\n}\nvec3 toneMap(vec3 color) {\n	color *= exposure / 0.6;\n	color = color * ACESInputMat;\n	color = RRTAndODTFit(color);\n	color = color * ACESOutputMat;\n	color = clamp(color, 0.0, 1.0);\n	return color;\n}\n";
            
            var tonemappingFilmicPS$1 = "\nconst float A =  0.15;\nconst float B =  0.50;\nconst float C =  0.10;\nconst float D =  0.20;\nconst float E =  0.02;\nconst float F =  0.30;\nconst float W =  11.2;\nuniform float exposure;\nvec3 uncharted2Tonemap(vec3 x) {\n   return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\nvec3 toneMap(vec3 color) {\n	color = uncharted2Tonemap(color * exposure);\n	vec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W,W,W));\n	color = color * whiteScale;\n	return color;\n}\n";
            
            var tonemappingHejlPS$1 = "\nuniform float exposure;\nvec3 toneMap(vec3 color) {\n	color *= exposure;\n	const float  A = 0.22, B = 0.3, C = .1, D = 0.2, E = .01, F = 0.3;\n	const float Scl = 1.25;\n	vec3 h = max( vec3(0.0), color - vec3(0.004) );\n	return (h*((Scl*A)*h+Scl*vec3(C*B,C*B,C*B))+Scl*vec3(D*E,D*E,D*E)) / (h*(A*h+vec3(B,B,B))+vec3(D*F,D*F,D*F)) - Scl*vec3(E/F,E/F,E/F);\n}\n";
            
            var tonemappingLinearPS$1 = "\nuniform float exposure;\nvec3 toneMap(vec3 color) {\n	return color * exposure;\n}\n";
            
            var tonemappingNeutralPS$1 = "\nuniform float exposure;\nvec3 toneMap(vec3 color) {\n	color *= exposure;\n	float startCompression = 0.8 - 0.04;\n	float desaturation = 0.15;\n	float x = min(color.r, min(color.g, color.b));\n	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n	color -= offset;\n	float peak = max(color.r, max(color.g, color.b));\n	if (peak < startCompression) return color;\n	float d = 1. - startCompression;\n	float newPeak = 1. - d * d / (peak + d - startCompression);\n	color *= newPeak / peak;\n	float g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);\n	return mix(color, newPeak * vec3(1, 1, 1), g);\n}\n";
            
            var tonemappingNonePS$1 = "\nvec3 toneMap(vec3 color) {\n	return color;\n}\n";
            
            var transformVS$1 = "\n#ifdef PIXELSNAP\nuniform vec4 uScreenSize;\n#endif\n#ifdef SCREENSPACE\nuniform float projectionFlipY;\n#endif\nvec4 evalWorldPosition(vec3 vertexPosition, mat4 modelMatrix) {\n	vec3 localPos = getLocalPosition(vertexPosition);\n	#ifdef NINESLICED\n		localPos.xz *= outerScale;\n		vec2 positiveUnitOffset = clamp(vertexPosition.xz, vec2(0.0), vec2(1.0));\n		vec2 negativeUnitOffset = clamp(-vertexPosition.xz, vec2(0.0), vec2(1.0));\n		localPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n		vTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0;\n		localPos.xz *= -0.5;\n		localPos = localPos.xzy;\n	#endif\n	vec4 posW = modelMatrix * vec4(localPos, 1.0);\n	#ifdef SCREENSPACE\n		posW.zw = vec2(0.0, 1.0);\n	#endif\n	return posW;\n}\nvec4 getPosition() {\n	dModelMatrix = getModelMatrix();\n	vec4 posW = evalWorldPosition(vertex_position.xyz, dModelMatrix);\n	dPositionW = posW.xyz;\n	vec4 screenPos;\n	#ifdef UV1LAYOUT\n		screenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);\n		#ifdef WEBGPU\n			screenPos.y *= -1.0;\n		#endif\n	#else\n		#ifdef SCREENSPACE\n			screenPos = posW;\n			screenPos.y *= projectionFlipY;\n		#else\n			screenPos = matrix_viewProjection * posW;\n		#endif\n		#ifdef PIXELSNAP\n			screenPos.xy = (screenPos.xy * 0.5) + 0.5;\n			screenPos.xy *= uScreenSize.xy;\n			screenPos.xy = floor(screenPos.xy);\n			screenPos.xy *= uScreenSize.zw;\n			screenPos.xy = (screenPos.xy * 2.0) - 1.0;\n		#endif\n	#endif\n	return screenPos;\n}\nvec3 getWorldPosition() {\n	return dPositionW;\n}\n";
            
            var transformCoreVS$1 = '\nattribute vec4 vertex_position;\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\n#ifdef MORPHING\n	uniform vec2 morph_tex_params;\n	attribute uint morph_vertex_id;\n	ivec2 getTextureMorphCoords() {\n		ivec2 textureSize = ivec2(morph_tex_params);\n		int morphGridV = int(morph_vertex_id) / textureSize.x;\n		int morphGridU = int(morph_vertex_id) - (morphGridV * textureSize.x);\n		#ifdef WEBGPU\n			morphGridV = textureSize.y - morphGridV - 1;\n		#endif\n		return ivec2(morphGridU, morphGridV);\n	}\n	#ifdef MORPHING_POSITION\n		#ifdef MORPHING_INT\n			uniform vec3 aabbSize;\n			uniform vec3 aabbMin;\n			uniform usampler2D morphPositionTex;\n		#else\n			uniform highp sampler2D morphPositionTex;\n		#endif\n	#endif\n#endif\n#ifdef defined(BATCH)\n	#include "skinBatchVS"\n	mat4 getModelMatrix() {\n		return getBoneMatrix(vertex_boneIndices);\n	}\n#elif defined(SKIN)\n	#include "skinVS"\n	mat4 getModelMatrix() {\n		return matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);\n	}\n#elif defined(INSTANCING)\n	#include "transformInstancingVS"\n#else\n	mat4 getModelMatrix() {\n		return matrix_model;\n	}\n#endif\nvec3 getLocalPosition(vec3 vertexPosition) {\n	vec3 localPos = vertexPosition;\n	#ifdef MORPHING_POSITION\n		ivec2 morphUV = getTextureMorphCoords();\n		#ifdef MORPHING_INT\n			vec3 morphPos = vec3(texelFetch(morphPositionTex, ivec2(morphUV), 0).xyz) / 65535.0 * aabbSize + aabbMin;\n		#else\n			vec3 morphPos = texelFetch(morphPositionTex, ivec2(morphUV), 0).xyz;\n		#endif\n		localPos += morphPos;\n	#endif\n	return localPos;\n}\n';
            
            var transformInstancingVS = "\nattribute vec4 instance_line1;\nattribute vec4 instance_line2;\nattribute vec4 instance_line3;\nattribute vec4 instance_line4;\nmat4 getModelMatrix() {\n	return matrix_model * mat4(instance_line1, instance_line2, instance_line3, instance_line4);\n}\n";
            
            var transmissionPS = "\n#ifdef STD_REFRACTION_CONSTANT\nuniform float material_refraction;\n#endif\nvoid getRefraction() {\n	float refraction = 1.0;\n	#ifdef STD_REFRACTION_CONSTANT\n	refraction = material_refraction;\n	#endif\n	#ifdef STD_REFRACTION_TEXTURE\n	refraction *= texture2DBias({STD_REFRACTION_TEXTURE_NAME}, {STD_REFRACTION_TEXTURE_UV}, textureBias).{STD_REFRACTION_TEXTURE_CHANNEL};\n	#endif\n	#ifdef STD_REFRACTION_VERTEX\n	refraction *= saturate(vVertexColor.{STD_REFRACTION_VERTEX_CHANNEL});\n	#endif\n	dTransmission = refraction;\n}\n";
            
            var twoSidedLightingPS = "\nuniform float twoSidedLightingNegScaleFactor;\nvoid handleTwoSidedLighting() {\n	dTBN[2] *= gl_FrontFacing ? twoSidedLightingNegScaleFactor : -twoSidedLightingNegScaleFactor;\n}\n";
            
            var uv0VS$1 = "\n#ifdef NINESLICED\n	vec2 getUv0() {\n		vec2 uv = vertex_position.xz;\n		vec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n		vec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n		uv += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n		uv = uv * -0.5 + 0.5;\n		uv = uv * atlasRect.zw + atlasRect.xy;\n		vMask = vertex_texCoord0.xy;\n		return uv;\n	}\n#else\n	vec2 getUv0() {\n		return vertex_texCoord0;\n	}\n#endif\n";
            
            var uv1VS$1 = "\nvec2 getUv1() {\n	return vertex_texCoord1;\n}\n";
            
            var uvTransformVS$1 = "\nvUV{TRANSFORM_UV_{i}}_{TRANSFORM_ID_{i}} = vec2(\n	dot(vec3(uv{TRANSFORM_UV_{i}}, 1), {TRANSFORM_NAME_{i}}0),\n	dot(vec3(uv{TRANSFORM_UV_{i}}, 1), {TRANSFORM_NAME_{i}}1)\n);\n";
            
            var uvTransformUniformsPS$1 = "\n	uniform vec3 {TRANSFORM_NAME_{i}}0;\n	uniform vec3 {TRANSFORM_NAME_{i}}1;\n";
            
            var viewDirPS = "\nvoid getViewDir() {\n	dViewDirW = normalize(view_position - vPositionW);\n}\n";
            
            var shaderChunks = {
            		alphaTestPS,
            		ambientPS: ambientPS$1,
            		aoPS,
            		aoDiffuseOccPS,
            		aoSpecOccPS,
            		basePS: basePS$1,
            		baseNineSlicedPS,
            		baseNineSlicedTiledPS,
            		bayerPS,
            		blurVSMPS,
            		clearCoatPS,
            		clearCoatGlossPS,
            		clearCoatNormalPS,
            		clusteredLightCookiesPS,
            		clusteredLightShadowsPS,
            		clusteredLightUtilsPS,
            		clusteredLightPS,
            		combinePS: combinePS$1,
            		cookieBlit2DPS: cookieBlit2DPS$1,
            		cookieBlitCubePS: cookieBlitCubePS$1,
            		cookieBlitVS: cookieBlitVS$1,
            		cookiePS,
            		cubeMapProjectPS,
            		cubeMapRotatePS,
            		debugOutputPS: debugOutputPS$1,
            		debugProcessFrontendPS: debugProcessFrontendPS$1,
            		detailModesPS,
            		diffusePS,
            		decodePS: decodePS$1,
            		emissivePS,
            		encodePS: encodePS$1,
            		endPS: endPS$1,
            		envAtlasPS: envAtlasPS$1,
            		envProcPS: envProcPS$1,
            		falloffInvSquaredPS,
            		falloffLinearPS,
            		floatAsUintPS,
            		fogPS: fogPS$1,
            		fresnelSchlickPS,
            		fullscreenQuadPS,
            		fullscreenQuadVS,
            		gammaPS: gammaPS$1,
            		gles3PS,
            		gles3VS,
            		glossPS,
            		gsplatCenterVS,
            		gsplatCornerVS,
            		gsplatColorVS,
            		gsplatCommonVS,
            		gsplatCompressedDataVS,
            		gsplatCompressedSHVS,
            		gsplatSogsColorVS,
            		gsplatSogsDataVS,
            		gsplatSogsSHVS,
            		gsplatDataVS,
            		gsplatOutputVS,
            		gsplatPS,
            		gsplatSHVS,
            		gsplatSourceVS,
            		gsplatVS,
            		immediateLinePS: immediateLinePS$1,
            		immediateLineVS: immediateLineVS$1,
            		iridescenceDiffractionPS,
            		iridescencePS,
            		iridescenceThicknessPS,
            		iorPS,
            		lightBufferDefinesPS: '',
            		lightDeclarationPS,
            		lightDiffuseLambertPS,
            		lightDirPointPS,
            		lightEvaluationPS,
            		lightFunctionLightPS,
            		lightFunctionShadowPS,
            		lightingPS: lightingPS$1,
            		lightmapAddPS,
            		lightmapPS,
            		lightSpecularAnisoGGXPS,
            		lightSpecularBlinnPS,
            		lightSheenPS,
            		linearizeDepthPS,
            		litForwardBackendPS: litForwardBackendPS$1,
            		litForwardDeclarationPS: litForwardDeclarationPS$1,
            		litForwardMainPS: litForwardMainPS$1,
            		litForwardPostCodePS: litForwardPostCodePS$1,
            		litForwardPreCodePS: litForwardPreCodePS$1,
            		litMainVS: litMainVS$1,
            		litOtherMainPS,
            		litShaderArgsPS: litShaderArgsPS$1,
            		litShaderCorePS: litShaderCorePS$1,
            		litShadowMainPS,
            		ltcPS,
            		metalnessPS,
            		metalnessModulatePS,
            		morphEvaluationPS: morphEvaluationPS$1,
            		morphDeclarationPS: morphDeclarationPS$1,
            		morphPS: morphPS$1,
            		morphVS: morphVS$1,
            		msdfPS,
            		msdfVS,
            		normalVS,
            		normalCoreVS: normalCoreVS$1,
            		normalMapPS,
            		opacityPS,
            		opacityDitherPS,
            		outputPS: outputPS$1,
            		outputAlphaPS: outputAlphaPS$1,
            		outputTex2DPS,
            		sheenPS,
            		sheenGlossPS,
            		parallaxPS,
            		particlePS,
            		particleVS,
            		particleAnimFrameClampVS,
            		particleAnimFrameLoopVS,
            		particleAnimTexVS,
            		particleInputFloatPS,
            		particleInputRgba8PS,
            		particleOutputFloatPS,
            		particleOutputRgba8PS,
            		particleUpdaterAABBPS,
            		particleUpdaterEndPS,
            		particleUpdaterInitPS,
            		particleUpdaterNoRespawnPS,
            		particleUpdaterOnStopPS,
            		particleUpdaterRespawnPS,
            		particleUpdaterSpherePS,
            		particleUpdaterStartPS,
            		particle_billboardVS,
            		particle_blendAddPS,
            		particle_blendMultiplyPS,
            		particle_blendNormalPS,
            		particle_cpuVS,
            		particle_cpu_endVS,
            		particle_customFaceVS,
            		particle_endPS,
            		particle_endVS,
            		particle_halflambertPS,
            		particle_initVS,
            		particle_lambertPS,
            		particle_lightingPS,
            		particle_localShiftVS,
            		particle_meshVS,
            		particle_normalVS,
            		particle_normalMapPS,
            		particle_pointAlongVS,
            		particle_simulationPS,
            		particle_shaderPS,
            		particle_shaderVS,
            		particle_softPS,
            		particle_softVS,
            		particle_stretchVS,
            		particle_TBNVS,
            		particle_wrapVS,
            		pickPS,
            		reflDirPS,
            		reflDirAnisoPS,
            		reflectionCCPS,
            		reflectionCubePS,
            		reflectionEnvHQPS,
            		reflectionEnvPS,
            		reflectionSpherePS,
            		reflectionSheenPS,
            		refractionCubePS,
            		refractionDynamicPS,
            		reprojectPS: reprojectPS$1,
            		reprojectVS: reprojectVS$1,
            		sampleCatmullRomPS,
            		screenDepthPS,
            		shadowCascadesPS,
            		shadowEVSMPS,
            		shadowPCF1PS,
            		shadowPCF3PS,
            		shadowPCF5PS,
            		shadowPCSSPS,
            		shadowSoftPS,
            		skinBatchVS,
            		skinVS: skinVS$1,
            		skyboxPS: skyboxPS$1,
            		skyboxVS: skyboxVS$1,
            		specularPS,
            		sphericalPS: sphericalPS$1,
            		specularityFactorPS,
            		spotPS,
            		startNineSlicedPS,
            		startNineSlicedTiledPS,
            		stdDeclarationPS,
            		stdFrontEndPS,
            		tangentBinormalVS,
            		TBNPS,
            		thicknessPS,
            		tonemappingPS: tonemappingPS$1,
            		tonemappingAcesPS: tonemappingAcesPS$1,
            		tonemappingAces2PS: tonemappingAces2PS$1,
            		tonemappingFilmicPS: tonemappingFilmicPS$1,
            		tonemappingHejlPS: tonemappingHejlPS$1,
            		tonemappingLinearPS: tonemappingLinearPS$1,
            		tonemappingNeutralPS: tonemappingNeutralPS$1,
            		tonemappingNonePS: tonemappingNonePS$1,
            		transformVS: transformVS$1,
            		transformCoreVS: transformCoreVS$1,
            		transformInstancingVS,
            		transmissionPS,
            		twoSidedLightingPS,
            		uv0VS: uv0VS$1,
            		uv1VS: uv1VS$1,
            		uvTransformVS: uvTransformVS$1,
            		uvTransformUniformsPS: uvTransformUniformsPS$1,
            		viewDirPS,
            		webgpuPS,
            		webgpuVS
            };
            
            var programLibraryDeviceCache = new DeviceCache();
            function getProgramLibrary(device) {
            		var library = programLibraryDeviceCache.get(device);
            		return library;
            }
            function setProgramLibrary(device, library) {
            		programLibraryDeviceCache.get(device, ()=>{
            				return library;
            		});
            }
            
            class ShaderGenerator {
            		static definesHash(defines) {
            				var sortedArray = Array.from(defines).sort((a, b)=>a[0] > b[0] ? 1 : -1);
            				return hashCode(JSON.stringify(sortedArray));
            		}
            }
            
            var shaderPassDeviceCache = new DeviceCache();
            class ShaderPassInfo {
            		buildShaderDefines() {
            				var keyword;
            				if (this.isShadow) {
            						keyword = 'SHADOW';
            				} else if (this.isForward) {
            						keyword = 'FORWARD';
            				} else if (this.index === SHADER_DEPTH) {
            						keyword = 'DEPTH';
            				} else if (this.index === SHADER_PICK) {
            						keyword = 'PICK';
            				}
            				this.defines.set("" + keyword + "_PASS", '');
            				this.defines.set("" + this.name.toUpperCase() + "_PASS", '');
            		}
            		constructor(name, index, options = {}){
            				this.defines = new Map();
            				this.name = name;
            				this.index = index;
            				Object.assign(this, options);
            				this.buildShaderDefines();
            		}
            }
            class ShaderPass {
            		static get(device) {
            				return shaderPassDeviceCache.get(device, ()=>{
            						return new ShaderPass();
            				});
            		}
            		allocate(name, options) {
            				var info = this.passesNamed.get(name);
            				if (info === undefined) {
            						info = new ShaderPassInfo(name, this.nextIndex, options);
            						this.passesNamed.set(info.name, info);
            						this.passesIndexed[info.index] = info;
            						this.nextIndex++;
            				}
            				return info;
            		}
            		getByIndex(index) {
            				var info = this.passesIndexed[index];
            				return info;
            		}
            		getByName(name) {
            				return this.passesNamed.get(name);
            		}
            		constructor(){
            				this.passesNamed = new Map();
            				this.passesIndexed = [];
            				this.nextIndex = 0;
            				var add = (name, index, options)=>{
            						this.allocate(name, options);
            				};
            				add('forward', SHADER_FORWARD, {
            						isForward: true
            				});
            				add('prepass');
            				add('depth');
            				add('pick');
            				add('shadow');
            		}
            }
            
            function _extends$g() {
            		_extends$g = Object.assign || function(target) {
            				for(var i = 1; i < arguments.length; i++){
            						var source = arguments[i];
            						for(var key in source){
            								if (Object.prototype.hasOwnProperty.call(source, key)) {
            										target[key] = source[key];
            								}
            						}
            				}
            				return target;
            		};
            		return _extends$g.apply(this, arguments);
            }
            function createShaderFromCode(device, vsCode, fsCode, uniqueName, attributes, useTransformFeedback, shaderDefinitionOptions) {
            		if (useTransformFeedback === void 0) useTransformFeedback = false;
            		if (shaderDefinitionOptions === void 0) shaderDefinitionOptions = {};
            		if (typeof useTransformFeedback === 'boolean') {
            				shaderDefinitionOptions.useTransformFeedback = useTransformFeedback;
            		} else if (typeof useTransformFeedback === 'object') {
            				shaderDefinitionOptions = _extends$g({}, shaderDefinitionOptions, useTransformFeedback);
            		}
            		var programLibrary = getProgramLibrary(device);
            		var shader = programLibrary.getCachedShader(uniqueName);
            		if (!shader) {
            				shader = new Shader(device, ShaderUtils.createDefinition(device, _extends$g({}, shaderDefinitionOptions, {
            						name: uniqueName,
            						vertexCode: vsCode,
            						fragmentCode: fsCode,
            						attributes: attributes
            				})));
            				programLibrary.setCachedShader(uniqueName, shader);
            		}
            		return shader;
            }
            class ShaderGeneratorPassThrough extends ShaderGenerator {
            		generateKey(options) {
            				return this.key;
            		}
            		createShaderDefinition(device, options) {
            				return this.shaderDefinition;
            		}
            		constructor(key, shaderDefinition){
            				super();
            				this.key = key;
            				this.shaderDefinition = shaderDefinition;
            		}
            }
            function processShader(shader, processingOptions) {
            		var shaderDefinition = shader.definition;
            		var _shaderDefinition_name;
            		var name = (_shaderDefinition_name = shaderDefinition.name) != null ? _shaderDefinition_name : 'shader';
            		var key = name + "-id-" + shader.id;
            		var materialGenerator = new ShaderGeneratorPassThrough(key, shaderDefinition);
            		var libraryModuleName = 'shader';
            		var library = getProgramLibrary(shader.device);
            		library.register(libraryModuleName, materialGenerator);
            		var variant = library.getProgram(libraryModuleName, {}, processingOptions);
            		library.unregister(libraryModuleName);
            		return variant;
            }
            var getCoreDefines = (material, params)=>{
            		var defines = new Map(material.defines);
            		params.cameraShaderParams.defines.forEach((value, key)=>defines.set(key, value));
            		var shaderPassInfo = ShaderPass.get(params.device).getByIndex(params.pass);
            		shaderPassInfo.defines.forEach((value, key)=>defines.set(key, value));
            		return defines;
            };
            
            var _quadPrimitive = {
            		type: PRIMITIVE_TRISTRIP,
            		base: 0,
            		count: 4,
            		indexed: false
            };
            var _tempViewport = new Vec4();
            var _tempScissor = new Vec4();
            var _dynamicBindGroup$1 = new DynamicBindGroup();
            class QuadRender {
            		destroy() {
            				var _this_uniformBuffer, _this_bindGroup;
            				(_this_uniformBuffer = this.uniformBuffer) == null ? void 0 : _this_uniformBuffer.destroy();
            				this.uniformBuffer = null;
            				(_this_bindGroup = this.bindGroup) == null ? void 0 : _this_bindGroup.destroy();
            				this.bindGroup = null;
            		}
            		render(viewport, scissor) {
            				var device = this.shader.device;
            				if (viewport) {
            						_tempViewport.set(device.vx, device.vy, device.vw, device.vh);
            						_tempScissor.set(device.sx, device.sy, device.sw, device.sh);
            						scissor = scissor != null ? scissor : viewport;
            						device.setViewport(viewport.x, viewport.y, viewport.z, viewport.w);
            						device.setScissor(scissor.x, scissor.y, scissor.z, scissor.w);
            				}
            				device.setVertexBuffer(device.quadVertexBuffer, 0);
            				var shader = this.shader;
            				device.setShader(shader);
            				if (device.supportsUniformBuffers) {
            						device.setBindGroup(BINDGROUP_VIEW, device.emptyBindGroup);
            						var bindGroup = this.bindGroup;
            						bindGroup.update();
            						device.setBindGroup(BINDGROUP_MESH, bindGroup);
            						var uniformBuffer = this.uniformBuffer;
            						if (uniformBuffer) {
            								uniformBuffer.update(_dynamicBindGroup$1);
            								device.setBindGroup(BINDGROUP_MESH_UB, _dynamicBindGroup$1.bindGroup, _dynamicBindGroup$1.offsets);
            						} else {
            								device.setBindGroup(BINDGROUP_MESH_UB, device.emptyBindGroup);
            						}
            				}
            				device.draw(_quadPrimitive);
            				if (viewport) {
            						device.setViewport(_tempViewport.x, _tempViewport.y, _tempViewport.z, _tempViewport.w);
            						device.setScissor(_tempScissor.x, _tempScissor.y, _tempScissor.z, _tempScissor.w);
            				}
            		}
            		constructor(shader){
            				var device = shader.device;
            				this.shader = shader;
            				if (device.supportsUniformBuffers) {
            						var processingOptions = new ShaderProcessorOptions();
            						this.shader = processShader(shader, processingOptions);
            						var ubFormat = this.shader.meshUniformBufferFormat;
            						if (ubFormat) {
            								this.uniformBuffer = new UniformBuffer(device, ubFormat, false);
            						}
            						var bindGroupFormat = this.shader.meshBindGroupFormat;
            						this.bindGroup = new BindGroup(device, bindGroupFormat);
            				}
            		}
            }
            
            class RenderPassQuad extends RenderPass {
            		execute() {
            				var { device } = this;
            				device.setCullMode(CULLFACE_NONE);
            				device.setDepthState(DepthState.NODEPTH);
            				device.setStencilState(null, null);
            				this.quad.render(this.rect, this.scissorRect);
            		}
            		constructor(device, quad, rect, scissorRect){
            				super(device);
            				this.quad = quad;
            				this.rect = rect;
            				this.scissorRect = scissorRect;
            		}
            }
            
            var _tempRect = new Vec4();
            function drawQuadWithShader(device, target, shader, rect, scissorRect) {
            		var quad = new QuadRender(shader);
            		if (!rect) {
            				rect = _tempRect;
            				rect.x = 0;
            				rect.y = 0;
            				rect.z = target ? target.width : device.width;
            				rect.w = target ? target.height : device.height;
            		}
            		var renderPass = new RenderPassQuad(device, quad, rect, scissorRect);
            		renderPass.init(target);
            		renderPass.colorOps.clear = false;
            		renderPass.depthStencilOps.clearDepth = false;
            		if (device.isWebGPU && target === null && device.samples > 1) {
            				renderPass.colorOps.store = true;
            		}
            		renderPass.render();
            		quad.destroy();
            }
            
            class Batch {
            		destroy(scene, layers) {
            				if (this.meshInstance) {
            						this.removeFromLayers(scene, layers);
            						this.meshInstance.destroy();
            						this.meshInstance = null;
            				}
            		}
            		addToLayers(scene, layers) {
            				for(var i = 0; i < layers.length; i++){
            						var layer = scene.layers.getLayerById(layers[i]);
            						if (layer) {
            								layer.addMeshInstances([
            										this.meshInstance
            								]);
            						}
            				}
            		}
            		removeFromLayers(scene, layers) {
            				for(var i = 0; i < layers.length; i++){
            						var layer = scene.layers.getLayerById(layers[i]);
            						if (layer) {
            								layer.removeMeshInstances([
            										this.meshInstance
            								]);
            						}
            				}
            		}
            		updateBoundingBox() {
            				this._aabb.copy(this.origMeshInstances[0].aabb);
            				for(var i = 1; i < this.origMeshInstances.length; i++){
            						this._aabb.add(this.origMeshInstances[i].aabb);
            				}
            				this.meshInstance.aabb = this._aabb;
            				this.meshInstance._aabbVer = 0;
            		}
            		get model() {
            				return undefined;
            		}
            		constructor(meshInstances, dynamic, batchGroupId){
            				this._aabb = new BoundingBox();
            				this.meshInstance = null;
            				this.origMeshInstances = meshInstances;
            				this.dynamic = dynamic;
            				this.batchGroupId = batchGroupId;
            		}
            }
            
            class BatchGroup {
            		constructor(id, name, dynamic, maxAabbSize, layers = [
            				LAYERID_WORLD
            		]){
            				this._ui = false;
            				this._sprite = false;
            				this._obj = {
            						model: [],
            						element: [],
            						sprite: [],
            						render: []
            				};
            				this.id = id;
            				this.name = name;
            				this.dynamic = dynamic;
            				this.maxAabbSize = maxAabbSize;
            				this.layers = layers;
            		}
            }
            BatchGroup.MODEL = 'model';
            BatchGroup.ELEMENT = 'element';
            BatchGroup.SPRITE = 'sprite';
            BatchGroup.RENDER = 'render';
            
            var _invMatrix = new Mat4();
            class SkinInstance {
            		set rootBone(rootBone) {
            				this._rootBone = rootBone;
            		}
            		get rootBone() {
            				return this._rootBone;
            		}
            		init(device, numBones) {
            				var numPixels = numBones * 3;
            				var width = Math.ceil(Math.sqrt(numPixels));
            				width = math.roundUp(width, 3);
            				var height = Math.ceil(numPixels / width);
            				this.boneTexture = new Texture(device, {
            						width: width,
            						height: height,
            						format: PIXELFORMAT_RGBA32F,
            						mipmaps: false,
            						minFilter: FILTER_NEAREST,
            						magFilter: FILTER_NEAREST,
            						name: 'skin'
            				});
            				this.matrixPalette = this.boneTexture.lock({
            						mode: TEXTURELOCK_READ
            				});
            				this.boneTexture.unlock();
            		}
            		destroy() {
            				if (this.boneTexture) {
            						this.boneTexture.destroy();
            						this.boneTexture = null;
            				}
            		}
            		resolve(rootBone, entity) {
            				this.rootBone = rootBone;
            				var skin = this.skin;
            				var bones = [];
            				for(var j = 0; j < skin.boneNames.length; j++){
            						var boneName = skin.boneNames[j];
            						var bone = rootBone.findByName(boneName);
            						if (!bone) {
            								bone = entity;
            						}
            						bones.push(bone);
            				}
            				this.bones = bones;
            		}
            		initSkin(skin) {
            				this.skin = skin;
            				this.bones = [];
            				var numBones = skin.inverseBindPose.length;
            				this.init(skin.device, numBones);
            				this.matrices = [];
            				for(var i = 0; i < numBones; i++){
            						this.matrices[i] = new Mat4();
            				}
            		}
            		uploadBones(device) {
            				this.boneTexture.upload();
            		}
            		_updateMatrices(rootNode, skinUpdateIndex) {
            				if (this._skinUpdateIndex !== skinUpdateIndex) {
            						this._skinUpdateIndex = skinUpdateIndex;
            						_invMatrix.copy(rootNode.getWorldTransform()).invert();
            						for(var i = this.bones.length - 1; i >= 0; i--){
            								this.matrices[i].mulAffine2(_invMatrix, this.bones[i].getWorldTransform());
            								this.matrices[i].mulAffine2(this.matrices[i], this.skin.inverseBindPose[i]);
            						}
            				}
            		}
            		updateMatrices(rootNode, skinUpdateIndex) {
            				if (this._updateBeforeCull) {
            						this._updateMatrices(rootNode, skinUpdateIndex);
            				}
            		}
            		updateMatrixPalette(rootNode, skinUpdateIndex) {
            				this._updateMatrices(rootNode, skinUpdateIndex);
            				var mp = this.matrixPalette;
            				var count = this.bones.length;
            				for(var i = 0; i < count; i++){
            						var pe = this.matrices[i].data;
            						var base = i * 12;
            						mp[base] = pe[0];
            						mp[base + 1] = pe[4];
            						mp[base + 2] = pe[8];
            						mp[base + 3] = pe[12];
            						mp[base + 4] = pe[1];
            						mp[base + 5] = pe[5];
            						mp[base + 6] = pe[9];
            						mp[base + 7] = pe[13];
            						mp[base + 8] = pe[2];
            						mp[base + 9] = pe[6];
            						mp[base + 10] = pe[10];
            						mp[base + 11] = pe[14];
            				}
            				this.uploadBones(this.skin.device);
            		}
            		constructor(skin){
            				this._dirty = true;
            				this._rootBone = null;
            				this._skinUpdateIndex = -1;
            				this._updateBeforeCull = true;
            				if (skin) {
            						this.initSkin(skin);
            				}
            		}
            }
            
            class SkinBatchInstance extends SkinInstance {
            		updateMatrices(rootNode, skinUpdateIndex) {}
            		updateMatrixPalette(rootNode, skinUpdateIndex) {
            				var mp = this.matrixPalette;
            				var count = this.bones.length;
            				for(var i = 0; i < count; i++){
            						var pe = this.bones[i].getWorldTransform().data;
            						var base = i * 12;
            						mp[base] = pe[0];
            						mp[base + 1] = pe[4];
            						mp[base + 2] = pe[8];
            						mp[base + 3] = pe[12];
            						mp[base + 4] = pe[1];
            						mp[base + 5] = pe[5];
            						mp[base + 6] = pe[9];
            						mp[base + 7] = pe[13];
            						mp[base + 8] = pe[2];
            						mp[base + 9] = pe[6];
            						mp[base + 10] = pe[10];
            						mp[base + 11] = pe[14];
            				}
            				this.uploadBones(this.device);
            		}
            		constructor(device, nodes, rootNode){
            				super();
            				var numBones = nodes.length;
            				this.init(device, numBones);
            				this.device = device;
            				this.rootNode = rootNode;
            				this.bones = nodes;
            		}
            }
            
            var id$3 = 0;
            class GeometryData {
            		initDefaults() {
            				this.recreate = false;
            				this.verticesUsage = BUFFER_STATIC;
            				this.indicesUsage = BUFFER_STATIC;
            				this.maxVertices = 0;
            				this.maxIndices = 0;
            				this.vertexCount = 0;
            				this.indexCount = 0;
            				this.vertexStreamsUpdated = false;
            				this.indexStreamUpdated = false;
            				this.vertexStreamDictionary = {};
            				this.indices = null;
            		}
            		_changeVertexCount(count, semantic) {
            				if (!this.vertexCount) {
            						this.vertexCount = count;
            				}
            		}
            		constructor(){
            				this.initDefaults();
            		}
            }
            GeometryData.DEFAULT_COMPONENTS_POSITION = 3;
            GeometryData.DEFAULT_COMPONENTS_NORMAL = 3;
            GeometryData.DEFAULT_COMPONENTS_UV = 2;
            GeometryData.DEFAULT_COMPONENTS_COLORS = 4;
            class GeometryVertexStream {
            		constructor(data, componentCount, dataType, dataTypeNormalize, asInt){
            				this.data = data;
            				this.componentCount = componentCount;
            				this.dataType = dataType;
            				this.dataTypeNormalize = dataTypeNormalize;
            				this.asInt = asInt;
            		}
            }
            class Mesh extends RefCountedObject {
            		static fromGeometry(graphicsDevice, geometry, options) {
            				if (options === void 0) options = {};
            				var mesh = new Mesh(graphicsDevice, options);
            				var { positions, normals, tangents, colors, uvs, uvs1, blendIndices, blendWeights, indices } = geometry;
            				if (positions) {
            						mesh.setPositions(positions);
            				}
            				if (normals) {
            						mesh.setNormals(normals);
            				}
            				if (tangents) {
            						mesh.setVertexStream(SEMANTIC_TANGENT, tangents, 4);
            				}
            				if (colors) {
            						mesh.setColors32(colors);
            				}
            				if (uvs) {
            						mesh.setUvs(0, uvs);
            				}
            				if (uvs1) {
            						mesh.setUvs(1, uvs1);
            				}
            				if (blendIndices) {
            						mesh.setVertexStream(SEMANTIC_BLENDINDICES, blendIndices, 4, blendIndices.length / 4, TYPE_UINT8);
            				}
            				if (blendWeights) {
            						mesh.setVertexStream(SEMANTIC_BLENDWEIGHT, blendWeights, 4);
            				}
            				if (indices) {
            						mesh.setIndices(indices);
            				}
            				mesh.update();
            				return mesh;
            		}
            		set morph(morph) {
            				if (morph !== this._morph) {
            						if (this._morph) {
            								this._morph.decRefCount();
            						}
            						this._morph = morph;
            						if (morph) {
            								morph.incRefCount();
            						}
            				}
            		}
            		get morph() {
            				return this._morph;
            		}
            		set aabb(aabb) {
            				this._aabb = aabb;
            				this._aabbVer++;
            		}
            		get aabb() {
            				return this._aabb;
            		}
            		destroy() {
            				var morph = this.morph;
            				if (morph) {
            						this.morph = null;
            						if (morph.refCount < 1) {
            								morph.destroy();
            						}
            				}
            				if (this.vertexBuffer) {
            						this.vertexBuffer.destroy();
            						this.vertexBuffer = null;
            				}
            				for(var j = 0; j < this.indexBuffer.length; j++){
            						this._destroyIndexBuffer(j);
            				}
            				this.indexBuffer.length = 0;
            				this._geometryData = null;
            		}
            		_destroyIndexBuffer(index) {
            				if (this.indexBuffer[index]) {
            						this.indexBuffer[index].destroy();
            						this.indexBuffer[index] = null;
            				}
            		}
            		_initBoneAabbs(morphTargets) {
            				this.boneAabb = [];
            				this.boneUsed = [];
            				var x, y, z;
            				var bMax, bMin;
            				var boneMin = [];
            				var boneMax = [];
            				var boneUsed = this.boneUsed;
            				var numBones = this.skin.boneNames.length;
            				var maxMorphX, maxMorphY, maxMorphZ;
            				for(var i = 0; i < numBones; i++){
            						boneMin[i] = new Vec3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
            						boneMax[i] = new Vec3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            				}
            				var iterator = new VertexIterator(this.vertexBuffer);
            				var posElement = iterator.element[SEMANTIC_POSITION];
            				var weightsElement = iterator.element[SEMANTIC_BLENDWEIGHT];
            				var indicesElement = iterator.element[SEMANTIC_BLENDINDICES];
            				var numVerts = this.vertexBuffer.numVertices;
            				for(var j = 0; j < numVerts; j++){
            						for(var k = 0; k < 4; k++){
            								var boneWeight = weightsElement.array[weightsElement.index + k];
            								if (boneWeight > 0) {
            										var boneIndex = indicesElement.array[indicesElement.index + k];
            										boneUsed[boneIndex] = true;
            										x = posElement.array[posElement.index];
            										y = posElement.array[posElement.index + 1];
            										z = posElement.array[posElement.index + 2];
            										bMax = boneMax[boneIndex];
            										bMin = boneMin[boneIndex];
            										if (bMin.x > x) bMin.x = x;
            										if (bMin.y > y) bMin.y = y;
            										if (bMin.z > z) bMin.z = z;
            										if (bMax.x < x) bMax.x = x;
            										if (bMax.y < y) bMax.y = y;
            										if (bMax.z < z) bMax.z = z;
            										if (morphTargets) {
            												var minMorphX = maxMorphX = x;
            												var minMorphY = maxMorphY = y;
            												var minMorphZ = maxMorphZ = z;
            												for(var l = 0; l < morphTargets.length; l++){
            														var target = morphTargets[l];
            														var dx = target.deltaPositions[j * 3];
            														var dy = target.deltaPositions[j * 3 + 1];
            														var dz = target.deltaPositions[j * 3 + 2];
            														if (dx < 0) {
            																minMorphX += dx;
            														} else {
            																maxMorphX += dx;
            														}
            														if (dy < 0) {
            																minMorphY += dy;
            														} else {
            																maxMorphY += dy;
            														}
            														if (dz < 0) {
            																minMorphZ += dz;
            														} else {
            																maxMorphZ += dz;
            														}
            												}
            												if (bMin.x > minMorphX) bMin.x = minMorphX;
            												if (bMin.y > minMorphY) bMin.y = minMorphY;
            												if (bMin.z > minMorphZ) bMin.z = minMorphZ;
            												if (bMax.x < maxMorphX) bMax.x = maxMorphX;
            												if (bMax.y < maxMorphY) bMax.y = maxMorphY;
            												if (bMax.z < maxMorphZ) bMax.z = maxMorphZ;
            										}
            								}
            						}
            						iterator.next();
            				}
            				var positionElement = this.vertexBuffer.getFormat().elements.find((e)=>e.name === SEMANTIC_POSITION);
            				if (positionElement && positionElement.normalize) {
            						var func = (()=>{
            								switch(positionElement.dataType){
            										case TYPE_INT8:
            												return (x)=>Math.max(x / 127.0, -1);
            										case TYPE_UINT8:
            												return (x)=>x / 255.0;
            										case TYPE_INT16:
            												return (x)=>Math.max(x / 32767.0, -1);
            										case TYPE_UINT16:
            												return (x)=>x / 65535.0;
            										default:
            												return (x)=>x;
            								}
            						})();
            						for(var i1 = 0; i1 < numBones; i1++){
            								if (boneUsed[i1]) {
            										var min = boneMin[i1];
            										var max = boneMax[i1];
            										min.set(func(min.x), func(min.y), func(min.z));
            										max.set(func(max.x), func(max.y), func(max.z));
            								}
            						}
            				}
            				for(var i2 = 0; i2 < numBones; i2++){
            						var aabb = new BoundingBox();
            						aabb.setMinMax(boneMin[i2], boneMax[i2]);
            						this.boneAabb.push(aabb);
            				}
            		}
            		_initGeometryData() {
            				if (!this._geometryData) {
            						this._geometryData = new GeometryData();
            						if (this.vertexBuffer) {
            								this._geometryData.vertexCount = this.vertexBuffer.numVertices;
            								this._geometryData.maxVertices = this.vertexBuffer.numVertices;
            						}
            						if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
            								this._geometryData.indexCount = this.indexBuffer[0].numIndices;
            								this._geometryData.maxIndices = this.indexBuffer[0].numIndices;
            						}
            				}
            		}
            		clear(verticesDynamic, indicesDynamic, maxVertices, maxIndices) {
            				if (maxVertices === void 0) maxVertices = 0;
            				if (maxIndices === void 0) maxIndices = 0;
            				this._initGeometryData();
            				this._geometryData.initDefaults();
            				this._geometryData.recreate = true;
            				this._geometryData.maxVertices = maxVertices;
            				this._geometryData.maxIndices = maxIndices;
            				this._geometryData.verticesUsage = verticesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;
            				this._geometryData.indicesUsage = indicesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;
            		}
            		setVertexStream(semantic, data, componentCount, numVertices, dataType, dataTypeNormalize, asInt) {
            				if (dataType === void 0) dataType = TYPE_FLOAT32;
            				if (dataTypeNormalize === void 0) dataTypeNormalize = false;
            				if (asInt === void 0) asInt = false;
            				this._initGeometryData();
            				var vertexCount = numVertices || data.length / componentCount;
            				this._geometryData._changeVertexCount(vertexCount, semantic);
            				this._geometryData.vertexStreamsUpdated = true;
            				this._geometryData.vertexStreamDictionary[semantic] = new GeometryVertexStream(data, componentCount, dataType, dataTypeNormalize, asInt);
            		}
            		getVertexStream(semantic, data) {
            				var count = 0;
            				var done = false;
            				if (this._geometryData) {
            						var stream = this._geometryData.vertexStreamDictionary[semantic];
            						if (stream) {
            								done = true;
            								count = this._geometryData.vertexCount;
            								if (ArrayBuffer.isView(data)) {
            										data.set(stream.data);
            								} else {
            										data.length = 0;
            										data.push(stream.data);
            								}
            						}
            				}
            				if (!done) {
            						if (this.vertexBuffer) {
            								var iterator = new VertexIterator(this.vertexBuffer);
            								count = iterator.readData(semantic, data);
            						}
            				}
            				return count;
            		}
            		setPositions(positions, componentCount, numVertices) {
            				if (componentCount === void 0) componentCount = GeometryData.DEFAULT_COMPONENTS_POSITION;
            				this.setVertexStream(SEMANTIC_POSITION, positions, componentCount, numVertices, TYPE_FLOAT32, false);
            		}
            		setNormals(normals, componentCount, numVertices) {
            				if (componentCount === void 0) componentCount = GeometryData.DEFAULT_COMPONENTS_NORMAL;
            				this.setVertexStream(SEMANTIC_NORMAL, normals, componentCount, numVertices, TYPE_FLOAT32, false);
            		}
            		setUvs(channel, uvs, componentCount, numVertices) {
            				if (componentCount === void 0) componentCount = GeometryData.DEFAULT_COMPONENTS_UV;
            				this.setVertexStream(SEMANTIC_TEXCOORD + channel, uvs, componentCount, numVertices, TYPE_FLOAT32, false);
            		}
            		setColors(colors, componentCount, numVertices) {
            				if (componentCount === void 0) componentCount = GeometryData.DEFAULT_COMPONENTS_COLORS;
            				this.setVertexStream(SEMANTIC_COLOR, colors, componentCount, numVertices, TYPE_FLOAT32, false);
            		}
            		setColors32(colors, numVertices) {
            				this.setVertexStream(SEMANTIC_COLOR, colors, GeometryData.DEFAULT_COMPONENTS_COLORS, numVertices, TYPE_UINT8, true);
            		}
            		setIndices(indices, numIndices) {
            				this._initGeometryData();
            				this._geometryData.indexStreamUpdated = true;
            				this._geometryData.indices = indices;
            				this._geometryData.indexCount = numIndices || indices.length;
            		}
            		getPositions(positions) {
            				return this.getVertexStream(SEMANTIC_POSITION, positions);
            		}
            		getNormals(normals) {
            				return this.getVertexStream(SEMANTIC_NORMAL, normals);
            		}
            		getUvs(channel, uvs) {
            				return this.getVertexStream(SEMANTIC_TEXCOORD + channel, uvs);
            		}
            		getColors(colors) {
            				return this.getVertexStream(SEMANTIC_COLOR, colors);
            		}
            		getIndices(indices) {
            				var count = 0;
            				if (this._geometryData && this._geometryData.indices) {
            						var streamIndices = this._geometryData.indices;
            						count = this._geometryData.indexCount;
            						if (ArrayBuffer.isView(indices)) {
            								indices.set(streamIndices);
            						} else {
            								indices.length = 0;
            								for(var i = 0, il = streamIndices.length; i < il; i++){
            										indices.push(streamIndices[i]);
            								}
            						}
            				} else {
            						if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
            								var indexBuffer = this.indexBuffer[0];
            								count = indexBuffer.readData(indices);
            						}
            				}
            				return count;
            		}
            		update(primitiveType, updateBoundingBox) {
            				if (primitiveType === void 0) primitiveType = PRIMITIVE_TRIANGLES;
            				if (updateBoundingBox === void 0) updateBoundingBox = true;
            				if (this._geometryData) {
            						if (updateBoundingBox) {
            								var stream = this._geometryData.vertexStreamDictionary[SEMANTIC_POSITION];
            								if (stream) {
            										if (stream.componentCount === 3) {
            												this._aabb.compute(stream.data, this._geometryData.vertexCount);
            												this._aabbVer++;
            										}
            								}
            						}
            						var destroyVB = this._geometryData.recreate;
            						if (this._geometryData.vertexCount > this._geometryData.maxVertices) {
            								destroyVB = true;
            								this._geometryData.maxVertices = this._geometryData.vertexCount;
            						}
            						if (destroyVB) {
            								if (this.vertexBuffer) {
            										this.vertexBuffer.destroy();
            										this.vertexBuffer = null;
            								}
            						}
            						var destroyIB = this._geometryData.recreate;
            						if (this._geometryData.indexCount > this._geometryData.maxIndices) {
            								destroyIB = true;
            								this._geometryData.maxIndices = this._geometryData.indexCount;
            						}
            						if (destroyIB) {
            								if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
            										this.indexBuffer[0].destroy();
            										this.indexBuffer[0] = null;
            								}
            						}
            						if (this._geometryData.vertexStreamsUpdated) {
            								this._updateVertexBuffer();
            						}
            						if (this._geometryData.indexStreamUpdated) {
            								this._updateIndexBuffer();
            						}
            						this.primitive[0].type = primitiveType;
            						if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
            								if (this._geometryData.indexStreamUpdated) {
            										this.primitive[0].count = this._geometryData.indexCount;
            										this.primitive[0].indexed = true;
            								}
            						} else {
            								if (this._geometryData.vertexStreamsUpdated) {
            										this.primitive[0].count = this._geometryData.vertexCount;
            										this.primitive[0].indexed = false;
            								}
            						}
            						this._geometryData.vertexCount = 0;
            						this._geometryData.indexCount = 0;
            						this._geometryData.vertexStreamsUpdated = false;
            						this._geometryData.indexStreamUpdated = false;
            						this._geometryData.recreate = false;
            						this.updateRenderStates();
            				}
            		}
            		_buildVertexFormat(vertexCount) {
            				var vertexDesc = [];
            				for(var semantic in this._geometryData.vertexStreamDictionary){
            						var stream = this._geometryData.vertexStreamDictionary[semantic];
            						vertexDesc.push({
            								semantic: semantic,
            								components: stream.componentCount,
            								type: stream.dataType,
            								normalize: stream.dataTypeNormalize,
            								asInt: stream.asInt
            						});
            				}
            				return new VertexFormat(this.device, vertexDesc, vertexCount);
            		}
            		_updateVertexBuffer() {
            				if (!this.vertexBuffer) {
            						var allocateVertexCount = this._geometryData.maxVertices;
            						var format = this._buildVertexFormat(allocateVertexCount);
            						this.vertexBuffer = new VertexBuffer(this.device, format, allocateVertexCount, {
            								usage: this._geometryData.verticesUsage,
            								storage: this._storageVertex
            						});
            				}
            				var iterator = new VertexIterator(this.vertexBuffer);
            				var numVertices = this._geometryData.vertexCount;
            				for(var semantic in this._geometryData.vertexStreamDictionary){
            						var stream = this._geometryData.vertexStreamDictionary[semantic];
            						iterator.writeData(semantic, stream.data, numVertices);
            						delete this._geometryData.vertexStreamDictionary[semantic];
            				}
            				iterator.end();
            		}
            		_updateIndexBuffer() {
            				if (this.indexBuffer.length <= 0 || !this.indexBuffer[0]) {
            						var maxVertices = this._geometryData.maxVertices;
            						var createFormat = maxVertices > 0xffff || maxVertices === 0 ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;
            						var options = this._storageIndex ? {
            								storage: true
            						} : undefined;
            						this.indexBuffer[0] = new IndexBuffer(this.device, createFormat, this._geometryData.maxIndices, this._geometryData.indicesUsage, undefined, options);
            				}
            				var srcIndices = this._geometryData.indices;
            				if (srcIndices) {
            						var indexBuffer = this.indexBuffer[0];
            						indexBuffer.writeData(srcIndices, this._geometryData.indexCount);
            						this._geometryData.indices = null;
            				}
            		}
            		prepareRenderState(renderStyle) {
            				if (renderStyle === RENDERSTYLE_WIREFRAME) {
            						this.generateWireframe();
            				} else if (renderStyle === RENDERSTYLE_POINTS) {
            						this.primitive[RENDERSTYLE_POINTS] = {
            								type: PRIMITIVE_POINTS,
            								base: 0,
            								count: this.vertexBuffer ? this.vertexBuffer.numVertices : 0,
            								indexed: false
            						};
            				}
            		}
            		updateRenderStates() {
            				if (this.primitive[RENDERSTYLE_POINTS]) {
            						this.prepareRenderState(RENDERSTYLE_POINTS);
            				}
            				if (this.primitive[RENDERSTYLE_WIREFRAME]) {
            						this.prepareRenderState(RENDERSTYLE_WIREFRAME);
            				}
            		}
            		generateWireframe() {
            				this._destroyIndexBuffer(RENDERSTYLE_WIREFRAME);
            				var numVertices = this.vertexBuffer.numVertices;
            				var lines = [];
            				var format;
            				if (this.indexBuffer.length > 0 && this.indexBuffer[0]) {
            						var offsets = [
            								[
            										0,
            										1
            								],
            								[
            										1,
            										2
            								],
            								[
            										2,
            										0
            								]
            						];
            						var base = this.primitive[RENDERSTYLE_SOLID].base;
            						var count = this.primitive[RENDERSTYLE_SOLID].count;
            						var indexBuffer = this.indexBuffer[RENDERSTYLE_SOLID];
            						var srcIndices = new typedArrayIndexFormats[indexBuffer.format](indexBuffer.storage);
            						var seen = new Set();
            						for(var j = base; j < base + count; j += 3){
            								for(var k = 0; k < 3; k++){
            										var i1 = srcIndices[j + offsets[k][0]];
            										var i2 = srcIndices[j + offsets[k][1]];
            										var hash = i1 > i2 ? i2 * numVertices + i1 : i1 * numVertices + i2;
            										if (!seen.has(hash)) {
            												seen.add(hash);
            												lines.push(i1, i2);
            										}
            								}
            						}
            						format = indexBuffer.format;
            				} else {
            						for(var i = 0; i < numVertices; i += 3){
            								lines.push(i, i + 1, i + 1, i + 2, i + 2, i);
            						}
            						format = lines.length > 65535 ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;
            				}
            				var wireBuffer = new IndexBuffer(this.vertexBuffer.device, format, lines.length);
            				var dstIndices = new typedArrayIndexFormats[wireBuffer.format](wireBuffer.storage);
            				dstIndices.set(lines);
            				wireBuffer.unlock();
            				this.primitive[RENDERSTYLE_WIREFRAME] = {
            						type: PRIMITIVE_LINES,
            						base: 0,
            						count: lines.length,
            						indexed: true
            				};
            				this.indexBuffer[RENDERSTYLE_WIREFRAME] = wireBuffer;
            		}
            		constructor(graphicsDevice, options){
            				super(), this.indexBuffer = [
            						null
            				], this.vertexBuffer = null, this.primitive = [
            						{
            								type: 0,
            								base: 0,
            								count: 0
            						}
            				], this.skin = null, this.boneAabb = null, this._aabbVer = 0, this._aabb = new BoundingBox(), this._geometryData = null, this._morph = null, this._storageIndex = false, this._storageVertex = false;
            				this.id = id$3++;
            				this.device = graphicsDevice;
            				this._storageIndex = (options == null ? void 0 : options.storageIndex) || false;
            				this._storageVertex = (options == null ? void 0 : options.storageVertex) || false;
            		}
            }
            
            var defaultMaterialDeviceCache = new DeviceCache();
            function getDefaultMaterial(device) {
            		var material = defaultMaterialDeviceCache.get(device);
            		return material;
            }
            function setDefaultMaterial(device, material) {
            		defaultMaterialDeviceCache.get(device, ()=>{
            				return material;
            		});
            }
            
            class RefCountedCache {
            		destroy() {
            				this.cache.forEach((refCount, object)=>{
            						object.destroy();
            				});
            				this.cache.clear();
            		}
            		incRef(object) {
            				var refCount = (this.cache.get(object) || 0) + 1;
            				this.cache.set(object, refCount);
            		}
            		decRef(object) {
            				if (object) {
            						var refCount = this.cache.get(object);
            						if (refCount) {
            								refCount--;
            								if (refCount === 0) {
            										this.cache.delete(object);
            										object.destroy();
            								} else {
            										this.cache.set(object, refCount);
            								}
            						}
            				}
            		}
            		constructor(){
            				this.cache = new Map();
            		}
            }
            
            class LightmapCache {
            		static incRef(texture) {
            				this.cache.incRef(texture);
            		}
            		static decRef(texture) {
            				this.cache.decRef(texture);
            		}
            		static destroy() {
            				this.cache.destroy();
            		}
            }
            LightmapCache.cache = new RefCountedCache();
            
            var id$2 = 0;
            var _tmpAabb = new BoundingBox();
            var _tempBoneAabb = new BoundingBox();
            var _tempSphere = new BoundingSphere();
            var _meshSet = new Set();
            var lookupHashes = new Uint32Array(4);
            class InstancingData {
            		destroy() {
            				if (this._destroyVertexBuffer) {
            						var _this_vertexBuffer;
            						(_this_vertexBuffer = this.vertexBuffer) == null ? void 0 : _this_vertexBuffer.destroy();
            				}
            				this.vertexBuffer = null;
            		}
            		constructor(numObjects){
            				this.vertexBuffer = null;
            				this._destroyVertexBuffer = false;
            				this.count = numObjects;
            		}
            }
            class ShaderInstance {
            		getBindGroup(device) {
            				if (!this.bindGroup) {
            						var shader = this.shader;
            						var bindGroupFormat = shader.meshBindGroupFormat;
            						this.bindGroup = new BindGroup(device, bindGroupFormat);
            				}
            				return this.bindGroup;
            		}
            		getUniformBuffer(device) {
            				if (!this.uniformBuffer) {
            						var shader = this.shader;
            						var ubFormat = shader.meshUniformBufferFormat;
            						this.uniformBuffer = new UniformBuffer(device, ubFormat, false);
            				}
            				return this.uniformBuffer;
            		}
            		destroy() {
            				var _this_bindGroup, _this_uniformBuffer;
            				(_this_bindGroup = this.bindGroup) == null ? void 0 : _this_bindGroup.destroy();
            				this.bindGroup = null;
            				(_this_uniformBuffer = this.uniformBuffer) == null ? void 0 : _this_uniformBuffer.destroy();
            				this.uniformBuffer = null;
            		}
            		constructor(){
            				this.bindGroup = null;
            				this.uniformBuffer = null;
            		}
            }
            class MeshInstance {
            		set drawBucket(bucket) {
            				this._drawBucket = Math.floor(bucket) & 0xff;
            				this.updateKey();
            		}
            		get drawBucket() {
            				return this._drawBucket;
            		}
            		set renderStyle(renderStyle) {
            				this._renderStyle = renderStyle;
            				this.mesh.prepareRenderState(renderStyle);
            		}
            		get renderStyle() {
            				return this._renderStyle;
            		}
            		set mesh(mesh) {
            				if (mesh === this._mesh) {
            						return;
            				}
            				if (this._mesh) {
            						this._mesh.decRefCount();
            				}
            				this._mesh = mesh;
            				if (mesh) {
            						mesh.incRefCount();
            				}
            		}
            		get mesh() {
            				return this._mesh;
            		}
            		set aabb(aabb) {
            				this._aabb = aabb;
            		}
            		get aabb() {
            				if (!this._updateAabb) {
            						return this._aabb;
            				}
            				if (this._updateAabbFunc) {
            						return this._updateAabbFunc(this._aabb);
            				}
            				var localAabb = this._customAabb;
            				var toWorldSpace = !!localAabb;
            				if (!localAabb) {
            						localAabb = _tmpAabb;
            						if (this.skinInstance) {
            								if (!this.mesh.boneAabb) {
            										var morphTargets = this._morphInstance ? this._morphInstance.morph._targets : null;
            										this.mesh._initBoneAabbs(morphTargets);
            								}
            								var boneUsed = this.mesh.boneUsed;
            								var first = true;
            								for(var i = 0; i < this.mesh.boneAabb.length; i++){
            										if (boneUsed[i]) {
            												_tempBoneAabb.setFromTransformedAabb(this.mesh.boneAabb[i], this.skinInstance.matrices[i]);
            												if (first) {
            														first = false;
            														localAabb.center.copy(_tempBoneAabb.center);
            														localAabb.halfExtents.copy(_tempBoneAabb.halfExtents);
            												} else {
            														localAabb.add(_tempBoneAabb);
            												}
            										}
            								}
            								toWorldSpace = true;
            						} else if (this.node._aabbVer !== this._aabbVer || this.mesh._aabbVer !== this._aabbMeshVer) {
            								if (this.mesh) {
            										localAabb.center.copy(this.mesh.aabb.center);
            										localAabb.halfExtents.copy(this.mesh.aabb.halfExtents);
            								} else {
            										localAabb.center.set(0, 0, 0);
            										localAabb.halfExtents.set(0, 0, 0);
            								}
            								if (this.mesh && this.mesh.morph) {
            										var morphAabb = this.mesh.morph.aabb;
            										localAabb._expand(morphAabb.getMin(), morphAabb.getMax());
            								}
            								toWorldSpace = true;
            								this._aabbVer = this.node._aabbVer;
            								this._aabbMeshVer = this.mesh._aabbVer;
            						}
            				}
            				if (toWorldSpace) {
            						this._aabb.setFromTransformedAabb(localAabb, this.node.getWorldTransform());
            				}
            				return this._aabb;
            		}
            		clearShaders() {
            				this._shaderCache.forEach((shaderInstance)=>{
            						shaderInstance.destroy();
            				});
            				this._shaderCache.clear();
            		}
            		getShaderInstance(shaderPass, lightHash, scene, cameraShaderParams, viewUniformFormat, viewBindGroupFormat, sortedLights) {
            				var shaderDefs = this._shaderDefs;
            				lookupHashes[0] = shaderPass;
            				lookupHashes[1] = lightHash;
            				lookupHashes[2] = shaderDefs;
            				lookupHashes[3] = cameraShaderParams.hash;
            				var hash = hash32Fnv1a(lookupHashes);
            				var shaderInstance = this._shaderCache.get(hash);
            				if (!shaderInstance) {
            						var mat = this._material;
            						shaderInstance = new ShaderInstance();
            						shaderInstance.shader = mat.variants.get(hash);
            						shaderInstance.hashes = new Uint32Array(lookupHashes);
            						if (!shaderInstance.shader) {
            								var _this_mesh_vertexBuffer;
            								var shader = mat.getShaderVariant({
            										device: this.mesh.device,
            										scene: scene,
            										objDefs: shaderDefs,
            										cameraShaderParams: cameraShaderParams,
            										pass: shaderPass,
            										sortedLights: sortedLights,
            										viewUniformFormat: viewUniformFormat,
            										viewBindGroupFormat: viewBindGroupFormat,
            										vertexFormat: (_this_mesh_vertexBuffer = this.mesh.vertexBuffer) == null ? void 0 : _this_mesh_vertexBuffer.format
            								});
            								mat.variants.set(hash, shader);
            								shaderInstance.shader = shader;
            						}
            						this._shaderCache.set(hash, shaderInstance);
            				}
            				return shaderInstance;
            		}
            		set material(material) {
            				this.clearShaders();
            				var prevMat = this._material;
            				if (prevMat) {
            						prevMat.removeMeshInstanceRef(this);
            				}
            				this._material = material;
            				if (material) {
            						material.addMeshInstanceRef(this);
            						this.transparent = material.transparent;
            						this.updateKey();
            				}
            		}
            		get material() {
            				return this._material;
            		}
            		_updateShaderDefs(shaderDefs) {
            				if (shaderDefs !== this._shaderDefs) {
            						this._shaderDefs = shaderDefs;
            						this.clearShaders();
            				}
            		}
            		set calculateSortDistance(calculateSortDistance) {
            				this._calculateSortDistance = calculateSortDistance;
            		}
            		get calculateSortDistance() {
            				return this._calculateSortDistance;
            		}
            		set receiveShadow(val) {
            				if (this._receiveShadow !== val) {
            						this._receiveShadow = val;
            						this._updateShaderDefs(val ? this._shaderDefs & -2 : this._shaderDefs | SHADERDEF_NOSHADOW);
            				}
            		}
            		get receiveShadow() {
            				return this._receiveShadow;
            		}
            		set batching(val) {
            				this._updateShaderDefs(val ? this._shaderDefs | SHADERDEF_BATCH : this._shaderDefs & -16385);
            		}
            		get batching() {
            				return (this._shaderDefs & SHADERDEF_BATCH) !== 0;
            		}
            		set skinInstance(val) {
            				this._skinInstance = val;
            				this._updateShaderDefs(val ? this._shaderDefs | SHADERDEF_SKIN : this._shaderDefs & -3);
            				this._setupSkinUpdate();
            		}
            		get skinInstance() {
            				return this._skinInstance;
            		}
            		set morphInstance(val) {
            				var _this__morphInstance;
            				(_this__morphInstance = this._morphInstance) == null ? void 0 : _this__morphInstance.destroy();
            				this._morphInstance = val;
            				var shaderDefs = this._shaderDefs;
            				shaderDefs = val && val.morph.morphPositions ? shaderDefs | SHADERDEF_MORPH_POSITION : shaderDefs & -1025;
            				shaderDefs = val && val.morph.morphNormals ? shaderDefs | SHADERDEF_MORPH_NORMAL : shaderDefs & -2049;
            				shaderDefs = val && val.morph.intRenderFormat ? shaderDefs | SHADERDEF_MORPH_TEXTURE_BASED_INT : shaderDefs & -8193;
            				this._updateShaderDefs(shaderDefs);
            		}
            		get morphInstance() {
            				return this._morphInstance;
            		}
            		set screenSpace(val) {
            				if (this._screenSpace !== val) {
            						this._screenSpace = val;
            						this._updateShaderDefs(val ? this._shaderDefs | SHADERDEF_SCREENSPACE : this._shaderDefs & -257);
            				}
            		}
            		get screenSpace() {
            				return this._screenSpace;
            		}
            		set key(val) {
            				this._sortKeyForward = val;
            		}
            		get key() {
            				return this._sortKeyForward;
            		}
            		set mask(val) {
            				var toggles = this._shaderDefs & 0x0000FFFF;
            				this._updateShaderDefs(toggles | val << 16);
            		}
            		get mask() {
            				return this._shaderDefs >> 16;
            		}
            		set instancingCount(value) {
            				if (this.instancingData) {
            						this.instancingData.count = value;
            				}
            		}
            		get instancingCount() {
            				return this.instancingData ? this.instancingData.count : 0;
            		}
            		destroy() {
            				var _this__skinInstance, _this_morphInstance, _this_instancingData;
            				var mesh = this.mesh;
            				if (mesh) {
            						this.mesh = null;
            						if (mesh.refCount < 1) {
            								mesh.destroy();
            						}
            				}
            				this.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], null);
            				this.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], null);
            				(_this__skinInstance = this._skinInstance) == null ? void 0 : _this__skinInstance.destroy();
            				this._skinInstance = null;
            				(_this_morphInstance = this.morphInstance) == null ? void 0 : _this_morphInstance.destroy();
            				this.morphInstance = null;
            				this.clearShaders();
            				this.material = null;
            				(_this_instancingData = this.instancingData) == null ? void 0 : _this_instancingData.destroy();
            		}
            		static _prepareRenderStyleForArray(meshInstances, renderStyle) {
            				if (meshInstances) {
            						for(var i = 0; i < meshInstances.length; i++){
            								meshInstances[i]._renderStyle = renderStyle;
            								var mesh = meshInstances[i].mesh;
            								if (!_meshSet.has(mesh)) {
            										_meshSet.add(mesh);
            										mesh.prepareRenderState(renderStyle);
            								}
            						}
            						_meshSet.clear();
            				}
            		}
            		_isVisible(camera) {
            				if (this.visible) {
            						if (this.isVisibleFunc) {
            								return this.isVisibleFunc(camera);
            						}
            						_tempSphere.center = this.aabb.center;
            						_tempSphere.radius = this._aabb.halfExtents.length();
            						return camera.frustum.containsSphere(_tempSphere) > 0;
            				}
            				return false;
            		}
            		updateKey() {
            				var { material } = this;
            				this._sortKeyForward = this._drawBucket << 25 | (material.alphaToCoverage || material.alphaTest ? 0x1000000 : 0) | material.id & 0xffffff;
            		}
            		setInstancing(vertexBuffer, cull) {
            				if (cull === void 0) cull = false;
            				if (vertexBuffer) {
            						this.instancingData = new InstancingData(vertexBuffer.numVertices);
            						this.instancingData.vertexBuffer = vertexBuffer;
            						vertexBuffer.format.instancing = true;
            						this.cull = cull;
            				} else {
            						this.instancingData = null;
            						this.cull = true;
            				}
            				this._updateShaderDefs(vertexBuffer ? this._shaderDefs | SHADERDEF_INSTANCING : this._shaderDefs & -33);
            		}
            		ensureMaterial(device) {
            				if (!this.material) {
            						this.material = getDefaultMaterial(device);
            				}
            		}
            		clearParameters() {
            				this.parameters = {};
            		}
            		getParameters() {
            				return this.parameters;
            		}
            		getParameter(name) {
            				return this.parameters[name];
            		}
            		setParameter(name, data, passFlags) {
            				if (passFlags === void 0) passFlags = 0xFFFFFFFF;
            				var param = this.parameters[name];
            				if (param) {
            						param.data = data;
            						param.passFlags = passFlags;
            				} else {
            						this.parameters[name] = {
            								scopeId: null,
            								data: data,
            								passFlags: passFlags
            						};
            				}
            		}
            		setRealtimeLightmap(name, texture) {
            				var old = this.getParameter(name);
            				if (old === texture) {
            						return;
            				}
            				if (old) {
            						LightmapCache.decRef(old.data);
            				}
            				if (texture) {
            						LightmapCache.incRef(texture);
            						this.setParameter(name, texture);
            				} else {
            						this.deleteParameter(name);
            				}
            		}
            		deleteParameter(name) {
            				if (this.parameters[name]) {
            						delete this.parameters[name];
            				}
            		}
            		setParameters(device, passFlag) {
            				var parameters = this.parameters;
            				for(var paramName in parameters){
            						var parameter = parameters[paramName];
            						if (parameter.passFlags & passFlag) {
            								if (!parameter.scopeId) {
            										parameter.scopeId = device.scope.resolve(paramName);
            								}
            								parameter.scopeId.setValue(parameter.data);
            						}
            				}
            		}
            		setLightmapped(value) {
            				if (value) {
            						this.mask = (this.mask | MASK_AFFECT_LIGHTMAPPED) & -6;
            				} else {
            						this.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], null);
            						this.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], null);
            						this._shaderDefs &= -4289;
            						this.mask = (this.mask | MASK_AFFECT_DYNAMIC) & -7;
            				}
            		}
            		setCustomAabb(aabb) {
            				if (aabb) {
            						if (this._customAabb) {
            								this._customAabb.copy(aabb);
            						} else {
            								this._customAabb = aabb.clone();
            						}
            				} else {
            						this._customAabb = null;
            						this._aabbVer = -1;
            				}
            				this._setupSkinUpdate();
            		}
            		_setupSkinUpdate() {
            				if (this._skinInstance) {
            						this._skinInstance._updateBeforeCull = !this._customAabb;
            				}
            		}
            		constructor(mesh, material, node = null){
            				this.castShadow = false;
            				this.cull = true;
            				this.drawOrder = 0;
            				this._drawBucket = 127;
            				this.visible = true;
            				this.visibleThisFrame = false;
            				this.flipFacesFactor = 1;
            				this.gsplatInstance = null;
            				this.id = id$2++;
            				this.isVisibleFunc = null;
            				this.instancingData = null;
            				this.parameters = {};
            				this.pick = true;
            				this.stencilFront = null;
            				this.stencilBack = null;
            				this.transparent = false;
            				this._aabb = new BoundingBox();
            				this._aabbVer = -1;
            				this._aabbMeshVer = -1;
            				this._customAabb = null;
            				this._updateAabb = true;
            				this._updateAabbFunc = null;
            				this._sortKeyShadow = 0;
            				this._sortKeyForward = 0;
            				this._sortKeyDynamic = 0;
            				this._layer = LAYER_WORLD;
            				this._material = null;
            				this._skinInstance = null;
            				this._morphInstance = null;
            				this._receiveShadow = true;
            				this._renderStyle = RENDERSTYLE_SOLID;
            				this._screenSpace = false;
            				this._shaderCache = new Map();
            				this._shaderDefs = MASK_AFFECT_DYNAMIC << 16;
            				this._calculateSortDistance = null;
            				this.node = node;
            				this._mesh = mesh;
            				mesh.incRefCount();
            				this.material = material;
            				if (mesh.vertexBuffer) {
            						var format = mesh.vertexBuffer.format;
            						this._shaderDefs |= format.hasUv0 ? SHADERDEF_UV0 : 0;
            						this._shaderDefs |= format.hasUv1 ? SHADERDEF_UV1 : 0;
            						this._shaderDefs |= format.hasColor ? SHADERDEF_VCOLOR : 0;
            						this._shaderDefs |= format.hasTangents ? SHADERDEF_TANGENTS : 0;
            				}
            				this.updateKey();
            		}
            }
            MeshInstance.lightmapParamNames = [
            		'texture_lightMap',
            		'texture_dirLightMap'
            ];
            
            var _triFanIndices = [
            		0,
            		1,
            		3,
            		2,
            		3,
            		1
            ];
            var _triStripIndices = [
            		0,
            		1,
            		3,
            		0,
            		3,
            		2
            ];
            var mat3 = new Mat3();
            function paramsIdentical(a, b) {
            		if (a && !b) return false;
            		if (!a && b) return false;
            		a = a.data;
            		b = b.data;
            		if (a === b) return true;
            		if (a instanceof Float32Array && b instanceof Float32Array) {
            				if (a.length !== b.length) return false;
            				for(var i = 0; i < a.length; i++){
            						if (a[i] !== b[i]) return false;
            				}
            				return true;
            		}
            		return false;
            }
            function equalParamSets(params1, params2) {
            		for(var param in params1){
            				if (params1.hasOwnProperty(param) && !paramsIdentical(params1[param], params2[param])) {
            						return false;
            				}
            		}
            		for(var param1 in params2){
            				if (params2.hasOwnProperty(param1) && !paramsIdentical(params2[param1], params1[param1])) {
            						return false;
            				}
            		}
            		return true;
            }
            function getScaleSign(mi) {
            		return mi.node.worldTransform.scaleSign;
            }
            class BatchManager {
            		destroy() {
            				this.device = null;
            				this.rootNode = null;
            				this.scene = null;
            				this._batchGroups = {};
            				this._batchList = [];
            				this._dirtyGroups = [];
            		}
            		addGroup(name, dynamic, maxAabbSize, id, layers) {
            				if (id === undefined) {
            						id = this._batchGroupCounter;
            						this._batchGroupCounter++;
            				}
            				if (this._batchGroups[id]) {
            						return undefined;
            				}
            				var group = new BatchGroup(id, name, dynamic, maxAabbSize, layers);
            				this._batchGroups[id] = group;
            				return group;
            		}
            		removeGroup(id) {
            				if (!this._batchGroups[id]) {
            						return;
            				}
            				var newBatchList = [];
            				for(var i = 0; i < this._batchList.length; i++){
            						if (this._batchList[i].batchGroupId === id) {
            								this.destroyBatch(this._batchList[i]);
            						} else {
            								newBatchList.push(this._batchList[i]);
            						}
            				}
            				this._batchList = newBatchList;
            				this._removeModelsFromBatchGroup(this.rootNode, id);
            				delete this._batchGroups[id];
            		}
            		markGroupDirty(id) {
            				if (this._dirtyGroups.indexOf(id) < 0) {
            						this._dirtyGroups.push(id);
            				}
            		}
            		getGroupByName(name) {
            				var groups = this._batchGroups;
            				for(var group in groups){
            						if (!groups.hasOwnProperty(group)) continue;
            						if (groups[group].name === name) {
            								return groups[group];
            						}
            				}
            				return null;
            		}
            		getBatches(batchGroupId) {
            				var results = [];
            				var len = this._batchList.length;
            				for(var i = 0; i < len; i++){
            						var batch = this._batchList[i];
            						if (batch.batchGroupId === batchGroupId) {
            								results.push(batch);
            						}
            				}
            				return results;
            		}
            		_removeModelsFromBatchGroup(node, id) {
            				if (!node.enabled) return;
            				if (node.model && node.model.batchGroupId === id) {
            						node.model.batchGroupId = -1;
            				}
            				if (node.render && node.render.batchGroupId === id) {
            						node.render.batchGroupId = -1;
            				}
            				if (node.element && node.element.batchGroupId === id) {
            						node.element.batchGroupId = -1;
            				}
            				if (node.sprite && node.sprite.batchGroupId === id) {
            						node.sprite.batchGroupId = -1;
            				}
            				for(var i = 0; i < node._children.length; i++){
            						this._removeModelsFromBatchGroup(node._children[i], id);
            				}
            		}
            		insert(type, groupId, node) {
            				var group = this._batchGroups[groupId];
            				if (group) {
            						if (group._obj[type].indexOf(node) < 0) {
            								group._obj[type].push(node);
            								this.markGroupDirty(groupId);
            						}
            				}
            		}
            		remove(type, groupId, node) {
            				var group = this._batchGroups[groupId];
            				if (group) {
            						var idx = group._obj[type].indexOf(node);
            						if (idx >= 0) {
            								group._obj[type].splice(idx, 1);
            								this.markGroupDirty(groupId);
            						}
            				}
            		}
            		_extractRender(node, arr, group, groupMeshInstances) {
            				if (node.render) {
            						arr = groupMeshInstances[node.render.batchGroupId] = arr.concat(node.render.meshInstances);
            						node.render.removeFromLayers();
            				}
            				return arr;
            		}
            		_extractModel(node, arr, group, groupMeshInstances) {
            				if (node.model && node.model.model) {
            						arr = groupMeshInstances[node.model.batchGroupId] = arr.concat(node.model.meshInstances);
            						node.model.removeModelFromLayers();
            				}
            				return arr;
            		}
            		_extractElement(node, arr, group) {
            				if (!node.element) return;
            				var valid = false;
            				if (node.element._text && node.element._text._model.meshInstances.length > 0) {
            						arr.push(node.element._text._model.meshInstances[0]);
            						node.element.removeModelFromLayers(node.element._text._model);
            						valid = true;
            				} else if (node.element._image) {
            						arr.push(node.element._image._renderable.meshInstance);
            						node.element.removeModelFromLayers(node.element._image._renderable.model);
            						if (node.element._image._renderable.unmaskMeshInstance) {
            								arr.push(node.element._image._renderable.unmaskMeshInstance);
            								if (!node.element._image._renderable.unmaskMeshInstance.stencilFront || !node.element._image._renderable.unmaskMeshInstance.stencilBack) {
            										node.element._dirtifyMask();
            										node.element._onPrerender();
            								}
            						}
            						valid = true;
            				}
            				if (valid) {
            						group._ui = true;
            				}
            		}
            		_collectAndRemoveMeshInstances(groupMeshInstances, groupIds) {
            				for(var g = 0; g < groupIds.length; g++){
            						var id = groupIds[g];
            						var group = this._batchGroups[id];
            						if (!group) continue;
            						var arr = groupMeshInstances[id];
            						if (!arr) arr = groupMeshInstances[id] = [];
            						for(var m = 0; m < group._obj.model.length; m++){
            								arr = this._extractModel(group._obj.model[m], arr, group, groupMeshInstances);
            						}
            						for(var r = 0; r < group._obj.render.length; r++){
            								arr = this._extractRender(group._obj.render[r], arr, group, groupMeshInstances);
            						}
            						for(var e = 0; e < group._obj.element.length; e++){
            								this._extractElement(group._obj.element[e], arr, group);
            						}
            						for(var s = 0; s < group._obj.sprite.length; s++){
            								var node = group._obj.sprite[s];
            								if (node.sprite && node.sprite._meshInstance && (group.dynamic || node.sprite.sprite._renderMode === SPRITE_RENDERMODE_SIMPLE)) {
            										arr.push(node.sprite._meshInstance);
            										node.sprite.removeModelFromLayers();
            										group._sprite = true;
            										node.sprite._batchGroup = group;
            								}
            						}
            				}
            		}
            		generate(groupIds) {
            				var groupMeshInstances = {};
            				if (!groupIds) {
            						groupIds = Object.keys(this._batchGroups);
            				}
            				var newBatchList = [];
            				for(var i = 0; i < this._batchList.length; i++){
            						if (groupIds.indexOf(this._batchList[i].batchGroupId) < 0) {
            								newBatchList.push(this._batchList[i]);
            								continue;
            						}
            						this.destroyBatch(this._batchList[i]);
            				}
            				this._batchList = newBatchList;
            				this._collectAndRemoveMeshInstances(groupMeshInstances, groupIds);
            				if (groupIds === this._dirtyGroups) {
            						this._dirtyGroups.length = 0;
            				} else {
            						var newDirtyGroups = [];
            						for(var i1 = 0; i1 < this._dirtyGroups.length; i1++){
            								if (groupIds.indexOf(this._dirtyGroups[i1]) < 0) newDirtyGroups.push(this._dirtyGroups[i1]);
            						}
            						this._dirtyGroups = newDirtyGroups;
            				}
            				var group, lists, groupData, batch;
            				for(var groupId in groupMeshInstances){
            						if (!groupMeshInstances.hasOwnProperty(groupId)) continue;
            						group = groupMeshInstances[groupId];
            						groupData = this._batchGroups[groupId];
            						if (!groupData) {
            								continue;
            						}
            						lists = this.prepare(group, groupData.dynamic, groupData.maxAabbSize, groupData._ui || groupData._sprite);
            						for(var i2 = 0; i2 < lists.length; i2++){
            								batch = this.create(lists[i2], groupData.dynamic, parseInt(groupId, 10));
            								if (batch) {
            										batch.addToLayers(this.scene, groupData.layers);
            								}
            						}
            				}
            		}
            		prepare(meshInstances, dynamic, maxAabbSize, translucent) {
            				if (maxAabbSize === void 0) maxAabbSize = Number.POSITIVE_INFINITY;
            				if (meshInstances.length === 0) return [];
            				var halfMaxAabbSize = maxAabbSize * 0.5;
            				var maxInstanceCount = 1024;
            				var maxNumVertices = 0xffffffff;
            				var aabb = new BoundingBox();
            				var testAabb = new BoundingBox();
            				var skipTranslucentAabb = null;
            				var sf;
            				var lists = [];
            				var j = 0;
            				if (translucent) {
            						meshInstances.sort((a, b)=>{
            								return a.drawOrder - b.drawOrder;
            						});
            				}
            				var meshInstancesLeftA = meshInstances;
            				var meshInstancesLeftB;
            				var skipMesh = translucent ? function skipMesh(mi) {
            						if (skipTranslucentAabb) {
            								skipTranslucentAabb.add(mi.aabb);
            						} else {
            								skipTranslucentAabb = mi.aabb.clone();
            						}
            						meshInstancesLeftB.push(mi);
            				} : function(mi) {
            						meshInstancesLeftB.push(mi);
            				};
            				while(meshInstancesLeftA.length > 0){
            						lists[j] = [
            								meshInstancesLeftA[0]
            						];
            						meshInstancesLeftB = [];
            						var material = meshInstancesLeftA[0].material;
            						var layer = meshInstancesLeftA[0].layer;
            						var defs = meshInstancesLeftA[0]._shaderDefs;
            						var params = meshInstancesLeftA[0].parameters;
            						var stencil = meshInstancesLeftA[0].stencilFront;
            						var vertCount = meshInstancesLeftA[0].mesh.vertexBuffer.getNumVertices();
            						var drawOrder = meshInstancesLeftA[0].drawOrder;
            						aabb.copy(meshInstancesLeftA[0].aabb);
            						var scaleSign = getScaleSign(meshInstancesLeftA[0]);
            						var vertexFormatBatchingHash = meshInstancesLeftA[0].mesh.vertexBuffer.format.batchingHash;
            						var indexed = meshInstancesLeftA[0].mesh.primitive[0].indexed;
            						skipTranslucentAabb = null;
            						for(var i = 1; i < meshInstancesLeftA.length; i++){
            								var mi = meshInstancesLeftA[i];
            								if (dynamic && lists[j].length >= maxInstanceCount) {
            										meshInstancesLeftB = meshInstancesLeftB.concat(meshInstancesLeftA.slice(i));
            										break;
            								}
            								if (material !== mi.material || layer !== mi.layer || vertexFormatBatchingHash !== mi.mesh.vertexBuffer.format.batchingHash || indexed !== mi.mesh.primitive[0].indexed || defs !== mi._shaderDefs || vertCount + mi.mesh.vertexBuffer.getNumVertices() > maxNumVertices) {
            										skipMesh(mi);
            										continue;
            								}
            								testAabb.copy(aabb);
            								testAabb.add(mi.aabb);
            								if (testAabb.halfExtents.x > halfMaxAabbSize || testAabb.halfExtents.y > halfMaxAabbSize || testAabb.halfExtents.z > halfMaxAabbSize) {
            										skipMesh(mi);
            										continue;
            								}
            								if (stencil) {
            										if (!(sf = mi.stencilFront) || stencil.func !== sf.func || stencil.zpass !== sf.zpass) {
            												skipMesh(mi);
            												continue;
            										}
            								}
            								if (scaleSign !== getScaleSign(mi)) {
            										skipMesh(mi);
            										continue;
            								}
            								if (!equalParamSets(params, mi.parameters)) {
            										skipMesh(mi);
            										continue;
            								}
            								if (translucent && skipTranslucentAabb && skipTranslucentAabb.intersects(mi.aabb) && mi.drawOrder !== drawOrder) {
            										skipMesh(mi);
            										continue;
            								}
            								aabb.add(mi.aabb);
            								vertCount += mi.mesh.vertexBuffer.getNumVertices();
            								lists[j].push(mi);
            						}
            						j++;
            						meshInstancesLeftA = meshInstancesLeftB;
            				}
            				return lists;
            		}
            		collectBatchedMeshData(meshInstances, dynamic) {
            				var streams = null;
            				var batchNumVerts = 0;
            				var batchNumIndices = 0;
            				var material = null;
            				for(var i = 0; i < meshInstances.length; i++){
            						if (meshInstances[i].visible) {
            								var mesh = meshInstances[i].mesh;
            								var numVerts = mesh.vertexBuffer.numVertices;
            								batchNumVerts += numVerts;
            								if (mesh.primitive[0].indexed) {
            										batchNumIndices += mesh.primitive[0].count;
            								} else {
            										var primitiveType = mesh.primitive[0].type;
            										if (primitiveType === PRIMITIVE_TRIFAN || primitiveType === PRIMITIVE_TRISTRIP) {
            												if (mesh.primitive[0].count === 4) {
            														batchNumIndices += 6;
            												}
            										}
            								}
            								if (!streams) {
            										material = meshInstances[i].material;
            										streams = {};
            										var elems = mesh.vertexBuffer.format.elements;
            										for(var j = 0; j < elems.length; j++){
            												var semantic = elems[j].name;
            												streams[semantic] = {
            														numComponents: elems[j].numComponents,
            														dataType: elems[j].dataType,
            														normalize: elems[j].normalize,
            														count: 0
            												};
            										}
            										if (dynamic) {
            												streams[SEMANTIC_BLENDINDICES] = {
            														numComponents: 1,
            														dataType: TYPE_FLOAT32,
            														normalize: false,
            														count: 0
            												};
            										}
            								}
            						}
            				}
            				return {
            						streams: streams,
            						batchNumVerts: batchNumVerts,
            						batchNumIndices: batchNumIndices,
            						material: material
            				};
            		}
            		create(meshInstances, dynamic, batchGroupId) {
            				if (!this._init) {
            						this.vertexFormats = {};
            						this._init = true;
            				}
            				var stream = null;
            				var semantic;
            				var mesh, numVerts;
            				var batch = null;
            				var batchData = this.collectBatchedMeshData(meshInstances, dynamic);
            				if (batchData.streams) {
            						var streams = batchData.streams;
            						var material = batchData.material;
            						var batchNumVerts = batchData.batchNumVerts;
            						var batchNumIndices = batchData.batchNumIndices;
            						batch = new Batch(meshInstances, dynamic, batchGroupId);
            						this._batchList.push(batch);
            						var indexBase, numIndices, indexData;
            						var verticesOffset = 0;
            						var indexOffset = 0;
            						var transform;
            						var indexArrayType = batchNumVerts <= 0xffff ? Uint16Array : Uint32Array;
            						var indices = new indexArrayType(batchNumIndices);
            						for(semantic in streams){
            								stream = streams[semantic];
            								stream.typeArrayType = typedArrayTypes[stream.dataType];
            								stream.elementByteSize = typedArrayTypesByteSize[stream.dataType];
            								stream.buffer = new stream.typeArrayType(batchNumVerts * stream.numComponents);
            						}
            						for(var i = 0; i < meshInstances.length; i++){
            								if (!meshInstances[i].visible) {
            										continue;
            								}
            								mesh = meshInstances[i].mesh;
            								numVerts = mesh.vertexBuffer.numVertices;
            								if (!dynamic) {
            										transform = meshInstances[i].node.getWorldTransform();
            								}
            								for(semantic in streams){
            										if (semantic !== SEMANTIC_BLENDINDICES) {
            												stream = streams[semantic];
            												var subarray = new stream.typeArrayType(stream.buffer.buffer, stream.elementByteSize * stream.count);
            												var totalComponents = mesh.getVertexStream(semantic, subarray) * stream.numComponents;
            												stream.count += totalComponents;
            												if (!dynamic && stream.numComponents >= 3) {
            														if (semantic === SEMANTIC_POSITION) {
            																var m = transform.data;
            																var m0 = m[0];
            																var m1 = m[1];
            																var m2 = m[2];
            																var m4 = m[4];
            																var m5 = m[5];
            																var m6 = m[6];
            																var m8 = m[8];
            																var m9 = m[9];
            																var m10 = m[10];
            																var m12 = m[12];
            																var m13 = m[13];
            																var m14 = m[14];
            																var x = void 0, y = void 0, z = void 0;
            																for(var j = 0; j < totalComponents; j += stream.numComponents){
            																		x = subarray[j];
            																		y = subarray[j + 1];
            																		z = subarray[j + 2];
            																		subarray[j] = x * m0 + y * m4 + z * m8 + m12;
            																		subarray[j + 1] = x * m1 + y * m5 + z * m9 + m13;
            																		subarray[j + 2] = x * m2 + y * m6 + z * m10 + m14;
            																}
            														} else if (semantic === SEMANTIC_NORMAL || semantic === SEMANTIC_TANGENT) {
            																mat3.invertMat4(transform).transpose();
            																var [m01, m11, m21, m3, m41, m51, m61, m7, m81] = mat3.data;
            																var x1 = void 0, y1 = void 0, z1 = void 0;
            																for(var j1 = 0; j1 < totalComponents; j1 += stream.numComponents){
            																		x1 = subarray[j1];
            																		y1 = subarray[j1 + 1];
            																		z1 = subarray[j1 + 2];
            																		subarray[j1] = x1 * m01 + y1 * m3 + z1 * m61;
            																		subarray[j1 + 1] = x1 * m11 + y1 * m41 + z1 * m7;
            																		subarray[j1 + 2] = x1 * m21 + y1 * m51 + z1 * m81;
            																}
            														}
            												}
            										}
            								}
            								if (dynamic) {
            										stream = streams[SEMANTIC_BLENDINDICES];
            										for(var j2 = 0; j2 < numVerts; j2++){
            												stream.buffer[stream.count++] = i;
            										}
            								}
            								if (mesh.primitive[0].indexed) {
            										indexBase = mesh.primitive[0].base;
            										numIndices = mesh.primitive[0].count;
            										var srcFormat = mesh.indexBuffer[0].getFormat();
            										indexData = new typedArrayIndexFormats[srcFormat](mesh.indexBuffer[0].storage);
            								} else {
            										var primitiveType = mesh.primitive[0].type;
            										if (primitiveType === PRIMITIVE_TRIFAN || primitiveType === PRIMITIVE_TRISTRIP) {
            												if (mesh.primitive[0].count === 4) {
            														indexBase = 0;
            														numIndices = 6;
            														indexData = primitiveType === PRIMITIVE_TRIFAN ? _triFanIndices : _triStripIndices;
            												} else {
            														numIndices = 0;
            														continue;
            												}
            										}
            								}
            								for(var j3 = 0; j3 < numIndices; j3++){
            										indices[j3 + indexOffset] = indexData[indexBase + j3] + verticesOffset;
            								}
            								indexOffset += numIndices;
            								verticesOffset += numVerts;
            						}
            						mesh = new Mesh(this.device);
            						for(semantic in streams){
            								stream = streams[semantic];
            								mesh.setVertexStream(semantic, stream.buffer, stream.numComponents, undefined, stream.dataType, stream.normalize);
            						}
            						if (indices.length > 0) {
            								mesh.setIndices(indices);
            						}
            						mesh.update(PRIMITIVE_TRIANGLES, false);
            						if (dynamic) {
            								material = material.clone();
            								material.update();
            						}
            						var meshInstance = new MeshInstance(mesh, material, this.rootNode);
            						meshInstance.castShadow = batch.origMeshInstances[0].castShadow;
            						meshInstance.parameters = batch.origMeshInstances[0].parameters;
            						meshInstance.layer = batch.origMeshInstances[0].layer;
            						meshInstance._shaderDefs = batch.origMeshInstances[0]._shaderDefs;
            						meshInstance.batching = true;
            						meshInstance.cull = batch.origMeshInstances[0].cull;
            						var batchGroup = this._batchGroups[batchGroupId];
            						if (batchGroup && batchGroup._ui) {
            								meshInstance.cull = false;
            						}
            						if (dynamic) {
            								var nodes = [];
            								for(var i1 = 0; i1 < batch.origMeshInstances.length; i1++){
            										nodes.push(batch.origMeshInstances[i1].node);
            								}
            								meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);
            						}
            						meshInstance._updateAabb = false;
            						meshInstance.drawOrder = batch.origMeshInstances[0].drawOrder;
            						meshInstance.stencilFront = batch.origMeshInstances[0].stencilFront;
            						meshInstance.stencilBack = batch.origMeshInstances[0].stencilBack;
            						meshInstance.flipFacesFactor = getScaleSign(batch.origMeshInstances[0]);
            						meshInstance.castShadow = batch.origMeshInstances[0].castShadow;
            						batch.meshInstance = meshInstance;
            						batch.updateBoundingBox();
            				}
            				return batch;
            		}
            		updateAll() {
            				if (this._dirtyGroups.length > 0) {
            						this.generate(this._dirtyGroups);
            				}
            				for(var i = 0; i < this._batchList.length; i++){
            						if (!this._batchList[i].dynamic) continue;
            						this._batchList[i].updateBoundingBox();
            				}
            		}
            		clone(batch, clonedMeshInstances) {
            				var batch2 = new Batch(clonedMeshInstances, batch.dynamic, batch.batchGroupId);
            				this._batchList.push(batch2);
            				var nodes = [];
            				for(var i = 0; i < clonedMeshInstances.length; i++){
            						nodes.push(clonedMeshInstances[i].node);
            				}
            				batch2.meshInstance = new MeshInstance(batch.meshInstance.mesh, batch.meshInstance.material, batch.meshInstance.node);
            				batch2.meshInstance._updateAabb = false;
            				batch2.meshInstance.parameters = clonedMeshInstances[0].parameters;
            				batch2.meshInstance.cull = clonedMeshInstances[0].cull;
            				batch2.meshInstance.layer = clonedMeshInstances[0].layer;
            				if (batch.dynamic) {
            						batch2.meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);
            				}
            				batch2.meshInstance.castShadow = batch.meshInstance.castShadow;
            				return batch2;
            		}
            		destroyBatch(batch) {
            				batch.destroy(this.scene, this._batchGroups[batch.batchGroupId].layers);
            		}
            		constructor(device, root, scene){
            				this.device = device;
            				this.rootNode = root;
            				this.scene = scene;
            				this._init = false;
            				this._batchGroups = {};
            				this._batchGroupCounter = 0;
            				this._batchList = [];
            				this._dirtyGroups = [];
            		}
            }
            
            var _colorUniformName = 'uSceneColorMap';
            class RenderPassColorGrab extends RenderPass {
            		destroy() {
            				super.destroy();
            				this.releaseRenderTarget(this.colorRenderTarget);
            		}
            		shouldReallocate(targetRT, sourceTexture, sourceFormat) {
            				var targetFormat = targetRT == null ? void 0 : targetRT.colorBuffer.format;
            				if (targetFormat !== sourceFormat) {
            						return true;
            				}
            				var width = (sourceTexture == null ? void 0 : sourceTexture.width) || this.device.width;
            				var height = (sourceTexture == null ? void 0 : sourceTexture.height) || this.device.height;
            				return !targetRT || width !== targetRT.width || height !== targetRT.height;
            		}
            		allocateRenderTarget(renderTarget, sourceRenderTarget, device, format) {
            				var texture = new Texture(device, {
            						name: _colorUniformName,
            						format,
            						width: sourceRenderTarget ? sourceRenderTarget.colorBuffer.width : device.width,
            						height: sourceRenderTarget ? sourceRenderTarget.colorBuffer.height : device.height,
            						mipmaps: true,
            						minFilter: FILTER_LINEAR_MIPMAP_LINEAR,
            						magFilter: FILTER_LINEAR,
            						addressU: ADDRESS_CLAMP_TO_EDGE,
            						addressV: ADDRESS_CLAMP_TO_EDGE
            				});
            				if (renderTarget) {
            						renderTarget.destroyFrameBuffers();
            						renderTarget._colorBuffer = texture;
            						renderTarget._colorBuffers = [
            								texture
            						];
            				} else {
            						renderTarget = new RenderTarget({
            								name: 'ColorGrabRT',
            								colorBuffer: texture,
            								depth: false,
            								stencil: false,
            								autoResolve: false
            						});
            				}
            				return renderTarget;
            		}
            		releaseRenderTarget(rt) {
            				if (rt) {
            						rt.destroyTextureBuffers();
            						rt.destroy();
            				}
            		}
            		frameUpdate() {
            				var device = this.device;
            				var sourceRt = this.source;
            				var _sourceRt_colorBuffer_format;
            				var sourceFormat = (_sourceRt_colorBuffer_format = sourceRt == null ? void 0 : sourceRt.colorBuffer.format) != null ? _sourceRt_colorBuffer_format : this.device.backBufferFormat;
            				if (this.shouldReallocate(this.colorRenderTarget, sourceRt == null ? void 0 : sourceRt.colorBuffer, sourceFormat)) {
            						this.releaseRenderTarget(this.colorRenderTarget);
            						this.colorRenderTarget = this.allocateRenderTarget(this.colorRenderTarget, sourceRt, device, sourceFormat);
            				}
            				var colorBuffer = this.colorRenderTarget.colorBuffer;
            				device.scope.resolve(_colorUniformName).setValue(colorBuffer);
            		}
            		execute() {
            				var device = this.device;
            				var sourceRt = this.source;
            				var colorBuffer = this.colorRenderTarget.colorBuffer;
            				if (device.isWebGPU) {
            						device.copyRenderTarget(sourceRt, this.colorRenderTarget, true, false);
            						device.mipmapRenderer.generate(this.colorRenderTarget.colorBuffer.impl);
            				} else {
            						device.copyRenderTarget(sourceRt, this.colorRenderTarget, true, false);
            						device.activeTexture(device.maxCombinedTextures - 1);
            						device.bindTexture(colorBuffer);
            						device.gl.generateMipmap(colorBuffer.impl._glTarget);
            				}
            		}
            		constructor(...args){
            				super(...args), this.colorRenderTarget = null, this.source = null;
            		}
            }
            
            var _depthUniformName = 'uSceneDepthMap';
            class RenderPassDepthGrab extends RenderPass {
            		destroy() {
            				super.destroy();
            				this.releaseRenderTarget(this.depthRenderTarget);
            		}
            		shouldReallocate(targetRT, sourceTexture) {
            				var width = (sourceTexture == null ? void 0 : sourceTexture.width) || this.device.width;
            				var height = (sourceTexture == null ? void 0 : sourceTexture.height) || this.device.height;
            				return !targetRT || width !== targetRT.width || height !== targetRT.height;
            		}
            		allocateRenderTarget(renderTarget, sourceRenderTarget, device, format, isDepth) {
            				var texture = new Texture(device, {
            						name: _depthUniformName,
            						format,
            						width: sourceRenderTarget ? sourceRenderTarget.colorBuffer.width : device.width,
            						height: sourceRenderTarget ? sourceRenderTarget.colorBuffer.height : device.height,
            						mipmaps: false,
            						minFilter: FILTER_NEAREST,
            						magFilter: FILTER_NEAREST,
            						addressU: ADDRESS_CLAMP_TO_EDGE,
            						addressV: ADDRESS_CLAMP_TO_EDGE
            				});
            				if (renderTarget) {
            						renderTarget.destroyFrameBuffers();
            						if (isDepth) {
            								renderTarget._depthBuffer = texture;
            						} else {
            								renderTarget._colorBuffer = texture;
            								renderTarget._colorBuffers = [
            										texture
            								];
            						}
            				} else {
            						renderTarget = new RenderTarget({
            								name: 'DepthGrabRT',
            								colorBuffer: isDepth ? null : texture,
            								depthBuffer: isDepth ? texture : null,
            								depth: !isDepth,
            								stencil: device.supportsStencil,
            								autoResolve: false
            						});
            				}
            				return renderTarget;
            		}
            		releaseRenderTarget(rt) {
            				if (rt) {
            						rt.destroyTextureBuffers();
            						rt.destroy();
            				}
            		}
            		before() {
            				var _camera_renderTarget, _camera_renderTarget1;
            				var camera = this.camera;
            				var device = this.device;
            				var _camera_renderTarget2;
            				var destinationRt = (_camera_renderTarget2 = camera == null ? void 0 : camera.renderTarget) != null ? _camera_renderTarget2 : device.backBuffer;
            				var useDepthBuffer = true;
            				var format = destinationRt.stencil ? PIXELFORMAT_DEPTHSTENCIL : PIXELFORMAT_DEPTH;
            				if (device.isWebGPU) {
            						var numSamples = destinationRt.samples;
            						if (numSamples > 1) {
            								format = PIXELFORMAT_R32F;
            								useDepthBuffer = false;
            						}
            				}
            				var _camera_renderTarget_depthBuffer;
            				var sourceTexture = (_camera_renderTarget_depthBuffer = (_camera_renderTarget = camera.renderTarget) == null ? void 0 : _camera_renderTarget.depthBuffer) != null ? _camera_renderTarget_depthBuffer : (_camera_renderTarget1 = camera.renderTarget) == null ? void 0 : _camera_renderTarget1.colorBuffer;
            				if (this.shouldReallocate(this.depthRenderTarget, sourceTexture)) {
            						this.releaseRenderTarget(this.depthRenderTarget);
            						this.depthRenderTarget = this.allocateRenderTarget(this.depthRenderTarget, camera.renderTarget, device, format, useDepthBuffer);
            				}
            				var colorBuffer = useDepthBuffer ? this.depthRenderTarget.depthBuffer : this.depthRenderTarget.colorBuffer;
            				device.scope.resolve(_depthUniformName).setValue(colorBuffer);
            		}
            		execute() {
            				var device = this.device;
            				if (device.isWebGL2 && device.renderTarget.samples > 1) {
            						var src = device.renderTarget.impl._glFrameBuffer;
            						var dest = this.depthRenderTarget;
            						device.renderTarget = dest;
            						device.updateBegin();
            						this.depthRenderTarget.impl.internalResolve(device, src, dest.impl._glFrameBuffer, this.depthRenderTarget, device.gl.DEPTH_BUFFER_BIT);
            				} else {
            						device.copyRenderTarget(device.renderTarget, this.depthRenderTarget, false, true);
            				}
            		}
            		constructor(device, camera){
            				super(device), this.depthRenderTarget = null, this.camera = null;
            				this.camera = camera;
            		}
            }
            
            class CameraShaderParams {
            		get hash() {
            				if (this._hash === undefined) {
            						var key = this.gammaCorrection + "_" + this.toneMapping + "_" + this.srgbRenderTarget + "_" + this.fog + "_" + this.ssaoEnabled + "_" + this.sceneDepthMapLinear;
            						this._hash = hashCode(key);
            				}
            				return this._hash;
            		}
            		get defines() {
            				var defines = this._defines;
            				if (this._definesDirty) {
            						this._definesDirty = false;
            						defines.clear();
            						if (this._sceneDepthMapLinear) defines.set('SCENE_DEPTHMAP_LINEAR', true);
            						defines.set('FOG', this._fog.toUpperCase());
            						defines.set('TONEMAP', tonemapNames[this._toneMapping]);
            						defines.set('GAMMA', gammaNames[this.shaderOutputGamma]);
            				}
            				return defines;
            		}
            		markDirty() {
            				this._hash = undefined;
            				this._definesDirty = true;
            		}
            		set fog(type) {
            				if (this._fog !== type) {
            						this._fog = type;
            						this.markDirty();
            				}
            		}
            		get fog() {
            				return this._fog;
            		}
            		set ssaoEnabled(value) {
            				if (this._ssaoEnabled !== value) {
            						this._ssaoEnabled = value;
            						this.markDirty();
            				}
            		}
            		get ssaoEnabled() {
            				return this._ssaoEnabled;
            		}
            		set gammaCorrection(value) {
            				this._gammaCorrectionAssigned = true;
            				if (this._gammaCorrection !== value) {
            						this._gammaCorrection = value;
            						this.markDirty();
            				}
            		}
            		get gammaCorrection() {
            				return this._gammaCorrection;
            		}
            		set toneMapping(value) {
            				if (this._toneMapping !== value) {
            						this._toneMapping = value;
            						this.markDirty();
            				}
            		}
            		get toneMapping() {
            				return this._toneMapping;
            		}
            		set srgbRenderTarget(value) {
            				if (this._srgbRenderTarget !== value) {
            						this._srgbRenderTarget = value;
            						this.markDirty();
            				}
            		}
            		get srgbRenderTarget() {
            				return this._srgbRenderTarget;
            		}
            		set sceneDepthMapLinear(value) {
            				if (this._sceneDepthMapLinear !== value) {
            						this._sceneDepthMapLinear = value;
            						this.markDirty();
            				}
            		}
            		get sceneDepthMapLinear() {
            				return this._sceneDepthMapLinear;
            		}
            		get shaderOutputGamma() {
            				var gammaOutput = this._gammaCorrection === GAMMA_SRGB && !this._srgbRenderTarget;
            				return gammaOutput ? GAMMA_SRGB : GAMMA_NONE;
            		}
            		constructor(){
            				this._gammaCorrection = GAMMA_SRGB;
            				this._toneMapping = TONEMAP_LINEAR;
            				this._srgbRenderTarget = false;
            				this._ssaoEnabled = false;
            				this._fog = FOG_NONE;
            				this._sceneDepthMapLinear = false;
            				this._defines = new Map();
            				this._definesDirty = true;
            		}
            }
            
            var _deviceCoord = new Vec3();
            var _halfSize = new Vec3();
            var _point$1 = new Vec3();
            var _invViewProjMat = new Mat4();
            var _frustumPoints = [
            		new Vec3(),
            		new Vec3(),
            		new Vec3(),
            		new Vec3(),
            		new Vec3(),
            		new Vec3(),
            		new Vec3(),
            		new Vec3()
            ];
            class Camera {
            		destroy() {
            				var _this_renderPassColorGrab, _this_renderPassDepthGrab;
            				(_this_renderPassColorGrab = this.renderPassColorGrab) == null ? void 0 : _this_renderPassColorGrab.destroy();
            				this.renderPassColorGrab = null;
            				(_this_renderPassDepthGrab = this.renderPassDepthGrab) == null ? void 0 : _this_renderPassDepthGrab.destroy();
            				this.renderPassDepthGrab = null;
            				this.renderPasses.length = 0;
            		}
            		_storeShaderMatrices(viewProjMat, jitterX, jitterY, renderVersion) {
            				if (this._shaderMatricesVersion !== renderVersion) {
            						this._shaderMatricesVersion = renderVersion;
            						var _this__viewProjCurrent;
            						this._viewProjPrevious.copy((_this__viewProjCurrent = this._viewProjCurrent) != null ? _this__viewProjCurrent : viewProjMat);
            						var _this__viewProjCurrent1;
            						(_this__viewProjCurrent1 = this._viewProjCurrent) != null ? _this__viewProjCurrent1 : this._viewProjCurrent = new Mat4();
            						this._viewProjCurrent.copy(viewProjMat);
            						this._viewProjInverse.invert(viewProjMat);
            						this._jitters[2] = this._jitters[0];
            						this._jitters[3] = this._jitters[1];
            						this._jitters[0] = jitterX;
            						this._jitters[1] = jitterY;
            				}
            		}
            		get fullSizeClearRect() {
            				var rect = this._scissorRectClear ? this.scissorRect : this._rect;
            				return rect.x === 0 && rect.y === 0 && rect.z === 1 && rect.w === 1;
            		}
            		set aspectRatio(newValue) {
            				if (this._aspectRatio !== newValue) {
            						this._aspectRatio = newValue;
            						this._projMatDirty = true;
            				}
            		}
            		get aspectRatio() {
            				var _this_xr;
            				return ((_this_xr = this.xr) == null ? void 0 : _this_xr.active) ? this._xrProperties.aspectRatio : this._aspectRatio;
            		}
            		set aspectRatioMode(newValue) {
            				if (this._aspectRatioMode !== newValue) {
            						this._aspectRatioMode = newValue;
            						this._projMatDirty = true;
            				}
            		}
            		get aspectRatioMode() {
            				return this._aspectRatioMode;
            		}
            		set calculateProjection(newValue) {
            				this._calculateProjection = newValue;
            				this._projMatDirty = true;
            		}
            		get calculateProjection() {
            				return this._calculateProjection;
            		}
            		set calculateTransform(newValue) {
            				this._calculateTransform = newValue;
            		}
            		get calculateTransform() {
            				return this._calculateTransform;
            		}
            		set clearColor(newValue) {
            				this._clearColor.copy(newValue);
            		}
            		get clearColor() {
            				return this._clearColor;
            		}
            		set clearColorBuffer(newValue) {
            				this._clearColorBuffer = newValue;
            		}
            		get clearColorBuffer() {
            				return this._clearColorBuffer;
            		}
            		set clearDepth(newValue) {
            				this._clearDepth = newValue;
            		}
            		get clearDepth() {
            				return this._clearDepth;
            		}
            		set clearDepthBuffer(newValue) {
            				this._clearDepthBuffer = newValue;
            		}
            		get clearDepthBuffer() {
            				return this._clearDepthBuffer;
            		}
            		set clearStencil(newValue) {
            				this._clearStencil = newValue;
            		}
            		get clearStencil() {
            				return this._clearStencil;
            		}
            		set clearStencilBuffer(newValue) {
            				this._clearStencilBuffer = newValue;
            		}
            		get clearStencilBuffer() {
            				return this._clearStencilBuffer;
            		}
            		set cullFaces(newValue) {
            				this._cullFaces = newValue;
            		}
            		get cullFaces() {
            				return this._cullFaces;
            		}
            		set farClip(newValue) {
            				if (this._farClip !== newValue) {
            						this._farClip = newValue;
            						this._projMatDirty = true;
            				}
            		}
            		get farClip() {
            				var _this_xr;
            				return ((_this_xr = this.xr) == null ? void 0 : _this_xr.active) ? this._xrProperties.farClip : this._farClip;
            		}
            		set flipFaces(newValue) {
            				this._flipFaces = newValue;
            		}
            		get flipFaces() {
            				return this._flipFaces;
            		}
            		set fov(newValue) {
            				if (this._fov !== newValue) {
            						this._fov = newValue;
            						this._projMatDirty = true;
            				}
            		}
            		get fov() {
            				var _this_xr;
            				return ((_this_xr = this.xr) == null ? void 0 : _this_xr.active) ? this._xrProperties.fov : this._fov;
            		}
            		set frustumCulling(newValue) {
            				this._frustumCulling = newValue;
            		}
            		get frustumCulling() {
            				return this._frustumCulling;
            		}
            		set horizontalFov(newValue) {
            				if (this._horizontalFov !== newValue) {
            						this._horizontalFov = newValue;
            						this._projMatDirty = true;
            				}
            		}
            		get horizontalFov() {
            				var _this_xr;
            				return ((_this_xr = this.xr) == null ? void 0 : _this_xr.active) ? this._xrProperties.horizontalFov : this._horizontalFov;
            		}
            		set layers(newValue) {
            				this._layers = newValue.slice(0);
            				this._layersSet = new Set(this._layers);
            		}
            		get layers() {
            				return this._layers;
            		}
            		get layersSet() {
            				return this._layersSet;
            		}
            		set nearClip(newValue) {
            				if (this._nearClip !== newValue) {
            						this._nearClip = newValue;
            						this._projMatDirty = true;
            				}
            		}
            		get nearClip() {
            				var _this_xr;
            				return ((_this_xr = this.xr) == null ? void 0 : _this_xr.active) ? this._xrProperties.nearClip : this._nearClip;
            		}
            		set node(newValue) {
            				this._node = newValue;
            		}
            		get node() {
            				return this._node;
            		}
            		set orthoHeight(newValue) {
            				if (this._orthoHeight !== newValue) {
            						this._orthoHeight = newValue;
            						this._projMatDirty = true;
            				}
            		}
            		get orthoHeight() {
            				return this._orthoHeight;
            		}
            		set projection(newValue) {
            				if (this._projection !== newValue) {
            						this._projection = newValue;
            						this._projMatDirty = true;
            				}
            		}
            		get projection() {
            				return this._projection;
            		}
            		get projectionMatrix() {
            				this._evaluateProjectionMatrix();
            				return this._projMat;
            		}
            		set rect(newValue) {
            				this._rect.copy(newValue);
            		}
            		get rect() {
            				return this._rect;
            		}
            		set renderTarget(newValue) {
            				this._renderTarget = newValue;
            		}
            		get renderTarget() {
            				return this._renderTarget;
            		}
            		set scissorRect(newValue) {
            				this._scissorRect.copy(newValue);
            		}
            		get scissorRect() {
            				return this._scissorRect;
            		}
            		get viewMatrix() {
            				if (this._viewMatDirty) {
            						var wtm = this._node.getWorldTransform();
            						this._viewMat.copy(wtm).invert();
            						this._viewMatDirty = false;
            				}
            				return this._viewMat;
            		}
            		set aperture(newValue) {
            				this._aperture = newValue;
            		}
            		get aperture() {
            				return this._aperture;
            		}
            		set sensitivity(newValue) {
            				this._sensitivity = newValue;
            		}
            		get sensitivity() {
            				return this._sensitivity;
            		}
            		set shutter(newValue) {
            				this._shutter = newValue;
            		}
            		get shutter() {
            				return this._shutter;
            		}
            		set xr(newValue) {
            				if (this._xr !== newValue) {
            						this._xr = newValue;
            						this._projMatDirty = true;
            				}
            		}
            		get xr() {
            				return this._xr;
            		}
            		clone() {
            				return new Camera().copy(this);
            		}
            		copy(other) {
            				this._aspectRatio = other._aspectRatio;
            				this._farClip = other._farClip;
            				this._fov = other._fov;
            				this._horizontalFov = other._horizontalFov;
            				this._nearClip = other._nearClip;
            				this._xrProperties.aspectRatio = other._xrProperties.aspectRatio;
            				this._xrProperties.farClip = other._xrProperties.farClip;
            				this._xrProperties.fov = other._xrProperties.fov;
            				this._xrProperties.horizontalFov = other._xrProperties.horizontalFov;
            				this._xrProperties.nearClip = other._xrProperties.nearClip;
            				this.aspectRatioMode = other.aspectRatioMode;
            				this.calculateProjection = other.calculateProjection;
            				this.calculateTransform = other.calculateTransform;
            				this.clearColor = other.clearColor;
            				this.clearColorBuffer = other.clearColorBuffer;
            				this.clearDepth = other.clearDepth;
            				this.clearDepthBuffer = other.clearDepthBuffer;
            				this.clearStencil = other.clearStencil;
            				this.clearStencilBuffer = other.clearStencilBuffer;
            				this.cullFaces = other.cullFaces;
            				this.flipFaces = other.flipFaces;
            				this.frustumCulling = other.frustumCulling;
            				this.layers = other.layers;
            				this.orthoHeight = other.orthoHeight;
            				this.projection = other.projection;
            				this.rect = other.rect;
            				this.renderTarget = other.renderTarget;
            				this.scissorRect = other.scissorRect;
            				this.aperture = other.aperture;
            				this.shutter = other.shutter;
            				this.sensitivity = other.sensitivity;
            				this.shaderPassInfo = other.shaderPassInfo;
            				this.jitter = other.jitter;
            				this._projMatDirty = true;
            				return this;
            		}
            		_enableRenderPassColorGrab(device, enable) {
            				if (enable) {
            						if (!this.renderPassColorGrab) {
            								this.renderPassColorGrab = new RenderPassColorGrab(device);
            						}
            				} else {
            						var _this_renderPassColorGrab;
            						(_this_renderPassColorGrab = this.renderPassColorGrab) == null ? void 0 : _this_renderPassColorGrab.destroy();
            						this.renderPassColorGrab = null;
            				}
            		}
            		_enableRenderPassDepthGrab(device, renderer, enable) {
            				if (enable) {
            						if (!this.renderPassDepthGrab) {
            								this.renderPassDepthGrab = new RenderPassDepthGrab(device, this);
            						}
            				} else {
            						var _this_renderPassDepthGrab;
            						(_this_renderPassDepthGrab = this.renderPassDepthGrab) == null ? void 0 : _this_renderPassDepthGrab.destroy();
            						this.renderPassDepthGrab = null;
            				}
            		}
            		_updateViewProjMat() {
            				if (this._projMatDirty || this._viewMatDirty || this._viewProjMatDirty) {
            						this._viewProjMat.mul2(this.projectionMatrix, this.viewMatrix);
            						this._viewProjMatDirty = false;
            				}
            		}
            		worldToScreen(worldCoord, cw, ch, screenCoord) {
            				if (screenCoord === void 0) screenCoord = new Vec3();
            				this._updateViewProjMat();
            				this._viewProjMat.transformPoint(worldCoord, screenCoord);
            				var vpm = this._viewProjMat.data;
            				var w = worldCoord.x * vpm[3] + worldCoord.y * vpm[7] + worldCoord.z * vpm[11] + 1 * vpm[15];
            				screenCoord.x = (screenCoord.x / w + 1) * 0.5 * cw;
            				screenCoord.y = (1 - screenCoord.y / w) * 0.5 * ch;
            				return screenCoord;
            		}
            		screenToWorld(x, y, z, cw, ch, worldCoord) {
            				if (worldCoord === void 0) worldCoord = new Vec3();
            				var range = this.farClip - this.nearClip;
            				_deviceCoord.set(x / cw, (ch - y) / ch, z / range);
            				_deviceCoord.mulScalar(2);
            				_deviceCoord.sub(Vec3.ONE);
            				if (this._projection === PROJECTION_PERSPECTIVE) {
            						Mat4._getPerspectiveHalfSize(_halfSize, this.fov, this.aspectRatio, this.nearClip, this.horizontalFov);
            						_halfSize.x *= _deviceCoord.x;
            						_halfSize.y *= _deviceCoord.y;
            						var invView = this._node.getWorldTransform();
            						_halfSize.z = -this.nearClip;
            						invView.transformPoint(_halfSize, _point$1);
            						var cameraPos = this._node.getPosition();
            						worldCoord.sub2(_point$1, cameraPos);
            						worldCoord.normalize();
            						worldCoord.mulScalar(z);
            						worldCoord.add(cameraPos);
            				} else {
            						this._updateViewProjMat();
            						_invViewProjMat.copy(this._viewProjMat).invert();
            						_invViewProjMat.transformPoint(_deviceCoord, worldCoord);
            				}
            				return worldCoord;
            		}
            		_evaluateProjectionMatrix() {
            				if (this._projMatDirty) {
            						if (this._projection === PROJECTION_PERSPECTIVE) {
            								this._projMat.setPerspective(this.fov, this.aspectRatio, this.nearClip, this.farClip, this.horizontalFov);
            								this._projMatSkybox.copy(this._projMat);
            						} else {
            								var y = this._orthoHeight;
            								var x = y * this.aspectRatio;
            								this._projMat.setOrtho(-x, x, -y, y, this.nearClip, this.farClip);
            								this._projMatSkybox.setPerspective(this.fov, this.aspectRatio, this.nearClip, this.farClip);
            						}
            						this._projMatDirty = false;
            				}
            		}
            		getProjectionMatrixSkybox() {
            				this._evaluateProjectionMatrix();
            				return this._projMatSkybox;
            		}
            		getExposure() {
            				var ev100 = Math.log2(this._aperture * this._aperture / this._shutter * 100.0 / this._sensitivity);
            				return 1.0 / (Math.pow(2.0, ev100) * 1.2);
            		}
            		getScreenSize(sphere) {
            				if (this._projection === PROJECTION_PERSPECTIVE) {
            						var distance = this._node.getPosition().distance(sphere.center);
            						if (distance < sphere.radius) {
            								return 1;
            						}
            						var viewAngle = Math.asin(sphere.radius / distance);
            						var sphereViewHeight = Math.tan(viewAngle);
            						var screenViewHeight = Math.tan(this.fov / 2 * math.DEG_TO_RAD);
            						return Math.min(sphereViewHeight / screenViewHeight, 1);
            				}
            				return math.clamp(sphere.radius / this._orthoHeight, 0, 1);
            		}
            		getFrustumCorners(near, far) {
            				if (near === void 0) near = this.nearClip;
            				if (far === void 0) far = this.farClip;
            				var fov = this.fov * Math.PI / 180.0;
            				var x, y;
            				if (this.projection === PROJECTION_PERSPECTIVE) {
            						if (this.horizontalFov) {
            								x = near * Math.tan(fov / 2.0);
            								y = x / this.aspectRatio;
            						} else {
            								y = near * Math.tan(fov / 2.0);
            								x = y * this.aspectRatio;
            						}
            				} else {
            						y = this._orthoHeight;
            						x = y * this.aspectRatio;
            				}
            				var points = _frustumPoints;
            				points[0].x = x;
            				points[0].y = -y;
            				points[0].z = -near;
            				points[1].x = x;
            				points[1].y = y;
            				points[1].z = -near;
            				points[2].x = -x;
            				points[2].y = y;
            				points[2].z = -near;
            				points[3].x = -x;
            				points[3].y = -y;
            				points[3].z = -near;
            				if (this._projection === PROJECTION_PERSPECTIVE) {
            						if (this.horizontalFov) {
            								x = far * Math.tan(fov / 2.0);
            								y = x / this.aspectRatio;
            						} else {
            								y = far * Math.tan(fov / 2.0);
            								x = y * this.aspectRatio;
            						}
            				}
            				points[4].x = x;
            				points[4].y = -y;
            				points[4].z = -far;
            				points[5].x = x;
            				points[5].y = y;
            				points[5].z = -far;
            				points[6].x = -x;
            				points[6].y = y;
            				points[6].z = -far;
            				points[7].x = -x;
            				points[7].y = -y;
            				points[7].z = -far;
            				return points;
            		}
            		setXrProperties(properties) {
            				Object.assign(this._xrProperties, properties);
            				this._projMatDirty = true;
            		}
            		constructor(){
            				this.shaderPassInfo = null;
            				this.renderPassColorGrab = null;
            				this.renderPassDepthGrab = null;
            				this.fogParams = null;
            				this.shaderParams = new CameraShaderParams();
            				this.renderPasses = [];
            				this.jitter = 0;
            				this._aspectRatio = 16 / 9;
            				this._aspectRatioMode = ASPECT_AUTO;
            				this._calculateProjection = null;
            				this._calculateTransform = null;
            				this._clearColor = new Color(0.75, 0.75, 0.75, 1);
            				this._clearColorBuffer = true;
            				this._clearDepth = 1;
            				this._clearDepthBuffer = true;
            				this._clearStencil = 0;
            				this._clearStencilBuffer = true;
            				this._cullFaces = true;
            				this._farClip = 1000;
            				this._flipFaces = false;
            				this._fov = 45;
            				this._frustumCulling = true;
            				this._horizontalFov = false;
            				this._layers = [
            						LAYERID_WORLD,
            						LAYERID_DEPTH,
            						LAYERID_SKYBOX,
            						LAYERID_UI,
            						LAYERID_IMMEDIATE
            				];
            				this._layersSet = new Set(this._layers);
            				this._nearClip = 0.1;
            				this._node = null;
            				this._orthoHeight = 10;
            				this._projection = PROJECTION_PERSPECTIVE;
            				this._rect = new Vec4(0, 0, 1, 1);
            				this._renderTarget = null;
            				this._scissorRect = new Vec4(0, 0, 1, 1);
            				this._scissorRectClear = false;
            				this._aperture = 16.0;
            				this._shutter = 1.0 / 1000.0;
            				this._sensitivity = 1000;
            				this._projMat = new Mat4();
            				this._projMatDirty = true;
            				this._projMatSkybox = new Mat4();
            				this._viewMat = new Mat4();
            				this._viewMatDirty = true;
            				this._viewProjMat = new Mat4();
            				this._viewProjMatDirty = true;
            				this._shaderMatricesVersion = 0;
            				this._viewProjInverse = new Mat4();
            				this._viewProjCurrent = null;
            				this._viewProjPrevious = new Mat4();
            				this._jitters = [
            						0,
            						0,
            						0,
            						0
            				];
            				this.frustum = new Frustum();
            				this._xr = null;
            				this._xrProperties = {
            						horizontalFov: this._horizontalFov,
            						fov: this._fov,
            						aspectRatio: this._aspectRatio,
            						farClip: this._farClip,
            						nearClip: this._nearClip
            				};
            		}
            }
            
            function _type_of(obj) {
            		"@swc/helpers - typeof";
            		return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
            }
            var scaleCompensatePosTransform = new Mat4();
            var scaleCompensatePos = new Vec3();
            var scaleCompensateRot = new Quat();
            var scaleCompensateRot2 = new Quat();
            var scaleCompensateScale = new Vec3();
            var scaleCompensateScaleForParent = new Vec3();
            var tmpMat4 = new Mat4();
            var tmpQuat = new Quat();
            var position$1 = new Vec3();
            var invParentWtm$1 = new Mat4();
            var rotation = new Quat();
            var invParentRot = new Quat();
            var matrix = new Mat4();
            var target = new Vec3();
            var up$2 = new Vec3();
            function createTest(attr, value) {
            		if (attr instanceof Function) {
            				return attr;
            		}
            		return (node)=>{
            				var x = node[attr];
            				if (x instanceof Function) {
            						x = x();
            				}
            				return x === value;
            		};
            }
            function findNode(node, test) {
            		if (test(node)) {
            				return node;
            		}
            		var children = node._children;
            		var len = children.length;
            		for(var i = 0; i < len; ++i){
            				var result = findNode(children[i], test);
            				if (result) {
            						return result;
            				}
            		}
            		return null;
            }
            class GraphNode extends EventHandler {
            		get right() {
            				if (!this._right) {
            						this._right = new Vec3();
            				}
            				return this.getWorldTransform().getX(this._right).normalize();
            		}
            		get up() {
            				if (!this._up) {
            						this._up = new Vec3();
            				}
            				return this.getWorldTransform().getY(this._up).normalize();
            		}
            		get forward() {
            				if (!this._forward) {
            						this._forward = new Vec3();
            				}
            				return this.getWorldTransform().getZ(this._forward).normalize().mulScalar(-1);
            		}
            		get normalMatrix() {
            				var normalMat = this._normalMatrix;
            				if (this._dirtyNormal) {
            						normalMat.invertMat4(this.getWorldTransform()).transpose();
            						this._dirtyNormal = false;
            				}
            				return normalMat;
            		}
            		set enabled(enabled) {
            				if (this._enabled !== enabled) {
            						var _this__parent;
            						this._enabled = enabled;
            						if (enabled && ((_this__parent = this._parent) == null ? void 0 : _this__parent.enabled) || !enabled) {
            								this._notifyHierarchyStateChanged(this, enabled);
            						}
            				}
            		}
            		get enabled() {
            				return this._enabled && this._enabledInHierarchy;
            		}
            		get parent() {
            				return this._parent;
            		}
            		get path() {
            				var node = this._parent;
            				if (!node) {
            						return '';
            				}
            				var result = this.name;
            				while(node && node._parent){
            						result = node.name + "/" + result;
            						node = node._parent;
            				}
            				return result;
            		}
            		get root() {
            				var result = this;
            				while(result._parent){
            						result = result._parent;
            				}
            				return result;
            		}
            		get children() {
            				return this._children;
            		}
            		get graphDepth() {
            				return this._graphDepth;
            		}
            		_notifyHierarchyStateChanged(node, enabled) {
            				node._onHierarchyStateChanged(enabled);
            				var c = node._children;
            				for(var i = 0, len = c.length; i < len; i++){
            						if (c[i]._enabled) {
            								this._notifyHierarchyStateChanged(c[i], enabled);
            						}
            				}
            		}
            		_onHierarchyStateChanged(enabled) {
            				this._enabledInHierarchy = enabled;
            				if (enabled && !this._frozen) {
            						this._unfreezeParentToRoot();
            				}
            		}
            		_cloneInternal(clone) {
            				clone.name = this.name;
            				var tags = this.tags._list;
            				clone.tags.clear();
            				for(var i = 0; i < tags.length; i++){
            						clone.tags.add(tags[i]);
            				}
            				clone.localPosition.copy(this.localPosition);
            				clone.localRotation.copy(this.localRotation);
            				clone.localScale.copy(this.localScale);
            				clone.localEulerAngles.copy(this.localEulerAngles);
            				clone.position.copy(this.position);
            				clone.rotation.copy(this.rotation);
            				clone.eulerAngles.copy(this.eulerAngles);
            				clone.localTransform.copy(this.localTransform);
            				clone._dirtyLocal = this._dirtyLocal;
            				clone.worldTransform.copy(this.worldTransform);
            				clone._dirtyWorld = this._dirtyWorld;
            				clone._dirtyNormal = this._dirtyNormal;
            				clone._aabbVer = this._aabbVer + 1;
            				clone._enabled = this._enabled;
            				clone.scaleCompensation = this.scaleCompensation;
            				clone._enabledInHierarchy = false;
            		}
            		clone() {
            				var clone = new this.constructor();
            				this._cloneInternal(clone);
            				return clone;
            		}
            		copy(source) {
            				source._cloneInternal(this);
            				return this;
            		}
            		destroy() {
            				this.remove();
            				var children = this._children;
            				while(children.length){
            						var child = children.pop();
            						child._parent = null;
            						child.destroy();
            				}
            				this.fire('destroy', this);
            				this.off();
            		}
            		find(attr, value) {
            				var results = [];
            				var test = createTest(attr, value);
            				this.forEach((node)=>{
            						if (test(node)) {
            								results.push(node);
            						}
            				});
            				return results;
            		}
            		findOne(attr, value) {
            				var test = createTest(attr, value);
            				return findNode(this, test);
            		}
            		findByTag() {
            				for(var _len = arguments.length, query = new Array(_len), _key = 0; _key < _len; _key++){
            						query[_key] = arguments[_key];
            				}
            				var results = [];
            				var queryNode = (node, checkNode)=>{
            						if (checkNode && node.tags.has(...query)) {
            								results.push(node);
            						}
            						for(var i = 0; i < node._children.length; i++){
            								queryNode(node._children[i], true);
            						}
            				};
            				queryNode(this, false);
            				return results;
            		}
            		findByName(name) {
            				return this.findOne('name', name);
            		}
            		findByPath(path) {
            				var _loop = function(i, imax) {
            						result = result.children.find((c)=>c.name === parts[i]);
            						if (!result) {
            								return {
            										v: null
            								};
            						}
            				};
            				var parts = Array.isArray(path) ? path : path.split('/');
            				var result = this;
            				for(var i = 0, imax = parts.length; i < imax; ++i){
            						var _ret = _loop(i);
            						if (_type_of(_ret) === "object") return _ret.v;
            				}
            				return result;
            		}
            		forEach(callback, thisArg) {
            				callback.call(thisArg, this);
            				var children = this._children;
            				var len = children.length;
            				for(var i = 0; i < len; ++i){
            						children[i].forEach(callback, thisArg);
            				}
            		}
            		isDescendantOf(node) {
            				var parent = this._parent;
            				while(parent){
            						if (parent === node) {
            								return true;
            						}
            						parent = parent._parent;
            				}
            				return false;
            		}
            		isAncestorOf(node) {
            				return node.isDescendantOf(this);
            		}
            		getEulerAngles() {
            				this.getWorldTransform().getEulerAngles(this.eulerAngles);
            				return this.eulerAngles;
            		}
            		getLocalEulerAngles() {
            				this.localRotation.getEulerAngles(this.localEulerAngles);
            				return this.localEulerAngles;
            		}
            		getLocalPosition() {
            				return this.localPosition;
            		}
            		getLocalRotation() {
            				return this.localRotation;
            		}
            		getLocalScale() {
            				return this.localScale;
            		}
            		getLocalTransform() {
            				if (this._dirtyLocal) {
            						this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
            						this._dirtyLocal = false;
            				}
            				return this.localTransform;
            		}
            		getPosition() {
            				this.getWorldTransform().getTranslation(this.position);
            				return this.position;
            		}
            		getRotation() {
            				this.rotation.setFromMat4(this.getWorldTransform());
            				return this.rotation;
            		}
            		getScale() {
            				if (!this._scale) {
            						this._scale = new Vec3();
            				}
            				return this.getWorldTransform().getScale(this._scale);
            		}
            		getWorldTransform() {
            				if (!this._dirtyLocal && !this._dirtyWorld) {
            						return this.worldTransform;
            				}
            				if (this._parent) {
            						this._parent.getWorldTransform();
            				}
            				this._sync();
            				return this.worldTransform;
            		}
            		get worldScaleSign() {
            				if (this._worldScaleSign === 0) {
            						this._worldScaleSign = this.getWorldTransform().scaleSign;
            				}
            				return this._worldScaleSign;
            		}
            		remove() {
            				var _this__parent;
            				(_this__parent = this._parent) == null ? void 0 : _this__parent.removeChild(this);
            		}
            		reparent(parent, index) {
            				this.remove();
            				if (parent) {
            						if (index >= 0) {
            								parent.insertChild(this, index);
            						} else {
            								parent.addChild(this);
            						}
            				}
            		}
            		setLocalEulerAngles(x, y, z) {
            				this.localRotation.setFromEulerAngles(x, y, z);
            				if (!this._dirtyLocal) {
            						this._dirtifyLocal();
            				}
            		}
            		setLocalPosition(x, y, z) {
            				if (x instanceof Vec3) {
            						this.localPosition.copy(x);
            				} else {
            						this.localPosition.set(x, y, z);
            				}
            				if (!this._dirtyLocal) {
            						this._dirtifyLocal();
            				}
            		}
            		setLocalRotation(x, y, z, w) {
            				if (x instanceof Quat) {
            						this.localRotation.copy(x);
            				} else {
            						this.localRotation.set(x, y, z, w);
            				}
            				if (!this._dirtyLocal) {
            						this._dirtifyLocal();
            				}
            		}
            		setLocalScale(x, y, z) {
            				if (x instanceof Vec3) {
            						this.localScale.copy(x);
            				} else {
            						this.localScale.set(x, y, z);
            				}
            				if (!this._dirtyLocal) {
            						this._dirtifyLocal();
            				}
            		}
            		_dirtifyLocal() {
            				if (!this._dirtyLocal) {
            						this._dirtyLocal = true;
            						if (!this._dirtyWorld) {
            								this._dirtifyWorld();
            						}
            				}
            		}
            		_unfreezeParentToRoot() {
            				var p = this._parent;
            				while(p){
            						p._frozen = false;
            						p = p._parent;
            				}
            		}
            		_dirtifyWorld() {
            				if (!this._dirtyWorld) {
            						this._unfreezeParentToRoot();
            				}
            				this._dirtifyWorldInternal();
            		}
            		_dirtifyWorldInternal() {
            				if (!this._dirtyWorld) {
            						this._frozen = false;
            						this._dirtyWorld = true;
            						for(var i = 0; i < this._children.length; i++){
            								if (!this._children[i]._dirtyWorld) {
            										this._children[i]._dirtifyWorldInternal();
            								}
            						}
            				}
            				this._dirtyNormal = true;
            				this._worldScaleSign = 0;
            				this._aabbVer++;
            		}
            		setPosition(x, y, z) {
            				if (x instanceof Vec3) {
            						position$1.copy(x);
            				} else {
            						position$1.set(x, y, z);
            				}
            				if (this._parent === null) {
            						this.localPosition.copy(position$1);
            				} else {
            						invParentWtm$1.copy(this._parent.getWorldTransform()).invert();
            						invParentWtm$1.transformPoint(position$1, this.localPosition);
            				}
            				if (!this._dirtyLocal) {
            						this._dirtifyLocal();
            				}
            		}
            		setRotation(x, y, z, w) {
            				if (x instanceof Quat) {
            						rotation.copy(x);
            				} else {
            						rotation.set(x, y, z, w);
            				}
            				if (this._parent === null) {
            						this.localRotation.copy(rotation);
            				} else {
            						var parentRot = this._parent.getRotation();
            						invParentRot.copy(parentRot).invert();
            						this.localRotation.copy(invParentRot).mul(rotation);
            				}
            				if (!this._dirtyLocal) {
            						this._dirtifyLocal();
            				}
            		}
            		setPositionAndRotation(position, rotation) {
            				if (this._parent === null) {
            						this.localPosition.copy(position);
            						this.localRotation.copy(rotation);
            				} else {
            						var parentWtm = this._parent.getWorldTransform();
            						invParentWtm$1.copy(parentWtm).invert();
            						invParentWtm$1.transformPoint(position, this.localPosition);
            						this.localRotation.setFromMat4(invParentWtm$1).mul(rotation);
            				}
            				if (!this._dirtyLocal) {
            						this._dirtifyLocal();
            				}
            		}
            		setEulerAngles(x, y, z) {
            				this.localRotation.setFromEulerAngles(x, y, z);
            				if (this._parent !== null) {
            						var parentRot = this._parent.getRotation();
            						invParentRot.copy(parentRot).invert();
            						this.localRotation.mul2(invParentRot, this.localRotation);
            				}
            				if (!this._dirtyLocal) {
            						this._dirtifyLocal();
            				}
            		}
            		addChild(node) {
            				this._prepareInsertChild(node);
            				this._children.push(node);
            				this._onInsertChild(node);
            		}
            		addChildAndSaveTransform(node) {
            				var wPos = node.getPosition();
            				var wRot = node.getRotation();
            				this._prepareInsertChild(node);
            				node.setPosition(tmpMat4.copy(this.worldTransform).invert().transformPoint(wPos));
            				node.setRotation(tmpQuat.copy(this.getRotation()).invert().mul(wRot));
            				this._children.push(node);
            				this._onInsertChild(node);
            		}
            		insertChild(node, index) {
            				this._prepareInsertChild(node);
            				this._children.splice(index, 0, node);
            				this._onInsertChild(node);
            		}
            		_prepareInsertChild(node) {
            				node.remove();
            		}
            		_fireOnHierarchy(name, nameHierarchy, parent) {
            				this.fire(name, parent);
            				for(var i = 0; i < this._children.length; i++){
            						this._children[i]._fireOnHierarchy(nameHierarchy, nameHierarchy, parent);
            				}
            		}
            		_onInsertChild(node) {
            				node._parent = this;
            				var enabledInHierarchy = node._enabled && this.enabled;
            				if (node._enabledInHierarchy !== enabledInHierarchy) {
            						node._enabledInHierarchy = enabledInHierarchy;
            						node._notifyHierarchyStateChanged(node, enabledInHierarchy);
            				}
            				node._updateGraphDepth();
            				node._dirtifyWorld();
            				if (this._frozen) {
            						node._unfreezeParentToRoot();
            				}
            				node._fireOnHierarchy('insert', 'inserthierarchy', this);
            				if (this.fire) this.fire('childinsert', node);
            		}
            		_updateGraphDepth() {
            				this._graphDepth = this._parent ? this._parent._graphDepth + 1 : 0;
            				for(var i = 0, len = this._children.length; i < len; i++){
            						this._children[i]._updateGraphDepth();
            				}
            		}
            		removeChild(child) {
            				var index = this._children.indexOf(child);
            				if (index === -1) {
            						return;
            				}
            				this._children.splice(index, 1);
            				child._parent = null;
            				child._fireOnHierarchy('remove', 'removehierarchy', this);
            				this.fire('childremove', child);
            		}
            		_sync() {
            				if (this._dirtyLocal) {
            						this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
            						this._dirtyLocal = false;
            				}
            				if (this._dirtyWorld) {
            						if (this._parent === null) {
            								this.worldTransform.copy(this.localTransform);
            						} else {
            								if (this.scaleCompensation) {
            										var parentWorldScale;
            										var parent = this._parent;
            										var scale = this.localScale;
            										var parentToUseScaleFrom = parent;
            										if (parentToUseScaleFrom) {
            												while(parentToUseScaleFrom && parentToUseScaleFrom.scaleCompensation){
            														parentToUseScaleFrom = parentToUseScaleFrom._parent;
            												}
            												if (parentToUseScaleFrom) {
            														parentToUseScaleFrom = parentToUseScaleFrom._parent;
            														if (parentToUseScaleFrom) {
            																parentWorldScale = parentToUseScaleFrom.worldTransform.getScale();
            																scaleCompensateScale.mul2(parentWorldScale, this.localScale);
            																scale = scaleCompensateScale;
            														}
            												}
            										}
            										scaleCompensateRot2.setFromMat4(parent.worldTransform);
            										scaleCompensateRot.mul2(scaleCompensateRot2, this.localRotation);
            										var tmatrix = parent.worldTransform;
            										if (parent.scaleCompensation) {
            												scaleCompensateScaleForParent.mul2(parentWorldScale, parent.getLocalScale());
            												scaleCompensatePosTransform.setTRS(parent.worldTransform.getTranslation(scaleCompensatePos), scaleCompensateRot2, scaleCompensateScaleForParent);
            												tmatrix = scaleCompensatePosTransform;
            										}
            										tmatrix.transformPoint(this.localPosition, scaleCompensatePos);
            										this.worldTransform.setTRS(scaleCompensatePos, scaleCompensateRot, scale);
            								} else {
            										this.worldTransform.mulAffine2(this._parent.worldTransform, this.localTransform);
            								}
            						}
            						this._dirtyWorld = false;
            				}
            		}
            		syncHierarchy() {
            				if (!this._enabled) {
            						return;
            				}
            				if (this._frozen) {
            						return;
            				}
            				this._frozen = true;
            				if (this._dirtyLocal || this._dirtyWorld) {
            						this._sync();
            				}
            				var children = this._children;
            				for(var i = 0, len = children.length; i < len; i++){
            						children[i].syncHierarchy();
            				}
            		}
            		lookAt(x, y, z, ux, uy, uz) {
            				if (ux === void 0) ux = 0;
            				if (uy === void 0) uy = 1;
            				if (uz === void 0) uz = 0;
            				if (x instanceof Vec3) {
            						target.copy(x);
            						if (y instanceof Vec3) {
            								up$2.copy(y);
            						} else {
            								up$2.copy(Vec3.UP);
            						}
            				} else if (z === undefined) {
            						return;
            				} else {
            						target.set(x, y, z);
            						up$2.set(ux, uy, uz);
            				}
            				matrix.setLookAt(this.getPosition(), target, up$2);
            				rotation.setFromMat4(matrix);
            				this.setRotation(rotation);
            		}
            		translate(x, y, z) {
            				if (x instanceof Vec3) {
            						position$1.copy(x);
            				} else {
            						position$1.set(x, y, z);
            				}
            				position$1.add(this.getPosition());
            				this.setPosition(position$1);
            		}
            		translateLocal(x, y, z) {
            				if (x instanceof Vec3) {
            						position$1.copy(x);
            				} else {
            						position$1.set(x, y, z);
            				}
            				this.localRotation.transformVector(position$1, position$1);
            				this.localPosition.add(position$1);
            				if (!this._dirtyLocal) {
            						this._dirtifyLocal();
            				}
            		}
            		rotate(x, y, z) {
            				rotation.setFromEulerAngles(x, y, z);
            				if (this._parent === null) {
            						this.localRotation.mul2(rotation, this.localRotation);
            				} else {
            						var rot = this.getRotation();
            						var parentRot = this._parent.getRotation();
            						invParentRot.copy(parentRot).invert();
            						rotation.mul2(invParentRot, rotation);
            						this.localRotation.mul2(rotation, rot);
            				}
            				if (!this._dirtyLocal) {
            						this._dirtifyLocal();
            				}
            		}
            		rotateLocal(x, y, z) {
            				rotation.setFromEulerAngles(x, y, z);
            				this.localRotation.mul(rotation);
            				if (!this._dirtyLocal) {
            						this._dirtifyLocal();
            				}
            		}
            		constructor(name = 'Untitled'){
            				super(), this.tags = new Tags(this), this.localPosition = new Vec3(), this.localRotation = new Quat(), this.localScale = new Vec3(1, 1, 1), this.localEulerAngles = new Vec3(), this.position = new Vec3(), this.rotation = new Quat(), this.eulerAngles = new Vec3(), this._scale = null, this.localTransform = new Mat4(), this._dirtyLocal = false, this._aabbVer = 0, this._frozen = false, this.worldTransform = new Mat4(), this._dirtyWorld = false, this._worldScaleSign = 0, this._normalMatrix = new Mat3(), this._dirtyNormal = true, this._right = null, this._up = null, this._forward = null, this._parent = null, this._children = [], this._graphDepth = 0, this._enabled = true, this._enabledInHierarchy = false, this.scaleCompensation = false;
            				this.name = name;
            		}
            }
            
            var _viewMat = new Mat4();
            var _viewProjMat = new Mat4();
            var _viewportMatrix = new Mat4();
            class LightCamera {
            		static create(name, lightType, face) {
            				var camera = new Camera();
            				camera.node = new GraphNode(name);
            				camera.aspectRatio = 1;
            				camera.aspectRatioMode = ASPECT_MANUAL;
            				camera._scissorRectClear = true;
            				switch(lightType){
            						case LIGHTTYPE_OMNI:
            								camera.node.setRotation(LightCamera.pointLightRotations[face]);
            								camera.fov = 90;
            								camera.projection = PROJECTION_PERSPECTIVE;
            								break;
            						case LIGHTTYPE_SPOT:
            								camera.projection = PROJECTION_PERSPECTIVE;
            								break;
            						case LIGHTTYPE_DIRECTIONAL:
            								camera.projection = PROJECTION_ORTHOGRAPHIC;
            								break;
            				}
            				return camera;
            		}
            		static evalSpotCookieMatrix(light) {
            				var cookieCamera = LightCamera._spotCookieCamera;
            				if (!cookieCamera) {
            						cookieCamera = LightCamera.create('SpotCookieCamera', LIGHTTYPE_SPOT);
            						LightCamera._spotCookieCamera = cookieCamera;
            				}
            				cookieCamera.fov = light._outerConeAngle * 2;
            				var cookieNode = cookieCamera._node;
            				cookieNode.setPosition(light._node.getPosition());
            				cookieNode.setRotation(light._node.getRotation());
            				cookieNode.rotateLocal(-90, 0, 0);
            				_viewMat.setTRS(cookieNode.getPosition(), cookieNode.getRotation(), Vec3.ONE).invert();
            				_viewProjMat.mul2(cookieCamera.projectionMatrix, _viewMat);
            				var cookieMatrix = light.cookieMatrix;
            				var rectViewport = light.atlasViewport;
            				_viewportMatrix.setViewport(rectViewport.x, rectViewport.y, rectViewport.z, rectViewport.w);
            				cookieMatrix.mul2(_viewportMatrix, _viewProjMat);
            				return cookieMatrix;
            		}
            }
            LightCamera.pointLightRotations = [
            		new Quat().setFromEulerAngles(0, 90, 180),
            		new Quat().setFromEulerAngles(0, -90, 180),
            		new Quat().setFromEulerAngles(90, 0, 0),
            		new Quat().setFromEulerAngles(-90, 0, 0),
            		new Quat().setFromEulerAngles(0, 180, 180),
            		new Quat().setFromEulerAngles(0, 0, 180)
            ];
            LightCamera._spotCookieCamera = null;
            
            var ambientPS = '\n\n#if LIT_AMBIENT_SOURCE == AMBIENTSH\n#endif\n\n#if LIT_AMBIENT_SOURCE == ENVALATLAS\n    #include "envAtlasPS"\n\n    #ifndef ENV_ATLAS\n        #define ENV_ATLAS\n        var texture_envAtlas: texture_2d<f32>;\n        var texture_envAtlasSampler: sampler;\n    #endif\n#endif\n\nfn addAmbient(worldNormal: vec3f) {\n    #ifdef LIT_AMBIENT_SOURCE == AMBIENTSH\n\n        let n: vec3f = cubeMapRotate(worldNormal);\n        let color: vec3f =\n            uniform.ambientSH[0] +\n            uniform.ambientSH[1] * n.x +\n            uniform.ambientSH[2] * n.y +\n            uniform.ambientSH[3] * n.z +\n            uniform.ambientSH[4] * n.x * n.z +\n            uniform.ambientSH[5] * n.z * n.y +\n            uniform.ambientSH[6] * n.y * n.x +\n            uniform.ambientSH[7] * (3.0 * n.z * n.z - 1.0) +\n            uniform.ambientSH[8] * (n.x * n.x - n.y * n.y);\n\n        dDiffuseLight += processEnvironment(max(color, vec3f(0.0)));\n\n    #endif\n\n    #if LIT_AMBIENT_SOURCE == ENVALATLAS\n\n        let dir: vec3f = normalize(cubeMapRotate(worldNormal) * vec3f(-1.0, 1.0, 1.0));\n        let uv: vec2f = mapUv(toSphericalUv(dir), vec4f(128.0, 256.0 + 128.0, 64.0, 32.0) / atlasSize);\n\n        let raw: vec4f = textureSample(texture_envAtlas, texture_envAtlasSampler, uv);\n        let linear: vec3f = {ambientDecode}(raw);\n        dDiffuseLight += processEnvironment(linear);\n\n    #endif\n\n    #if LIT_AMBIENT_SOURCE == CONSTANT\n\n        dDiffuseLight += uniform.light_globalAmbient;\n\n    #endif\n}\n';
            
            var basePS = "\nuniform view_position: vec3f;\n\nuniform light_globalAmbient: vec3f;\n\nfn square(x: f32) -> f32 {\n    return x*x;\n}\n\nfn saturate(x: f32) -> f32 {\n    return clamp(x, 0.0, 1.0);\n}\n\nfn saturate3(x: vec3f) -> vec3f {\n    return clamp(x, vec3f(0.0), vec3f(1.0));\n}\n";
            
            var combinePS = "\nfn combineColor(albedo: vec3f, sheenSpecularity: vec3f, clearcoatSpecularity: f32) -> vec3f {\n    var ret: vec3f = vec3f(0.0);\n\n    #ifdef LIT_OLD_AMBIENT\n        ret += (dDiffuseLight - uniform.light_globalAmbient) * albedo + uniform.material_ambient * uniform.light_globalAmbient;\n    #else\n        ret += albedo * dDiffuseLight;\n    #endif // LIT_OLD_AMBIENT\n    #ifdef LIT_SPECULAR\n        ret += dSpecularLight;\n    #endif // LIT_SPECULAR\n    #ifdef LIT_REFLECTIONS\n        ret += dReflection.rgb * dReflection.a;\n    #endif // LIT_REFLECTIONS\n\n    #ifdef LIT_SHEEN\n        let sheenScaling: f32 = 1.0 - max(max(sheenSpecularity.r, sheenSpecularity.g), sheenSpecularity.b) * 0.157;\n        ret = ret * sheenScaling + (sSpecularLight + sReflection.rgb) * sheenSpecularity;\n    #endif // LIT_SHEEN\n    #ifdef LIT_CLEARCOAT\n        let clearCoatScaling: f32 = 1.0 - ccFresnel * clearcoatSpecularity;\n        ret = ret * clearCoatScaling + (ccSpecularLight + ccReflection.rgb) * clearcoatSpecularity;\n    #endif // LIT_CLEARCOAT\n\n    return ret;\n}\n";
            
            var cookieBlit2DPS = "\n    varying uv0: vec2f;\n\n    var blitTexture: texture_2d<f32>;\n    var blitTextureSampler : sampler;\n\n    @fragment\n    fn fragmentMain(input : FragmentInput) -> FragmentOutput {\n        var output: FragmentOutput;\n        output.color = textureSample(blitTexture, blitTextureSampler, input.uv0);\n        return output;\n    }\n";
            
            var cookieBlitCubePS = "\n    varying uv0: vec2f;\n    uniform invViewProj: mat4x4<f32>;\n    var blitTexture: texture_cube<f32>;\n    var blitTextureSampler : sampler;\n\n    @fragment\n    fn fragmentMain(input : FragmentInput) -> FragmentOutput {\n        var output: FragmentOutput;\n        var projPos = vec4f(input.uv0 * 2.0 - 1.0, 0.5, 1.0);\n        var worldPos = uniform.invViewProj * projPos;\n        output.color = textureSample(blitTexture, blitTextureSampler, worldPos.xyz);\n        return output;\n    }\n";
            
            var cookieBlitVS = "\n    attribute vertex_position: vec2f;\n    varying uv0: vec2f;\n\n    @vertex\n    fn vertexMain(input: VertexInput) -> VertexOutput {\n        var output: VertexOutput;\n        output.position = vec4f(input.vertex_position, 0.5, 1.0);\n        output.uv0 = input.vertex_position * 0.5 + vec2f(0.5, 0.5);\n        output.uv0.y = 1.0 - output.uv0.y;\n        return output;\n    }\n";
            
            var debugOutputPS = "\n#ifdef DEBUG_ALBEDO_PASS\noutput.color = vec4(gammaCorrectOutput(dAlbedo), 1.0);\n#endif\n\n#ifdef DEBUG_UV0_PASS\noutput.color = vec4f(litArgs_albedo , 1.0);\n#endif\n\n#ifdef DEBUG_WORLD_NORMAL_PASS\noutput.color = vec4f(litArgs_worldNormal * 0.5 + 0.5, 1.0);\n#endif\n\n#ifdef DEBUG_OPACITY_PASS\noutput.color = vec4f(vec3f(litArgs_opacity) , 1.0);\n#endif\n\n#ifdef DEBUG_SPECULARITY_PASS\noutput.color = vec4f(litArgs_specularity, 1.0);\n#endif\n\n#ifdef DEBUG_GLOSS_PASS\noutput.color = vec4f(vec3f(litArgs_gloss) , 1.0);\n#endif\n\n#ifdef DEBUG_METALNESS_PASS\noutput.color = vec4f(vec3f(litArgs_metalness) , 1.0);\n#endif\n\n#ifdef DEBUG_AO_PASS\noutput.color = vec4f(vec3f(litArgs_ao) , 1.0);\n#endif\n\n#ifdef DEBUG_EMISSION_PASS\noutput.color = vec4f(gammaCorrectOutput(litArgs_emission), 1.0);\n#endif\n";
            
            var debugProcessFrontendPS = "\n#ifdef DEBUG_LIGHTING_PASS\n    litArgs_albedo = vec3f(0.5);\n#endif\n\n#ifdef DEBUG_UV0_PASS\n#ifdef VARYING_VUV0\n    litArgs_albedo = vec3f(vUv0, 0.0);\n#else\n    litArgs_albedo = vec3f(0.0);\n#endif\n#endif\n";
            
            var decodePS = "\n\n#ifndef _DECODE_INCLUDED_\n#define _DECODE_INCLUDED_\n\nfn decodeLinear(raw: vec4f) -> vec3f {\n    return raw.rgb;\n}\n\nfn decodeGammaFloat(raw: f32) -> f32 {\n    return pow(raw, 2.2);\n}\n\nfn decodeGamma3(raw: vec3f) -> vec3f {\n    return pow(raw, vec3f(2.2));\n}\n\nfn decodeGamma(raw: vec4f) -> vec3f {\n    return pow(raw.xyz, vec3f(2.2));\n}\n\nfn decodeRGBM(raw: vec4f) -> vec3f {\n    let color = (8.0 * raw.a) * raw.rgb;\n    return color * color;\n}\n\nfn decodeRGBP(raw: vec4f) -> vec3f {\n    let color = raw.rgb * (-raw.a * 7.0 + 8.0);\n    return color * color;\n}\n\nfn decodeRGBE(raw: vec4f) -> vec3f {\n    return select(vec3f(0.0), raw.xyz * pow(2.0, raw.w * 255.0 - 128.0), raw.a != 0.0);\n}\n\nfn passThrough(raw: vec4f) -> vec4f {\n    return raw;\n}\n\nfn unpackNormalXYZ(nmap: vec4f) -> vec3f {\n    return nmap.xyz * 2.0 - 1.0;\n}\n\nfn unpackNormalXY(nmap: vec4f) -> vec3f {\n    var xy = nmap.wy * 2.0 - 1.0;\n    return vec3f(xy, sqrt(1.0 - clamp(dot(xy, xy), 0.0, 1.0)));\n}\n\n#endif\n";
            
            var encodePS = "\nfn encodeLinear(source: vec3f) -> vec4f {\n    return vec4f(source, 1.0);\n}\n\nfn encodeGamma(source: vec3f) -> vec4f {\n    return vec4f(pow(source + vec3f(0.0000001), vec3f(1.0 / 2.2)), 1.0);\n}\n\nfn encodeRGBM(source: vec3f) -> vec4f {\n    var color: vec3f = pow(source, vec3f(0.5));\n    color *= 1.0 / 8.0;\n\n    var a: f32 = saturate(max(max(color.r, color.g), max(color.b, 1.0 / 255.0)));\n    a = ceil(a * 255.0) / 255.0;\n\n    color /= a;\n    return vec4f(color, a);\n}\n\nfn encodeRGBP(source: vec3f) -> vec4f {\n    // convert incoming linear to gamma(ish)\n    var gamma: vec3f = pow(source, vec3f(0.5));\n\n    // calculate the maximum component clamped to 1..8\n    var maxVal: f32 = min(8.0, max(1.0, max(gamma.x, max(gamma.y, gamma.z))));\n\n    // calculate storage factor\n    var v: f32 = 1.0 - ((maxVal - 1.0) / 7.0);\n\n    // round the value for storage in 8bit channel\n    v = ceil(v * 255.0) / 255.0;\n\n    return vec4f(gamma / (-v * 7.0 + 8.0), v);\n}\n\nfn encodeRGBE(source: vec3f) -> vec4f {\n    var maxVal: f32 = max(source.x, max(source.y, source.z));\n    if (maxVal < 1e-32) {\n        return vec4f(0.0, 0.0, 0.0, 0.0);\n    } else {\n        var e: f32 = ceil(log2(maxVal));\n        return vec4f(source / pow(2.0, e), (e + 128.0) / 255.0);\n    }\n}\n";
            
            var endPS = "\n    var finalRgb: vec3f = combineColor(litArgs_albedo, litArgs_sheen_specularity, litArgs_clearcoat_specularity);\n\n    finalRgb = finalRgb + litArgs_emission;\n    finalRgb = addFog(finalRgb);\n    finalRgb = toneMap(finalRgb);\n    finalRgb = gammaCorrectOutput(finalRgb);\n    output.color = vec4f(finalRgb, output.color.a);\n";
            
            var envAtlasPS = "\n// the envAtlas is fixed at 512 pixels. every equirect is generated with 1 pixel boundary.\nconst atlasSize : f32 = 512.0;\nconst seamSize : f32 = 1.0 / atlasSize;\n\n// map a normalized equirect UV to the given rectangle (taking 1 pixel seam into account).\nfn mapUv(uv : vec2f, rect : vec4f) -> vec2f {\n    return vec2f(mix(rect.x + seamSize, rect.x + rect.z - seamSize, uv.x),\n                 mix(rect.y + seamSize, rect.y + rect.w - seamSize, uv.y));\n}\n\n// map a normalized equirect UV and roughness level to the correct atlas rect.\nfn mapRoughnessUv(uv : vec2f, level : f32) -> vec2f {\n    let t : f32 = 1.0 / exp2(level);\n    return mapUv(uv, vec4f(0.0, 1.0 - t, t, t * 0.5));\n}\n\n// map shiny level UV\nfn mapShinyUv(uv : vec2f, level : f32) -> vec2f {\n    let t : f32 = 1.0 / exp2(level);\n    return mapUv(uv, vec4f(1.0 - t, 1.0 - t, t, t * 0.5));\n}\n";
            
            var envProcPS = "\n#ifdef LIT_SKYBOX_INTENSITY\n    uniform skyboxIntensity : f32;\n#endif\n\nfn processEnvironment(color : vec3f) -> vec3f {\n    #ifdef LIT_SKYBOX_INTENSITY\n        return color * uniform.skyboxIntensity;\n    #else\n        return color;\n    #endif\n}\n";
            
            var fogPS = "\n\nvar<private> dBlendModeFogFactor : f32 = 1.0;\n\n#if (FOG != NONE)\n    uniform fog_color : vec3f;\n    \n    #if (FOG == LINEAR)\n        uniform fog_start : f32;\n        uniform fog_end : f32;\n    #else\n        uniform fog_density : f32;\n    #endif\n#endif\n\nfn getFogFactor() -> f32 {\n\n    let depth = pcPosition.z / pcPosition.w;\n\n    var fogFactor : f32 = 0.0;\n\n    #if (FOG == LINEAR)\n        fogFactor = (uniform.fog_end - depth) / (uniform.fog_end - uniform.fog_start);\n    #elif (FOG == EXP)\n        fogFactor = exp(-depth * uniform.fog_density);\n    #elif (FOG == EXP2)\n        fogFactor = exp(-depth * depth * uniform.fog_density * uniform.fog_density);\n    #endif\n\n    return clamp(fogFactor, 0.0, 1.0);\n}\n\nfn addFog(color : vec3f) -> vec3f {\n    #if (FOG != NONE)\n        return mix(uniform.fog_color * dBlendModeFogFactor, color, getFogFactor());\n    #else\n        return color;\n    #endif\n}\n";
            
            var gammaPS = '\n\n#include "decodePS"\n\n#if (GAMMA == SRGB)\n\n    fn gammaCorrectInput(color: f32) -> f32 {\n        return decodeGammaFloat(color);\n    }\n\n    fn gammaCorrectInputVec3(color: vec3f) -> vec3f {\n        return decodeGamma3(color);\n    }\n\n    fn gammaCorrectInputVec4(color: vec4f) -> vec4f {\n        return vec4f(decodeGamma3(color.xyz), color.w);\n    }\n\n    fn gammaCorrectOutput(color: vec3f) -> vec3f {\n        return pow(color + 0.0000001, vec3f(1.0 / 2.2));\n    }\n\n#else // NONE\n\n    fn gammaCorrectInput(color: f32) -> f32 {\n        return color;\n    }\n\n    fn gammaCorrectInputVec3(color: vec3f) -> vec3f {\n        return color;\n    }\n\n    fn gammaCorrectInputVec4(color: vec4f) -> vec4f {\n        return color;\n    }\n\n    fn gammaCorrectOutput(color: vec3f) -> vec3f {\n        return color;\n    }\n\n#endif\n';
            
            var immediateLinePS = '\n    #include "gammaPS"\n    varying color: vec4f;\n    @fragment\n    fn fragmentMain(input : FragmentInput) -> FragmentOutput {\n        var output: FragmentOutput;\n        output.color = vec4f(gammaCorrectOutput(decodeGamma3(input.color.rgb)), input.color.a);\n        return output;\n    }\n';
            
            var immediateLineVS = "\n    attribute vertex_position: vec4f;\n    attribute vertex_color: vec4f;\n    uniform matrix_model: mat4x4f;\n    uniform matrix_viewProjection: mat4x4f;\n    varying color: vec4f;\n    @vertex\n    fn vertexMain(input : VertexInput) -> VertexOutput {\n        var output : VertexOutput;\n        output.color = input.vertex_color;\n        output.position = uniform.matrix_viewProjection * uniform.matrix_model * input.vertex_position;\n        return output;\n    }\n";
            
            var lightingPS = '\n\n#ifdef LIT_CLUSTERED_LIGHTS\n    // all this functionality that needs to be included for clustered lighting\n    #define LIT_CODE_FALLOFF_LINEAR\n    #define LIT_CODE_FALLOFF_SQUARED\n    #define LIT_CODE_LIGHTS_POINT\n    #define LIT_CODE_LIGHTS_SPOT\n#endif\n\n#ifdef AREA_LIGHTS\n    var areaLightsLutTex1: texture_2d<f32>;\n    var areaLightsLutTex1Sampler: sampler;\n    var areaLightsLutTex2: texture_2d<f32>;\n    var areaLightsLutTex2Sampler: sampler;\n#endif\n\n#ifdef LIT_LIGHTING\n    #include "lightDiffuseLambertPS"\n\n    // area lights\n    #if defined(AREA_LIGHTS) || defined(LIT_CLUSTERED_AREA_LIGHTS)\n        #include "ltcPS"\n    #endif\n#endif\n\n#ifdef SHADOW_DIRECTIONAL\n    #include "shadowCascadesPS"\n#endif\n\n#if defined(SHADOW_KIND_PCF1)\n    #include "shadowPCF1PS"\n#endif\n\n#if defined(SHADOW_KIND_PCF3)\n    #include "shadowPCF3PS"\n#endif\n\n#if defined(SHADOW_KIND_PCF5)\n    #include "shadowPCF5PS"\n#endif\n\n#if defined(SHADOW_KIND_PCSS)\n    #include "linearizeDepthPS"\n    #include "shadowPCSSPS"\n    #include "shadowSoftPS"\n#endif\n\n#if defined(SHADOW_KIND_VSM)\n    #include "shadowEVSMPS"\n#endif\n\n#ifdef LIT_CODE_FALLOFF_LINEAR\n    #include "falloffLinearPS"\n#endif\n\n#ifdef LIT_CODE_FALLOFF_SQUARED\n    #include "falloffInvSquaredPS"\n#endif\n\n#ifdef LIT_CODE_LIGHTS_POINT\n    #include "lightDirPointPS"\n#endif\n\n#ifdef LIT_CODE_LIGHTS_SPOT\n    #include "spotPS"\n#endif\n\n#ifdef LIT_CODE_COOKIE\n    #include "cookiePS"\n#endif\n\n// clustered lighting\n#ifdef LIT_CLUSTERED_LIGHTS\n    #include "clusteredLightPS"\n#endif\n\n#ifdef LIGHT_COUNT > 0\n    // LOOP - generate shadow evaluation functions for all non-clustered lights\n    #include "lightFunctionShadowPS, LIGHT_COUNT"\n\n    // LOOP - generate light evaluation functions for all non-clustered lights\n    #include "lightFunctionLightPS, LIGHT_COUNT"\n#endif\n';
            
            var litForwardBackendPS = '\nfn evaluateBackend() -> FragmentOutput {\n\n    var output: FragmentOutput;\n\n    // apply SSAO during lighting\n    #ifdef LIT_SSAO\n        litArgs_ao = litArgs_ao * textureSampleLevel(ssaoTexture, ssaoTextureSampler, pcPosition.xy * ssaoTextureSizeInv, 0.0).r;\n    #endif\n\n    // transform tangent space normals to world space\n    #ifdef LIT_NEEDS_NORMAL\n        #ifdef LIT_SPECULAR\n            getReflDir(litArgs_worldNormal, dViewDirW, litArgs_gloss, dTBN);\n        #endif\n\n        #ifdef LIT_CLEARCOAT\n            ccReflDirW = normalize(-reflect(dViewDirW, litArgs_clearcoat_worldNormal));\n        #endif\n    #endif\n\n    #ifdef LIT_SPECULAR_OR_REFLECTION\n        #ifdef LIT_METALNESS\n            var f0: f32 = 1.0 / litArgs_ior;\n            f0 = (f0 - 1.0) / (f0 + 1.0);\n            f0 = f0 * f0;\n            litArgs_specularity = getSpecularModulate(litArgs_specularity, litArgs_albedo, litArgs_metalness, f0);\n            litArgs_albedo = getAlbedoModulate(litArgs_albedo, litArgs_metalness);\n        #endif\n\n        #ifdef LIT_IRIDESCENCE\n            var iridescenceFresnel: vec3f = getIridescence(saturate3(dot(dViewDirW, litArgs_worldNormal)), litArgs_specularity, litArgs_iridescence_thickness);\n        #endif\n    #endif\n\n    // ambient\n    #ifdef LIT_ADD_AMBIENT\n        addAmbient(litArgs_worldNormal);\n\n        #ifdef LIT_SPECULAR\n            dDiffuseLight = dDiffuseLight * (1.0 - litArgs_specularity);\n        #endif\n\n        // move ambient color out of diffuse (used by Lightmapper, to multiply ambient color by accumulated AO)\n        #ifdef LIT_SEPARATE_AMBIENT\n            var dAmbientLight: vec3f = dDiffuseLight;\n            dDiffuseLight = vec3(0.0);\n        #endif\n    #endif\n\n    #ifndef LIT_OLD_AMBIENT\n        dDiffuseLight = dDiffuseLight * uniform.material_ambient;\n    #endif\n\n    #ifdef LIT_AO\n        #ifndef LIT_OCCLUDE_DIRECT\n            occludeDiffuse(litArgs_ao);\n        #endif\n    #endif\n\n    #ifdef LIT_LIGHTMAP\n        addLightMap(\n            litArgs_lightmap, \n            litArgs_lightmapDir, \n            litArgs_worldNormal, \n            dViewDirW, \n            dReflDirW, \n            litArgs_gloss, \n            litArgs_specularity, \n            dVertexNormalW,\n            dTBN\n        #if defined(LIT_IRIDESCENCE)\n            , iridescenceFresnel,\n            litArgs_iridescence_intensity\n        #endif\n        );\n    #endif\n\n    #ifdef LIT_LIGHTING || LIT_REFLECTIONS\n\n        #ifdef LIT_REFLECTIONS\n\n            #ifdef LIT_CLEARCOAT\n                addReflectionCC(ccReflDirW, litArgs_clearcoat_gloss);\n            \n                #ifdef LIT_SPECULAR_FRESNEL\n                    ccFresnel = getFresnelCC(dot(dViewDirW, litArgs_clearcoat_worldNormal));\n                    ccReflection.rgb = ccReflection.rgb * ccFresnel;\n                #else\n                    ccFresnel = 0.0;\n                #endif\n            #endif\n\n            #ifdef LIT_SPECULARITY_FACTOR\n                ccReflection.rgb = ccReflection.rgb * litArgs_specularityFactor;\n            #endif\n\n            #ifdef LIT_SHEEN\n                addReflectionSheen(litArgs_worldNormal, dViewDirW, litArgs_sheen_gloss);\n            #endif\n\n            // Fresnel has to be applied to reflections\n            addReflection(dReflDirW, litArgs_gloss);\n\n            #ifdef LIT_FRESNEL_MODEL\n\n                dReflection.rgb = dReflection.rgb * getFresnel(\n                    dot(dViewDirW, litArgs_worldNormal), \n                    litArgs_gloss, \n                    litArgs_specularity\n                #if defined(LIT_IRIDESCENCE)\n                    , iridescenceFresnel,\n                    litArgs_iridescence_intensity\n                #endif\n                    );\n\n            #else\n\n                dReflection.rgb = dReflection.rgb * litArgs_specularity;\n\n            #endif\n\n            #ifdef LIT_SPECULARITY_FACTOR\n                dReflection.rgb = dReflection.rgb * litArgs_specularityFactor;\n            #endif\n\n        #endif\n\n        #ifdef AREA_LIGHTS\n            // specular has to be accumulated differently if we want area lights to look correct\n            dSpecularLight = dSpecularLight * litArgs_specularity;\n\n            #ifdef LIT_SPECULAR\n                // evaluate material based area lights data, shared by all area lights\n                calcLTCLightValues(litArgs_gloss, litArgs_worldNormal, dViewDirW, litArgs_specularity, litArgs_clearcoat_gloss, litArgs_clearcoat_worldNormal, litArgs_clearcoat_specularity);\n            #endif\n        #endif\n        \n        // LOOP - evaluate all non-clustered lights\n        #include "lightEvaluationPS, LIGHT_COUNT"\n\n        // clustered lighting\n        #ifdef LIT_CLUSTERED_LIGHTS\n            addClusteredLights(litArgs_worldNormal, dViewDirW, dReflDirW,\n                #if defined(LIT_CLEARCOAT)\n                        ccReflDirW,\n                #endif\n                        litArgs_gloss, litArgs_specularity, dVertexNormalW, dTBN, \n                #if defined(LIT_IRIDESCENCE)\n                        iridescenceFresnel,\n                #endif\n                        litArgs_clearcoat_worldNormal, litArgs_clearcoat_gloss, litArgs_sheen_gloss, litArgs_iridescence_intensity\n            );\n        #endif\n\n        #ifdef AREA_LIGHTS\n\n            #ifdef LIT_CLEARCOAT\n                // specular has to be accumulated differently if we want area lights to look correct\n                litArgs_clearcoat_specularity = 1.0;\n            #endif\n\n            #ifdef LIT_SPECULAR\n                litArgs_specularity = vec3(1.0);\n            #endif\n\n        #endif\n\n        #ifdef LIT_REFRACTION\n            addRefraction(\n                litArgs_worldNormal, \n                dViewDirW, \n                litArgs_thickness, \n                litArgs_gloss, \n                litArgs_specularity, \n                litArgs_albedo, \n                litArgs_transmission,\n                litArgs_ior,\n                litArgs_dispersion\n                #if defined(LIT_IRIDESCENCE)\n                    , iridescenceFresnel, \n                    litArgs_iridescence_intensity\n                #endif\n            );\n        #endif\n    #endif\n\n    // apply ambient occlusion\n    #ifdef LIT_AO\n        #ifdef LIT_OCCLUDE_DIRECT\n            occludeDiffuse(litArgs_ao);\n        #endif\n\n        #if LIT_OCCLUDE_SPECULAR != NONE\n            occludeSpecular(litArgs_gloss, litArgs_ao, litArgs_worldNormal, dViewDirW);\n        #endif\n    #endif\n\n    #ifdef LIT_SPECULARITY_FACTOR\n        dSpecularLight = dSpecularLight * litArgs_specularityFactor;\n    #endif\n\n    #if !defined(LIT_OPACITY_FADES_SPECULAR)\n\n        #if LIT_BLEND_TYPE == NORMAL || LIT_BLEND_TYPE == PREMULTIPLIED\n\n            var specLum: f32 = dot((dSpecularLight + dReflection.rgb * dReflection.a), vec3f( 0.2126, 0.7152, 0.0722 ));\n            #ifdef LIT_CLEARCOAT\n                specLum = specLum + dot(ccSpecularLight * litArgs_clearcoat_specularity + ccReflection.rgb * litArgs_clearcoat_specularity, vec3f( 0.2126, 0.7152, 0.0722 ));\n            #endif\n            litArgs_opacity = clamp(litArgs_opacity + gammaCorrectInput(specLum), 0.0, 1.0);\n\n        #endif\n\n        litArgs_opacity = litArgs_opacity * material_alphaFade;\n\n    #endif\n\n    #include "endPS"\n    #include "outputAlphaPS"\n\n    #ifdef LIT_MSDF\n        output.color = applyMsdf(gl_FragColor);\n    #endif\n\n    #include "outputPS"\n    #include "debugOutputPS"\n\n    #ifdef LIT_SHADOW_CATCHER\n        // output when the shadow catcher is enabled - accumulated shadows\n        output.color = vec4f(dShadowCatcher, output.color.a);\n    #endif\n\n    return output;\n}\n';
            
            var litForwardDeclarationPS = '\n\n// globals\nvar<private> sReflection: vec3f;\nvar<private> dVertexNormalW: vec3f;\nvar<private> dTangentW: vec3f;\nvar<private> dBinormalW: vec3f;\nvar<private> dViewDirW: vec3f;\nvar<private> dReflDirW: vec3f;\nvar<private> ccReflDirW: vec3f;\n\n// Per-light temporaries\nvar<private> dLightDirNormW: vec3f;\nvar<private> dAtten: f32;\n\n// Outputs\nvar<private> dTBN: mat3x3f;\nvar<private> dReflection: vec4f;\nvar<private> dDiffuseLight: vec3f;\nvar<private> dSpecularLight: vec3f;\nvar<private> ccFresnel: f32;\nvar<private> ccReflection: vec3f;\nvar<private> ccSpecularLight: vec3f;\nvar<private> ccSpecularityNoFres: f32;\nvar<private> sSpecularLight: vec3f;\n\n// FRAGMENT SHADER INPUTS: UNIFORMS\n\n#ifdef LIT_DISPERSION\n    uniform material_dispersion: f32;\n#endif\n\n#ifndef LIT_OPACITY_FADES_SPECULAR\n    uniform material_alphaFade: f32;\n#endif\n\n#ifdef LIT_SSAO\n    var ssaoTexture : texture_2d<f32>;\n    var ssaoTextureSampler : sampler;\n    uniform ssaoTextureSizeInv: vec2f;\n#endif\n\n// lighting and shadowing declarations\n\n#ifdef LIT_SHADOW_CATCHER\n    // a variable to accumulate shadows for shadow catcher materials\n    var<private> dShadowCatcher: f32 = 1.0;\n#endif\n\n// LOOP - uniform declarations for all non-clustered lights\n#if LIGHT_COUNT > 0\n    #include "lightDeclarationPS, LIGHT_COUNT"\n#endif\n\n#ifdef LIT_SPECULAR\n    #if LIT_FRESNEL_MODEL == NONE && !defined(LIT_REFLECTIONS) && !defined(LIT_DIFFUSE_MAP) \n        #define LIT_OLD_AMBIENT\n    #endif\n#endif\n';
            
            var litForwardMainPS = '\n\n@fragment\nfn fragmentMain(input: FragmentInput) -> FragmentOutput {\n\n    dReflection = vec4f(0.0);\n\n    #ifdef LIT_CLEARCOAT\n        ccSpecularLight = vec3f(0.0);\n        ccReflection = vec3f(0.0);\n    #endif\n\n    #if LIT_NONE_SLICE_MODE == SLICED\n        #include "startNineSlicedPS"\n    #elif LIT_NONE_SLICE_MODE == TILED\n        #include "startNineSlicedTiledPS"\n    #endif\n\n    #ifdef LIT_NEEDS_NORMAL\n        dVertexNormalW = normalize(vNormalW);\n\n        #ifdef LIT_TANGENTS\n            #if defined(LIT_HEIGHTS) || defined(LIT_USE_NORMALS) || defined(LIT_USE_CLEARCOAT_NORMALS)\n                dTangentW = vTangentW;\n                dBinormalW = vBinormalW;\n            #endif\n        #endif\n\n        getViewDir();\n\n        #ifdef LIT_TBN\n            getTBN(dTangentW, dBinormalW, dVertexNormalW);\n\n            #ifdef LIT_TWO_SIDED_LIGHTING\n                handleTwoSidedLighting();\n            #endif\n        #endif\n    #endif\n\n    // invoke frontend functions\n    evaluateFrontend();\n\n    #include "debugProcessFrontendPS"\n\n    var output: FragmentOutput = evaluateBackend();\n\n    return output;\n}\n';
            
            var litForwardPostCodePS = '\n\n#ifdef LIT_NEEDS_NORMAL\n    #include "cubeMapRotatePS"\n    #include "cubeMapProjectPS"\n    #include "envProcPS"\n#endif\n\n// ----- specular or reflections -----\n#ifdef LIT_SPECULAR_OR_REFLECTION\n    #ifdef LIT_METALNESS\n        #include "metalnessModulatePS"\n    #endif\n\n    #if LIT_FRESNEL_MODEL == SCHLICK\n        #include "fresnelSchlickPS"\n    #endif\n\n    #ifdef LIT_IRIDESCENCE\n        #include "iridescenceDiffractionPS"\n    #endif\n#endif\n\n// ----- ambient occlusion -----\n#ifdef LIT_AO\n    #include "aoDiffuseOccPS"\n    #include "aoSpecOccPS"\n#endif\n\n#if LIT_REFLECTION_SOURCE == ENVATLASHQ\n    #include "envAtlasPS"\n    #include "reflectionEnvHQPS"\n#elif LIT_REFLECTION_SOURCE == ENVATLAS\n    #include "envAtlasPS"\n    #include "reflectionEnvPS"\n#elif LIT_REFLECTION_SOURCE == CUBEMAP\n    #include "reflectionCubePS"\n#elif LIT_REFLECTION_SOURCE == SPHEREMAP\n    #include "reflectionSpherePS"\n#endif\n\n#ifdef LIT_REFLECTIONS\n    #ifdef LIT_CLEARCOAT\n        #include "reflectionCCPS"\n    #endif\n\n    #ifdef LIT_SHEEN\n        #include "reflectionSheenPS"\n    #endif\n#endif\n\n#ifdef LIT_REFRACTION\n    #if defined(LIT_DYNAMIC_REFRACTION)\n        #include "refractionDynamicPS"\n    #elif defined(LIT_REFLECTIONS)\n        #include "refractionCubePS"\n    #endif\n#endif\n\n#ifdef LIT_SHEEN\n    #include "lightSheenPS"\n#endif\n\n#ifdef LIT_GGX_SPECULAR\n    uniform material_anisotropy: f32;\n#endif\n\nuniform material_ambient: vec3f;\n\n#ifdef LIT_SPECULAR\n    #ifdef LIT_LIGHTING\n        #ifdef LIT_GGX_SPECULAR\n            #include "lightSpecularAnisoGGXPS"\n        #else\n            #include "lightSpecularBlinnPS"\n        #endif\n    #endif\n#endif\n\n#include "combinePS"\n\n#ifdef LIT_LIGHTMAP\n    #include "lightmapAddPS"\n#endif\n\n#ifdef LIT_ADD_AMBIENT\n    #include "ambientPS"\n#endif\n\n#ifdef LIT_MSDF\n    #include "msdfPS"\n#endif\n\n#ifdef LIT_NEEDS_NORMAL\n    #include "viewDirPS"\n    #ifdef LIT_SPECULAR\n        #ifdef LIT_GGX_SPECULAR\n            #include "reflDirAnisoPS"\n        #else\n            #include "reflDirPS"\n        #endif\n    #endif\n#endif\n\n// lighting functionality\n#include "lightingPS"\n\n';
            
            var litForwardPreCodePS = '\n\n#include "basePS"\n#include "sphericalPS"\n#include "decodePS"\n#include "gammaPS"\n#include "tonemappingPS"\n#include "fogPS"\n\n// 9-slice support code\n#if LIT_NONE_SLICE_MODE == SLICED\n    #include "baseNineSlicedPS"\n#elif LIT_NONE_SLICE_MODE == TILED\n    #include "baseNineSlicedTiledPS"\n#endif\n\n// TBN\n#ifdef LIT_TBN\n    #include "TBNPS"\n\n    #ifdef LIT_TWO_SIDED_LIGHTING\n        #include "twoSidedLightingPS"\n    #endif\n#endif\n\n';
            
            var litMainVS = '\n#ifdef VERTEX_COLOR\n    attribute vertex_color: vec4f;\n#endif\n\n#ifdef NINESLICED\n\n    varying vMask: vec2f;\n    varying vTiledUv: vec2f;\n\n    uniform innerOffset: vec4f;\n    uniform outerScale: vec2f;\n    uniform atlasRect: vec4f;\n\n#endif\n\nvar<private> dPositionW: vec3f;\nvar<private> dModelMatrix: mat4x4f;\n\n#include "transformCoreVS"\n\n#ifdef UV0\n    attribute vertex_texCoord0: vec2f;\n    #include "uv0VS"\n#endif\n\n#ifdef UV1\n    attribute vertex_texCoord1: vec2f;\n    #include "uv1VS"\n#endif\n\n\n#ifdef LINEAR_DEPTH\n    #ifndef VIEWMATRIX\n    #define VIEWMATRIX\n        uniform matrix_view: mat4x4f;\n    #endif\n#endif\n\n#include "transformVS"\n\n#ifdef NORMALS\n    #include "normalCoreVS"\n    #include "normalVS"\n#endif\n\n#ifdef TANGENTS\n    attribute vertex_tangent: vec4f;\n    #include "tangentBinormalVS"\n#endif\n\n// expand uniforms for uv transforms\n#include "uvTransformUniformsPS, UV_TRANSFORMS_COUNT"\n\n#ifdef MSDF\n    #include "msdfVS"\n#endif\n\n@vertex\nfn vertexMain(input : VertexInput) -> VertexOutput {\n    var output : VertexOutput;\n    output.position = getPosition();\n    output.vPositionW = getWorldPosition();\n\n    #ifdef NORMALS\n        output.vNormalW = getNormal();\n    #endif\n\n    #ifdef TANGENTS\n        output.vTangentW = getTangent();\n        output.vBinormalW = getBinormal();\n    #elif defined(GGX_SPECULAR)\n        output.vObjectSpaceUpW = normalize(dNormalMatrix * vec3f(0.0, 1.0, 0.0));\n    #endif\n\n    #ifdef UV0\n        var uv0: vec2f = getUv0();\n        #ifdef UV0_UNMODIFIED\n            output.vUv0 = uv0;\n        #endif\n    #endif\n\n    #ifdef UV1\n        var uv1: vec2f = getUv1();\n        #ifdef UV1_UNMODIFIED\n            output.vUv1 = uv1;\n        #endif\n    #endif\n\n    // expand code for uv transforms\n    #include "uvTransformVS, UV_TRANSFORMS_COUNT"\n\n    #ifdef VERTEX_COLOR\n        output.vVertexColor = vertex_color;\n    #endif\n\n    #ifdef LINEAR_DEPTH\n        // linear depth from the worldPosition, see getLinearDepth\n        output.vLinearDepth = -(matrix_view * vec4f(vPositionW, 1.0)).z;\n    #endif\n\n    #ifdef MSDF\n        unpackMsdfParams();\n    #endif\n\n    return output;\n}\n';
            
            var litShaderArgsPS = "\n\n// Surface albedo absorbance\nvar<private> litArgs_albedo: vec3f;\n\n// Transparency\nvar<private> litArgs_opacity: f32;\n\n// Emission color\nvar<private> litArgs_emission: vec3f;\n\n// Normal direction in world space\nvar<private> litArgs_worldNormal: vec3f;\n\n// Ambient occlusion amount, range [0..1]\nvar<private> litArgs_ao: f32;\n\n// Light map color\nvar<private> litArgs_lightmap: vec3f;\n\n// Light map direction\nvar<private> litArgs_lightmapDir: vec3f;\n\n// Surface metalness factor, range [0..1]\nvar<private> litArgs_metalness: f32;\n\n// The f0 specularity factor\nvar<private> litArgs_specularity: vec3f;\n\n// Specularity intensity factor, range [0..1]\nvar<private> litArgs_specularityFactor: f32;\n\n// The microfacet glossiness factor, range [0..1]\nvar<private> litArgs_gloss: f32;\n\n// Glossiness of the sheen layer, range [0..1]\nvar<private> litArgs_sheen_gloss: f32;\n\n// The color of the f0 specularity factor for the sheen layer\nvar<private> litArgs_sheen_specularity: vec3f;\n\n// Transmission factor (refraction), range [0..1]\nvar<private> litArgs_transmission: f32;\n\n// Uniform thickness of medium, used by transmission, range [0..inf]\nvar<private> litArgs_thickness: f32;\n\n// Index of refraction\nvar<private> litArgs_ior: f32;\n\n// Dispersion, range [0..1] typically, but can be higher\nvar<private> litArgs_dispersion: f32;\n\n// Iridescence effect intensity, range [0..1]\nvar<private> litArgs_iridescence_intensity: f32;\n\n// Thickness of the iridescent microfilm layer, value is in nanometers, range [0..1000]\nvar<private> litArgs_iridescence_thickness: f32;\n\n// The normal used for the clearcoat layer\nvar<private> litArgs_clearcoat_worldNormal: vec3f;\n\n// Intensity of the clearcoat layer, range [0..1]\nvar<private> litArgs_clearcoat_specularity: f32;\n\n// Glossiness of clearcoat layer, range [0..1]\nvar<private> litArgs_clearcoat_gloss: f32;\n\n";
            
            var litShaderCorePS = '\n\n    // global texture bias for standard textures\n    #if LIT_NONE_SLICE_MODE == TILED\n        var<private> textureBias: f32 = -1000.0;\n    #else\n        uniform textureBias: f32;\n    #endif\n\n    #include "litShaderArgsPS"\n';
            
            var morphEvaluationPS = "\n    color += uniform.morphFactor[{i}].element * textureSampleLevel(morphBlendTex{i}, morphBlendTex{i}Sampler, input.uv0, 0).xyz;\n";
            
            var morphDeclarationPS = "\n    var morphBlendTex{i}: texture_2d<f32>;\n    var morphBlendTex{i}Sampler : sampler;\n";
            
            var morphPS = '\n\n    varying uv0: vec2f;\n\n    // LOOP - source morph target textures\n    #include "morphDeclarationPS, MORPH_TEXTURE_COUNT"\n\n    #if MORPH_TEXTURE_COUNT > 0\n        uniform morphFactor: array<f32, {MORPH_TEXTURE_COUNT}>;\n    #endif\n\n    @fragment\n    fn fragmentMain(input : FragmentInput) -> FragmentOutput {\n        var output: FragmentOutput;\n\n        var color = vec3f(0, 0, 0);\n\n        // LOOP - source morph target textures\n        #include "morphEvaluationPS, MORPH_TEXTURE_COUNT"\n\n        output.color = vec4f(color, 1.0);\n        return output;\n    }\n';
            
            var morphVS = "\n    attribute vertex_position: vec2f;\n    varying uv0: vec2f;\n\n    @vertex\n    fn vertexMain(input: VertexInput) -> VertexOutput {\n        var output: VertexOutput;\n        output.position = vec4f(input.vertex_position, 0.5, 1.0);\n        output.uv0 = input.vertex_position * 0.5 + vec2f(0.5, 0.5);\n        return output;\n    }\n";
            
            var normalCoreVS = "\nattribute vertex_normal: vec3f;\n#ifdef MORPHING_NORMAL\n	#ifdef MORPHING_INT\n		uniform morphNormalTex: texture_2d<u32>;\n		uniform morphNormalTexSampler: sampler;\n	#else\n		uniform morphNormalTex: texture_2d<f32>;\n		uniform morphNormalTexSampler: sampler;\n	#endif\n#endif\nfn getLocalNormal(vertexNormal: vec3f) -> vec3f {\n	var localNormal: vec3f = vertexNormal;\n	#ifdef MORPHING_NORMAL\n		let morphUV: vec2i = getTextureMorphCoords();\n		#ifdef MORPHING_INT\n			let morphNormalInt: vec4u = textureLoad(morphNormalTex, morphUV, 0);\n			let morphNormalF: vec3f = vec3f(morphNormalInt.xyz) / 65535.0 * 2.0 - 1.0;\n			localNormal = localNormal + morphNormalF;\n		#else\n			let morphNormal: vec3f = textureLoad(morphNormalTex, morphUV, 0).xyz;\n			localNormal = localNormal + morphNormal;\n		#endif\n	#endif\n	return localNormal;\n}\n#ifdef SKIN\n	fn getNormalMatrix(modelMatrix: mat4x4f) -> mat3x3f {\n		return mat3x3f(modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz);\n	}\n#elif defined(INSTANCING)\n	fn getNormalMatrix(modelMatrix: mat4x4f) -> mat3x3f {\n		return mat3x3f(modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz);\n	}\n#else\n	fn getNormalMatrix(modelMatrix: mat4x4f) -> mat3x3f {\n		return uniform.matrix_normal;\n	}\n#endif\n";
            
            var outputPS = "\n";
            
            var outputAlphaPS = "\n\n#if LIT_BLEND_TYPE == NORMAL || LIT_BLEND_TYPE == ADDITIVEALPHA || defined(LIT_ALPHA_TO_COVERAGE)\n\n    output.color = vec4f(output.color.rgb, litArgs_opacity);\n\n#elif LIT_BLEND_TYPE == PREMULTIPLIED\n\n    output.color = vec4f(output.color.rgb * litArgs_opacity, litArgs_opacity);\n\n#else\n\n    output.color = vec4f(output.color.rgb, 1.0);\n\n#endif\n";
            
            var reprojectPS = '\n\nvarying vUv0: vec2f;\n\n#ifdef CUBEMAP_SOURCE\n    var sourceCube: texture_cube<f32>;\n    var sourceCubeSampler : sampler;\n#else\n    var sourceTex: texture_2d<f32>;\n    var sourceTexSampler : sampler;\n#endif\n\n#ifdef USE_SAMPLES_TEX\n    // samples\n    var samplesTex: texture_2d<f32>;\n    var samplesTexSampler : sampler;\n    uniform samplesTexInverseSize: vec2f;\n#endif\n\n// params:\n// x - target cubemap face 0..6\n// y - target image total pixels\n// z - source cubemap size\nuniform params: vec3f;\n\nfn targetFace() -> f32 { return uniform.params.x; }\nfn targetTotalPixels() -> f32 { return uniform.params.y; }\nfn sourceTotalPixels() -> f32 { return uniform.params.z; }\n\nconst PI: f32 = 3.141592653589793;\n\nfn saturate(x: f32) -> f32 {\n    return clamp(x, 0.0, 1.0);\n}\n\n#include "decodePS"\n#include "encodePS"\n\n//-- supported projections\n\nfn modifySeams(dir: vec3f, scale: f32) -> vec3f {\n    let adir = abs(dir);\n    let M = max(max(adir.x, adir.y), adir.z);\n    return dir / M * vec3f(\n        select(scale, 1.0, adir.x == M),\n        select(scale, 1.0, adir.y == M),\n        select(scale, 1.0, adir.z == M)\n    );\n}\n\nfn toSpherical(dir: vec3f) -> vec2f {\n    let nonZeroXZ = any(dir.xz != vec2f(0.0, 0.0));\n    return vec2f(select(0.0, atan2(dir.x, dir.z), nonZeroXZ), asin(dir.y));\n}\n\nfn fromSpherical(uv: vec2f) -> vec3f {\n    return vec3f(cos(uv.y) * sin(uv.x),\n                sin(uv.y),\n                cos(uv.y) * cos(uv.x));\n}\n\nfn getDirectionEquirect(uv: vec2f) -> vec3f {\n    return fromSpherical((vec2f(uv.x, 1.0 - uv.y) * 2.0 - 1.0) * vec2f(PI, PI * 0.5));\n}\n\n// octahedral code, based on https://jcgt.org/published/0003/02/01/\n// "Survey of Efficient Representations for Independent Unit Vectors" by Cigolle, Donow, Evangelakos, Mara, McGuire, Meyer\n\nfn signNotZero(k: f32) -> f32 {\n    return select(-1.0, 1.0, k >= 0.0);\n}\n\nfn signNotZeroVec2(v: vec2f) -> vec2f {\n    return vec2f(signNotZero(v.x), signNotZero(v.y));\n}\n\n// Returns a unit vector. Argument o is an octahedral vector packed via octEncode, on the [-1, +1] square\nfn octDecode(o: vec2f) -> vec3f {\n    var v = vec3f(o.x, 1.0 - abs(o.x) - abs(o.y), o.y);\n    if (v.y < 0.0) {\n        var temp: vec2f = (1.0 - abs(v.zx)) * signNotZeroVec2(v.xz);\n        v = vec3f(temp.x, v.y, temp.y);\n    }\n    return normalize(v);\n}\n\nfn getDirectionOctahedral(uv: vec2f) -> vec3f {\n    return octDecode(vec2f(uv.x, 1.0 - uv.y) * 2.0 - 1.0);\n}\n\n// Assumes that v is a unit vector. The result is an octahedral vector on the [-1, +1] square\nfn octEncode(v: vec3f) -> vec2f {\n    let l1norm = abs(v.x) + abs(v.y) + abs(v.z);\n    var result = v.xz * (1.0 / l1norm);\n    if (v.y < 0.0) {\n        result = (1.0 - abs(result.yx)) * signNotZeroVec2(result.xy);\n    }\n    return result;\n}\n\n/////////////////////////////////////////////////////////////////////\n\n#ifdef CUBEMAP_SOURCE\n    fn sampleCubemapDir(dir: vec3f) -> vec4f {\n        return textureSample(sourceCube, sourceCubeSampler, modifySeams(dir, 1.0));\n    }\n\n    fn sampleCubemapSph(sph: vec2f) -> vec4f {\n        return sampleCubemapDir(fromSpherical(sph));\n    }\n\n    fn sampleCubemapDirLod(dir: vec3f, mipLevel: f32) -> vec4f {\n        return textureSampleLevel(sourceCube, sourceCubeSampler, modifySeams(dir, 1.0), mipLevel);\n    }\n\n    fn sampleCubemapSphLod(sph: vec2f, mipLevel: f32) -> vec4f {\n        return sampleCubemapDirLod(fromSpherical(sph), mipLevel);\n    }\n#else\n\n    fn sampleEquirectSph(sph: vec2f) -> vec4f {\n        let uv = sph / vec2f(PI * 2.0, PI) + 0.5;\n        return textureSample(sourceTex, sourceTexSampler, vec2f(uv.x, 1.0 - uv.y));\n    }\n\n    fn sampleEquirectDir(dir: vec3f) -> vec4f {\n        return sampleEquirectSph(toSpherical(dir));\n    }\n\n    fn sampleEquirectSphLod(sph: vec2f, mipLevel: f32) -> vec4f {\n        let uv = sph / vec2f(PI * 2.0, PI) + 0.5;\n        return textureSampleLevel(sourceTex, sourceTexSampler, vec2f(uv.x, 1.0 - uv.y), mipLevel);\n    }\n\n    fn sampleEquirectDirLod(dir: vec3f, mipLevel: f32) -> vec4f {\n        return sampleEquirectSphLod(toSpherical(dir), mipLevel);\n    }\n\n    fn sampleOctahedralDir(dir: vec3f) -> vec4f {\n        let uv = octEncode(dir) * 0.5 + 0.5;\n        return textureSample(sourceTex, sourceTexSampler, vec2f(uv.x, 1.0 - uv.y));\n    }\n\n    fn sampleOctahedralSph(sph: vec2f) -> vec4f {\n        return sampleOctahedralDir(fromSpherical(sph));\n    }\n\n    fn sampleOctahedralDirLod(dir: vec3f, mipLevel: f32) -> vec4f {\n        let uv = octEncode(dir) * 0.5 + 0.5;\n        return textureSampleLevel(sourceTex, sourceTexSampler, vec2f(uv.x, 1.0 - uv.y), mipLevel);\n    }\n\n    fn sampleOctahedralSphLod(sph: vec2f, mipLevel: f32) -> vec4f {\n        return sampleOctahedralDirLod(fromSpherical(sph), mipLevel);\n    }\n\n#endif\n\nfn getDirectionCubemap(uv: vec2f) -> vec3f {\n    let st = uv * 2.0 - 1.0;\n    let face = targetFace();\n\n    var vec: vec3f;\n    if (face == 0.0) {\n        vec = vec3f(1, -st.y, -st.x);\n    } else if (face == 1.0) {\n        vec = vec3f(-1, -st.y, st.x);\n    } else if (face == 2.0) {\n        vec = vec3f(st.x, 1, st.y);\n    } else if (face == 3.0) {\n        vec = vec3f(st.x, -1, -st.y);\n    } else if (face == 4.0) {\n        vec = vec3f(st.x, -st.y, 1);\n    } else {\n        vec = vec3f(-st.x, -st.y, -1);\n    }\n\n    return normalize(modifySeams(vec, 1.0));\n}\n\nfn matrixFromVector(n: vec3f) -> mat3x3f {\n    let a = 1.0 / (1.0 + n.z);\n    let b = -n.x * n.y * a;\n    let b1 = vec3f(1.0 - n.x * n.x * a, b, -n.x);\n    let b2 = vec3f(b, 1.0 - n.y * n.y * a, -n.y);\n    return mat3x3f(b1, b2, n);\n}\n\nfn matrixFromVectorSlow(n: vec3f) -> mat3x3f {\n    let up = select(vec3f(0.0, 0.0, select(-1.0, 1.0, n.y > 0.0)), vec3f(0.0, 1.0, 0.0), abs(n.y) > 0.0000001);\n    let x = normalize(cross(up, n));\n    let y = cross(n, x);\n    return mat3x3f(x, y, n);\n}\n\nfn reproject(uv: vec2f) -> vec4f {\n    if ({NUM_SAMPLES} <= 1) {\n        // single sample\n        return {ENCODE_FUNC}({DECODE_FUNC}({SOURCE_FUNC}Dir({TARGET_FUNC}(uv))));\n    } else {\n        // multi sample\n        let t = {TARGET_FUNC}(uv);\n        let tu = dpdx(t);\n        let tv = dpdy(t);\n\n        var result = vec3f(0.0);\n        for (var u = 0.0; u < {NUM_SAMPLES_SQRT}; u += 1.0) {\n            for (var v = 0.0; v < {NUM_SAMPLES_SQRT}; v += 1.0) {\n                result += {DECODE_FUNC}({SOURCE_FUNC}Dir(normalize(t +\n                                                            tu * (u / {NUM_SAMPLES_SQRT} - 0.5) +\n                                                            tv * (v / {NUM_SAMPLES_SQRT} - 0.5))));\n            }\n        }\n        return {ENCODE_FUNC}(result / ({NUM_SAMPLES_SQRT} * {NUM_SAMPLES_SQRT}));\n    }\n}\n\nconst unpackFloat: vec4f = vec4f(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);\n\n#ifdef USE_SAMPLES_TEX\n    fn unpackSample(i: i32, L: ptr<function, vec3f>, mipLevel: ptr<function, f32>) {\n        var u = (f32(i * 4) + 0.5) * uniform.samplesTexInverseSize.x;\n        var v = (floor(u) + 0.5) * uniform.samplesTexInverseSize.y;\n\n        var raw: vec4f;\n        raw.x = dot(textureSample(samplesTex, samplesTexSampler, vec2f(u, v)), unpackFloat); u += uniform.samplesTexInverseSize.x;\n        raw.y = dot(textureSample(samplesTex, samplesTexSampler, vec2f(u, v)), unpackFloat); u += uniform.samplesTexInverseSize.x;\n        raw.z = dot(textureSample(samplesTex, samplesTexSampler, vec2f(u, v)), unpackFloat); u += uniform.samplesTexInverseSize.x;\n        raw.w = dot(textureSample(samplesTex, samplesTexSampler, vec2f(u, v)), unpackFloat);\n\n        *L = raw.xyz * 2.0 - 1.0;\n        *mipLevel = raw.w * 8.0;\n    }\n\n    // convolve an environment given pre-generated samples\n    fn prefilterSamples(uv: vec2f) -> vec4f {\n        // construct vector space given target direction\n        let vecSpace = matrixFromVectorSlow({TARGET_FUNC}(uv));\n\n        var L: vec3f;\n        var mipLevel: f32;\n\n        var result = vec3f(0.0);\n        var totalWeight = 0.0;\n        for (var i = 0; i < {NUM_SAMPLES}; i += 1) {\n            unpackSample(i, &L, &mipLevel);\n            result += {DECODE_FUNC}({SOURCE_FUNC}DirLod(vecSpace * L, mipLevel)) * L.z;\n            totalWeight += L.z;\n        }\n\n        return {ENCODE_FUNC}(result / totalWeight);\n    }\n\n    // unweighted version of prefilterSamples\n    fn prefilterSamplesUnweighted(uv: vec2f) -> vec4f {\n        // construct vector space given target direction\n        let vecSpace = matrixFromVectorSlow({TARGET_FUNC}(uv));\n\n        var L: vec3f;\n        var mipLevel: f32;\n\n        var result = vec3f(0.0);\n        for (var i = 0; i < {NUM_SAMPLES}; i += 1) {\n            unpackSample(i, &L, &mipLevel);\n            result += {DECODE_FUNC}({SOURCE_FUNC}DirLod(vecSpace * L, mipLevel));\n        }\n\n        return {ENCODE_FUNC}(result / f32({NUM_SAMPLES}));\n    }\n#endif\n\n@fragment\nfn fragmentMain(input : FragmentInput) -> FragmentOutput {\n    var output: FragmentOutput;\n    output.color = {PROCESS_FUNC}(input.vUv0);\n    return output;\n}\n';
            
            var reprojectVS = "\nattribute vertex_position: vec2f;\nuniform uvMod: vec4f;\nvarying vUv0: vec2f;\n\n@vertex\nfn vertexMain(input: VertexInput) -> VertexOutput {\n  var output: VertexOutput;\n  output.position = vec4f(input.vertex_position, 0.5, 1.0);\n  output.vUv0 = getImageEffectUV((input.vertex_position * 0.5 + vec2f(0.5, 0.5)) * uniform.uvMod.xy + uniform.uvMod.zw);\n  return output;\n}\n";
            
            var skinVS = "\n\nattribute vertex_boneWeights: vec4f;\nattribute vertex_boneIndices: vec4f;\n\nvar texture_poseMap: texture_2d<f32>;\n\nstruct BoneMatrix {\n    v1: vec4f,\n    v2: vec4f,\n    v3: vec4f,\n}\n\nfn getBoneMatrix(width: i32, index: i32) -> BoneMatrix {\n\n    let v = index / width;\n    let u = index % width;\n\n    var result: BoneMatrix;\n    result.v1 = textureLoad(texture_poseMap, vec2i(u + 0, v), 0);\n    result.v2 = textureLoad(texture_poseMap, vec2i(u + 1, v), 0);\n    result.v3 = textureLoad(texture_poseMap, vec2i(u + 2, v), 0);\n    return result;\n}\n\nfn getSkinMatrix(indicesFloat: vec4f, weights: vec4f) -> mat4x4f {\n\n    let width = i32(textureDimensions(texture_poseMap).x);\n    var indices = vec4i(indicesFloat + 0.5) * 3;\n\n    let boneA = getBoneMatrix(width, indices.x);\n    let boneB = getBoneMatrix(width, indices.y);\n    let boneC = getBoneMatrix(width, indices.z);\n    let boneD = getBoneMatrix(width, indices.w);\n\n    // ... rest of getSkinMatrix remains the same ...\n    let v1 = boneA.v1 * weights.x + boneB.v1 * weights.y + boneC.v1 * weights.z + boneD.v1 * weights.w;\n    let v2 = boneA.v2 * weights.x + boneB.v2 * weights.y + boneC.v2 * weights.z + boneD.v2 * weights.w;\n    let v3 = boneA.v3 * weights.x + boneB.v3 * weights.y + boneC.v3 * weights.z + boneD.v3 * weights.w;\n\n    let one = dot(weights, vec4f(1.0, 1.0, 1.0, 1.0));\n\n    // transpose to 4x4 matrix\n    return mat4x4f(\n        v1.x, v2.x, v3.x, 0,\n        v1.y, v2.y, v3.y, 0,\n        v1.z, v2.z, v3.z, 0,\n        v1.w, v2.w, v3.w, one\n    );\n}\n";
            
            var skyboxPS = '\n    #define LIT_SKYBOX_INTENSITY\n\n    #include "envProcPS"\n    #include "gammaPS"\n    #include "tonemappingPS"\n\n    // Varying and uniform declarations\n    varying vViewDir : vec3f;\n    uniform skyboxHighlightMultiplier : f32;\n\n    #ifdef SKY_CUBEMAP\n\n        var texture_cubeMap : texture_cube<f32>;\n        var texture_cubeMap_sampler : sampler;\n\n        #ifdef SKYMESH\n            varying vWorldPos : vec3f;\n            uniform cubeMapRotationMatrix : mat3x3f;\n            uniform projectedSkydomeCenter : vec3f;\n        #endif\n\n    #else // env-atlas\n\n        #include "sphericalPS"\n        #include "envAtlasPS"\n\n        var texture_envAtlas : texture_2d<f32>;\n        var texture_envAtlas_sampler : sampler;\n\n        uniform mipLevel : f32;\n\n    #endif\n\n    @fragment\n    fn fragmentMain(input : FragmentInput) -> FragmentOutput {\n\n        var linear : vec3f;\n        var dir : vec3f;\n\n        #ifdef SKY_CUBEMAP\n\n            #ifdef SKYMESH\n                // get vector from world space pos to tripod origin\n                var envDir : vec3f = normalize(input.vWorldPos - uniform.projectedSkydomeCenter);\n                dir = envDir * uniform.cubeMapRotationMatrix;\n            #else\n                dir = input.vViewDir;\n            #endif\n\n            dir.x *= -1.0;\n            linear = {SKYBOX_DECODE_FNC}(textureSample(texture_cubeMap, texture_cubeMap_sampler, dir));\n\n        #else // env-atlas\n\n            dir = input.vViewDir * vec3f(-1.0, 1.0, 1.0);\n            let uv : vec2f = toSphericalUv(normalize(dir));\n            linear = {SKYBOX_DECODE_FNC}(textureSample(texture_envAtlas, texture_envAtlas_sampler, mapRoughnessUv(uv, uniform.mipLevel)));\n\n        #endif\n\n        // our HDR encodes values up to 64, so allow extra brightness for the clipped values\n        if (any(linear >= vec3f(64.0))) {\n            linear *= uniform.skyboxHighlightMultiplier;\n        }\n        \n        var output: FragmentOutput;\n        output.color = vec4f(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);\n        return output;\n    }\n';
            
            var skyboxVS = "\n    // Attribute\n    attribute aPosition : vec4f;\n\n    #ifndef VIEWMATRIX\n    #define VIEWMATRIX\n    uniform matrix_view : mat4x4f;\n    #endif\n\n    uniform matrix_projectionSkybox : mat4x4f;\n    uniform cubeMapRotationMatrix : mat3x3f;\n\n    varying vViewDir : vec3f;\n\n    #ifdef SKYMESH\n        uniform matrix_model : mat4x4f;\n        varying vWorldPos : vec3f;\n    #endif\n\n    @vertex\n    fn vertexMain(input : VertexInput) -> VertexOutput {\n\n        var output : VertexOutput;\n        var view : mat4x4f = uniform.matrix_view;\n\n        #ifdef SKYMESH\n\n            var worldPos : vec4f = uniform.matrix_model * input.aPosition;\n            output.vWorldPos = worldPos.xyz;\n            output.position = uniform.matrix_projectionSkybox * (view * worldPos);\n\n        #else\n\n            view[3][0] = 0.0;\n            view[3][1] = 0.0;\n            view[3][2] = 0.0;\n            output.position = uniform.matrix_projectionSkybox * (view * input.aPosition);\n            output.vViewDir = input.aPosition.xyz * uniform.cubeMapRotationMatrix;\n\n        #endif\n\n        // Force skybox to far Z, regardless of the clip planes on the camera\n        // Subtract a tiny fudge factor to ensure floating point errors don't\n        // still push pixels beyond far Z. See:\n        // https://community.khronos.org/t/skybox-problem/61857\n\n        output.position.z = output.position.w - 1.0e-7;\n\n        return output;\n    }\n";
            
            var sphericalPS = "\n\nfn toSpherical(dir: vec3f) -> vec2f {\n    let angle_xz = select(0.0, atan2(dir.x, dir.z), any(dir.xz != vec2f(0.0)));\n    return vec2f(angle_xz, asin(dir.y));\n}\n\nfn toSphericalUv(dir : vec3f) -> vec2f {\n    const PI : f32 = 3.141592653589793;\n    let uv : vec2f = toSpherical(dir) / vec2f(PI * 2.0, PI) + vec2f(0.5, 0.5);\n    return vec2f(uv.x, 1.0 - uv.y);\n}\n";
            
            var tonemappingPS = '\n#if (TONEMAP == NONE)\n    #include "tonemappingNonePS"\n#elif TONEMAP == FILMIC\n    #include "tonemappingFilmicPS"\n#elif TONEMAP == LINEAR\n    #include "tonemappingLinearPS"\n#elif TONEMAP == HEJL\n    #include "tonemappingHejlPS"\n#elif TONEMAP == ACES\n    #include "tonemappingAcesPS"\n#elif TONEMAP == ACES2\n    #include "tonemappingAces2PS"\n#elif TONEMAP == NEUTRAL\n    #include "tonemappingNeutralPS"\n#endif\n';
            
            var tonemappingAcesPS = "\nuniform exposure: f32;\n\nfn toneMap(color: vec3f) -> vec3f {\n    let tA: f32 = 2.51;\n    let tB: f32 = 0.03;\n    let tC: f32 = 2.43;\n    let tD: f32 = 0.59;\n    let tE: f32 = 0.14;\n    let x: vec3f = color * uniform.exposure;\n    return (x * (tA * x + tB)) / (x * (tC * x + tD) + tE);\n}\n";
            
            var tonemappingAces2PS = "\nuniform exposure: f32;\n\n// ACES approximation by Stephen Hill\n\n// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\nconst ACESInputMat: mat3x3f = mat3x3f(\n    vec3f(0.59719, 0.35458, 0.04823),\n    vec3f(0.07600, 0.90834, 0.01566),\n    vec3f(0.02840, 0.13383, 0.83777)\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst ACESOutputMat: mat3x3f = mat3x3f(\n    vec3f( 1.60475, -0.53108, -0.07367),\n    vec3f(-0.10208,  1.10813, -0.00605),\n    vec3f(-0.00327, -0.07276,  1.07602)\n);\n\nfn RRTAndODTFit(v: vec3f) -> vec3f {\n    let a: vec3f = v * (v + vec3f(0.0245786)) - vec3f(0.000090537);\n    let b: vec3f = v * (vec3f(0.983729) * v + vec3f(0.4329510)) + vec3f(0.238081);\n    return a / b;\n}\n\nfn toneMap(color: vec3f) -> vec3f {\n    var c: vec3f = color * (uniform.exposure / 0.6);\n    c = ACESInputMat * c;\n\n    // Apply RRT and ODT\n    c = RRTAndODTFit(c);\n    c = ACESOutputMat * c;\n\n    // Clamp to [0, 1]\n    return clamp(c, vec3f(0.0), vec3f(1.0));\n}\n";
            
            var tonemappingFilmicPS = "\nconst A: f32 = 0.15;\nconst B: f32 = 0.50;\nconst C: f32 = 0.10;\nconst D: f32 = 0.20;\nconst E: f32 = 0.02;\nconst F: f32 = 0.30;\nconst W: f32 = 11.2;\n\nuniform exposure: f32;\n\nfn uncharted2Tonemap(x: vec3f) -> vec3f {\n    return ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - vec3f(E / F);\n}\n\nfn toneMap(color: vec3f) -> vec3f {\n    var c: vec3f = uncharted2Tonemap(color * uniform.exposure);\n    let whiteScale: vec3f = vec3f(1.0) / uncharted2Tonemap(vec3f(W, W, W));\n    c *= whiteScale;\n    return c;\n}\n";
            
            var tonemappingHejlPS = "\nuniform exposure: f32;\n\nfn toneMap(color: vec3f) -> vec3f {\n    let A: f32 = 0.22;\n    let B: f32 = 0.3;\n    let C: f32 = 0.1;\n    let D: f32 = 0.2;\n    let E: f32 = 0.01;\n    let F: f32 = 0.3;\n    let Scl: f32 = 1.25;\n\n    let adjusted_color = color * uniform.exposure;\n    let h = max(vec3f(0.0), adjusted_color - vec3f(0.004));\n\n    return (h * ((Scl * A) * h + Scl * vec3f(C * B)) + Scl * vec3f(D * E)) /\n           (h * (A * h + vec3f(B)) + vec3f(D * F)) -\n           Scl * vec3f(E / F);\n}\n";
            
            var tonemappingLinearPS = "\nuniform exposure: f32;\n\nfn toneMap(color: vec3f) -> vec3f {\n    return color * uniform.exposure;\n}\n";
            
            var tonemappingNeutralPS = "\nuniform exposure: f32;\n\nfn toneMap(col: vec3f) -> vec3f {\n    var color = col * uniform.exposure;\n\n    let startCompression = 0.8 - 0.04;\n    let desaturation = 0.15;\n\n    let x = min(color.r, min(color.g, color.b));\n    let offset = select(0.04, x - 6.25 * x * x, x < 0.08);\n    color -= vec3f(offset);\n\n    let peak = max(color.r, max(color.g, color.b));\n    if (peak < startCompression) {\n        return color;\n    }\n\n    let d = 1.0 - startCompression;\n    let newPeak = 1.0 - d * d / (peak + d - startCompression);\n    color *= newPeak / peak;\n\n    let g = 1.0 - 1.0 / (desaturation * (peak - newPeak) + 1.0);\n    return mix(color, vec3f(newPeak), vec3f(g));\n}\n";
            
            var tonemappingNonePS = "\nfn toneMap(color: vec3f) -> vec3f {\n    return color;\n}\n";
            
            var transformVS = "\n#ifdef PIXELSNAP\n    uniform uScreenSize: vec4f;\n#endif\n\n#ifdef SCREENSPACE\n    uniform projectionFlipY: f32;\n#endif\n\nfn evalWorldPosition(vertexPosition: vec3f, modelMatrix: mat4x4f) -> vec4f {\n\n    var localPos: vec3f = getLocalPosition(vertexPosition);\n\n    #ifdef NINESLICED\n        // outer and inner vertices are at the same position, scale both\n        localPos.xz *= uniform.outerScale;\n\n        // offset inner vertices inside\n        // (original vertices must be in [-1;1] range)\n        let positiveUnitOffset: vec2f = clamp(vertexPosition.xz, vec2f(0.0), vec2f(1.0));\n        let negativeUnitOffset: vec2f = clamp(-vertexPosition.xz, vec2f(0.0), vec2f(1.0));\n        localPos.xz += (-positiveUnitOffset * uniform.innerOffset.xy + negativeUnitOffset * uniform.innerOffset.zw) * vertex_texCoord0.xy;\n\n        vTiledUv = (localPos.xz - outerScale + uniform.innerOffset.xy) * -0.5 + 1.0; // uv = local pos - inner corner\n\n        localPos.xz *= -0.5; // move from -1;1 to -0.5;0.5\n        localPos = localPos.xzy;\n    #endif\n\n    var posW: vec4f = modelMatrix * vec4f(localPos, 1.0);\n\n    #ifdef SCREENSPACE\n        posW.zw = vec2f(0.0, 1.0);\n    #endif\n\n    return posW;\n}\n\nfn getPosition() -> vec4f {\n\n    dModelMatrix = getModelMatrix();\n\n    let posW: vec4f = evalWorldPosition(vertex_position.xyz, dModelMatrix);\n    dPositionW = posW.xyz;\n\n    var screenPos: vec4f;\n    #ifdef UV1LAYOUT\n        screenPos = vec4f(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1.0);\n        screenPos.y *= -1.0;\n    #else\n        #ifdef SCREENSPACE\n            screenPos = posW;\n            screenPos.y *= uniforms.projectionFlipY;\n        #else\n            screenPos = uniform.matrix_viewProjection * posW;\n        #endif\n\n        #ifdef PIXELSNAP\n            // snap vertex to a pixel boundary\n            screenPos.xy = (screenPos.xy * 0.5) + 0.5;\n            screenPos.xy *= uniforms.uScreenSize.xy;\n            screenPos.xy = floor(screenPos.xy);\n            screenPos.xy *= uniforms.uScreenSize.zw;\n            screenPos.xy = (screenPos.xy * 2.0) - 1.0;\n        #endif\n    #endif\n\n    return screenPos;\n}\n\nfn getWorldPosition() -> vec3f {\n    return dPositionW;\n}\n";
            
            var transformCoreVS = '\n\n    attribute vertex_position: vec4f;\n\n    uniform matrix_viewProjection: mat4x4f;\n    uniform matrix_model: mat4x4f;\n    uniform matrix_normal: mat3x3f;\n\n    #ifdef MORPHING\n\n        uniform morph_tex_params: vec2f;\n        attribute morph_vertex_id: u32;\n\n        fn getTextureMorphCoords() -> vec2i {\n\n            // turn morph_vertex_id into int grid coordinates\n            var textureSize: vec2i = vec2i(uniform.morph_tex_params);\n            var morphGridV: i32 = i32(morph_vertex_id) / textureSize.x;\n            var morphGridU: i32 = i32(morph_vertex_id) - (morphGridV * textureSize.x);\n            morphGridV = textureSize.y - morphGridV - 1;\n            return vec2i(morphGridU, morphGridV);\n        }\n\n        #ifdef MORPHING_POSITION\n            #ifdef MORPHING_INT\n                uniform aabbSize: vec3f;\n                uniform aabbMin: vec3f;\n                var morphPositionTex: texture_2d<u32>;\n            #else\n                var morphPositionTex: texture_2d<f32>;\n            #endif\n        #endif\n    #endif\n\n    #ifdef defined(BATCH)\n        #include "skinBatchVS"\n\n        fn getModelMatrix() -> mat4x4f {\n            return getBoneMatrix(vertex_boneIndices);\n        }\n\n    #elif defined(SKIN)\n        #include "skinVS"\n        fn getModelMatrix() -> mat4x4f {\n            return uniform.matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);\n        }\n\n    #elif defined(INSTANCING)\n\n        #include "transformInstancingVS"\n\n    #else\n\n        fn getModelMatrix() -> mat4x4f {\n            return uniform.matrix_model;\n        }\n\n    #endif\n\n    fn getLocalPosition(vertexPosition: vec3f) -> vec3f {\n\n        var localPos: vec3f = vertexPosition;\n\n        #ifdef MORPHING_POSITION\n\n            var morphUV: vec2i = getTextureMorphCoords();\n\n            #ifdef MORPHING_INT\n                // Use textureLoad instead of texelFetch. Coordinates must be integer type (vec2i).\n                // WGSL requires explicit type conversion for vectors.\n                // Division by float literal ensures floating point division.\n                var morphPos: vec3f = vec3f(textureLoad(morphPositionTex, morphUV, 0).xyz) / 65535.0 * uniform.aabbSize + uniform.aabbMin;\n            #else\n                // Use textureLoad instead of texelFetch. Coordinates must be integer type (vec2i).\n                var morphPos: vec3f = textureLoad(morphPositionTex, morphUV, 0).xyz;\n            #endif\n\n            localPos += morphPos;\n\n        #endif\n\n        return localPos;\n    }\n';
            
            var uv0VS = "\n#ifdef NINESLICED\n    fn getUv0() -> vec2f {\n        var uv = vertex_position.xz;\n\n        // offset inner vertices inside\n        let positiveUnitOffset = clamp(vertex_position.xz, vec2f(0.0, 0.0), vec2f(1.0, 1.0));\n        let negativeUnitOffset = clamp(-vertex_position.xz, vec2f(0.0, 0.0), vec2f(1.0, 1.0));\n\n        uv = uv + ((-positiveUnitOffset * uniform.innerOffset.xy) + (negativeUnitOffset * uniform.innerOffset.zw)) * vertex_texCoord0.xy;\n\n        uv = uv * -0.5 + vec2f(0.5, 0.5);\n        uv = uv * uniform.atlasRect.zw + uniform.atlasRect.xy;\n\n        vMask = vertex_texCoord0.xy;\n\n        return uv;\n    }\n#else\n    fn getUv0() -> vec2f {\n        return vertex_texCoord0;\n    }\n#endif\n";
            
            var uv1VS = "\nfn getUv1() -> vec2f {\n    return vertex_texCoord1;\n}\n";
            
            var uvTransformVS = "\nvUV{TRANSFORM_UV_{i}}_{TRANSFORM_ID_{i}} = vec2f(\n    dot(vec3f(uv{TRANSFORM_UV_{i}}, 1), {TRANSFORM_NAME_{i}}0),\n    dot(vec3f(uv{TRANSFORM_UV_{i}}, 1), {TRANSFORM_NAME_{i}}1)\n);\n";
            
            var uvTransformUniformsPS = "\n    uniform {TRANSFORM_NAME_{i}}0: vec3f;\n    uniform {TRANSFORM_NAME_{i}}1: vec3f;\n";
            
            var shaderChunksWGSL = {
            		ambientPS,
            		basePS,
            		combinePS,
            		cookieBlit2DPS,
            		cookieBlitCubePS,
            		cookieBlitVS,
            		debugOutputPS,
            		debugProcessFrontendPS,
            		decodePS,
            		encodePS,
            		endPS,
            		envAtlasPS,
            		envProcPS,
            		fogPS,
            		gammaPS,
            		immediateLinePS,
            		immediateLineVS,
            		lightBufferDefinesPS: '',
            		lightingPS,
            		litForwardBackendPS,
            		litForwardDeclarationPS,
            		litForwardMainPS,
            		litForwardPostCodePS,
            		litForwardPreCodePS,
            		litMainVS,
            		litShaderArgsPS,
            		litShaderCorePS,
            		morphEvaluationPS,
            		morphDeclarationPS,
            		morphPS,
            		morphVS,
            		normalCoreVS,
            		outputPS,
            		outputAlphaPS,
            		reprojectPS,
            		reprojectVS,
            		skinVS,
            		skyboxPS,
            		skyboxVS,
            		sphericalPS,
            		tonemappingPS,
            		tonemappingAcesPS,
            		tonemappingAces2PS,
            		tonemappingFilmicPS,
            		tonemappingHejlPS,
            		tonemappingLinearPS,
            		tonemappingNeutralPS,
            		tonemappingNonePS,
            		transformVS,
            		transformCoreVS,
            		uv0VS,
            		uv1VS,
            		uvTransformVS,
            		uvTransformUniformsPS
            };
            
            var tempVec3$1 = new Vec3();
            var tempAreaLightSizes = new Float32Array(6);
            var areaHalfAxisWidth = new Vec3(-0.5, 0, 0);
            var areaHalfAxisHeight = new Vec3(0, 0, 0.5);
            var TextureIndexFloat = {
            		POSITION_RANGE: 0,
            		DIRECTION_FLAGS: 1,
            		COLOR_ANGLES_BIAS: 2,
            		PROJ_MAT_0: 3,
            		ATLAS_VIEWPORT: 3,
            		PROJ_MAT_1: 4,
            		PROJ_MAT_2: 5,
            		PROJ_MAT_3: 6,
            		AREA_DATA_WIDTH: 7,
            		AREA_DATA_HEIGHT: 8,
            		COUNT: 9
            };
            var enums = {
            		'{LIGHTSHAPE_PUNCTUAL}': "" + LIGHTSHAPE_PUNCTUAL + "u",
            		'{LIGHTSHAPE_RECT}': "" + LIGHTSHAPE_RECT + "u",
            		'{LIGHTSHAPE_DISK}': "" + LIGHTSHAPE_DISK + "u",
            		'{LIGHTSHAPE_SPHERE}': "" + LIGHTSHAPE_SPHERE + "u",
            		'{LIGHT_COLOR_DIVIDER}': "" + LIGHT_COLOR_DIVIDER + ".0"
            };
            var buildShaderDefines = (object, prefix)=>{
            		return Object.keys(object).map((key)=>"#define " + prefix + key + " " + object[key]).join('\n');
            };
            shaderChunks.lightBufferDefinesPS = shaderChunksWGSL.lightBufferDefinesPS = "\n\n    " + buildShaderDefines(TextureIndexFloat, 'CLUSTER_TEXTURE_') + "\n    " + buildShaderDefines(enums, '') + "\n";
            class LightsBuffer {
            		destroy() {
            				var _this_lightsTexture;
            				(_this_lightsTexture = this.lightsTexture) == null ? void 0 : _this_lightsTexture.destroy();
            				this.lightsTexture = null;
            		}
            		createTexture(device, width, height, format, name) {
            				var tex = new Texture(device, {
            						name: name,
            						width: width,
            						height: height,
            						mipmaps: false,
            						format: format,
            						addressU: ADDRESS_CLAMP_TO_EDGE,
            						addressV: ADDRESS_CLAMP_TO_EDGE,
            						type: TEXTURETYPE_DEFAULT,
            						magFilter: FILTER_NEAREST,
            						minFilter: FILTER_NEAREST,
            						anisotropy: 1
            				});
            				return tex;
            		}
            		setBounds(min, delta) {
            				this.boundsMin.copy(min);
            				this.boundsDelta.copy(delta);
            		}
            		uploadTextures() {
            				this.lightsTexture.lock().set(this.lightsFloat);
            				this.lightsTexture.unlock();
            		}
            		updateUniforms() {
            				this._lightsTextureId.setValue(this.lightsTexture);
            		}
            		getSpotDirection(direction, spot) {
            				var mat = spot._node.getWorldTransform();
            				mat.getY(direction).mulScalar(-1);
            				direction.normalize();
            		}
            		getLightAreaSizes(light) {
            				var mat = light._node.getWorldTransform();
            				mat.transformVector(areaHalfAxisWidth, tempVec3$1);
            				tempAreaLightSizes[0] = tempVec3$1.x;
            				tempAreaLightSizes[1] = tempVec3$1.y;
            				tempAreaLightSizes[2] = tempVec3$1.z;
            				mat.transformVector(areaHalfAxisHeight, tempVec3$1);
            				tempAreaLightSizes[3] = tempVec3$1.x;
            				tempAreaLightSizes[4] = tempVec3$1.y;
            				tempAreaLightSizes[5] = tempVec3$1.z;
            				return tempAreaLightSizes;
            		}
            		addLightData(light, lightIndex) {
            				var isSpot = light._type === LIGHTTYPE_SPOT;
            				var hasAtlasViewport = light.atlasViewportAllocated;
            				var isCookie = this.cookiesEnabled && !!light._cookie && hasAtlasViewport;
            				var isArea = this.areaLightsEnabled && light.shape !== LIGHTSHAPE_PUNCTUAL;
            				var castShadows = this.shadowsEnabled && light.castShadows && hasAtlasViewport;
            				var pos = light._node.getPosition();
            				var lightProjectionMatrix = null;
            				var atlasViewport = null;
            				if (isSpot) {
            						if (castShadows) {
            								var lightRenderData = light.getRenderData(null, 0);
            								lightProjectionMatrix = lightRenderData.shadowMatrix;
            						} else if (isCookie) {
            								lightProjectionMatrix = LightCamera.evalSpotCookieMatrix(light);
            						}
            				} else {
            						if (castShadows || isCookie) {
            								atlasViewport = light.atlasViewport;
            						}
            				}
            				var dataFloat = this.lightsFloat;
            				var dataUint = this.lightsUint;
            				var dataFloatStart = lightIndex * this.lightsTexture.width * 4;
            				dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 0] = pos.x;
            				dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 1] = pos.y;
            				dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 2] = pos.z;
            				dataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 3] = light.attenuationEnd;
            				var clusteredData = light.clusteredData;
            				dataUint[dataFloatStart + 4 * TextureIndexFloat.COLOR_ANGLES_BIAS + 0] = clusteredData[0];
            				dataUint[dataFloatStart + 4 * TextureIndexFloat.COLOR_ANGLES_BIAS + 1] = clusteredData[1];
            				dataUint[dataFloatStart + 4 * TextureIndexFloat.COLOR_ANGLES_BIAS + 2] = clusteredData[2];
            				if (light.castShadows) {
            						var lightRenderData1 = light.getRenderData(null, 0);
            						var biases = light._getUniformBiasValues(lightRenderData1);
            						var biasHalf = FloatPacking.float2Half(biases.bias);
            						var normalBiasHalf = FloatPacking.float2Half(biases.normalBias);
            						dataUint[dataFloatStart + 4 * TextureIndexFloat.COLOR_ANGLES_BIAS + 3] = biasHalf | normalBiasHalf << 16;
            				}
            				if (isSpot) {
            						this.getSpotDirection(tempVec3$1, light);
            						dataFloat[dataFloatStart + 4 * TextureIndexFloat.DIRECTION_FLAGS + 0] = tempVec3$1.x;
            						dataFloat[dataFloatStart + 4 * TextureIndexFloat.DIRECTION_FLAGS + 1] = tempVec3$1.y;
            						dataFloat[dataFloatStart + 4 * TextureIndexFloat.DIRECTION_FLAGS + 2] = tempVec3$1.z;
            				}
            				dataUint[dataFloatStart + 4 * TextureIndexFloat.DIRECTION_FLAGS + 3] = light.getClusteredFlags(castShadows, isCookie);
            				if (lightProjectionMatrix) {
            						var matData = lightProjectionMatrix.data;
            						for(var m = 0; m < 16; m++){
            								dataFloat[dataFloatStart + 4 * TextureIndexFloat.PROJ_MAT_0 + m] = matData[m];
            						}
            				}
            				if (atlasViewport) {
            						dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 0] = atlasViewport.x;
            						dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 1] = atlasViewport.y;
            						dataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 2] = atlasViewport.z / 3;
            				}
            				if (isArea) {
            						var areaSizes = this.getLightAreaSizes(light);
            						dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 0] = areaSizes[0];
            						dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 1] = areaSizes[1];
            						dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 2] = areaSizes[2];
            						dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 0] = areaSizes[3];
            						dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 1] = areaSizes[4];
            						dataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 2] = areaSizes[5];
            				}
            		}
            		constructor(device){
            				this.areaLightsEnabled = false;
            				this.device = device;
            				this.cookiesEnabled = false;
            				this.shadowsEnabled = false;
            				this.areaLightsEnabled = false;
            				this.maxLights = 255;
            				var pixelsPerLightFloat = TextureIndexFloat.COUNT;
            				this.lightsFloat = new Float32Array(4 * pixelsPerLightFloat * this.maxLights);
            				this.lightsUint = new Uint32Array(this.lightsFloat.buffer);
            				this.lightsTexture = this.createTexture(this.device, pixelsPerLightFloat, this.maxLights, PIXELFORMAT_RGBA32F, 'LightsTexture');
            				this._lightsTextureId = this.device.scope.resolve('lightsTexture');
            				this.invMaxColorValue = 0;
            				this.invMaxAttenuation = 0;
            				this.boundsMin = new Vec3();
            				this.boundsDelta = new Vec3();
            		}
            }
            
            var tempVec3 = new Vec3();
            var tempMin3 = new Vec3();
            var tempMax3 = new Vec3();
            var tempBox = new BoundingBox();
            class ClusterLight {
            		constructor(){
            				this.light = null;
            				this.min = new Vec3();
            				this.max = new Vec3();
            		}
            }
            class WorldClusters {
            		set maxCellLightCount(count) {
            				if (count !== this._maxCellLightCount) {
            						this._maxCellLightCount = count;
            						this._cellsDirty = true;
            				}
            		}
            		get maxCellLightCount() {
            				return this._maxCellLightCount;
            		}
            		set cells(value) {
            				tempVec3.copy(value).floor();
            				if (!this._cells.equals(tempVec3)) {
            						this._cells.copy(tempVec3);
            						this._cellsLimit.copy(tempVec3).sub(Vec3.ONE);
            						this._cellsDirty = true;
            				}
            		}
            		get cells() {
            				return this._cells;
            		}
            		destroy() {
            				this.lightsBuffer.destroy();
            				this.releaseClusterTexture();
            		}
            		releaseClusterTexture() {
            				if (this.clusterTexture) {
            						this.clusterTexture.destroy();
            						this.clusterTexture = null;
            				}
            		}
            		registerUniforms(device) {
            				this._clusterSkipId = device.scope.resolve('clusterSkip');
            				this._clusterMaxCellsId = device.scope.resolve('clusterMaxCells');
            				this._clusterWorldTextureId = device.scope.resolve('clusterWorldTexture');
            				this._clusterTextureSizeId = device.scope.resolve('clusterTextureSize');
            				this._clusterTextureSizeData = new Float32Array(3);
            				this._clusterBoundsMinId = device.scope.resolve('clusterBoundsMin');
            				this._clusterBoundsMinData = new Float32Array(3);
            				this._clusterBoundsDeltaId = device.scope.resolve('clusterBoundsDelta');
            				this._clusterBoundsDeltaData = new Float32Array(3);
            				this._clusterCellsCountByBoundsSizeId = device.scope.resolve('clusterCellsCountByBoundsSize');
            				this._clusterCellsCountByBoundsSizeData = new Float32Array(3);
            				this._clusterCellsDotId = device.scope.resolve('clusterCellsDot');
            				this._clusterCellsDotData = new Float32Array(3);
            				this._clusterCellsMaxId = device.scope.resolve('clusterCellsMax');
            				this._clusterCellsMaxData = new Float32Array(3);
            		}
            		updateParams(lightingParams) {
            				if (lightingParams) {
            						this.cells = lightingParams.cells;
            						this.maxCellLightCount = lightingParams.maxLightsPerCell;
            						this.lightsBuffer.cookiesEnabled = lightingParams.cookiesEnabled;
            						this.lightsBuffer.shadowsEnabled = lightingParams.shadowsEnabled;
            						this.lightsBuffer.areaLightsEnabled = lightingParams.areaLightsEnabled;
            				}
            		}
            		updateCells() {
            				if (this._cellsDirty) {
            						this._cellsDirty = false;
            						var cx = this._cells.x;
            						var cy = this._cells.y;
            						var cz = this._cells.z;
            						var numCells = cx * cy * cz;
            						var totalPixels = this.maxCellLightCount * numCells;
            						var width = Math.ceil(Math.sqrt(totalPixels));
            						width = math.roundUp(width, this.maxCellLightCount);
            						var height = Math.ceil(totalPixels / width);
            						this._clusterCellsMaxData[0] = cx;
            						this._clusterCellsMaxData[1] = cy;
            						this._clusterCellsMaxData[2] = cz;
            						this._clusterCellsDotData[0] = this.maxCellLightCount;
            						this._clusterCellsDotData[1] = cx * cz * this.maxCellLightCount;
            						this._clusterCellsDotData[2] = cx * this.maxCellLightCount;
            						this.clusters = new Uint8ClampedArray(totalPixels);
            						this.counts = new Int32Array(numCells);
            						this._clusterTextureSizeData[0] = width;
            						this._clusterTextureSizeData[1] = 1.0 / width;
            						this._clusterTextureSizeData[2] = 1.0 / height;
            						this.releaseClusterTexture();
            						this.clusterTexture = this.lightsBuffer.createTexture(this.device, width, height, PIXELFORMAT_R8, 'ClusterTexture');
            				}
            		}
            		uploadTextures() {
            				this.clusterTexture.lock().set(this.clusters);
            				this.clusterTexture.unlock();
            				this.lightsBuffer.uploadTextures();
            		}
            		updateUniforms() {
            				this._clusterSkipId.setValue(this._usedLights.length > 1 ? 0 : 1);
            				this.lightsBuffer.updateUniforms();
            				this._clusterWorldTextureId.setValue(this.clusterTexture);
            				this._clusterMaxCellsId.setValue(this.maxCellLightCount);
            				var boundsDelta = this.boundsDelta;
            				this._clusterCellsCountByBoundsSizeData[0] = this._cells.x / boundsDelta.x;
            				this._clusterCellsCountByBoundsSizeData[1] = this._cells.y / boundsDelta.y;
            				this._clusterCellsCountByBoundsSizeData[2] = this._cells.z / boundsDelta.z;
            				this._clusterCellsCountByBoundsSizeId.setValue(this._clusterCellsCountByBoundsSizeData);
            				this._clusterBoundsMinData[0] = this.boundsMin.x;
            				this._clusterBoundsMinData[1] = this.boundsMin.y;
            				this._clusterBoundsMinData[2] = this.boundsMin.z;
            				this._clusterBoundsDeltaData[0] = boundsDelta.x;
            				this._clusterBoundsDeltaData[1] = boundsDelta.y;
            				this._clusterBoundsDeltaData[2] = boundsDelta.z;
            				this._clusterTextureSizeId.setValue(this._clusterTextureSizeData);
            				this._clusterBoundsMinId.setValue(this._clusterBoundsMinData);
            				this._clusterBoundsDeltaId.setValue(this._clusterBoundsDeltaData);
            				this._clusterCellsDotId.setValue(this._clusterCellsDotData);
            				this._clusterCellsMaxId.setValue(this._clusterCellsMaxData);
            		}
            		evalLightCellMinMax(clusteredLight, min, max) {
            				min.copy(clusteredLight.min);
            				min.sub(this.boundsMin);
            				min.div(this.boundsDelta);
            				min.mul2(min, this.cells);
            				min.floor();
            				max.copy(clusteredLight.max);
            				max.sub(this.boundsMin);
            				max.div(this.boundsDelta);
            				max.mul2(max, this.cells);
            				max.ceil();
            				min.max(Vec3.ZERO);
            				max.min(this._cellsLimit);
            		}
            		collectLights(lights) {
            				var maxLights = this.lightsBuffer.maxLights;
            				var usedLights = this._usedLights;
            				var lightIndex = 1;
            				lights.forEach((light)=>{
            						var runtimeLight = !!(light.mask & (MASK_AFFECT_DYNAMIC | MASK_AFFECT_LIGHTMAPPED));
            						var zeroAngleSpotlight = light.type === LIGHTTYPE_SPOT && light._outerConeAngle === 0;
            						if (light.enabled && light.type !== LIGHTTYPE_DIRECTIONAL && light.visibleThisFrame && light.intensity > 0 && runtimeLight && !zeroAngleSpotlight) {
            								if (lightIndex < maxLights) {
            										var clusteredLight;
            										if (lightIndex < usedLights.length) {
            												clusteredLight = usedLights[lightIndex];
            										} else {
            												clusteredLight = new ClusterLight();
            												usedLights.push(clusteredLight);
            										}
            										clusteredLight.light = light;
            										light.getBoundingBox(tempBox);
            										clusteredLight.min.copy(tempBox.getMin());
            										clusteredLight.max.copy(tempBox.getMax());
            										lightIndex++;
            								}
            						}
            				});
            				usedLights.length = lightIndex;
            		}
            		evaluateBounds() {
            				var usedLights = this._usedLights;
            				var min = this.boundsMin;
            				var max = this.boundsMax;
            				if (usedLights.length > 1) {
            						min.copy(usedLights[1].min);
            						max.copy(usedLights[1].max);
            						for(var i = 2; i < usedLights.length; i++){
            								min.min(usedLights[i].min);
            								max.max(usedLights[i].max);
            						}
            				} else {
            						min.set(0, 0, 0);
            						max.set(1, 1, 1);
            				}
            				this.boundsDelta.sub2(max, min);
            				this.lightsBuffer.setBounds(min, this.boundsDelta);
            		}
            		updateClusters(lightingParams) {
            				this.counts.fill(0);
            				this.clusters.fill(0);
            				this.lightsBuffer.areaLightsEnabled = lightingParams ? lightingParams.areaLightsEnabled : false;
            				var divX = this._cells.x;
            				var divZ = this._cells.z;
            				var counts = this.counts;
            				var limit = this._maxCellLightCount;
            				var clusters = this.clusters;
            				var pixelsPerCellCount = this.maxCellLightCount;
            				var usedLights = this._usedLights;
            				for(var i = 1; i < usedLights.length; i++){
            						var clusteredLight = usedLights[i];
            						var light = clusteredLight.light;
            						this.lightsBuffer.addLightData(light, i);
            						this.evalLightCellMinMax(clusteredLight, tempMin3, tempMax3);
            						var xStart = tempMin3.x;
            						var xEnd = tempMax3.x;
            						var yStart = tempMin3.y;
            						var yEnd = tempMax3.y;
            						var zStart = tempMin3.z;
            						var zEnd = tempMax3.z;
            						for(var x = xStart; x <= xEnd; x++){
            								for(var z = zStart; z <= zEnd; z++){
            										for(var y = yStart; y <= yEnd; y++){
            												var clusterIndex = x + divX * (z + y * divZ);
            												var count = counts[clusterIndex];
            												if (count < limit) {
            														clusters[pixelsPerCellCount * clusterIndex + count] = i;
            														counts[clusterIndex] = count + 1;
            												}
            										}
            								}
            						}
            				}
            		}
            		update(lights, lightingParams) {
            				if (lightingParams === void 0) lightingParams = null;
            				this.updateParams(lightingParams);
            				this.updateCells();
            				this.collectLights(lights);
            				this.evaluateBounds();
            				this.updateClusters(lightingParams);
            				this.uploadTextures();
            		}
            		activate() {
            				this.updateUniforms();
            		}
            		constructor(device){
            				this.device = device;
            				this.name = 'Untitled';
            				this.reportCount = 0;
            				this.boundsMin = new Vec3();
            				this.boundsMax = new Vec3();
            				this.boundsDelta = new Vec3();
            				this._cells = new Vec3(1, 1, 1);
            				this._cellsLimit = new Vec3();
            				this.cells = this._cells;
            				this.maxCellLightCount = 4;
            				this._usedLights = [];
            				this._usedLights.push(new ClusterLight());
            				this.lightsBuffer = new LightsBuffer(device);
            				this.registerUniforms(device);
            		}
            }
            
            var base64String = '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';
            var data = null;
            var initData = ()=>{
            		if (!data) {
            				var binaryString = atob(base64String);
            				data = Uint8Array.from(binaryString, (char)=>char.charCodeAt(0));
            		}
            };
            var blueNoiseData = ()=>{
            		initData();
            		return data;
            };
            class BlueNoise {
            		_next() {
            				this.seed = (this.seed + 4) % data.length;
            		}
            		value() {
            				this._next();
            				return data[this.seed] / 255;
            		}
            		vec4(dest) {
            				if (dest === void 0) dest = new Vec4();
            				this._next();
            				return dest.set(data[this.seed], data[this.seed + 1], data[this.seed + 2], data[this.seed + 3]).mulScalar(1 / 255);
            		}
            		constructor(seed = 0){
            				this.seed = 0;
            				this.seed = seed * 4;
            				initData();
            		}
            }
            
            var lightCubeDir = [
            		new Vec3(-1, 0, 0),
            		new Vec3(1, 0, 0),
            		new Vec3(0, -1, 0),
            		new Vec3(0, 1, 0),
            		new Vec3(0, 0, -1),
            		new Vec3(0, 0, 1)
            ];
            class LightCube {
            		update(ambientLight, lights) {
            				var colors = this.colors;
            				var { r, g, b } = ambientLight;
            				for(var j = 0; j < 6; j++){
            						colors[j * 3] = r;
            						colors[j * 3 + 1] = g;
            						colors[j * 3 + 2] = b;
            				}
            				for(var j1 = 0; j1 < lights.length; j1++){
            						var light = lights[j1];
            						if (light._type === LIGHTTYPE_DIRECTIONAL) {
            								for(var c = 0; c < 6; c++){
            										var weight = Math.max(lightCubeDir[c].dot(light._direction), 0) * light._intensity;
            										var lightColor = light._color;
            										colors[c * 3] += lightColor.r * weight;
            										colors[c * 3 + 1] += lightColor.g * weight;
            										colors[c * 3 + 2] += lightColor.b * weight;
            								}
            						}
            				}
            		}
            		constructor(){
            				this.colors = new Float32Array(6 * 3);
            		}
            }
            
            var createTexture = (device, namePrefix, size, data)=>{
            		var texture = new Texture(device, {
            				name: "" + namePrefix + size,
            				width: size,
            				height: size,
            				format: PIXELFORMAT_RGBA8,
            				addressU: ADDRESS_REPEAT,
            				addressV: ADDRESS_REPEAT,
            				type: TEXTURETYPE_DEFAULT,
            				magFilter: FILTER_NEAREST,
            				minFilter: FILTER_NEAREST,
            				anisotropy: 1,
            				mipmaps: false
            		});
            		texture.lock().set(data);
            		texture.unlock();
            		return texture;
            };
            var deviceCacheBlueNoise = new DeviceCache();
            var getBlueNoiseTexture = (device)=>{
            		return deviceCacheBlueNoise.get(device, ()=>{
            				var data = blueNoiseData();
            				var size = Math.sqrt(data.length / 4);
            				return createTexture(device, 'BlueNoise', size, data);
            		});
            };
            
            class ShadowMap {
            		destroy() {
            				if (this.texture) {
            						this.texture.destroy();
            						this.texture = null;
            				}
            				var targets = this.renderTargets;
            				for(var i = 0; i < targets.length; i++){
            						targets[i].destroy();
            				}
            				this.renderTargets.length = 0;
            		}
            		static create(device, light) {
            				var shadowMap = null;
            				if (light._type === LIGHTTYPE_OMNI) {
            						shadowMap = this.createCubemap(device, light._shadowResolution, light._shadowType);
            				} else {
            						shadowMap = this.create2dMap(device, light._shadowResolution, light._shadowType);
            				}
            				return shadowMap;
            		}
            		static createAtlas(device, resolution, shadowType) {
            				var shadowMap = this.create2dMap(device, resolution, shadowType);
            				var targets = shadowMap.renderTargets;
            				var rt = targets[0];
            				for(var i = 0; i < 5; i++){
            						targets.push(rt);
            				}
            				return shadowMap;
            		}
            		static create2dMap(device, size, shadowType) {
            				var _pixelFormatInfo_get;
            				var shadowInfo = shadowTypeInfo.get(shadowType);
            				var format = shadowInfo.format;
            				if (format === PIXELFORMAT_R32F && !device.textureFloatRenderable && device.textureHalfFloatRenderable) {
            						format = PIXELFORMAT_R16F;
            				}
            				var formatName = (_pixelFormatInfo_get = pixelFormatInfo.get(format)) == null ? void 0 : _pixelFormatInfo_get.name;
            				var filter = FILTER_LINEAR;
            				if (shadowType === SHADOW_VSM_32F) {
            						filter = device.extTextureFloatLinear ? FILTER_LINEAR : FILTER_NEAREST;
            				}
            				if (shadowType === SHADOW_PCSS_32F) {
            						filter = FILTER_NEAREST;
            				}
            				var texture = new Texture(device, {
            						format: format,
            						width: size,
            						height: size,
            						mipmaps: false,
            						minFilter: filter,
            						magFilter: filter,
            						addressU: ADDRESS_CLAMP_TO_EDGE,
            						addressV: ADDRESS_CLAMP_TO_EDGE,
            						name: "ShadowMap2D_" + formatName
            				});
            				var target = null;
            				if (shadowInfo == null ? void 0 : shadowInfo.pcf) {
            						texture.compareOnRead = true;
            						texture.compareFunc = FUNC_LESS;
            						target = new RenderTarget({
            								depthBuffer: texture
            						});
            				} else {
            						target = new RenderTarget({
            								colorBuffer: texture,
            								depth: true
            						});
            				}
            				if (device.isWebGPU) {
            						target.flipY = true;
            				}
            				return new ShadowMap(texture, [
            						target
            				]);
            		}
            		static createCubemap(device, size, shadowType) {
            				var _pixelFormatInfo_get;
            				var shadowInfo = shadowTypeInfo.get(shadowType);
            				var formatName = (_pixelFormatInfo_get = pixelFormatInfo.get(shadowInfo.format)) == null ? void 0 : _pixelFormatInfo_get.name;
            				var isPcss = shadowType === SHADOW_PCSS_32F;
            				var filter = isPcss ? FILTER_NEAREST : FILTER_LINEAR;
            				var cubemap = new Texture(device, {
            						format: shadowInfo == null ? void 0 : shadowInfo.format,
            						width: size,
            						height: size,
            						cubemap: true,
            						mipmaps: false,
            						minFilter: filter,
            						magFilter: filter,
            						addressU: ADDRESS_CLAMP_TO_EDGE,
            						addressV: ADDRESS_CLAMP_TO_EDGE,
            						name: "ShadowMapCube_" + formatName
            				});
            				if (!isPcss) {
            						cubemap.compareOnRead = true;
            						cubemap.compareFunc = FUNC_LESS;
            				}
            				var targets = [];
            				for(var i = 0; i < 6; i++){
            						if (isPcss) {
            								targets.push(new RenderTarget({
            										colorBuffer: cubemap,
            										face: i,
            										depth: true
            								}));
            						} else {
            								targets.push(new RenderTarget({
            										depthBuffer: cubemap,
            										face: i
            								}));
            						}
            				}
            				return new ShadowMap(cubemap, targets);
            		}
            		constructor(texture, targets){
            				this.texture = texture;
            				this.cached = false;
            				this.renderTargets = targets;
            		}
            }
            
            var _tempArray = [];
            var _tempArray2 = [];
            var _viewport$1 = new Vec4();
            var _scissor = new Vec4();
            class Slot {
            		constructor(rect){
            				this.size = Math.floor(rect.w * 1024);
            				this.used = false;
            				this.lightId = -1;
            				this.rect = rect;
            		}
            }
            class LightTextureAtlas {
            		destroy() {
            				this.destroyShadowAtlas();
            				this.destroyCookieAtlas();
            		}
            		destroyShadowAtlas() {
            				var _this_shadowAtlas;
            				(_this_shadowAtlas = this.shadowAtlas) == null ? void 0 : _this_shadowAtlas.destroy();
            				this.shadowAtlas = null;
            		}
            		destroyCookieAtlas() {
            				var _this_cookieAtlas, _this_cookieRenderTarget;
            				(_this_cookieAtlas = this.cookieAtlas) == null ? void 0 : _this_cookieAtlas.destroy();
            				this.cookieAtlas = null;
            				(_this_cookieRenderTarget = this.cookieRenderTarget) == null ? void 0 : _this_cookieRenderTarget.destroy();
            				this.cookieRenderTarget = null;
            		}
            		allocateShadowAtlas(resolution, shadowType) {
            				if (shadowType === void 0) shadowType = SHADOW_PCF3_32F;
            				var _this_shadowAtlas;
            				var existingFormat = (_this_shadowAtlas = this.shadowAtlas) == null ? void 0 : _this_shadowAtlas.texture.format;
            				var requiredFormat = shadowTypeInfo.get(shadowType).format;
            				if (!this.shadowAtlas || this.shadowAtlas.texture.width !== resolution || existingFormat !== requiredFormat) {
            						this.version++;
            						this.destroyShadowAtlas();
            						this.shadowAtlas = ShadowMap.createAtlas(this.device, resolution, shadowType);
            						this.shadowAtlas.cached = true;
            						var scissorOffset = 4 / this.shadowAtlasResolution;
            						this.scissorVec.set(scissorOffset, scissorOffset, -2 * scissorOffset, -2 * scissorOffset);
            				}
            		}
            		allocateCookieAtlas(resolution) {
            				if (this.cookieAtlas.width !== resolution) {
            						this.cookieRenderTarget.resize(resolution, resolution);
            						this.version++;
            				}
            		}
            		allocateUniforms() {
            				this._shadowAtlasTextureId = this.device.scope.resolve('shadowAtlasTexture');
            				this._shadowAtlasParamsId = this.device.scope.resolve('shadowAtlasParams');
            				this._shadowAtlasParams = new Float32Array(2);
            				this._cookieAtlasTextureId = this.device.scope.resolve('cookieAtlasTexture');
            		}
            		updateUniforms() {
            				var rt = this.shadowAtlas.renderTargets[0];
            				var shadowBuffer = rt.depthBuffer;
            				this._shadowAtlasTextureId.setValue(shadowBuffer);
            				this._shadowAtlasParams[0] = this.shadowAtlasResolution;
            				this._shadowAtlasParams[1] = this.shadowEdgePixels;
            				this._shadowAtlasParamsId.setValue(this._shadowAtlasParams);
            				this._cookieAtlasTextureId.setValue(this.cookieAtlas);
            		}
            		subdivide(numLights, lightingParams) {
            				var atlasSplit = lightingParams.atlasSplit;
            				if (!atlasSplit) {
            						var gridSize = Math.ceil(Math.sqrt(numLights));
            						atlasSplit = _tempArray2;
            						atlasSplit[0] = gridSize;
            						atlasSplit.length = 1;
            				}
            				var arraysEqual = (a, b)=>a.length === b.length && a.every((v, i)=>v === b[i]);
            				if (!arraysEqual(atlasSplit, this.atlasSplit)) {
            						this.version++;
            						this.slots.length = 0;
            						this.atlasSplit.length = 0;
            						this.atlasSplit.push(...atlasSplit);
            						var splitCount = this.atlasSplit[0];
            						if (splitCount > 1) {
            								var invSize = 1 / splitCount;
            								for(var i = 0; i < splitCount; i++){
            										for(var j = 0; j < splitCount; j++){
            												var rect = new Vec4(i * invSize, j * invSize, invSize, invSize);
            												var nextLevelSplit = this.atlasSplit[1 + i * splitCount + j];
            												if (nextLevelSplit > 1) {
            														for(var x = 0; x < nextLevelSplit; x++){
            																for(var y = 0; y < nextLevelSplit; y++){
            																		var invSizeNext = invSize / nextLevelSplit;
            																		var rectNext = new Vec4(rect.x + x * invSizeNext, rect.y + y * invSizeNext, invSizeNext, invSizeNext);
            																		this.slots.push(new Slot(rectNext));
            																}
            														}
            												} else {
            														this.slots.push(new Slot(rect));
            												}
            										}
            								}
            						} else {
            								this.slots.push(new Slot(new Vec4(0, 0, 1, 1)));
            						}
            						this.slots.sort((a, b)=>{
            								return b.size - a.size;
            						});
            				}
            		}
            		collectLights(localLights, lightingParams) {
            				var cookiesEnabled = lightingParams.cookiesEnabled;
            				var shadowsEnabled = lightingParams.shadowsEnabled;
            				var needsShadowAtlas = false;
            				var needsCookieAtlas = false;
            				var lights = _tempArray;
            				lights.length = 0;
            				var processLights = (list)=>{
            						for(var i = 0; i < list.length; i++){
            								var light = list[i];
            								if (light.visibleThisFrame) {
            										var lightShadow = shadowsEnabled && light.castShadows;
            										var lightCookie = cookiesEnabled && !!light.cookie;
            										needsShadowAtlas || (needsShadowAtlas = lightShadow);
            										needsCookieAtlas || (needsCookieAtlas = lightCookie);
            										if (lightShadow || lightCookie) {
            												lights.push(light);
            										}
            								}
            						}
            				};
            				if (cookiesEnabled || shadowsEnabled) {
            						processLights(localLights);
            				}
            				lights.sort((a, b)=>{
            						return b.maxScreenSize - a.maxScreenSize;
            				});
            				if (needsShadowAtlas) {
            						this.allocateShadowAtlas(this.shadowAtlasResolution, lightingParams.shadowType);
            				}
            				if (needsCookieAtlas) {
            						this.allocateCookieAtlas(this.cookieAtlasResolution);
            				}
            				if (needsShadowAtlas || needsCookieAtlas) {
            						this.subdivide(lights.length, lightingParams);
            				}
            				return lights;
            		}
            		setupSlot(light, rect) {
            				light.atlasViewport.copy(rect);
            				var faceCount = light.numShadowFaces;
            				for(var face = 0; face < faceCount; face++){
            						if (light.castShadows || light._cookie) {
            								_viewport$1.copy(rect);
            								_scissor.copy(rect);
            								if (light._type === LIGHTTYPE_SPOT) {
            										_viewport$1.add(this.scissorVec);
            								}
            								if (light._type === LIGHTTYPE_OMNI) {
            										var smallSize = _viewport$1.z / 3;
            										var offset = this.cubeSlotsOffsets[face];
            										_viewport$1.x += smallSize * offset.x;
            										_viewport$1.y += smallSize * offset.y;
            										_viewport$1.z = smallSize;
            										_viewport$1.w = smallSize;
            										_scissor.copy(_viewport$1);
            								}
            								if (light.castShadows) {
            										var lightRenderData = light.getRenderData(null, face);
            										lightRenderData.shadowViewport.copy(_viewport$1);
            										lightRenderData.shadowScissor.copy(_scissor);
            								}
            						}
            				}
            		}
            		assignSlot(light, slotIndex, slotReassigned) {
            				light.atlasViewportAllocated = true;
            				var slot = this.slots[slotIndex];
            				slot.lightId = light.id;
            				slot.used = true;
            				if (slotReassigned) {
            						light.atlasSlotUpdated = true;
            						light.atlasVersion = this.version;
            						light.atlasSlotIndex = slotIndex;
            				}
            		}
            		update(localLights, lightingParams) {
            				this.shadowAtlasResolution = lightingParams.shadowAtlasResolution;
            				this.cookieAtlasResolution = lightingParams.cookieAtlasResolution;
            				var lights = this.collectLights(localLights, lightingParams);
            				if (lights.length > 0) {
            						var slots = this.slots;
            						for(var i = 0; i < slots.length; i++){
            								slots[i].used = false;
            						}
            						var assignCount = Math.min(lights.length, slots.length);
            						for(var i1 = 0; i1 < assignCount; i1++){
            								var light = lights[i1];
            								if (light.castShadows) {
            										light._shadowMap = this.shadowAtlas;
            								}
            								var previousSlot = slots[light.atlasSlotIndex];
            								if (light.atlasVersion === this.version && light.id === (previousSlot == null ? void 0 : previousSlot.lightId)) {
            										var previousSlot1 = slots[light.atlasSlotIndex];
            										if (previousSlot1.size === slots[i1].size && !previousSlot1.used) {
            												this.assignSlot(light, light.atlasSlotIndex, false);
            										}
            								}
            						}
            						var usedCount = 0;
            						for(var i2 = 0; i2 < assignCount; i2++){
            								while(usedCount < slots.length && slots[usedCount].used){
            										usedCount++;
            								}
            								var light1 = lights[i2];
            								if (!light1.atlasViewportAllocated) {
            										this.assignSlot(light1, usedCount, true);
            								}
            								var slot = slots[light1.atlasSlotIndex];
            								this.setupSlot(light1, slot.rect);
            						}
            				}
            				this.updateUniforms();
            		}
            		constructor(device){
            				this.device = device;
            				this.version = 1;
            				this.shadowAtlasResolution = 2048;
            				this.shadowAtlas = null;
            				this.shadowEdgePixels = 3;
            				this.cookieAtlasResolution = 4;
            				this.cookieAtlas = new Texture(this.device, {
            						name: 'CookieAtlas',
            						width: this.cookieAtlasResolution,
            						height: this.cookieAtlasResolution,
            						format: PIXELFORMAT_SRGBA8,
            						cubemap: false,
            						mipmaps: false,
            						minFilter: FILTER_NEAREST,
            						magFilter: FILTER_NEAREST,
            						addressU: ADDRESS_CLAMP_TO_EDGE,
            						addressV: ADDRESS_CLAMP_TO_EDGE
            				});
            				this.cookieRenderTarget = new RenderTarget({
            						colorBuffer: this.cookieAtlas,
            						depth: false,
            						flipY: true
            				});
            				this.slots = [];
            				this.atlasSplit = [];
            				this.cubeSlotsOffsets = [
            						new Vec2(0, 0),
            						new Vec2(0, 1),
            						new Vec2(1, 0),
            						new Vec2(1, 1),
            						new Vec2(2, 0),
            						new Vec2(2, 1)
            				];
            				this.scissorVec = new Vec4();
            				this.allocateShadowAtlas(1);
            				this.allocateCookieAtlas(1);
            				this.allocateUniforms();
            		}
            }
            
            var blendModes = [];
            blendModes[BLEND_SUBTRACTIVE] = {
            		src: BLENDMODE_ONE,
            		dst: BLENDMODE_ONE,
            		op: BLENDEQUATION_REVERSE_SUBTRACT
            };
            blendModes[BLEND_NONE] = {
            		src: BLENDMODE_ONE,
            		dst: BLENDMODE_ZERO,
            		op: BLENDEQUATION_ADD
            };
            blendModes[BLEND_NORMAL] = {
            		src: BLENDMODE_SRC_ALPHA,
            		dst: BLENDMODE_ONE_MINUS_SRC_ALPHA,
            		op: BLENDEQUATION_ADD,
            		alphaSrc: BLENDMODE_ONE
            };
            blendModes[BLEND_PREMULTIPLIED] = {
            		src: BLENDMODE_ONE,
            		dst: BLENDMODE_ONE_MINUS_SRC_ALPHA,
            		op: BLENDEQUATION_ADD
            };
            blendModes[BLEND_ADDITIVE] = {
            		src: BLENDMODE_ONE,
            		dst: BLENDMODE_ONE,
            		op: BLENDEQUATION_ADD
            };
            blendModes[BLEND_ADDITIVEALPHA] = {
            		src: BLENDMODE_SRC_ALPHA,
            		dst: BLENDMODE_ONE,
            		op: BLENDEQUATION_ADD
            };
            blendModes[BLEND_MULTIPLICATIVE2X] = {
            		src: BLENDMODE_DST_COLOR,
            		dst: BLENDMODE_SRC_COLOR,
            		op: BLENDEQUATION_ADD
            };
            blendModes[BLEND_SCREEN] = {
            		src: BLENDMODE_ONE_MINUS_DST_COLOR,
            		dst: BLENDMODE_ONE,
            		op: BLENDEQUATION_ADD
            };
            blendModes[BLEND_MULTIPLICATIVE] = {
            		src: BLENDMODE_DST_COLOR,
            		dst: BLENDMODE_ZERO,
            		op: BLENDEQUATION_ADD
            };
            blendModes[BLEND_MIN] = {
            		src: BLENDMODE_ONE,
            		dst: BLENDMODE_ONE,
            		op: BLENDEQUATION_MIN
            };
            blendModes[BLEND_MAX] = {
            		src: BLENDMODE_ONE,
            		dst: BLENDMODE_ONE,
            		op: BLENDEQUATION_MAX
            };
            var id$1 = 0;
            class Material {
            		set chunks(value) {
            				this._dirtyShader = true;
            				this._chunks = value;
            		}
            		get chunks() {
            				this._dirtyShader = true;
            				return this._chunks;
            		}
            		set depthBias(value) {
            				this._depthState.depthBias = value;
            		}
            		get depthBias() {
            				return this._depthState.depthBias;
            		}
            		set slopeDepthBias(value) {
            				this._depthState.depthBiasSlope = value;
            		}
            		get slopeDepthBias() {
            				return this._depthState.depthBiasSlope;
            		}
            		set redWrite(value) {
            				this._blendState.redWrite = value;
            		}
            		get redWrite() {
            				return this._blendState.redWrite;
            		}
            		set greenWrite(value) {
            				this._blendState.greenWrite = value;
            		}
            		get greenWrite() {
            				return this._blendState.greenWrite;
            		}
            		set blueWrite(value) {
            				this._blendState.blueWrite = value;
            		}
            		get blueWrite() {
            				return this._blendState.blueWrite;
            		}
            		set alphaWrite(value) {
            				this._blendState.alphaWrite = value;
            		}
            		get alphaWrite() {
            				return this._blendState.alphaWrite;
            		}
            		get transparent() {
            				return this._blendState.blend;
            		}
            		_updateTransparency() {
            				var transparent = this.transparent;
            				var meshInstances = this.meshInstances;
            				for(var i = 0; i < meshInstances.length; i++){
            						meshInstances[i].transparent = transparent;
            				}
            		}
            		set blendState(value) {
            				this._blendState.copy(value);
            				this._updateTransparency();
            		}
            		get blendState() {
            				return this._blendState;
            		}
            		set blendType(type) {
            				var blendMode = blendModes[type];
            				this._blendState.setColorBlend(blendMode.op, blendMode.src, blendMode.dst);
            				var _blendMode_alphaOp, _blendMode_alphaSrc, _blendMode_alphaDst;
            				this._blendState.setAlphaBlend((_blendMode_alphaOp = blendMode.alphaOp) != null ? _blendMode_alphaOp : blendMode.op, (_blendMode_alphaSrc = blendMode.alphaSrc) != null ? _blendMode_alphaSrc : blendMode.src, (_blendMode_alphaDst = blendMode.alphaDst) != null ? _blendMode_alphaDst : blendMode.dst);
            				var blend = type !== BLEND_NONE;
            				if (this._blendState.blend !== blend) {
            						this._blendState.blend = blend;
            						this._updateTransparency();
            				}
            				this._updateMeshInstanceKeys();
            		}
            		get blendType() {
            				if (!this.transparent) {
            						return BLEND_NONE;
            				}
            				var { colorOp, colorSrcFactor, colorDstFactor, alphaOp, alphaSrcFactor, alphaDstFactor } = this._blendState;
            				for(var i = 0; i < blendModes.length; i++){
            						var blendMode = blendModes[i];
            						if (blendMode.src === colorSrcFactor && blendMode.dst === colorDstFactor && blendMode.op === colorOp && blendMode.src === alphaSrcFactor && blendMode.dst === alphaDstFactor && blendMode.op === alphaOp) {
            								return i;
            						}
            				}
            				return BLEND_NORMAL;
            		}
            		set depthState(value) {
            				this._depthState.copy(value);
            		}
            		get depthState() {
            				return this._depthState;
            		}
            		set depthTest(value) {
            				this._depthState.test = value;
            		}
            		get depthTest() {
            				return this._depthState.test;
            		}
            		set depthFunc(value) {
            				this._depthState.func = value;
            		}
            		get depthFunc() {
            				return this._depthState.func;
            		}
            		set depthWrite(value) {
            				this._depthState.write = value;
            		}
            		get depthWrite() {
            				return this._depthState.write;
            		}
            		copy(source) {
            				var _source_stencilFront;
            				this.name = source.name;
            				this.alphaTest = source.alphaTest;
            				this.alphaToCoverage = source.alphaToCoverage;
            				this._blendState.copy(source._blendState);
            				this._depthState.copy(source._depthState);
            				this.cull = source.cull;
            				this.stencilFront = (_source_stencilFront = source.stencilFront) == null ? void 0 : _source_stencilFront.clone();
            				if (source.stencilBack) {
            						this.stencilBack = source.stencilFront === source.stencilBack ? this.stencilFront : source.stencilBack.clone();
            				}
            				this.clearParameters();
            				for(var name in source.parameters){
            						if (source.parameters.hasOwnProperty(name)) {
            								this._setParameterSimple(name, source.parameters[name].data);
            						}
            				}
            				this.defines.clear();
            				source.defines.forEach((value, key)=>this.defines.set(key, value));
            				var srcChunks = source._chunks;
            				for(var p in srcChunks){
            						if (srcChunks.hasOwnProperty(p)) {
            								this._chunks[p] = srcChunks[p];
            						}
            				}
            				return this;
            		}
            		clone() {
            				var clone = new this.constructor();
            				return clone.copy(this);
            		}
            		_updateMeshInstanceKeys() {
            				var meshInstances = this.meshInstances;
            				for(var i = 0; i < meshInstances.length; i++){
            						meshInstances[i].updateKey();
            				}
            		}
            		updateUniforms(device, scene) {
            				if (this._dirtyShader) {
            						this.clearVariants();
            				}
            		}
            		getShaderVariant(params) {}
            		update() {
            				if (this._definesDirty) {
            						this._definesDirty = false;
            						this.clearVariants();
            				}
            				this.dirty = true;
            		}
            		clearParameters() {
            				this.parameters = {};
            		}
            		getParameters() {
            				return this.parameters;
            		}
            		clearVariants() {
            				this.variants.clear();
            				var meshInstances = this.meshInstances;
            				var count = meshInstances.length;
            				for(var i = 0; i < count; i++){
            						meshInstances[i].clearShaders();
            				}
            		}
            		getParameter(name) {
            				return this.parameters[name];
            		}
            		_setParameterSimple(name, data) {
            				var param = this.parameters[name];
            				if (param) {
            						param.data = data;
            				} else {
            						this.parameters[name] = {
            								scopeId: null,
            								data: data
            						};
            				}
            		}
            		setParameter(name, data) {
            				if (data === undefined && typeof name === 'object') {
            						var uniformObject = name;
            						if (uniformObject.length) {
            								for(var i = 0; i < uniformObject.length; i++){
            										this.setParameter(uniformObject[i]);
            								}
            								return;
            						}
            						name = uniformObject.name;
            						data = uniformObject.value;
            				}
            				this._setParameterSimple(name, data);
            		}
            		deleteParameter(name) {
            				if (this.parameters[name]) {
            						delete this.parameters[name];
            				}
            		}
            		setParameters(device, names) {
            				var parameters = this.parameters;
            				if (names === undefined) names = parameters;
            				for(var paramName in names){
            						var parameter = parameters[paramName];
            						if (parameter) {
            								if (!parameter.scopeId) {
            										parameter.scopeId = device.scope.resolve(paramName);
            								}
            								parameter.scopeId.setValue(parameter.data);
            						}
            				}
            		}
            		setDefine(name, value) {
            				var modified = false;
            				var { defines } = this;
            				if (value !== undefined && value !== false) {
            						modified = !defines.has(name) || defines.get(name) !== value;
            						defines.set(name, value);
            				} else {
            						modified = defines.has(name);
            						defines.delete(name);
            				}
            				this._definesDirty || (this._definesDirty = modified);
            		}
            		getDefine(name) {
            				return this.defines.has(name);
            		}
            		destroy() {
            				this.variants.clear();
            				for(var i = 0; i < this.meshInstances.length; i++){
            						var meshInstance = this.meshInstances[i];
            						meshInstance.clearShaders();
            						meshInstance._material = null;
            						if (meshInstance.mesh) {
            								var defaultMaterial = getDefaultMaterial(meshInstance.mesh.device);
            								if (this !== defaultMaterial) {
            										meshInstance.material = defaultMaterial;
            								}
            						}
            				}
            				this.meshInstances.length = 0;
            		}
            		addMeshInstanceRef(meshInstance) {
            				this.meshInstances.push(meshInstance);
            		}
            		removeMeshInstanceRef(meshInstance) {
            				var meshInstances = this.meshInstances;
            				var i = meshInstances.indexOf(meshInstance);
            				if (i !== -1) {
            						meshInstances.splice(i, 1);
            				}
            		}
            		constructor(){
            				this.meshInstances = [];
            				this.name = 'Untitled';
            				this.userId = '';
            				this.id = id$1++;
            				this.variants = new Map();
            				this.defines = new Map();
            				this._definesDirty = false;
            				this.parameters = {};
            				this.alphaTest = 0;
            				this.alphaToCoverage = false;
            				this._blendState = new BlendState();
            				this._depthState = new DepthState();
            				this.cull = CULLFACE_BACK;
            				this.stencilFront = null;
            				this.stencilBack = null;
            				this._chunks = {};
            				this._dirtyShader = true;
            				this._shaderVersion = 0;
            				this._scene = null;
            				this.dirty = true;
            		}
            }
            
            class ShadowMapCache {
            		destroy() {
            				this.clear();
            				this.cache = null;
            		}
            		clear() {
            				this.cache.forEach((shadowMaps)=>{
            						shadowMaps.forEach((shadowMap)=>{
            								shadowMap.destroy();
            						});
            				});
            				this.cache.clear();
            		}
            		getKey(light) {
            				var isCubeMap = light._type === LIGHTTYPE_OMNI;
            				var shadowType = light._shadowType;
            				var resolution = light._shadowResolution;
            				return isCubeMap + "-" + shadowType + "-" + resolution;
            		}
            		get(device, light) {
            				var key = this.getKey(light);
            				var shadowMaps = this.cache.get(key);
            				if (shadowMaps && shadowMaps.length) {
            						return shadowMaps.pop();
            				}
            				var shadowMap = ShadowMap.create(device, light);
            				shadowMap.cached = true;
            				return shadowMap;
            		}
            		add(light, shadowMap) {
            				var key = this.getKey(light);
            				var shadowMaps = this.cache.get(key);
            				if (shadowMaps) {
            						shadowMaps.push(shadowMap);
            				} else {
            						this.cache.set(key, [
            								shadowMap
            						]);
            				}
            		}
            		constructor(){
            				this.cache = new Map();
            		}
            }
            
            class RenderPassShadowLocalNonClustered extends RenderPass {
            		execute() {
            				this.shadowRenderer.renderFace(this.light, null, this.face, false);
            		}
            		after() {
            				if (this.applyVsm) {
            						this.shadowRenderer.renderVsm(this.light, this.shadowCamera);
            				}
            		}
            		constructor(device, shadowRenderer, light, face, applyVsm){
            				super(device);
            				this.requiresCubemaps = false;
            				this.shadowRenderer = shadowRenderer;
            				this.light = light;
            				this.face = face;
            				this.applyVsm = applyVsm;
            				this.shadowCamera = shadowRenderer.prepareFace(light, null, face);
            				shadowRenderer.setupRenderPass(this, this.shadowCamera, true);
            		}
            }
            
            class ShadowRendererLocal {
            		cull(light, comp, casters) {
            				if (casters === void 0) casters = null;
            				var isClustered = this.renderer.scene.clusteredLightingEnabled;
            				light.visibleThisFrame = true;
            				if (!isClustered) {
            						if (!light._shadowMap) {
            								light._shadowMap = ShadowMap.create(this.device, light);
            						}
            				}
            				var type = light._type;
            				var faceCount = type === LIGHTTYPE_SPOT ? 1 : 6;
            				for(var face = 0; face < faceCount; face++){
            						var lightRenderData = light.getRenderData(null, face);
            						var shadowCam = lightRenderData.shadowCamera;
            						shadowCam.nearClip = light.attenuationEnd / 1000;
            						shadowCam.farClip = light.attenuationEnd;
            						var shadowCamNode = shadowCam._node;
            						var lightNode = light._node;
            						shadowCamNode.setPosition(lightNode.getPosition());
            						if (type === LIGHTTYPE_SPOT) {
            								shadowCam.fov = light._outerConeAngle * 2;
            								shadowCamNode.setRotation(lightNode.getRotation());
            								shadowCamNode.rotateLocal(-90, 0, 0);
            						} else if (type === LIGHTTYPE_OMNI) {
            								if (isClustered) {
            										var tileSize = this.shadowRenderer.lightTextureAtlas.shadowAtlasResolution * light.atlasViewport.z / 3;
            										var texelSize = 2 / tileSize;
            										var filterSize = texelSize * this.shadowRenderer.lightTextureAtlas.shadowEdgePixels;
            										shadowCam.fov = Math.atan(1 + filterSize) * math.RAD_TO_DEG * 2;
            								} else {
            										shadowCam.fov = 90;
            								}
            						}
            						this.renderer.updateCameraFrustum(shadowCam);
            						this.shadowRenderer.cullShadowCasters(comp, light, lightRenderData.visibleCasters, shadowCam, casters);
            				}
            		}
            		prepareLights(shadowLights, lights) {
            				var shadowCamera;
            				for(var i = 0; i < lights.length; i++){
            						var light = lights[i];
            						if (this.shadowRenderer.needsShadowRendering(light) && light.atlasViewportAllocated) {
            								shadowLights.push(light);
            								for(var face = 0; face < light.numShadowFaces; face++){
            										shadowCamera = this.shadowRenderer.prepareFace(light, null, face);
            								}
            						}
            				}
            				return shadowCamera;
            		}
            		buildNonClusteredRenderPasses(frameGraph, localLights) {
            				for(var i = 0; i < localLights.length; i++){
            						var light = localLights[i];
            						if (this.shadowRenderer.needsShadowRendering(light)) {
            								var applyVsm = light._type === LIGHTTYPE_SPOT;
            								var faceCount = light.numShadowFaces;
            								for(var face = 0; face < faceCount; face++){
            										var renderPass = new RenderPassShadowLocalNonClustered(this.device, this.shadowRenderer, light, face, applyVsm);
            										frameGraph.addRenderPass(renderPass);
            								}
            						}
            				}
            		}
            		constructor(renderer, shadowRenderer){
            				this.shadowLights = [];
            				this.renderer = renderer;
            				this.shadowRenderer = shadowRenderer;
            				this.device = renderer.device;
            		}
            }
            
            class RenderPassShadowDirectional extends RenderPass {
            		execute() {
            				var { light, camera, shadowRenderer, allCascadesRendering } = this;
            				var faceCount = light.numShadowFaces;
            				var shadowUpdateOverrides = light.shadowUpdateOverrides;
            				for(var face = 0; face < faceCount; face++){
            						if ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[face]) !== SHADOWUPDATE_NONE) {
            								shadowRenderer.renderFace(light, camera, face, !allCascadesRendering);
            						}
            						if ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[face]) === SHADOWUPDATE_THISFRAME) {
            								shadowUpdateOverrides[face] = SHADOWUPDATE_NONE;
            						}
            				}
            		}
            		after() {
            				this.shadowRenderer.renderVsm(this.light, this.camera);
            		}
            		constructor(device, shadowRenderer, light, camera, allCascadesRendering){
            				super(device);
            				this.shadowRenderer = shadowRenderer;
            				this.light = light;
            				this.camera = camera;
            				this.allCascadesRendering = allCascadesRendering;
            		}
            }
            
            var visibleSceneAabb = new BoundingBox();
            var center = new Vec3();
            var shadowCamView$1 = new Mat4();
            var aabbPoints = [
            		new Vec3(),
            		new Vec3(),
            		new Vec3(),
            		new Vec3(),
            		new Vec3(),
            		new Vec3(),
            		new Vec3(),
            		new Vec3()
            ];
            var _depthRange = {
            		min: 0,
            		max: 0
            };
            function getDepthRange(cameraViewMatrix, aabbMin, aabbMax) {
            		aabbPoints[0].x = aabbPoints[1].x = aabbPoints[2].x = aabbPoints[3].x = aabbMin.x;
            		aabbPoints[1].y = aabbPoints[3].y = aabbPoints[7].y = aabbPoints[5].y = aabbMin.y;
            		aabbPoints[2].z = aabbPoints[3].z = aabbPoints[6].z = aabbPoints[7].z = aabbMin.z;
            		aabbPoints[4].x = aabbPoints[5].x = aabbPoints[6].x = aabbPoints[7].x = aabbMax.x;
            		aabbPoints[0].y = aabbPoints[2].y = aabbPoints[4].y = aabbPoints[6].y = aabbMax.y;
            		aabbPoints[0].z = aabbPoints[1].z = aabbPoints[4].z = aabbPoints[5].z = aabbMax.z;
            		var minz = 9999999999;
            		var maxz = -9999999999;
            		for(var i = 0; i < 8; ++i){
            				cameraViewMatrix.transformPoint(aabbPoints[i], aabbPoints[i]);
            				var z = aabbPoints[i].z;
            				if (z < minz) minz = z;
            				if (z > maxz) maxz = z;
            		}
            		_depthRange.min = minz;
            		_depthRange.max = maxz;
            		return _depthRange;
            }
            class ShadowRendererDirectional {
            		cull(light, comp, camera, casters) {
            				if (casters === void 0) casters = null;
            				light.visibleThisFrame = true;
            				if (!light._shadowMap) {
            						light._shadowMap = ShadowMap.create(this.device, light);
            				}
            				var nearDist = camera._nearClip;
            				this.generateSplitDistances(light, nearDist, Math.min(camera._farClip, light.shadowDistance));
            				var shadowUpdateOverrides = light.shadowUpdateOverrides;
            				for(var cascade = 0; cascade < light.numCascades; cascade++){
            						if ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[cascade]) === SHADOWUPDATE_NONE) {
            								break;
            						}
            						var lightRenderData = light.getRenderData(camera, cascade);
            						var shadowCam = lightRenderData.shadowCamera;
            						shadowCam.renderTarget = light._shadowMap.renderTargets[0];
            						lightRenderData.shadowViewport.copy(light.cascades[cascade]);
            						lightRenderData.shadowScissor.copy(light.cascades[cascade]);
            						var shadowCamNode = shadowCam._node;
            						var lightNode = light._node;
            						shadowCamNode.setPosition(lightNode.getPosition());
            						shadowCamNode.setRotation(lightNode.getRotation());
            						shadowCamNode.rotateLocal(-90, 0, 0);
            						var frustumNearDist = cascade === 0 ? nearDist : light._shadowCascadeDistances[cascade - 1];
            						var frustumFarDist = light._shadowCascadeDistances[cascade];
            						var frustumPoints = camera.getFrustumCorners(frustumNearDist, frustumFarDist);
            						center.set(0, 0, 0);
            						var cameraWorldMat = camera.node.getWorldTransform();
            						for(var i = 0; i < 8; i++){
            								cameraWorldMat.transformPoint(frustumPoints[i], frustumPoints[i]);
            								center.add(frustumPoints[i]);
            						}
            						center.mulScalar(1 / 8);
            						var radius = 0;
            						for(var i1 = 0; i1 < 8; i1++){
            								var dist = frustumPoints[i1].sub(center).length();
            								if (dist > radius) {
            										radius = dist;
            								}
            						}
            						var right = shadowCamNode.right;
            						var up = shadowCamNode.up;
            						var lightDir = shadowCamNode.forward;
            						var sizeRatio = 0.25 * light._shadowResolution / radius;
            						var x = Math.ceil(center.dot(up) * sizeRatio) / sizeRatio;
            						var y = Math.ceil(center.dot(right) * sizeRatio) / sizeRatio;
            						var scaledUp = up.mulScalar(x);
            						var scaledRight = right.mulScalar(y);
            						var dot = center.dot(lightDir);
            						var scaledDir = lightDir.mulScalar(dot);
            						center.add2(scaledUp, scaledRight).add(scaledDir);
            						shadowCamNode.setPosition(center);
            						shadowCamNode.translateLocal(0, 0, 1000000);
            						shadowCam.nearClip = 0.01;
            						shadowCam.farClip = 2000000;
            						shadowCam.orthoHeight = radius;
            						this.renderer.updateCameraFrustum(shadowCam);
            						this.shadowRenderer.cullShadowCasters(comp, light, lightRenderData.visibleCasters, shadowCam, casters);
            						var emptyAabb = true;
            						var visibleCasters = lightRenderData.visibleCasters;
            						for(var i2 = 0; i2 < visibleCasters.length; i2++){
            								var meshInstance = visibleCasters[i2];
            								if (emptyAabb) {
            										emptyAabb = false;
            										visibleSceneAabb.copy(meshInstance.aabb);
            								} else {
            										visibleSceneAabb.add(meshInstance.aabb);
            								}
            						}
            						shadowCamView$1.copy(shadowCamNode.getWorldTransform()).invert();
            						var depthRange = getDepthRange(shadowCamView$1, visibleSceneAabb.getMin(), visibleSceneAabb.getMax());
            						shadowCamNode.translateLocal(0, 0, depthRange.max + 0.1);
            						shadowCam.farClip = depthRange.max - depthRange.min + 0.2;
            						lightRenderData.projectionCompensation = radius;
            				}
            		}
            		generateSplitDistances(light, nearDist, farDist) {
            				light._shadowCascadeDistances.fill(farDist);
            				for(var i = 1; i < light.numCascades; i++){
            						var fraction = i / light.numCascades;
            						var linearDist = nearDist + (farDist - nearDist) * fraction;
            						var logDist = nearDist * (farDist / nearDist) ** fraction;
            						var dist = math.lerp(linearDist, logDist, light.cascadeDistribution);
            						light._shadowCascadeDistances[i - 1] = dist;
            				}
            		}
            		getLightRenderPass(light, camera) {
            				var renderPass = null;
            				if (this.shadowRenderer.needsShadowRendering(light)) {
            						var faceCount = light.numShadowFaces;
            						var shadowUpdateOverrides = light.shadowUpdateOverrides;
            						var allCascadesRendering = true;
            						var shadowCamera;
            						for(var face = 0; face < faceCount; face++){
            								if ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[face]) === SHADOWUPDATE_NONE) {
            										allCascadesRendering = false;
            								}
            								shadowCamera = this.shadowRenderer.prepareFace(light, camera, face);
            						}
            						renderPass = new RenderPassShadowDirectional(this.device, this.shadowRenderer, light, camera, allCascadesRendering);
            						this.shadowRenderer.setupRenderPass(renderPass, shadowCamera, allCascadesRendering);
            				}
            				return renderPass;
            		}
            		constructor(renderer, shadowRenderer){
            				this.renderer = renderer;
            				this.shadowRenderer = shadowRenderer;
            				this.device = renderer.device;
            		}
            }
            
            var tempSet$1 = new Set();
            var shadowCamView = new Mat4();
            var shadowCamViewProj = new Mat4();
            var pixelOffset = new Float32Array(2);
            var blurScissorRect = new Vec4(1, 1, 0, 0);
            var viewportMatrix = new Mat4();
            function gauss(x, sigma) {
            		return Math.exp(-(x * x) / (2.0 * sigma * sigma));
            }
            function gaussWeights(kernelSize) {
            		var sigma = (kernelSize - 1) / (2 * 3);
            		var halfWidth = (kernelSize - 1) * 0.5;
            		var values = new Array(kernelSize);
            		var sum = 0.0;
            		for(var i = 0; i < kernelSize; ++i){
            				values[i] = gauss(i - halfWidth, sigma);
            				sum += values[i];
            		}
            		for(var i1 = 0; i1 < kernelSize; ++i1){
            				values[i1] /= sum;
            		}
            		return values;
            }
            class ShadowRenderer {
            		static createShadowCamera(shadowType, type, face) {
            				var shadowCam = LightCamera.create('ShadowCamera', type, face);
            				var shadowInfo = shadowTypeInfo.get(shadowType);
            				var _shadowInfo_vsm;
            				var isVsm = (_shadowInfo_vsm = shadowInfo == null ? void 0 : shadowInfo.vsm) != null ? _shadowInfo_vsm : false;
            				var _shadowInfo_pcf;
            				var isPcf = (_shadowInfo_pcf = shadowInfo == null ? void 0 : shadowInfo.pcf) != null ? _shadowInfo_pcf : false;
            				if (isVsm) {
            						shadowCam.clearColor = new Color(0, 0, 0, 0);
            				} else {
            						shadowCam.clearColor = new Color(1, 1, 1, 1);
            				}
            				shadowCam.clearDepthBuffer = true;
            				shadowCam.clearStencilBuffer = false;
            				shadowCam.clearColorBuffer = !isPcf;
            				return shadowCam;
            		}
            		_cullShadowCastersInternal(meshInstances, visible, camera) {
            				var numInstances = meshInstances.length;
            				for(var i = 0; i < numInstances; i++){
            						var meshInstance = meshInstances[i];
            						if (meshInstance.castShadow) {
            								if (!meshInstance.cull || meshInstance._isVisible(camera)) {
            										meshInstance.visibleThisFrame = true;
            										visible.push(meshInstance);
            								}
            						}
            				}
            		}
            		cullShadowCasters(comp, light, visible, camera, casters) {
            				visible.length = 0;
            				if (casters) {
            						this._cullShadowCastersInternal(casters, visible, camera);
            				} else {
            						var layers = comp.layerList;
            						var len = layers.length;
            						for(var i = 0; i < len; i++){
            								var layer = layers[i];
            								if (layer._lightsSet.has(light)) {
            										if (!tempSet$1.has(layer)) {
            												tempSet$1.add(layer);
            												this._cullShadowCastersInternal(layer.shadowCasters, visible, camera);
            										}
            								}
            						}
            						tempSet$1.clear();
            				}
            				visible.sort(this.sortCompareShader);
            		}
            		sortCompareShader(drawCallA, drawCallB) {
            				var keyA = drawCallA._sortKeyShadow;
            				var keyB = drawCallB._sortKeyShadow;
            				if (keyA === keyB) {
            						return drawCallB.mesh.id - drawCallA.mesh.id;
            				}
            				return keyB - keyA;
            		}
            		setupRenderState(device, light) {
            				var isClustered = this.renderer.scene.clusteredLightingEnabled;
            				var useShadowSampler = isClustered ? light._isPcf : light._isPcf && light._type !== LIGHTTYPE_OMNI;
            				device.setBlendState(useShadowSampler ? this.blendStateNoWrite : this.blendStateWrite);
            				device.setDepthState(light.shadowDepthState);
            				device.setStencilState(null, null);
            		}
            		dispatchUniforms(light, shadowCam, lightRenderData, face) {
            				var shadowCamNode = shadowCam._node;
            				if (light._type !== LIGHTTYPE_DIRECTIONAL) {
            						this.renderer.dispatchViewPos(shadowCamNode.getPosition());
            						this.shadowMapLightRadiusId.setValue(light.attenuationEnd);
            				}
            				shadowCamView.setTRS(shadowCamNode.getPosition(), shadowCamNode.getRotation(), Vec3.ONE).invert();
            				shadowCamViewProj.mul2(shadowCam.projectionMatrix, shadowCamView);
            				var rectViewport = lightRenderData.shadowViewport;
            				shadowCam.rect = rectViewport;
            				shadowCam.scissorRect = lightRenderData.shadowScissor;
            				viewportMatrix.setViewport(rectViewport.x, rectViewport.y, rectViewport.z, rectViewport.w);
            				lightRenderData.shadowMatrix.mul2(viewportMatrix, shadowCamViewProj);
            				if (light._type === LIGHTTYPE_DIRECTIONAL) {
            						light._shadowMatrixPalette.set(lightRenderData.shadowMatrix.data, face * 16);
            				}
            		}
            		getShadowPass(light) {
            				var _this_shadowPassCache_lightType;
            				var lightType = light._type;
            				var shadowType = light._shadowType;
            				var shadowPassInfo = (_this_shadowPassCache_lightType = this.shadowPassCache[lightType]) == null ? void 0 : _this_shadowPassCache_lightType[shadowType];
            				if (!shadowPassInfo) {
            						var shadowPassName = "ShadowPass_" + lightType + "_" + shadowType;
            						shadowPassInfo = ShaderPass.get(this.device).allocate(shadowPassName, {
            								isShadow: true,
            								lightType: lightType,
            								shadowType: shadowType
            						});
            						if (!this.shadowPassCache[lightType]) {
            								this.shadowPassCache[lightType] = [];
            						}
            						this.shadowPassCache[lightType][shadowType] = shadowPassInfo;
            				}
            				return shadowPassInfo.index;
            		}
            		submitCasters(visibleCasters, light, camera) {
            				var device = this.device;
            				var renderer = this.renderer;
            				var scene = renderer.scene;
            				var passFlags = 1 << SHADER_SHADOW;
            				var shadowPass = this.getShadowPass(light);
            				var cameraShaderParams = camera.shaderParams;
            				var flipFactor = camera.renderTarget.flipY ? -1 : 1;
            				var count = visibleCasters.length;
            				for(var i = 0; i < count; i++){
            						var meshInstance = visibleCasters[i];
            						var mesh = meshInstance.mesh;
            						meshInstance.ensureMaterial(device);
            						var material = meshInstance.material;
            						renderer.setBaseConstants(device, material);
            						renderer.setSkinning(device, meshInstance);
            						if (material.dirty) {
            								material.updateUniforms(device, scene);
            								material.dirty = false;
            						}
            						renderer.setupCullMode(true, flipFactor, meshInstance);
            						material.setParameters(device);
            						meshInstance.setParameters(device, passFlags);
            						var shaderInstance = meshInstance.getShaderInstance(shadowPass, 0, scene, cameraShaderParams, this.viewUniformFormat, this.viewBindGroupFormat);
            						var shadowShader = shaderInstance.shader;
            						if (shadowShader.failed) continue;
            						meshInstance._sortKeyShadow = shadowShader.id;
            						device.setShader(shadowShader);
            						renderer.setVertexBuffers(device, mesh);
            						renderer.setMorphing(device, meshInstance.morphInstance);
            						this.renderer.setupMeshUniformBuffers(shaderInstance, meshInstance);
            						var style = meshInstance.renderStyle;
            						device.setIndexBuffer(mesh.indexBuffer[style]);
            						renderer.drawInstance(device, meshInstance, mesh, style);
            						renderer._shadowDrawCalls++;
            				}
            		}
            		needsShadowRendering(light) {
            				var needs = light.enabled && light.castShadows && light.shadowUpdateMode !== SHADOWUPDATE_NONE && light.visibleThisFrame;
            				if (light.shadowUpdateMode === SHADOWUPDATE_THISFRAME) {
            						light.shadowUpdateMode = SHADOWUPDATE_NONE;
            				}
            				if (needs) {
            						this.renderer._shadowMapUpdates += light.numShadowFaces;
            				}
            				return needs;
            		}
            		getLightRenderData(light, camera, face) {
            				return light.getRenderData(light._type === LIGHTTYPE_DIRECTIONAL ? camera : null, face);
            		}
            		setupRenderPass(renderPass, shadowCamera, clearRenderTarget) {
            				var rt = shadowCamera.renderTarget;
            				renderPass.init(rt);
            				renderPass.depthStencilOps.clearDepthValue = 1;
            				renderPass.depthStencilOps.clearDepth = clearRenderTarget;
            				if (rt.depthBuffer) {
            						renderPass.depthStencilOps.storeDepth = true;
            				} else {
            						renderPass.colorOps.clearValue.copy(shadowCamera.clearColor);
            						renderPass.colorOps.clear = clearRenderTarget;
            						renderPass.depthStencilOps.storeDepth = false;
            				}
            				renderPass.requiresCubemaps = false;
            		}
            		prepareFace(light, camera, face) {
            				var type = light._type;
            				var lightRenderData = this.getLightRenderData(light, camera, face);
            				var shadowCam = lightRenderData.shadowCamera;
            				var renderTargetIndex = type === LIGHTTYPE_DIRECTIONAL ? 0 : face;
            				shadowCam.renderTarget = light._shadowMap.renderTargets[renderTargetIndex];
            				return shadowCam;
            		}
            		renderFace(light, camera, face, clear, insideRenderPass) {
            				if (insideRenderPass === void 0) insideRenderPass = true;
            				var device = this.device;
            				var lightRenderData = this.getLightRenderData(light, camera, face);
            				var shadowCam = lightRenderData.shadowCamera;
            				this.dispatchUniforms(light, shadowCam, lightRenderData, face);
            				var rt = shadowCam.renderTarget;
            				var renderer = this.renderer;
            				renderer.setCameraUniforms(shadowCam, rt);
            				if (device.supportsUniformBuffers) {
            						renderer.setupViewUniformBuffers(lightRenderData.viewBindGroups, this.viewUniformFormat, this.viewBindGroupFormat, 1);
            				}
            				if (insideRenderPass) {
            						renderer.setupViewport(shadowCam, rt);
            						if (clear) {
            								renderer.clear(shadowCam);
            						}
            				} else {
            						renderer.clearView(shadowCam, rt, true, false);
            				}
            				this.setupRenderState(device, light);
            				this.submitCasters(lightRenderData.visibleCasters, light, shadowCam);
            		}
            		render(light, camera, insideRenderPass) {
            				if (insideRenderPass === void 0) insideRenderPass = true;
            				if (this.needsShadowRendering(light)) {
            						var faceCount = light.numShadowFaces;
            						for(var face = 0; face < faceCount; face++){
            								this.prepareFace(light, camera, face);
            								this.renderFace(light, camera, face, true, insideRenderPass);
            						}
            						this.renderVsm(light, camera);
            				}
            		}
            		renderVsm(light, camera) {
            				if (light._isVsm && light._vsmBlurSize > 1) {
            						var isClustered = this.renderer.scene.clusteredLightingEnabled;
            						if (!isClustered || light._type === LIGHTTYPE_DIRECTIONAL) {
            								this.applyVsmBlur(light, camera);
            						}
            				}
            		}
            		getVsmBlurShader(blurMode, filterSize) {
            				var cache = this.blurVsmShader;
            				var blurShader = cache[blurMode][filterSize];
            				if (!blurShader) {
            						this.blurVsmWeights[filterSize] = gaussWeights(filterSize);
            						var blurVS = shaderChunks.fullscreenQuadVS;
            						var blurFS = "#define SAMPLES " + filterSize + "\n";
            						blurFS += this.blurVsmShaderCode[blurMode];
            						var blurShaderName = "blurVsm" + blurMode + filterSize;
            						blurShader = createShaderFromCode(this.device, blurVS, blurFS, blurShaderName);
            						cache[blurMode][filterSize] = blurShader;
            				}
            				return blurShader;
            		}
            		applyVsmBlur(light, camera) {
            				var device = this.device;
            				device.setBlendState(BlendState.NOBLEND);
            				var lightRenderData = light.getRenderData(light._type === LIGHTTYPE_DIRECTIONAL ? camera : null, 0);
            				var shadowCam = lightRenderData.shadowCamera;
            				var origShadowMap = shadowCam.renderTarget;
            				var tempShadowMap = this.renderer.shadowMapCache.get(device, light);
            				var tempRt = tempShadowMap.renderTargets[0];
            				var blurMode = light.vsmBlurMode;
            				var filterSize = light._vsmBlurSize;
            				var blurShader = this.getVsmBlurShader(blurMode, filterSize);
            				blurScissorRect.z = light._shadowResolution - 2;
            				blurScissorRect.w = blurScissorRect.z;
            				this.sourceId.setValue(origShadowMap.colorBuffer);
            				pixelOffset[0] = 1 / light._shadowResolution;
            				pixelOffset[1] = 0;
            				this.pixelOffsetId.setValue(pixelOffset);
            				if (blurMode === BLUR_GAUSSIAN) this.weightId.setValue(this.blurVsmWeights[filterSize]);
            				drawQuadWithShader(device, tempRt, blurShader, null, blurScissorRect);
            				this.sourceId.setValue(tempRt.colorBuffer);
            				pixelOffset[1] = pixelOffset[0];
            				pixelOffset[0] = 0;
            				this.pixelOffsetId.setValue(pixelOffset);
            				drawQuadWithShader(device, origShadowMap, blurShader, null, blurScissorRect);
            				this.renderer.shadowMapCache.add(light, tempShadowMap);
            		}
            		initViewBindGroupFormat() {
            				if (this.device.supportsUniformBuffers && !this.viewUniformFormat) {
            						this.viewUniformFormat = new UniformBufferFormat(this.device, [
            								new UniformFormat('matrix_viewProjection', UNIFORMTYPE_MAT4)
            						]);
            						this.viewBindGroupFormat = new BindGroupFormat(this.device, [
            								new BindUniformBufferFormat(UNIFORM_BUFFER_DEFAULT_SLOT_NAME, SHADERSTAGE_VERTEX | SHADERSTAGE_FRAGMENT)
            						]);
            				}
            		}
            		frameUpdate() {
            				this.initViewBindGroupFormat();
            		}
            		constructor(renderer, lightTextureAtlas){
            				this.shadowPassCache = [];
            				this.device = renderer.device;
            				this.renderer = renderer;
            				this.lightTextureAtlas = lightTextureAtlas;
            				var scope = this.device.scope;
            				this.sourceId = scope.resolve('source');
            				this.pixelOffsetId = scope.resolve('pixelOffset');
            				this.weightId = scope.resolve('weight[0]');
            				this.blurVsmShaderCode = [
            						shaderChunks.blurVSMPS,
            						"#define GAUSS\n" + shaderChunks.blurVSMPS
            				];
            				this.blurVsmShader = [
            						{},
            						{}
            				];
            				this.blurVsmWeights = {};
            				this.shadowMapLightRadiusId = scope.resolve('light_radius');
            				this.viewUniformFormat = null;
            				this.viewBindGroupFormat = null;
            				this.blendStateWrite = new BlendState();
            				this.blendStateNoWrite = new BlendState();
            				this.blendStateNoWrite.setColorWrite(false, false, false, false);
            		}
            }
            
            var tempClusterArray = [];
            class WorldClustersAllocator {
            		destroy() {
            				if (this._empty) {
            						this._empty.destroy();
            						this._empty = null;
            				}
            				this._allocated.forEach((cluster)=>{
            						cluster.destroy();
            				});
            				this._allocated.length = 0;
            		}
            		get count() {
            				return this._allocated.length;
            		}
            		get empty() {
            				if (!this._empty) {
            						var empty = new WorldClusters(this.device);
            						empty.name = 'ClusterEmpty';
            						empty.update([]);
            						this._empty = empty;
            				}
            				return this._empty;
            		}
            		assign(renderPasses) {
            				var empty = this.empty;
            				tempClusterArray.push(...this._allocated);
            				this._allocated.length = 0;
            				this._clusters.clear();
            				var passCount = renderPasses.length;
            				for(var p = 0; p < passCount; p++){
            						var renderPass = renderPasses[p];
            						var renderActions = renderPass.renderActions;
            						if (renderActions) {
            								var count = renderActions.length;
            								for(var i = 0; i < count; i++){
            										var ra = renderActions[i];
            										ra.lightClusters = null;
            										var layer = ra.layer;
            										if (layer.hasClusteredLights && layer.meshInstances.length) {
            												var hash = layer.getLightIdHash();
            												var existingRenderAction = this._clusters.get(hash);
            												var clusters = existingRenderAction == null ? void 0 : existingRenderAction.lightClusters;
            												if (!clusters) {
            														var _tempClusterArray_pop;
            														clusters = (_tempClusterArray_pop = tempClusterArray.pop()) != null ? _tempClusterArray_pop : new WorldClusters(this.device);
            														this._allocated.push(clusters);
            														this._clusters.set(hash, ra);
            												}
            												ra.lightClusters = clusters;
            										}
            										if (!ra.lightClusters) {
            												ra.lightClusters = empty;
            										}
            								}
            						}
            				}
            				tempClusterArray.forEach((item)=>item.destroy());
            				tempClusterArray.length = 0;
            		}
            		update(renderPasses, lighting) {
            				this.assign(renderPasses);
            				this._clusters.forEach((renderAction)=>{
            						var layer = renderAction.layer;
            						var cluster = renderAction.lightClusters;
            						cluster.update(layer.clusteredLightsSet, lighting);
            				});
            		}
            		constructor(graphicsDevice){
            				this._empty = null;
            				this._allocated = [];
            				this._clusters = new Map();
            				this.device = graphicsDevice;
            		}
            }
            
            var _viewport = new Vec4();
            var _invViewProjMatrices = [];
            class RenderPassCookieRenderer extends RenderPass {
            		destroy() {
            				var _this__quadRenderer2D, _this__quadRendererCube;
            				(_this__quadRenderer2D = this._quadRenderer2D) == null ? void 0 : _this__quadRenderer2D.destroy();
            				this._quadRenderer2D = null;
            				(_this__quadRendererCube = this._quadRendererCube) == null ? void 0 : _this__quadRendererCube.destroy();
            				this._quadRendererCube = null;
            		}
            		static create(renderTarget, cubeSlotsOffsets) {
            				var renderPass = new RenderPassCookieRenderer(renderTarget.device, cubeSlotsOffsets);
            				renderPass.init(renderTarget);
            				renderPass.colorOps.clear = false;
            				renderPass.depthStencilOps.clearDepth = false;
            				return renderPass;
            		}
            		update(lights) {
            				var filteredLights = this._filteredLights;
            				this.filter(lights, filteredLights);
            				this.executeEnabled = filteredLights.length > 0;
            		}
            		filter(lights, filteredLights) {
            				for(var i = 0; i < lights.length; i++){
            						var light = lights[i];
            						if (light._type === LIGHTTYPE_DIRECTIONAL) {
            								continue;
            						}
            						if (!light.atlasViewportAllocated) {
            								continue;
            						}
            						if (!light.atlasSlotUpdated) {
            								continue;
            						}
            						if (light.enabled && light.cookie && light.visibleThisFrame) {
            								filteredLights.push(light);
            						}
            				}
            		}
            		initInvViewProjMatrices() {
            				if (!_invViewProjMatrices.length) {
            						for(var face = 0; face < 6; face++){
            								var camera = LightCamera.create(null, LIGHTTYPE_OMNI, face);
            								var projMat = camera.projectionMatrix;
            								var viewMat = camera.node.getLocalTransform().clone().invert();
            								_invViewProjMatrices[face] = new Mat4().mul2(projMat, viewMat).invert();
            						}
            				}
            		}
            		get quadRenderer2D() {
            				if (!this._quadRenderer2D) {
            						var wgsl = this.device.isWebGPU;
            						var chunks = wgsl ? shaderChunksWGSL : shaderChunks;
            						var shader = createShaderFromCode(this.device, chunks.cookieBlitVS, chunks.cookieBlit2DPS, 'cookieRenderer2d', {
            								vertex_position: SEMANTIC_POSITION
            						}, {
            								shaderLanguage: wgsl ? SHADERLANGUAGE_WGSL : SHADERLANGUAGE_GLSL
            						});
            						this._quadRenderer2D = new QuadRender(shader);
            				}
            				return this._quadRenderer2D;
            		}
            		get quadRendererCube() {
            				if (!this._quadRendererCube) {
            						var wgsl = this.device.isWebGPU;
            						var chunks = wgsl ? shaderChunksWGSL : shaderChunks;
            						var shader = createShaderFromCode(this.device, chunks.cookieBlitVS, chunks.cookieBlitCubePS, 'cookieRendererCube', {
            								vertex_position: SEMANTIC_POSITION
            						}, {
            								shaderLanguage: wgsl ? SHADERLANGUAGE_WGSL : SHADERLANGUAGE_GLSL
            						});
            						this._quadRendererCube = new QuadRender(shader);
            				}
            				return this._quadRendererCube;
            		}
            		execute() {
            				var device = this.device;
            				device.setBlendState(BlendState.NOBLEND);
            				device.setCullMode(CULLFACE_NONE);
            				device.setDepthState(DepthState.NODEPTH);
            				device.setStencilState();
            				var renderTargetWidth = this.renderTarget.colorBuffer.width;
            				var cubeSlotsOffsets = this._cubeSlotsOffsets;
            				var filteredLights = this._filteredLights;
            				for(var i = 0; i < filteredLights.length; i++){
            						var light = filteredLights[i];
            						var faceCount = light.numShadowFaces;
            						var quad = faceCount > 1 ? this.quadRendererCube : this.quadRenderer2D;
            						if (faceCount > 1) {
            								this.initInvViewProjMatrices();
            						}
            						this.blitTextureId.setValue(light.cookie);
            						for(var face = 0; face < faceCount; face++){
            								_viewport.copy(light.atlasViewport);
            								if (faceCount > 1) {
            										var smallSize = _viewport.z / 3;
            										var offset = cubeSlotsOffsets[face];
            										_viewport.x += smallSize * offset.x;
            										_viewport.y += smallSize * offset.y;
            										_viewport.z = smallSize;
            										_viewport.w = smallSize;
            										this.invViewProjId.setValue(_invViewProjMatrices[face].data);
            								}
            								_viewport.mulScalar(renderTargetWidth);
            								quad.render(_viewport);
            						}
            				}
            				filteredLights.length = 0;
            		}
            		constructor(device, cubeSlotsOffsets){
            				super(device), this._quadRenderer2D = null, this._quadRendererCube = null, this._filteredLights = [];
            				this._cubeSlotsOffsets = cubeSlotsOffsets;
            				this.requiresCubemaps = false;
            				this.blitTextureId = device.scope.resolve('blitTexture');
            				this.invViewProjId = device.scope.resolve('invViewProj');
            		}
            }
            
            class RenderPassShadowLocalClustered extends RenderPass {
            		update(localLights) {
            				var shadowLights = this.shadowRendererLocal.shadowLights;
            				var shadowCamera = this.shadowRendererLocal.prepareLights(shadowLights, localLights);
            				var count = shadowLights.length;
            				this.enabled = count > 0;
            				if (count) {
            						this.shadowRenderer.setupRenderPass(this, shadowCamera, false);
            				}
            		}
            		execute() {
            				var shadowLights = this.shadowRendererLocal.shadowLights;
            				var count = shadowLights.length;
            				for(var i = 0; i < count; i++){
            						var light = shadowLights[i];
            						for(var face = 0; face < light.numShadowFaces; face++){
            								this.shadowRenderer.renderFace(light, null, face, true);
            						}
            				}
            				shadowLights.length = 0;
            		}
            		constructor(device, shadowRenderer, shadowRendererLocal){
            				super(device);
            				this.requiresCubemaps = false;
            				this.shadowRenderer = shadowRenderer;
            				this.shadowRendererLocal = shadowRendererLocal;
            		}
            }
            
            class RenderPassUpdateClustered extends RenderPass {
            		update(frameGraph, shadowsEnabled, cookiesEnabled, lights, localLights) {
            				this.frameGraph = frameGraph;
            				this.cookiesRenderPass.enabled = cookiesEnabled;
            				if (cookiesEnabled) {
            						this.cookiesRenderPass.update(lights);
            				}
            				this.shadowRenderPass.enabled = shadowsEnabled;
            				if (shadowsEnabled) {
            						this.shadowRenderPass.update(localLights);
            				}
            		}
            		destroy() {
            				this.cookiesRenderPass.destroy();
            				this.cookiesRenderPass = null;
            		}
            		execute() {
            				var { renderer } = this;
            				var { scene } = renderer;
            				renderer.worldClustersAllocator.update(this.frameGraph.renderPasses, scene.lighting);
            		}
            		constructor(device, renderer, shadowRenderer, shadowRendererLocal, lightTextureAtlas){
            				super(device);
            				this.renderer = renderer;
            				this.frameGraph = null;
            				this.cookiesRenderPass = RenderPassCookieRenderer.create(lightTextureAtlas.cookieRenderTarget, lightTextureAtlas.cubeSlotsOffsets);
            				this.beforePasses.push(this.cookiesRenderPass);
            				this.shadowRenderPass = new RenderPassShadowLocalClustered(device, shadowRenderer, shadowRendererLocal);
            				this.beforePasses.push(this.shadowRenderPass);
            		}
            }
            
            var _skinUpdateIndex = 0;
            var viewProjMat = new Mat4();
            var viewInvMat = new Mat4();
            var viewMat = new Mat4();
            var viewMat3 = new Mat3();
            var tempSphere$1 = new BoundingSphere();
            var _flipYMat = new Mat4().setScale(1, -1, 1);
            var _tempLightSet = new Set();
            var _tempLayerSet = new Set();
            var _dynamicBindGroup = new DynamicBindGroup();
            var _fixProjRangeMat = new Mat4().set([
            		1,
            		0,
            		0,
            		0,
            		0,
            		1,
            		0,
            		0,
            		0,
            		0,
            		0.5,
            		0,
            		0,
            		0,
            		0.5,
            		1
            ]);
            var _haltonSequence = [
            		new Vec2(0.5, 0.333333),
            		new Vec2(0.25, 0.666667),
            		new Vec2(0.75, 0.111111),
            		new Vec2(0.125, 0.444444),
            		new Vec2(0.625, 0.777778),
            		new Vec2(0.375, 0.222222),
            		new Vec2(0.875, 0.555556),
            		new Vec2(0.0625, 0.888889),
            		new Vec2(0.5625, 0.037037),
            		new Vec2(0.3125, 0.370370),
            		new Vec2(0.8125, 0.703704),
            		new Vec2(0.1875, 0.148148),
            		new Vec2(0.6875, 0.481481),
            		new Vec2(0.4375, 0.814815),
            		new Vec2(0.9375, 0.259259),
            		new Vec2(0.03125, 0.592593)
            ];
            var _tempProjMat0 = new Mat4();
            var _tempProjMat1 = new Mat4();
            var _tempProjMat2 = new Mat4();
            var _tempProjMat3 = new Mat4();
            var _tempProjMat4 = new Mat4();
            var _tempProjMat5 = new Mat4();
            var _tempSet = new Set();
            var _tempMeshInstances = [];
            var _tempMeshInstancesSkinned = [];
            class Renderer {
            		destroy() {
            				this.shadowRenderer = null;
            				this._shadowRendererLocal = null;
            				this._shadowRendererDirectional = null;
            				this.shadowMapCache.destroy();
            				this.shadowMapCache = null;
            				this._renderPassUpdateClustered.destroy();
            				this._renderPassUpdateClustered = null;
            				this.lightTextureAtlas.destroy();
            				this.lightTextureAtlas = null;
            		}
            		setupViewport(camera, renderTarget) {
            				var device = this.device;
            				var pixelWidth = renderTarget ? renderTarget.width : device.width;
            				var pixelHeight = renderTarget ? renderTarget.height : device.height;
            				var rect = camera.rect;
            				var x = Math.floor(rect.x * pixelWidth);
            				var y = Math.floor(rect.y * pixelHeight);
            				var w = Math.floor(rect.z * pixelWidth);
            				var h = Math.floor(rect.w * pixelHeight);
            				device.setViewport(x, y, w, h);
            				if (camera._scissorRectClear) {
            						var scissorRect = camera.scissorRect;
            						x = Math.floor(scissorRect.x * pixelWidth);
            						y = Math.floor(scissorRect.y * pixelHeight);
            						w = Math.floor(scissorRect.z * pixelWidth);
            						h = Math.floor(scissorRect.w * pixelHeight);
            				}
            				device.setScissor(x, y, w, h);
            		}
            		setCameraUniforms(camera, target) {
            				var flipY = target == null ? void 0 : target.flipY;
            				var viewCount = 1;
            				if (camera.xr && camera.xr.session) {
            						var _camera__node_parent, _camera__node;
            						var transform = ((_camera__node = camera._node) == null ? void 0 : (_camera__node_parent = _camera__node.parent) == null ? void 0 : _camera__node_parent.getWorldTransform()) || null;
            						var views = camera.xr.views;
            						viewCount = views.list.length;
            						for(var v = 0; v < viewCount; v++){
            								var view = views.list[v];
            								view.updateTransforms(transform);
            								camera.frustum.setFromMat4(view.projViewOffMat);
            						}
            				} else {
            						var projMat = camera.projectionMatrix;
            						if (camera.calculateProjection) {
            								camera.calculateProjection(projMat, VIEW_CENTER);
            						}
            						var projMatSkybox = camera.getProjectionMatrixSkybox();
            						if (flipY) {
            								projMat = _tempProjMat0.mul2(_flipYMat, projMat);
            								projMatSkybox = _tempProjMat1.mul2(_flipYMat, projMatSkybox);
            						}
            						if (this.device.isWebGPU) {
            								projMat = _tempProjMat2.mul2(_fixProjRangeMat, projMat);
            								projMatSkybox = _tempProjMat3.mul2(_fixProjRangeMat, projMatSkybox);
            						}
            						var { jitter } = camera;
            						var jitterX = 0;
            						var jitterY = 0;
            						if (jitter > 0) {
            								var targetWidth = target ? target.width : this.device.width;
            								var targetHeight = target ? target.height : this.device.height;
            								var offset = _haltonSequence[this.device.renderVersion % _haltonSequence.length];
            								jitterX = jitter * (offset.x * 2 - 1) / targetWidth;
            								jitterY = jitter * (offset.y * 2 - 1) / targetHeight;
            								projMat = _tempProjMat4.copy(projMat);
            								projMat.data[8] = jitterX;
            								projMat.data[9] = jitterY;
            								projMatSkybox = _tempProjMat5.copy(projMatSkybox);
            								projMatSkybox.data[8] = jitterX;
            								projMatSkybox.data[9] = jitterY;
            								if (this.blueNoiseJitterVersion !== this.device.renderVersion) {
            										this.blueNoiseJitterVersion = this.device.renderVersion;
            										this.blueNoise.vec4(this.blueNoiseJitterVec);
            								}
            						}
            						var jitterVec = jitter > 0 ? this.blueNoiseJitterVec : Vec4.ZERO;
            						this.blueNoiseJitterData[0] = jitterVec.x;
            						this.blueNoiseJitterData[1] = jitterVec.y;
            						this.blueNoiseJitterData[2] = jitterVec.z;
            						this.blueNoiseJitterData[3] = jitterVec.w;
            						this.blueNoiseJitterId.setValue(this.blueNoiseJitterData);
            						this.projId.setValue(projMat.data);
            						this.projSkyboxId.setValue(projMatSkybox.data);
            						if (camera.calculateTransform) {
            								camera.calculateTransform(viewInvMat, VIEW_CENTER);
            						} else {
            								var pos = camera._node.getPosition();
            								var rot = camera._node.getRotation();
            								viewInvMat.setTRS(pos, rot, Vec3.ONE);
            						}
            						this.viewInvId.setValue(viewInvMat.data);
            						viewMat.copy(viewInvMat).invert();
            						this.viewId.setValue(viewMat.data);
            						viewMat3.setFromMat4(viewMat);
            						this.viewId3.setValue(viewMat3.data);
            						viewProjMat.mul2(projMat, viewMat);
            						this.viewProjId.setValue(viewProjMat.data);
            						camera._storeShaderMatrices(viewProjMat, jitterX, jitterY, this.device.renderVersion);
            						this.flipYId.setValue(flipY ? -1 : 1);
            						this.dispatchViewPos(camera._node.getPosition());
            						camera.frustum.setFromMat4(viewProjMat);
            				}
            				this.tbnBasis.setValue(flipY ? -1 : 1);
            				var n = camera._nearClip;
            				var f = camera._farClip;
            				this.nearClipId.setValue(n);
            				this.farClipId.setValue(f);
            				this.cameraParams[0] = 1 / f;
            				this.cameraParams[1] = f;
            				this.cameraParams[2] = n;
            				this.cameraParams[3] = camera.projection === PROJECTION_ORTHOGRAPHIC ? 1 : 0;
            				this.cameraParamsId.setValue(this.cameraParams);
            				this.exposureId.setValue(this.scene.physicalUnits ? camera.getExposure() : this.scene.exposure);
            				return viewCount;
            		}
            		clear(camera, clearColor, clearDepth, clearStencil) {
            				var flags = ((clearColor != null ? clearColor : camera._clearColorBuffer) ? CLEARFLAG_COLOR : 0) | ((clearDepth != null ? clearDepth : camera._clearDepthBuffer) ? CLEARFLAG_DEPTH : 0) | ((clearStencil != null ? clearStencil : camera._clearStencilBuffer) ? CLEARFLAG_STENCIL : 0);
            				if (flags) {
            						var device = this.device;
            						device.clear({
            								color: [
            										camera._clearColor.r,
            										camera._clearColor.g,
            										camera._clearColor.b,
            										camera._clearColor.a
            								],
            								depth: camera._clearDepth,
            								stencil: camera._clearStencil,
            								flags: flags
            						});
            				}
            		}
            		setCamera(camera, target, clear, renderAction) {
            				this.setCameraUniforms(camera, target);
            				this.clearView(camera, target, clear, false);
            		}
            		clearView(camera, target, clear, forceWrite) {
            				var device = this.device;
            				device.setRenderTarget(target);
            				device.updateBegin();
            				if (forceWrite) {
            						device.setColorWrite(true, true, true, true);
            						device.setDepthWrite(true);
            				}
            				this.setupViewport(camera, target);
            				if (clear) {
            						var options = camera._clearOptions;
            						device.clear(options ? options : {
            								color: [
            										camera._clearColor.r,
            										camera._clearColor.g,
            										camera._clearColor.b,
            										camera._clearColor.a
            								],
            								depth: camera._clearDepth,
            								flags: (camera._clearColorBuffer ? CLEARFLAG_COLOR : 0) | (camera._clearDepthBuffer ? CLEARFLAG_DEPTH : 0) | (camera._clearStencilBuffer ? CLEARFLAG_STENCIL : 0),
            								stencil: camera._clearStencil
            						});
            				}
            		}
            		setupCullMode(cullFaces, flipFactor, drawCall) {
            				var material = drawCall.material;
            				var mode = CULLFACE_NONE;
            				if (cullFaces) {
            						var flipFaces = 1;
            						if (material.cull === CULLFACE_FRONT || material.cull === CULLFACE_BACK) {
            								flipFaces = flipFactor * drawCall.flipFacesFactor * drawCall.node.worldScaleSign;
            						}
            						if (flipFaces < 0) {
            								mode = material.cull === CULLFACE_FRONT ? CULLFACE_BACK : CULLFACE_FRONT;
            						} else {
            								mode = material.cull;
            						}
            				}
            				this.device.setCullMode(mode);
            				if (mode === CULLFACE_NONE && material.cull === CULLFACE_NONE) {
            						this.twoSidedLightingNegScaleFactorId.setValue(drawCall.node.worldScaleSign);
            				}
            		}
            		updateCameraFrustum(camera) {
            				if (camera.xr && camera.xr.views.list.length) {
            						var view = camera.xr.views.list[0];
            						viewProjMat.mul2(view.projMat, view.viewOffMat);
            						camera.frustum.setFromMat4(viewProjMat);
            						return;
            				}
            				var projMat = camera.projectionMatrix;
            				if (camera.calculateProjection) {
            						camera.calculateProjection(projMat, VIEW_CENTER);
            				}
            				if (camera.calculateTransform) {
            						camera.calculateTransform(viewInvMat, VIEW_CENTER);
            				} else {
            						var pos = camera._node.getPosition();
            						var rot = camera._node.getRotation();
            						viewInvMat.setTRS(pos, rot, Vec3.ONE);
            						this.viewInvId.setValue(viewInvMat.data);
            				}
            				viewMat.copy(viewInvMat).invert();
            				viewProjMat.mul2(projMat, viewMat);
            				camera.frustum.setFromMat4(viewProjMat);
            		}
            		setBaseConstants(device, material) {
            				device.setCullMode(material.cull);
            				if (material.opacityMap) {
            						this.opacityMapId.setValue(material.opacityMap);
            				}
            				if (material.opacityMap || material.alphaTest > 0) {
            						this.alphaTestId.setValue(material.alphaTest);
            				}
            		}
            		updateCpuSkinMatrices(drawCalls) {
            				_skinUpdateIndex++;
            				var drawCallsCount = drawCalls.length;
            				if (drawCallsCount === 0) return;
            				for(var i = 0; i < drawCallsCount; i++){
            						var si = drawCalls[i].skinInstance;
            						if (si) {
            								si.updateMatrices(drawCalls[i].node, _skinUpdateIndex);
            								si._dirty = true;
            						}
            				}
            		}
            		updateGpuSkinMatrices(drawCalls) {
            				for (var drawCall of drawCalls){
            						var skin = drawCall.skinInstance;
            						if (skin && skin._dirty) {
            								skin.updateMatrixPalette(drawCall.node, _skinUpdateIndex);
            								skin._dirty = false;
            						}
            				}
            		}
            		updateMorphing(drawCalls) {
            				for (var drawCall of drawCalls){
            						var morphInst = drawCall.morphInstance;
            						if (morphInst && morphInst._dirty) {
            								morphInst.update();
            						}
            				}
            		}
            		updateGSplats(drawCalls) {
            				for (var drawCall of drawCalls){
            						var _drawCall_gsplatInstance;
            						(_drawCall_gsplatInstance = drawCall.gsplatInstance) == null ? void 0 : _drawCall_gsplatInstance.update();
            				}
            		}
            		gpuUpdate(drawCalls) {
            				this.updateGpuSkinMatrices(drawCalls);
            				this.updateMorphing(drawCalls);
            				this.updateGSplats(drawCalls);
            		}
            		setVertexBuffers(device, mesh) {
            				device.setVertexBuffer(mesh.vertexBuffer);
            		}
            		setMorphing(device, morphInstance) {
            				if (morphInstance) {
            						morphInstance.prepareRendering(device);
            						device.setVertexBuffer(morphInstance.morph.vertexBufferIds);
            						this.morphPositionTex.setValue(morphInstance.texturePositions);
            						this.morphNormalTex.setValue(morphInstance.textureNormals);
            						this.morphTexParams.setValue(morphInstance._textureParams);
            				}
            		}
            		setSkinning(device, meshInstance) {
            				var skinInstance = meshInstance.skinInstance;
            				if (skinInstance) {
            						this._skinDrawCalls++;
            						var boneTexture = skinInstance.boneTexture;
            						this.boneTextureId.setValue(boneTexture);
            				}
            		}
            		dispatchViewPos(position) {
            				var vp = this.viewPos;
            				vp[0] = position.x;
            				vp[1] = position.y;
            				vp[2] = position.z;
            				this.viewPosId.setValue(vp);
            		}
            		initViewBindGroupFormat(isClustered) {
            				if (this.device.supportsUniformBuffers && !this.viewUniformFormat) {
            						var uniforms = [
            								new UniformFormat('matrix_viewProjection', UNIFORMTYPE_MAT4),
            								new UniformFormat('cubeMapRotationMatrix', UNIFORMTYPE_MAT3),
            								new UniformFormat('view_position', UNIFORMTYPE_VEC3),
            								new UniformFormat('skyboxIntensity', UNIFORMTYPE_FLOAT),
            								new UniformFormat('exposure', UNIFORMTYPE_FLOAT),
            								new UniformFormat('textureBias', UNIFORMTYPE_FLOAT)
            						];
            						if (isClustered) {
            								uniforms.push(...[
            										new UniformFormat('clusterCellsCountByBoundsSize', UNIFORMTYPE_VEC3),
            										new UniformFormat('clusterTextureSize', UNIFORMTYPE_VEC3),
            										new UniformFormat('clusterBoundsMin', UNIFORMTYPE_VEC3),
            										new UniformFormat('clusterBoundsDelta', UNIFORMTYPE_VEC3),
            										new UniformFormat('clusterCellsDot', UNIFORMTYPE_VEC3),
            										new UniformFormat('clusterCellsMax', UNIFORMTYPE_VEC3),
            										new UniformFormat('shadowAtlasParams', UNIFORMTYPE_VEC2),
            										new UniformFormat('clusterMaxCells', UNIFORMTYPE_INT),
            										new UniformFormat('clusterSkip', UNIFORMTYPE_FLOAT)
            								]);
            						}
            						this.viewUniformFormat = new UniformBufferFormat(this.device, uniforms);
            						var formats = [
            								new BindUniformBufferFormat(UNIFORM_BUFFER_DEFAULT_SLOT_NAME, SHADERSTAGE_VERTEX | SHADERSTAGE_FRAGMENT)
            						];
            						this.viewBindGroupFormat = new BindGroupFormat(this.device, formats);
            				}
            		}
            		setupViewUniformBuffers(viewBindGroups, viewUniformFormat, viewBindGroupFormat, viewCount) {
            				var device = this.device;
            				while(viewBindGroups.length < viewCount){
            						var ub = new UniformBuffer(device, viewUniformFormat, false);
            						var bg = new BindGroup(device, viewBindGroupFormat, ub);
            						viewBindGroups.push(bg);
            				}
            				var viewBindGroup = viewBindGroups[0];
            				viewBindGroup.defaultUniformBuffer.update();
            				viewBindGroup.update();
            				device.setBindGroup(BINDGROUP_VIEW, viewBindGroup);
            		}
            		setupMeshUniformBuffers(shaderInstance, meshInstance) {
            				var device = this.device;
            				if (device.supportsUniformBuffers) {
            						this.modelMatrixId.setValue(meshInstance.node.worldTransform.data);
            						this.normalMatrixId.setValue(meshInstance.node.normalMatrix.data);
            						var meshBindGroup = shaderInstance.getBindGroup(device);
            						meshBindGroup.update();
            						device.setBindGroup(BINDGROUP_MESH, meshBindGroup);
            						var meshUniformBuffer = shaderInstance.getUniformBuffer(device);
            						meshUniformBuffer.update(_dynamicBindGroup);
            						device.setBindGroup(BINDGROUP_MESH_UB, _dynamicBindGroup.bindGroup, _dynamicBindGroup.offsets);
            				}
            		}
            		drawInstance(device, meshInstance, mesh, style, normal) {
            				var modelMatrix = meshInstance.node.worldTransform;
            				this.modelMatrixId.setValue(modelMatrix.data);
            				if (normal) {
            						this.normalMatrixId.setValue(meshInstance.node.normalMatrix.data);
            				}
            				var instancingData = meshInstance.instancingData;
            				if (instancingData) {
            						if (instancingData.count > 0) {
            								this._instancedDrawCalls++;
            								device.setVertexBuffer(instancingData.vertexBuffer);
            								device.draw(mesh.primitive[style], instancingData.count);
            						} else {
            								device.clearVertexBuffer();
            								device.clearIndexBuffer();
            						}
            				} else {
            						device.draw(mesh.primitive[style]);
            				}
            		}
            		drawInstance2(device, meshInstance, mesh, style) {
            				var instancingData = meshInstance.instancingData;
            				if (instancingData) {
            						if (instancingData.count > 0) {
            								this._instancedDrawCalls++;
            								device.draw(mesh.primitive[style], instancingData.count, true);
            						} else {
            								device.clearVertexBuffer();
            								device.clearIndexBuffer();
            						}
            				} else {
            						device.draw(mesh.primitive[style], undefined, true);
            				}
            		}
            		cull(camera, drawCalls, culledInstances) {
            				var opaque = culledInstances.opaque;
            				opaque.length = 0;
            				var transparent = culledInstances.transparent;
            				transparent.length = 0;
            				var doCull = camera.frustumCulling;
            				var count = drawCalls.length;
            				for(var i = 0; i < count; i++){
            						var drawCall = drawCalls[i];
            						if (drawCall.visible) {
            								var visible = !doCull || !drawCall.cull || drawCall._isVisible(camera);
            								if (visible) {
            										drawCall.visibleThisFrame = true;
            										var bucket = drawCall.transparent ? transparent : opaque;
            										bucket.push(drawCall);
            										if (drawCall.skinInstance || drawCall.morphInstance || drawCall.gsplatInstance) {
            												this.processingMeshInstances.add(drawCall);
            												if (drawCall.gsplatInstance) {
            														drawCall.gsplatInstance.cameras.push(camera);
            												}
            										}
            								}
            						}
            				}
            		}
            		collectLights(comp) {
            				this.lights.length = 0;
            				this.localLights.length = 0;
            				var stats = this.scene._stats;
            				var count = comp.layerList.length;
            				for(var i = 0; i < count; i++){
            						var layer = comp.layerList[i];
            						if (!_tempLayerSet.has(layer)) {
            								_tempLayerSet.add(layer);
            								var lights = layer._lights;
            								for(var j = 0; j < lights.length; j++){
            										var light = lights[j];
            										if (!_tempLightSet.has(light)) {
            												_tempLightSet.add(light);
            												this.lights.push(light);
            												if (light._type !== LIGHTTYPE_DIRECTIONAL) {
            														this.localLights.push(light);
            												}
            										}
            								}
            						}
            				}
            				stats.lights = this.lights.length;
            				_tempLightSet.clear();
            				_tempLayerSet.clear();
            		}
            		cullLights(camera, lights) {
            				var clusteredLightingEnabled = this.scene.clusteredLightingEnabled;
            				var physicalUnits = this.scene.physicalUnits;
            				for(var i = 0; i < lights.length; i++){
            						var light = lights[i];
            						if (light.enabled) {
            								if (light._type !== LIGHTTYPE_DIRECTIONAL) {
            										light.getBoundingSphere(tempSphere$1);
            										if (camera.frustum.containsSphere(tempSphere$1)) {
            												light.visibleThisFrame = true;
            												light.usePhysicalUnits = physicalUnits;
            												var screenSize = camera.getScreenSize(tempSphere$1);
            												light.maxScreenSize = Math.max(light.maxScreenSize, screenSize);
            										} else {
            												if (!clusteredLightingEnabled) {
            														if (light.castShadows && !light.shadowMap) {
            																light.visibleThisFrame = true;
            														}
            												}
            										}
            								} else {
            										light.usePhysicalUnits = this.scene.physicalUnits;
            								}
            						}
            				}
            		}
            		cullShadowmaps(comp) {
            				var isClustered = this.scene.clusteredLightingEnabled;
            				for(var i = 0; i < this.localLights.length; i++){
            						var light = this.localLights[i];
            						if (light._type !== LIGHTTYPE_DIRECTIONAL) {
            								if (isClustered) {
            										if (light.atlasSlotUpdated && light.shadowUpdateMode === SHADOWUPDATE_NONE) {
            												light.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
            										}
            								} else {
            										if (light.shadowUpdateMode === SHADOWUPDATE_NONE && light.castShadows) {
            												if (!light.getRenderData(null, 0).shadowCamera.renderTarget) {
            														light.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
            												}
            										}
            								}
            								if (light.visibleThisFrame && light.castShadows && light.shadowUpdateMode !== SHADOWUPDATE_NONE) {
            										this._shadowRendererLocal.cull(light, comp);
            								}
            						}
            				}
            				this.cameraDirShadowLights.clear();
            				var cameras = comp.cameras;
            				for(var i1 = 0; i1 < cameras.length; i1++){
            						var cameraComponent = cameras[i1];
            						if (cameraComponent.enabled) {
            								var camera = cameraComponent.camera;
            								var lightList = void 0;
            								var cameraLayers = camera.layers;
            								for(var l = 0; l < cameraLayers.length; l++){
            										var cameraLayer = comp.getLayerById(cameraLayers[l]);
            										if (cameraLayer) {
            												var layerDirLights = cameraLayer.splitLights[LIGHTTYPE_DIRECTIONAL];
            												for(var j = 0; j < layerDirLights.length; j++){
            														var light1 = layerDirLights[j];
            														if (light1.castShadows && !_tempSet.has(light1)) {
            																_tempSet.add(light1);
            																lightList = lightList != null ? lightList : [];
            																lightList.push(light1);
            																this._shadowRendererDirectional.cull(light1, comp, camera);
            														}
            												}
            										}
            								}
            								if (lightList) {
            										this.cameraDirShadowLights.set(camera, lightList);
            								}
            								_tempSet.clear();
            						}
            				}
            		}
            		cullComposition(comp) {
            				var { scene } = this;
            				this.processingMeshInstances.clear();
            				var numCameras = comp.cameras.length;
            				this._camerasRendered += numCameras;
            				for(var i = 0; i < numCameras; i++){
            						var camera = comp.cameras[i];
            						scene == null ? void 0 : scene.fire(EVENT_PRECULL, camera);
            						var renderTarget = camera.renderTarget;
            						camera.frameUpdate(renderTarget);
            						this.updateCameraFrustum(camera.camera);
            						var layerIds = camera.layers;
            						for(var j = 0; j < layerIds.length; j++){
            								var layer = comp.getLayerById(layerIds[j]);
            								if (layer && layer.enabled) {
            										this.cullLights(camera.camera, layer._lights);
            										var culledInstances = layer.getCulledInstances(camera.camera);
            										this.cull(camera.camera, layer.meshInstances, culledInstances);
            								}
            						}
            						scene == null ? void 0 : scene.fire(EVENT_POSTCULL, camera);
            				}
            				if (scene.clusteredLightingEnabled) {
            						this.updateLightTextureAtlas();
            				}
            				this.cullShadowmaps(comp);
            		}
            		updateShaders(drawCalls, onlyLitShaders) {
            				var count = drawCalls.length;
            				for(var i = 0; i < count; i++){
            						var mat = drawCalls[i].material;
            						if (mat) {
            								if (!_tempSet.has(mat)) {
            										_tempSet.add(mat);
            										if (mat.getShaderVariant !== Material.prototype.getShaderVariant) {
            												if (onlyLitShaders) {
            														if (!mat.useLighting || mat.emitter && !mat.emitter.lighting) {
            																continue;
            														}
            												}
            												mat.clearVariants();
            										}
            								}
            						}
            				}
            				_tempSet.clear();
            		}
            		updateFrameUniforms() {
            				this.blueNoiseTextureId.setValue(getBlueNoiseTexture(this.device));
            		}
            		beginFrame(comp) {
            				var scene = this.scene;
            				var updateShaders = scene.updateShaders || this.device._shadersDirty;
            				var layers = comp.layerList;
            				var layerCount = layers.length;
            				for(var i = 0; i < layerCount; i++){
            						var layer = layers[i];
            						var meshInstances = layer.meshInstances;
            						var count = meshInstances.length;
            						for(var j = 0; j < count; j++){
            								var meshInst = meshInstances[j];
            								meshInst.visibleThisFrame = false;
            								if (updateShaders) {
            										_tempMeshInstances.push(meshInst);
            								}
            								if (meshInst.skinInstance) {
            										_tempMeshInstancesSkinned.push(meshInst);
            								}
            						}
            				}
            				if (updateShaders) {
            						var onlyLitShaders = !scene.updateShaders || !this.device._shadersDirty;
            						this.updateShaders(_tempMeshInstances, onlyLitShaders);
            						scene.updateShaders = false;
            						this.device._shadersDirty = false;
            						scene._shaderVersion++;
            				}
            				this.updateFrameUniforms();
            				this.updateCpuSkinMatrices(_tempMeshInstancesSkinned);
            				_tempMeshInstances.length = 0;
            				_tempMeshInstancesSkinned.length = 0;
            				var lights = this.lights;
            				var lightCount = lights.length;
            				for(var i1 = 0; i1 < lightCount; i1++){
            						lights[i1].beginFrame();
            				}
            		}
            		updateLightTextureAtlas() {
            				this.lightTextureAtlas.update(this.localLights, this.scene.lighting);
            		}
            		updateLayerComposition(comp) {
            				var len = comp.layerList.length;
            				var scene = this.scene;
            				var shaderVersion = scene._shaderVersion;
            				for(var i = 0; i < len; i++){
            						var layer = comp.layerList[i];
            						layer._shaderVersion = shaderVersion;
            				}
            				comp._update();
            		}
            		frameUpdate() {
            				this.clustersDebugRendered = false;
            				this.initViewBindGroupFormat(this.scene.clusteredLightingEnabled);
            				this.dirLightShadows.clear();
            		}
            		constructor(graphicsDevice){
            				this.clustersDebugRendered = false;
            				this.processingMeshInstances = new Set();
            				this.lights = [];
            				this.localLights = [];
            				this.cameraDirShadowLights = new Map();
            				this.dirLightShadows = new Map();
            				this.blueNoise = new BlueNoise(123);
            				this.device = graphicsDevice;
            				this.scene = null;
            				this.worldClustersAllocator = new WorldClustersAllocator(graphicsDevice);
            				this.lightTextureAtlas = new LightTextureAtlas(graphicsDevice);
            				this.shadowMapCache = new ShadowMapCache();
            				this.shadowRenderer = new ShadowRenderer(this, this.lightTextureAtlas);
            				this._shadowRendererLocal = new ShadowRendererLocal(this, this.shadowRenderer);
            				this._shadowRendererDirectional = new ShadowRendererDirectional(this, this.shadowRenderer);
            				this._renderPassUpdateClustered = new RenderPassUpdateClustered(this.device, this, this.shadowRenderer, this._shadowRendererLocal, this.lightTextureAtlas);
            				this.viewUniformFormat = null;
            				this.viewBindGroupFormat = null;
            				this._skinTime = 0;
            				this._morphTime = 0;
            				this._cullTime = 0;
            				this._shadowMapTime = 0;
            				this._lightClustersTime = 0;
            				this._layerCompositionUpdateTime = 0;
            				this._shadowDrawCalls = 0;
            				this._skinDrawCalls = 0;
            				this._instancedDrawCalls = 0;
            				this._shadowMapUpdates = 0;
            				this._numDrawCallsCulled = 0;
            				this._camerasRendered = 0;
            				this._lightClusters = 0;
            				var scope = graphicsDevice.scope;
            				this.boneTextureId = scope.resolve('texture_poseMap');
            				this.modelMatrixId = scope.resolve('matrix_model');
            				this.normalMatrixId = scope.resolve('matrix_normal');
            				this.viewInvId = scope.resolve('matrix_viewInverse');
            				this.viewPos = new Float32Array(3);
            				this.viewPosId = scope.resolve('view_position');
            				this.projId = scope.resolve('matrix_projection');
            				this.projSkyboxId = scope.resolve('matrix_projectionSkybox');
            				this.viewId = scope.resolve('matrix_view');
            				this.viewId3 = scope.resolve('matrix_view3');
            				this.viewProjId = scope.resolve('matrix_viewProjection');
            				this.flipYId = scope.resolve('projectionFlipY');
            				this.tbnBasis = scope.resolve('tbnBasis');
            				this.nearClipId = scope.resolve('camera_near');
            				this.farClipId = scope.resolve('camera_far');
            				this.cameraParams = new Float32Array(4);
            				this.cameraParamsId = scope.resolve('camera_params');
            				this.viewIndexId = scope.resolve('view_index');
            				this.blueNoiseJitterVersion = 0;
            				this.blueNoiseJitterVec = new Vec4();
            				this.blueNoiseJitterData = new Float32Array(4);
            				this.blueNoiseJitterId = scope.resolve('blueNoiseJitter');
            				this.blueNoiseTextureId = scope.resolve('blueNoiseTex32');
            				this.alphaTestId = scope.resolve('alpha_ref');
            				this.opacityMapId = scope.resolve('texture_opacityMap');
            				this.exposureId = scope.resolve('exposure');
            				this.twoSidedLightingNegScaleFactorId = scope.resolve('twoSidedLightingNegScaleFactor');
            				this.twoSidedLightingNegScaleFactorId.setValue(0);
            				this.morphPositionTex = scope.resolve('morphPositionTex');
            				this.morphNormalTex = scope.resolve('morphNormalTex');
            				this.morphTexParams = scope.resolve('morph_tex_params');
            				this.lightCube = new LightCube();
            				this.constantLightCube = scope.resolve('lightCube[0]');
            		}
            }
            
            class RenderAction {
            		destroy() {
            				this.viewBindGroups.forEach((bg)=>{
            						bg.defaultUniformBuffer.destroy();
            						bg.destroy();
            				});
            				this.viewBindGroups.length = 0;
            		}
            		setupClears(camera, layer) {
            				this.clearColor = (camera == null ? void 0 : camera.clearColorBuffer) || layer.clearColorBuffer;
            				this.clearDepth = (camera == null ? void 0 : camera.clearDepthBuffer) || layer.clearDepthBuffer;
            				this.clearStencil = (camera == null ? void 0 : camera.clearStencilBuffer) || layer.clearStencilBuffer;
            		}
            		constructor(){
            				this.camera = null;
            				this.layer = null;
            				this.transparent = false;
            				this.renderTarget = null;
            				this.lightClusters = null;
            				this.clearColor = false;
            				this.clearDepth = false;
            				this.clearStencil = false;
            				this.triggerPostprocess = false;
            				this.firstCameraUse = false;
            				this.lastCameraUse = false;
            				this.viewBindGroups = [];
            				this.useCameraPasses = false;
            		}
            }
            
            class RenderPassForward extends RenderPass {
            		get rendersAnything() {
            				return this.renderActions.length > 0;
            		}
            		addRenderAction(renderAction) {
            				this.renderActions.push(renderAction);
            		}
            		addLayer(cameraComponent, layer, transparent, autoClears) {
            				if (autoClears === void 0) autoClears = true;
            				var ra = new RenderAction();
            				ra.renderTarget = this.renderTarget;
            				ra.camera = cameraComponent;
            				ra.layer = layer;
            				ra.transparent = transparent;
            				if (autoClears) {
            						var firstRa = this.renderActions.length === 0;
            						ra.setupClears(firstRa ? cameraComponent : undefined, layer);
            				}
            				this.addRenderAction(ra);
            		}
            		addLayers(composition, cameraComponent, startIndex, firstLayerClears, lastLayerId, lastLayerIsTransparent) {
            				if (lastLayerIsTransparent === void 0) lastLayerIsTransparent = true;
            				var { layerList, subLayerList } = composition;
            				var clearRenderTarget = firstLayerClears;
            				var index = startIndex;
            				while(index < layerList.length){
            						var layer = layerList[index];
            						var isTransparent = subLayerList[index];
            						var renderedByCamera = cameraComponent.camera.layersSet.has(layer.id);
            						if (renderedByCamera) {
            								this.addLayer(cameraComponent, layer, isTransparent, clearRenderTarget);
            								clearRenderTarget = false;
            						}
            						index++;
            						if (layer.id === lastLayerId && isTransparent === lastLayerIsTransparent) {
            								break;
            						}
            				}
            				return index;
            		}
            		updateDirectionalShadows() {
            				var { renderer, renderActions } = this;
            				for(var i = 0; i < renderActions.length; i++){
            						var renderAction = renderActions[i];
            						var cameraComp = renderAction.camera;
            						var camera = cameraComp.camera;
            						var shadowDirLights = this.renderer.cameraDirShadowLights.get(camera);
            						if (shadowDirLights) {
            								for(var l = 0; l < shadowDirLights.length; l++){
            										var light = shadowDirLights[l];
            										if (renderer.dirLightShadows.get(light) !== camera) {
            												renderer.dirLightShadows.set(light, camera);
            												var shadowPass = renderer._shadowRendererDirectional.getLightRenderPass(light, camera);
            												if (shadowPass) {
            														this.beforePasses.push(shadowPass);
            												}
            										}
            								}
            						}
            				}
            		}
            		updateClears() {
            				var renderAction = this.renderActions[0];
            				if (renderAction) {
            						var cameraComponent = renderAction.camera;
            						var camera = cameraComponent.camera;
            						var fullSizeClearRect = camera.fullSizeClearRect;
            						this.setClearColor(fullSizeClearRect && renderAction.clearColor ? camera.clearColor : undefined);
            						this.setClearDepth(fullSizeClearRect && renderAction.clearDepth && !this.noDepthClear ? camera.clearDepth : undefined);
            						this.setClearStencil(fullSizeClearRect && renderAction.clearStencil ? camera.clearStencil : undefined);
            				}
            		}
            		frameUpdate() {
            				super.frameUpdate();
            				this.updateDirectionalShadows();
            				this.updateClears();
            		}
            		before() {
            				var { renderActions } = this;
            				for(var i = 0; i < renderActions.length; i++){
            						var ra = renderActions[i];
            						if (ra.firstCameraUse) {
            								this.scene.fire(EVENT_PRERENDER, ra.camera);
            						}
            				}
            		}
            		execute() {
            				var { layerComposition, renderActions } = this;
            				for(var i = 0; i < renderActions.length; i++){
            						var ra = renderActions[i];
            						var layer = ra.layer;
            						if (layerComposition.isEnabled(layer, ra.transparent)) {
            								this.renderRenderAction(ra, i === 0);
            						}
            				}
            		}
            		after() {
            				for(var i = 0; i < this.renderActions.length; i++){
            						var ra = this.renderActions[i];
            						if (ra.lastCameraUse) {
            								this.scene.fire(EVENT_POSTRENDER, ra.camera);
            						}
            				}
            				this.beforePasses.length = 0;
            		}
            		renderRenderAction(renderAction, firstRenderAction) {
            				var { renderer, scene } = this;
            				var device = renderer.device;
            				var { layer, transparent, camera } = renderAction;
            				if (camera) {
            						var _camera_camera_shaderPassInfo;
            						var originalGammaCorrection = camera.gammaCorrection;
            						var originalToneMapping = camera.toneMapping;
            						if (this.gammaCorrection !== undefined) camera.gammaCorrection = this.gammaCorrection;
            						if (this.toneMapping !== undefined) camera.toneMapping = this.toneMapping;
            						scene.fire(EVENT_PRERENDER_LAYER, camera, layer, transparent);
            						var options = {
            								lightClusters: renderAction.lightClusters
            						};
            						var _camera_camera_shaderPassInfo_index;
            						var shaderPass = (_camera_camera_shaderPassInfo_index = (_camera_camera_shaderPassInfo = camera.camera.shaderPassInfo) == null ? void 0 : _camera_camera_shaderPassInfo.index) != null ? _camera_camera_shaderPassInfo_index : SHADER_FORWARD;
            						if (!firstRenderAction || !camera.camera.fullSizeClearRect) {
            								options.clearColor = renderAction.clearColor;
            								options.clearDepth = renderAction.clearDepth;
            								options.clearStencil = renderAction.clearStencil;
            						}
            						var _renderAction_renderTarget;
            						var renderTarget = (_renderAction_renderTarget = renderAction.renderTarget) != null ? _renderAction_renderTarget : device.backBuffer;
            						renderer.renderForwardLayer(camera.camera, renderTarget, layer, transparent, shaderPass, renderAction.viewBindGroups, options);
            						device.setBlendState(BlendState.NOBLEND);
            						device.setStencilState(null, null);
            						device.setAlphaToCoverage(false);
            						scene.fire(EVENT_POSTRENDER_LAYER, camera, layer, transparent);
            						if (this.gammaCorrection !== undefined) camera.gammaCorrection = originalGammaCorrection;
            						if (this.toneMapping !== undefined) camera.toneMapping = originalToneMapping;
            				}
            		}
            		constructor(device, layerComposition, scene, renderer){
            				super(device), this.renderActions = [], this.noDepthClear = false;
            				this.layerComposition = layerComposition;
            				this.scene = scene;
            				this.renderer = renderer;
            		}
            }
            
            class RenderPassPostprocessing extends RenderPass {
            		execute() {
            				var renderAction = this.renderAction;
            				var camera = renderAction.camera;
            				camera.onPostprocessing();
            		}
            		constructor(device, renderer, renderAction){
            				super(device);
            				this.renderer = renderer;
            				this.renderAction = renderAction;
            				this.requiresCubemaps = false;
            		}
            }
            
            var _noLights = [
            		[],
            		[],
            		[]
            ];
            var tmpColor$1 = new Color();
            var _drawCallList = {
            		drawCalls: [],
            		shaderInstances: [],
            		isNewMaterial: [],
            		lightMaskChanged: [],
            		clear: function clear() {
            				this.drawCalls.length = 0;
            				this.shaderInstances.length = 0;
            				this.isNewMaterial.length = 0;
            				this.lightMaskChanged.length = 0;
            		}
            };
            function vogelDiskPrecalculationSamples(numSamples) {
            		var samples = [];
            		for(var i = 0; i < numSamples; ++i){
            				var r = Math.sqrt(i + 0.5) / Math.sqrt(numSamples);
            				samples.push(r);
            		}
            		return samples;
            }
            function vogelSpherePrecalculationSamples(numSamples) {
            		var samples = [];
            		for(var i = 0; i < numSamples; i++){
            				var weight = i / numSamples;
            				var radius = Math.sqrt(weight * weight);
            				samples.push(radius);
            		}
            		return samples;
            }
            class ForwardRenderer extends Renderer {
            		destroy() {
            				super.destroy();
            		}
            		dispatchGlobalLights(scene) {
            				var ambientUniform = this.ambientColor;
            				tmpColor$1.linear(scene.ambientLight);
            				ambientUniform[0] = tmpColor$1.r;
            				ambientUniform[1] = tmpColor$1.g;
            				ambientUniform[2] = tmpColor$1.b;
            				if (scene.physicalUnits) {
            						for(var i = 0; i < 3; i++){
            								ambientUniform[i] *= scene.ambientLuminance;
            						}
            				}
            				this.ambientId.setValue(ambientUniform);
            				this.skyboxIntensityId.setValue(scene.physicalUnits ? scene.skyboxLuminance : scene.skyboxIntensity);
            				this.cubeMapRotationMatrixId.setValue(scene._skyboxRotationMat3.data);
            		}
            		_resolveLight(scope, i) {
            				var light = "light" + i;
            				this.lightColorId[i] = scope.resolve("" + light + "_color");
            				this.lightDir[i] = new Float32Array(3);
            				this.lightDirId[i] = scope.resolve("" + light + "_direction");
            				this.lightShadowMapId[i] = scope.resolve("" + light + "_shadowMap");
            				this.lightShadowMatrixId[i] = scope.resolve("" + light + "_shadowMatrix");
            				this.lightShadowParamsId[i] = scope.resolve("" + light + "_shadowParams");
            				this.lightShadowIntensity[i] = scope.resolve("" + light + "_shadowIntensity");
            				this.lightShadowSearchAreaId[i] = scope.resolve("" + light + "_shadowSearchArea");
            				this.lightRadiusId[i] = scope.resolve("" + light + "_radius");
            				this.lightPos[i] = new Float32Array(3);
            				this.lightPosId[i] = scope.resolve("" + light + "_position");
            				this.lightWidth[i] = new Float32Array(3);
            				this.lightWidthId[i] = scope.resolve("" + light + "_halfWidth");
            				this.lightHeight[i] = new Float32Array(3);
            				this.lightHeightId[i] = scope.resolve("" + light + "_halfHeight");
            				this.lightInAngleId[i] = scope.resolve("" + light + "_innerConeAngle");
            				this.lightOutAngleId[i] = scope.resolve("" + light + "_outerConeAngle");
            				this.lightCookieId[i] = scope.resolve("" + light + "_cookie");
            				this.lightCookieIntId[i] = scope.resolve("" + light + "_cookieIntensity");
            				this.lightCookieMatrixId[i] = scope.resolve("" + light + "_cookieMatrix");
            				this.lightCookieOffsetId[i] = scope.resolve("" + light + "_cookieOffset");
            				this.lightCameraParamsId[i] = scope.resolve("" + light + "_cameraParams");
            				this.lightSoftShadowParamsId[i] = scope.resolve("" + light + "_softShadowParams");
            				this.shadowMatrixPaletteId[i] = scope.resolve("" + light + "_shadowMatrixPalette[0]");
            				this.shadowCascadeDistancesId[i] = scope.resolve("" + light + "_shadowCascadeDistances");
            				this.shadowCascadeCountId[i] = scope.resolve("" + light + "_shadowCascadeCount");
            				this.shadowCascadeBlendId[i] = scope.resolve("" + light + "_shadowCascadeBlend");
            		}
            		setLTCDirectionalLight(wtm, cnt, dir, campos, far) {
            				this.lightPos[cnt][0] = campos.x - dir.x * far;
            				this.lightPos[cnt][1] = campos.y - dir.y * far;
            				this.lightPos[cnt][2] = campos.z - dir.z * far;
            				this.lightPosId[cnt].setValue(this.lightPos[cnt]);
            				var hWidth = wtm.transformVector(new Vec3(-0.5, 0, 0));
            				this.lightWidth[cnt][0] = hWidth.x * far;
            				this.lightWidth[cnt][1] = hWidth.y * far;
            				this.lightWidth[cnt][2] = hWidth.z * far;
            				this.lightWidthId[cnt].setValue(this.lightWidth[cnt]);
            				var hHeight = wtm.transformVector(new Vec3(0, 0, 0.5));
            				this.lightHeight[cnt][0] = hHeight.x * far;
            				this.lightHeight[cnt][1] = hHeight.y * far;
            				this.lightHeight[cnt][2] = hHeight.z * far;
            				this.lightHeightId[cnt].setValue(this.lightHeight[cnt]);
            		}
            		dispatchDirectLights(dirs, mask, camera) {
            				var cnt = 0;
            				var scope = this.device.scope;
            				for(var i = 0; i < dirs.length; i++){
            						if (!(dirs[i].mask & mask)) continue;
            						var directional = dirs[i];
            						var wtm = directional._node.getWorldTransform();
            						if (!this.lightColorId[cnt]) {
            								this._resolveLight(scope, cnt);
            						}
            						this.lightColorId[cnt].setValue(directional._colorLinear);
            						wtm.getY(directional._direction).mulScalar(-1);
            						directional._direction.normalize();
            						this.lightDir[cnt][0] = directional._direction.x;
            						this.lightDir[cnt][1] = directional._direction.y;
            						this.lightDir[cnt][2] = directional._direction.z;
            						this.lightDirId[cnt].setValue(this.lightDir[cnt]);
            						if (directional.shape !== LIGHTSHAPE_PUNCTUAL) {
            								this.setLTCDirectionalLight(wtm, cnt, directional._direction, camera._node.getPosition(), camera.farClip);
            						}
            						if (directional.castShadows) {
            								var lightRenderData = directional.getRenderData(camera, 0);
            								var biases = directional._getUniformBiasValues(lightRenderData);
            								this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);
            								this.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);
            								this.shadowMatrixPaletteId[cnt].setValue(directional._shadowMatrixPalette);
            								this.shadowCascadeDistancesId[cnt].setValue(directional._shadowCascadeDistances);
            								this.shadowCascadeCountId[cnt].setValue(directional.numCascades);
            								this.shadowCascadeBlendId[cnt].setValue(1 - directional.cascadeBlend);
            								this.lightShadowIntensity[cnt].setValue(directional.shadowIntensity);
            								this.lightSoftShadowParamsId[cnt].setValue(directional._softShadowParams);
            								var shadowRT = lightRenderData.shadowCamera.renderTarget;
            								if (shadowRT) {
            										this.lightShadowSearchAreaId[cnt].setValue(directional.penumbraSize / lightRenderData.shadowCamera.renderTarget.width * lightRenderData.projectionCompensation);
            								}
            								var cameraParams = directional._shadowCameraParams;
            								cameraParams.length = 4;
            								cameraParams[0] = 0;
            								cameraParams[1] = lightRenderData.shadowCamera._farClip;
            								cameraParams[2] = lightRenderData.shadowCamera._nearClip;
            								cameraParams[3] = 1;
            								this.lightCameraParamsId[cnt].setValue(cameraParams);
            								var params = directional._shadowRenderParams;
            								params.length = 4;
            								params[0] = directional._shadowResolution;
            								params[1] = biases.normalBias;
            								params[2] = biases.bias;
            								params[3] = 0;
            								this.lightShadowParamsId[cnt].setValue(params);
            						}
            						cnt++;
            				}
            				return cnt;
            		}
            		setLTCPositionalLight(wtm, cnt) {
            				var hWidth = wtm.transformVector(new Vec3(-0.5, 0, 0));
            				this.lightWidth[cnt][0] = hWidth.x;
            				this.lightWidth[cnt][1] = hWidth.y;
            				this.lightWidth[cnt][2] = hWidth.z;
            				this.lightWidthId[cnt].setValue(this.lightWidth[cnt]);
            				var hHeight = wtm.transformVector(new Vec3(0, 0, 0.5));
            				this.lightHeight[cnt][0] = hHeight.x;
            				this.lightHeight[cnt][1] = hHeight.y;
            				this.lightHeight[cnt][2] = hHeight.z;
            				this.lightHeightId[cnt].setValue(this.lightHeight[cnt]);
            		}
            		dispatchOmniLight(scope, omni, cnt) {
            				var wtm = omni._node.getWorldTransform();
            				if (!this.lightColorId[cnt]) {
            						this._resolveLight(scope, cnt);
            				}
            				this.lightRadiusId[cnt].setValue(omni.attenuationEnd);
            				this.lightColorId[cnt].setValue(omni._colorLinear);
            				wtm.getTranslation(omni._position);
            				this.lightPos[cnt][0] = omni._position.x;
            				this.lightPos[cnt][1] = omni._position.y;
            				this.lightPos[cnt][2] = omni._position.z;
            				this.lightPosId[cnt].setValue(this.lightPos[cnt]);
            				if (omni.shape !== LIGHTSHAPE_PUNCTUAL) {
            						this.setLTCPositionalLight(wtm, cnt);
            				}
            				if (omni.castShadows) {
            						var lightRenderData = omni.getRenderData(null, 0);
            						this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);
            						var biases = omni._getUniformBiasValues(lightRenderData);
            						var params = omni._shadowRenderParams;
            						params.length = 4;
            						params[0] = omni._shadowResolution;
            						params[1] = biases.normalBias;
            						params[2] = biases.bias;
            						params[3] = 1.0 / omni.attenuationEnd;
            						this.lightShadowParamsId[cnt].setValue(params);
            						this.lightShadowIntensity[cnt].setValue(omni.shadowIntensity);
            						var pixelsPerMeter = omni.penumbraSize / lightRenderData.shadowCamera.renderTarget.width;
            						this.lightShadowSearchAreaId[cnt].setValue(pixelsPerMeter);
            						var cameraParams = omni._shadowCameraParams;
            						cameraParams.length = 4;
            						cameraParams[0] = 0;
            						cameraParams[1] = lightRenderData.shadowCamera._farClip;
            						cameraParams[2] = lightRenderData.shadowCamera._nearClip;
            						cameraParams[3] = 0;
            						this.lightCameraParamsId[cnt].setValue(cameraParams);
            				}
            				if (omni._cookie) {
            						this.lightCookieId[cnt].setValue(omni._cookie);
            						this.lightShadowMatrixId[cnt].setValue(wtm.data);
            						this.lightCookieIntId[cnt].setValue(omni.cookieIntensity);
            				}
            		}
            		dispatchSpotLight(scope, spot, cnt) {
            				var wtm = spot._node.getWorldTransform();
            				if (!this.lightColorId[cnt]) {
            						this._resolveLight(scope, cnt);
            				}
            				this.lightInAngleId[cnt].setValue(spot._innerConeAngleCos);
            				this.lightOutAngleId[cnt].setValue(spot._outerConeAngleCos);
            				this.lightRadiusId[cnt].setValue(spot.attenuationEnd);
            				this.lightColorId[cnt].setValue(spot._colorLinear);
            				wtm.getTranslation(spot._position);
            				this.lightPos[cnt][0] = spot._position.x;
            				this.lightPos[cnt][1] = spot._position.y;
            				this.lightPos[cnt][2] = spot._position.z;
            				this.lightPosId[cnt].setValue(this.lightPos[cnt]);
            				if (spot.shape !== LIGHTSHAPE_PUNCTUAL) {
            						this.setLTCPositionalLight(wtm, cnt);
            				}
            				wtm.getY(spot._direction).mulScalar(-1);
            				spot._direction.normalize();
            				this.lightDir[cnt][0] = spot._direction.x;
            				this.lightDir[cnt][1] = spot._direction.y;
            				this.lightDir[cnt][2] = spot._direction.z;
            				this.lightDirId[cnt].setValue(this.lightDir[cnt]);
            				if (spot.castShadows) {
            						var lightRenderData = spot.getRenderData(null, 0);
            						this.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);
            						this.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);
            						var biases = spot._getUniformBiasValues(lightRenderData);
            						var params = spot._shadowRenderParams;
            						params.length = 4;
            						params[0] = spot._shadowResolution;
            						params[1] = biases.normalBias;
            						params[2] = biases.bias;
            						params[3] = 1.0 / spot.attenuationEnd;
            						this.lightShadowParamsId[cnt].setValue(params);
            						this.lightShadowIntensity[cnt].setValue(spot.shadowIntensity);
            						var pixelsPerMeter = spot.penumbraSize / lightRenderData.shadowCamera.renderTarget.width;
            						var fov = lightRenderData.shadowCamera._fov * Math.PI / 180.0;
            						var fovRatio = 1.0 / Math.tan(fov / 2.0);
            						this.lightShadowSearchAreaId[cnt].setValue(pixelsPerMeter * fovRatio);
            						var cameraParams = spot._shadowCameraParams;
            						cameraParams.length = 4;
            						cameraParams[0] = 0;
            						cameraParams[1] = lightRenderData.shadowCamera._farClip;
            						cameraParams[2] = lightRenderData.shadowCamera._nearClip;
            						cameraParams[3] = 0;
            						this.lightCameraParamsId[cnt].setValue(cameraParams);
            				}
            				if (spot._cookie) {
            						if (!spot.castShadows) {
            								var cookieMatrix = LightCamera.evalSpotCookieMatrix(spot);
            								this.lightShadowMatrixId[cnt].setValue(cookieMatrix.data);
            						}
            						this.lightCookieId[cnt].setValue(spot._cookie);
            						this.lightCookieIntId[cnt].setValue(spot.cookieIntensity);
            						if (spot._cookieTransform) {
            								spot._cookieTransformUniform[0] = spot._cookieTransform.x;
            								spot._cookieTransformUniform[1] = spot._cookieTransform.y;
            								spot._cookieTransformUniform[2] = spot._cookieTransform.z;
            								spot._cookieTransformUniform[3] = spot._cookieTransform.w;
            								this.lightCookieMatrixId[cnt].setValue(spot._cookieTransformUniform);
            								spot._cookieOffsetUniform[0] = spot._cookieOffset.x;
            								spot._cookieOffsetUniform[1] = spot._cookieOffset.y;
            								this.lightCookieOffsetId[cnt].setValue(spot._cookieOffsetUniform);
            						}
            				}
            		}
            		dispatchLocalLights(sortedLights, mask, usedDirLights) {
            				var cnt = usedDirLights;
            				var scope = this.device.scope;
            				var omnis = sortedLights[LIGHTTYPE_OMNI];
            				var numOmnis = omnis.length;
            				for(var i = 0; i < numOmnis; i++){
            						var omni = omnis[i];
            						if (!(omni.mask & mask)) continue;
            						this.dispatchOmniLight(scope, omni, cnt);
            						cnt++;
            				}
            				var spts = sortedLights[LIGHTTYPE_SPOT];
            				var numSpts = spts.length;
            				for(var i1 = 0; i1 < numSpts; i1++){
            						var spot = spts[i1];
            						if (!(spot.mask & mask)) continue;
            						this.dispatchSpotLight(scope, spot, cnt);
            						cnt++;
            				}
            		}
            		renderForwardPrepareMaterials(camera, renderTarget, drawCalls, sortedLights, layer, pass) {
            				var _camera_fogParams;
            				var fogParams = (_camera_fogParams = camera.fogParams) != null ? _camera_fogParams : this.scene.fog;
            				var shaderParams = camera.shaderParams;
            				shaderParams.fog = fogParams.type;
            				var _renderTarget_isColorBufferSrgb;
            				shaderParams.srgbRenderTarget = (_renderTarget_isColorBufferSrgb = renderTarget == null ? void 0 : renderTarget.isColorBufferSrgb(0)) != null ? _renderTarget_isColorBufferSrgb : false;
            				var addCall = (drawCall, shaderInstance, isNewMaterial, lightMaskChanged)=>{
            						_drawCallList.drawCalls.push(drawCall);
            						_drawCallList.shaderInstances.push(shaderInstance);
            						_drawCallList.isNewMaterial.push(isNewMaterial);
            						_drawCallList.lightMaskChanged.push(lightMaskChanged);
            				};
            				_drawCallList.clear();
            				var device = this.device;
            				var scene = this.scene;
            				var clusteredLightingEnabled = scene.clusteredLightingEnabled;
            				var _layer_getLightHash;
            				var lightHash = (_layer_getLightHash = layer == null ? void 0 : layer.getLightHash(clusteredLightingEnabled)) != null ? _layer_getLightHash : 0;
            				var prevMaterial = null, prevObjDefs, prevLightMask;
            				var drawCallsCount = drawCalls.length;
            				for(var i = 0; i < drawCallsCount; i++){
            						var drawCall = drawCalls[i];
            						drawCall.ensureMaterial(device);
            						var material = drawCall.material;
            						var objDefs = drawCall._shaderDefs;
            						var lightMask = drawCall.mask;
            						if (material && material === prevMaterial && objDefs !== prevObjDefs) {
            								prevMaterial = null;
            						}
            						if (material !== prevMaterial) {
            								this._materialSwitches++;
            								material._scene = scene;
            								if (material.dirty) {
            										material.updateUniforms(device, scene);
            										material.dirty = false;
            								}
            						}
            						var shaderInstance = drawCall.getShaderInstance(pass, lightHash, scene, shaderParams, this.viewUniformFormat, this.viewBindGroupFormat, sortedLights);
            						addCall(drawCall, shaderInstance, material !== prevMaterial, !prevMaterial || lightMask !== prevLightMask);
            						prevMaterial = material;
            						prevObjDefs = objDefs;
            						prevLightMask = lightMask;
            				}
            				return _drawCallList;
            		}
            		renderForwardInternal(camera, preparedCalls, sortedLights, pass, drawCallback, flipFaces) {
            				var device = this.device;
            				var scene = this.scene;
            				var passFlag = 1 << pass;
            				var flipFactor = flipFaces ? -1 : 1;
            				var clusteredLightingEnabled = scene.clusteredLightingEnabled;
            				var preparedCallsCount = preparedCalls.drawCalls.length;
            				for(var i = 0; i < preparedCallsCount; i++){
            						var drawCall = preparedCalls.drawCalls[i];
            						var newMaterial = preparedCalls.isNewMaterial[i];
            						var lightMaskChanged = preparedCalls.lightMaskChanged[i];
            						var shaderInstance = preparedCalls.shaderInstances[i];
            						var material = drawCall.material;
            						var lightMask = drawCall.mask;
            						if (shaderInstance.shader.failed) continue;
            						if (newMaterial) {
            								var asyncCompile = false;
            								device.setShader(shaderInstance.shader, asyncCompile);
            								material.setParameters(device);
            								if (lightMaskChanged) {
            										var usedDirLights = this.dispatchDirectLights(sortedLights[LIGHTTYPE_DIRECTIONAL], lightMask, camera);
            										if (!clusteredLightingEnabled) {
            												this.dispatchLocalLights(sortedLights, lightMask, usedDirLights);
            										}
            								}
            								this.alphaTestId.setValue(material.alphaTest);
            								device.setBlendState(material.blendState);
            								device.setDepthState(material.depthState);
            								device.setAlphaToCoverage(material.alphaToCoverage);
            						}
            						this.setupCullMode(camera._cullFaces, flipFactor, drawCall);
            						var _drawCall_stencilFront;
            						var stencilFront = (_drawCall_stencilFront = drawCall.stencilFront) != null ? _drawCall_stencilFront : material.stencilFront;
            						var _drawCall_stencilBack;
            						var stencilBack = (_drawCall_stencilBack = drawCall.stencilBack) != null ? _drawCall_stencilBack : material.stencilBack;
            						device.setStencilState(stencilFront, stencilBack);
            						drawCall.setParameters(device, passFlag);
            						device.scope.resolve('meshInstanceId').setValue(drawCall.id);
            						var mesh = drawCall.mesh;
            						this.setVertexBuffers(device, mesh);
            						this.setMorphing(device, drawCall.morphInstance);
            						this.setSkinning(device, drawCall);
            						this.setupMeshUniformBuffers(shaderInstance, drawCall);
            						var style = drawCall.renderStyle;
            						device.setIndexBuffer(mesh.indexBuffer[style]);
            						drawCallback == null ? void 0 : drawCallback(drawCall, i);
            						if (camera.xr && camera.xr.session && camera.xr.views.list.length) {
            								var views = camera.xr.views;
            								for(var v = 0; v < views.list.length; v++){
            										var view = views.list[v];
            										device.setViewport(view.viewport.x, view.viewport.y, view.viewport.z, view.viewport.w);
            										this.projId.setValue(view.projMat.data);
            										this.projSkyboxId.setValue(view.projMat.data);
            										this.viewId.setValue(view.viewOffMat.data);
            										this.viewInvId.setValue(view.viewInvOffMat.data);
            										this.viewId3.setValue(view.viewMat3.data);
            										this.viewProjId.setValue(view.projViewOffMat.data);
            										this.viewPosId.setValue(view.positionData);
            										this.viewIndexId.setValue(v);
            										if (v === 0) {
            												this.drawInstance(device, drawCall, mesh, style, true);
            										} else {
            												this.drawInstance2(device, drawCall, mesh, style);
            										}
            										this._forwardDrawCalls++;
            								}
            						} else {
            								this.drawInstance(device, drawCall, mesh, style, true);
            								this._forwardDrawCalls++;
            						}
            						if (i < preparedCallsCount - 1 && !preparedCalls.isNewMaterial[i + 1]) {
            								material.setParameters(device, drawCall.parameters);
            						}
            				}
            		}
            		renderForward(camera, renderTarget, allDrawCalls, sortedLights, pass, drawCallback, layer, flipFaces) {
            				var preparedCalls = this.renderForwardPrepareMaterials(camera, renderTarget, allDrawCalls, sortedLights, layer, pass);
            				this.renderForwardInternal(camera, preparedCalls, sortedLights, pass, drawCallback, flipFaces);
            				_drawCallList.clear();
            		}
            		renderForwardLayer(camera, renderTarget, layer, transparent, shaderPass, viewBindGroups, options) {
            				if (options === void 0) options = {};
            				var { scene, device } = this;
            				var clusteredLightingEnabled = scene.clusteredLightingEnabled;
            				this.setupViewport(camera, renderTarget);
            				var visible, splitLights;
            				if (layer) {
            						layer.sortVisible(camera, transparent);
            						var culledInstances = layer.getCulledInstances(camera);
            						visible = transparent ? culledInstances.transparent : culledInstances.opaque;
            						scene.immediate.onPreRenderLayer(layer, visible, transparent);
            						if (layer.requiresLightCube) {
            								this.lightCube.update(scene.ambientLight, layer._lights);
            								this.constantLightCube.setValue(this.lightCube.colors);
            						}
            						splitLights = layer.splitLights;
            				} else {
            						visible = options.meshInstances;
            						var _options_splitLights;
            						splitLights = (_options_splitLights = options.splitLights) != null ? _options_splitLights : _noLights;
            				}
            				if (clusteredLightingEnabled) {
            						var _options_lightClusters;
            						var lightClusters = (_options_lightClusters = options.lightClusters) != null ? _options_lightClusters : this.worldClustersAllocator.empty;
            						lightClusters.activate();
            						if (layer) {
            								if (!this.clustersDebugRendered && scene.lighting.debugLayer === layer.id) {
            										this.clustersDebugRendered = true;
            								}
            						}
            				}
            				scene._activeCamera = camera;
            				var _camera_fogParams;
            				var fogParams = (_camera_fogParams = camera.fogParams) != null ? _camera_fogParams : this.scene.fog;
            				this.setFogConstants(fogParams);
            				var viewCount = this.setCameraUniforms(camera, renderTarget);
            				if (device.supportsUniformBuffers) {
            						this.setupViewUniformBuffers(viewBindGroups, this.viewUniformFormat, this.viewBindGroupFormat, viewCount);
            				}
            				var _options_clearColor;
            				var clearColor = (_options_clearColor = options.clearColor) != null ? _options_clearColor : false;
            				var _options_clearDepth;
            				var clearDepth = (_options_clearDepth = options.clearDepth) != null ? _options_clearDepth : false;
            				var _options_clearStencil;
            				var clearStencil = (_options_clearStencil = options.clearStencil) != null ? _options_clearStencil : false;
            				if (clearColor || clearDepth || clearStencil) {
            						this.clear(camera, clearColor, clearDepth, clearStencil);
            				}
            				var flipFaces = !!(camera._flipFaces ^ (renderTarget == null ? void 0 : renderTarget.flipY));
            				var forwardDrawCalls = this._forwardDrawCalls;
            				this.renderForward(camera, renderTarget, visible, splitLights, shaderPass, null, layer, flipFaces);
            				if (layer) {
            						layer._forwardDrawCalls += this._forwardDrawCalls - forwardDrawCalls;
            				}
            		}
            		setFogConstants(fogParams) {
            				if (fogParams.type !== FOG_NONE) {
            						tmpColor$1.linear(fogParams.color);
            						var fogUniform = this.fogColor;
            						fogUniform[0] = tmpColor$1.r;
            						fogUniform[1] = tmpColor$1.g;
            						fogUniform[2] = tmpColor$1.b;
            						this.fogColorId.setValue(fogUniform);
            						if (fogParams.type === FOG_LINEAR) {
            								this.fogStartId.setValue(fogParams.start);
            								this.fogEndId.setValue(fogParams.end);
            						} else {
            								this.fogDensityId.setValue(fogParams.density);
            						}
            				}
            		}
            		setSceneConstants() {
            				var scene = this.scene;
            				this.dispatchGlobalLights(scene);
            				var device = this.device;
            				this._screenSize[0] = device.width;
            				this._screenSize[1] = device.height;
            				this._screenSize[2] = 1 / device.width;
            				this._screenSize[3] = 1 / device.height;
            				this.screenSizeId.setValue(this._screenSize);
            				this.pcssDiskSamplesId.setValue(this.pcssDiskSamples);
            				this.pcssSphereSamplesId.setValue(this.pcssSphereSamples);
            		}
            		buildFrameGraph(frameGraph, layerComposition) {
            				var scene = this.scene;
            				frameGraph.reset();
            				if (scene.clusteredLightingEnabled) {
            						var { shadowsEnabled, cookiesEnabled } = scene.lighting;
            						this._renderPassUpdateClustered.update(frameGraph, shadowsEnabled, cookiesEnabled, this.lights, this.localLights);
            						frameGraph.addRenderPass(this._renderPassUpdateClustered);
            				} else {
            						this._shadowRendererLocal.buildNonClusteredRenderPasses(frameGraph, this.localLights);
            				}
            				var startIndex = 0;
            				var newStart = true;
            				var renderTarget = null;
            				var renderActions = layerComposition._renderActions;
            				for(var i = startIndex; i < renderActions.length; i++){
            						var renderAction = renderActions[i];
            						var { layer, camera } = renderAction;
            						if (renderAction.useCameraPasses) {
            								camera.camera.renderPasses.forEach((renderPass)=>{
            										frameGraph.addRenderPass(renderPass);
            								});
            						} else {
            								var isDepthLayer = layer.id === LAYERID_DEPTH;
            								var isGrabPass = isDepthLayer && (camera.renderSceneColorMap || camera.renderSceneDepthMap);
            								if (newStart) {
            										newStart = false;
            										startIndex = i;
            										renderTarget = renderAction.renderTarget;
            								}
            								var nextRenderAction = renderActions[i + 1];
            								var isNextLayerDepth = nextRenderAction ? !nextRenderAction.useCameraPasses && nextRenderAction.layer.id === LAYERID_DEPTH : false;
            								var isNextLayerGrabPass = isNextLayerDepth && (camera.renderSceneColorMap || camera.renderSceneDepthMap);
            								var nextNeedDirShadows = nextRenderAction ? nextRenderAction.firstCameraUse && this.cameraDirShadowLights.has(nextRenderAction.camera.camera) : false;
            								if (!nextRenderAction || nextRenderAction.renderTarget !== renderTarget || nextNeedDirShadows || isNextLayerGrabPass || isGrabPass) {
            										var isDepthOnly = isDepthLayer && startIndex === i;
            										if (!isDepthOnly) {
            												this.addMainRenderPass(frameGraph, layerComposition, renderTarget, startIndex, i);
            										}
            										if (isDepthLayer) {
            												if (camera.renderSceneColorMap) {
            														var colorGrabPass = camera.camera.renderPassColorGrab;
            														colorGrabPass.source = camera.renderTarget;
            														frameGraph.addRenderPass(colorGrabPass);
            												}
            												if (camera.renderSceneDepthMap) {
            														frameGraph.addRenderPass(camera.camera.renderPassDepthGrab);
            												}
            										}
            										if (renderAction.triggerPostprocess && (camera == null ? void 0 : camera.onPostprocessing)) {
            												var renderPass = new RenderPassPostprocessing(this.device, this, renderAction);
            												frameGraph.addRenderPass(renderPass);
            										}
            										newStart = true;
            								}
            						}
            				}
            		}
            		addMainRenderPass(frameGraph, layerComposition, renderTarget, startIndex, endIndex) {
            				var renderPass = new RenderPassForward(this.device, layerComposition, this.scene, this);
            				renderPass.init(renderTarget);
            				var renderActions = layerComposition._renderActions;
            				for(var i = startIndex; i <= endIndex; i++){
            						renderPass.addRenderAction(renderActions[i]);
            				}
            				frameGraph.addRenderPass(renderPass);
            		}
            		update(comp) {
            				this.frameUpdate();
            				this.shadowRenderer.frameUpdate();
            				this.scene._updateSkyMesh();
            				this.updateLayerComposition(comp);
            				this.collectLights(comp);
            				this.beginFrame(comp);
            				this.setSceneConstants();
            				this.cullComposition(comp);
            				this.gpuUpdate(this.processingMeshInstances);
            		}
            		constructor(graphicsDevice){
            				super(graphicsDevice);
            				var device = this.device;
            				this._forwardDrawCalls = 0;
            				this._materialSwitches = 0;
            				this._depthMapTime = 0;
            				this._forwardTime = 0;
            				this._sortTime = 0;
            				var scope = device.scope;
            				this.fogColorId = scope.resolve('fog_color');
            				this.fogStartId = scope.resolve('fog_start');
            				this.fogEndId = scope.resolve('fog_end');
            				this.fogDensityId = scope.resolve('fog_density');
            				this.ambientId = scope.resolve('light_globalAmbient');
            				this.skyboxIntensityId = scope.resolve('skyboxIntensity');
            				this.cubeMapRotationMatrixId = scope.resolve('cubeMapRotationMatrix');
            				this.pcssDiskSamplesId = scope.resolve('pcssDiskSamples[0]');
            				this.pcssSphereSamplesId = scope.resolve('pcssSphereSamples[0]');
            				this.lightColorId = [];
            				this.lightDir = [];
            				this.lightDirId = [];
            				this.lightShadowMapId = [];
            				this.lightShadowMatrixId = [];
            				this.lightShadowParamsId = [];
            				this.lightShadowIntensity = [];
            				this.lightRadiusId = [];
            				this.lightPos = [];
            				this.lightPosId = [];
            				this.lightWidth = [];
            				this.lightWidthId = [];
            				this.lightHeight = [];
            				this.lightHeightId = [];
            				this.lightInAngleId = [];
            				this.lightOutAngleId = [];
            				this.lightCookieId = [];
            				this.lightCookieIntId = [];
            				this.lightCookieMatrixId = [];
            				this.lightCookieOffsetId = [];
            				this.lightShadowSearchAreaId = [];
            				this.lightCameraParamsId = [];
            				this.lightSoftShadowParamsId = [];
            				this.shadowMatrixPaletteId = [];
            				this.shadowCascadeDistancesId = [];
            				this.shadowCascadeCountId = [];
            				this.shadowCascadeBlendId = [];
            				this.screenSizeId = scope.resolve('uScreenSize');
            				this._screenSize = new Float32Array(4);
            				this.fogColor = new Float32Array(3);
            				this.ambientColor = new Float32Array(3);
            				this.pcssDiskSamples = vogelDiskPrecalculationSamples(16);
            				this.pcssSphereSamples = vogelSpherePrecalculationSamples(16);
            		}
            }
            
            var layerCounter = 0;
            var lightKeys = [];
            var _tempMaterials = new Set();
            function sortManual(drawCallA, drawCallB) {
            		return drawCallA.drawOrder - drawCallB.drawOrder;
            }
            function sortMaterialMesh(drawCallA, drawCallB) {
            		var keyA = drawCallA._sortKeyForward;
            		var keyB = drawCallB._sortKeyForward;
            		if (keyA === keyB) {
            				return drawCallB.mesh.id - drawCallA.mesh.id;
            		}
            		return keyB - keyA;
            }
            function sortBackToFront(drawCallA, drawCallB) {
            		return drawCallB._sortKeyDynamic - drawCallA._sortKeyDynamic;
            }
            function sortFrontToBack(drawCallA, drawCallB) {
            		return drawCallA._sortKeyDynamic - drawCallB._sortKeyDynamic;
            }
            var sortCallbacks = [
            		null,
            		sortManual,
            		sortMaterialMesh,
            		sortBackToFront,
            		sortFrontToBack
            ];
            class CulledInstances {
            		constructor(){
            				this.opaque = [];
            				this.transparent = [];
            		}
            }
            class Layer {
            		set enabled(val) {
            				if (val !== this._enabled) {
            						this._dirtyComposition = true;
            						this._enabled = val;
            						if (val) {
            								this.incrementCounter();
            								if (this.onEnable) this.onEnable();
            						} else {
            								this.decrementCounter();
            								if (this.onDisable) this.onDisable();
            						}
            				}
            		}
            		get enabled() {
            				return this._enabled;
            		}
            		set clearColorBuffer(val) {
            				this._clearColorBuffer = val;
            				this._dirtyComposition = true;
            		}
            		get clearColorBuffer() {
            				return this._clearColorBuffer;
            		}
            		set clearDepthBuffer(val) {
            				this._clearDepthBuffer = val;
            				this._dirtyComposition = true;
            		}
            		get clearDepthBuffer() {
            				return this._clearDepthBuffer;
            		}
            		set clearStencilBuffer(val) {
            				this._clearStencilBuffer = val;
            				this._dirtyComposition = true;
            		}
            		get clearStencilBuffer() {
            				return this._clearStencilBuffer;
            		}
            		get hasClusteredLights() {
            				return this._clusteredLightsSet.size > 0;
            		}
            		get clusteredLightsSet() {
            				return this._clusteredLightsSet;
            		}
            		incrementCounter() {
            				if (this._refCounter === 0) {
            						this._enabled = true;
            						if (this.onEnable) this.onEnable();
            				}
            				this._refCounter++;
            		}
            		decrementCounter() {
            				if (this._refCounter === 1) {
            						this._enabled = false;
            						if (this.onDisable) this.onDisable();
            				} else if (this._refCounter === 0) {
            						return;
            				}
            				this._refCounter--;
            		}
            		addMeshInstances(meshInstances, skipShadowCasters) {
            				var destMeshInstances = this.meshInstances;
            				var destMeshInstancesSet = this.meshInstancesSet;
            				for(var i = 0; i < meshInstances.length; i++){
            						var mi = meshInstances[i];
            						if (!destMeshInstancesSet.has(mi)) {
            								destMeshInstances.push(mi);
            								destMeshInstancesSet.add(mi);
            								_tempMaterials.add(mi.material);
            						}
            				}
            				if (!skipShadowCasters) {
            						this.addShadowCasters(meshInstances);
            				}
            				if (_tempMaterials.size > 0) {
            						var sceneShaderVer = this._shaderVersion;
            						_tempMaterials.forEach((mat)=>{
            								if (sceneShaderVer >= 0 && mat._shaderVersion !== sceneShaderVer) {
            										if (mat.getShaderVariant !== Material.prototype.getShaderVariant) {
            												mat.clearVariants();
            										}
            										mat._shaderVersion = sceneShaderVer;
            								}
            						});
            						_tempMaterials.clear();
            				}
            		}
            		removeMeshInstances(meshInstances, skipShadowCasters) {
            				var destMeshInstances = this.meshInstances;
            				var destMeshInstancesSet = this.meshInstancesSet;
            				for(var i = 0; i < meshInstances.length; i++){
            						var mi = meshInstances[i];
            						if (destMeshInstancesSet.has(mi)) {
            								destMeshInstancesSet.delete(mi);
            								var j = destMeshInstances.indexOf(mi);
            								if (j >= 0) {
            										destMeshInstances.splice(j, 1);
            								}
            						}
            				}
            				if (!skipShadowCasters) {
            						this.removeShadowCasters(meshInstances);
            				}
            		}
            		addShadowCasters(meshInstances) {
            				var shadowCasters = this.shadowCasters;
            				var shadowCastersSet = this.shadowCastersSet;
            				for(var i = 0; i < meshInstances.length; i++){
            						var mi = meshInstances[i];
            						if (mi.castShadow && !shadowCastersSet.has(mi)) {
            								shadowCastersSet.add(mi);
            								shadowCasters.push(mi);
            						}
            				}
            		}
            		removeShadowCasters(meshInstances) {
            				var shadowCasters = this.shadowCasters;
            				var shadowCastersSet = this.shadowCastersSet;
            				for(var i = 0; i < meshInstances.length; i++){
            						var mi = meshInstances[i];
            						if (shadowCastersSet.has(mi)) {
            								shadowCastersSet.delete(mi);
            								var j = shadowCasters.indexOf(mi);
            								if (j >= 0) {
            										shadowCasters.splice(j, 1);
            								}
            						}
            				}
            		}
            		clearMeshInstances(skipShadowCasters) {
            				if (skipShadowCasters === void 0) skipShadowCasters = false;
            				this.meshInstances.length = 0;
            				this.meshInstancesSet.clear();
            				if (!skipShadowCasters) {
            						this.shadowCasters.length = 0;
            						this.shadowCastersSet.clear();
            				}
            		}
            		markLightsDirty() {
            				this._lightHashDirty = true;
            				this._lightIdHashDirty = true;
            				this._splitLightsDirty = true;
            		}
            		hasLight(light) {
            				return this._lightsSet.has(light);
            		}
            		addLight(light) {
            				var l = light.light;
            				if (!this._lightsSet.has(l)) {
            						this._lightsSet.add(l);
            						this._lights.push(l);
            						this.markLightsDirty();
            				}
            				if (l.type !== LIGHTTYPE_DIRECTIONAL) {
            						this._clusteredLightsSet.add(l);
            				}
            		}
            		removeLight(light) {
            				var l = light.light;
            				if (this._lightsSet.has(l)) {
            						this._lightsSet.delete(l);
            						this._lights.splice(this._lights.indexOf(l), 1);
            						this.markLightsDirty();
            				}
            				if (l.type !== LIGHTTYPE_DIRECTIONAL) {
            						this._clusteredLightsSet.delete(l);
            				}
            		}
            		clearLights() {
            				this._lightsSet.forEach((light)=>light.removeLayer(this));
            				this._lightsSet.clear();
            				this._clusteredLightsSet.clear();
            				this._lights.length = 0;
            				this.markLightsDirty();
            		}
            		get splitLights() {
            				if (this._splitLightsDirty) {
            						this._splitLightsDirty = false;
            						var splitLights = this._splitLights;
            						for(var i = 0; i < splitLights.length; i++){
            								splitLights[i].length = 0;
            						}
            						var lights = this._lights;
            						for(var i1 = 0; i1 < lights.length; i1++){
            								var light = lights[i1];
            								if (light.enabled) {
            										splitLights[light._type].push(light);
            								}
            						}
            						for(var i2 = 0; i2 < splitLights.length; i2++){
            								splitLights[i2].sort((a, b)=>a.key - b.key);
            						}
            				}
            				return this._splitLights;
            		}
            		evaluateLightHash(localLights, directionalLights, useIds) {
            				var hash = 0;
            				var lights = this._lights;
            				for(var i = 0; i < lights.length; i++){
            						var isLocalLight = lights[i].type !== LIGHTTYPE_DIRECTIONAL;
            						if (localLights && isLocalLight || directionalLights && !isLocalLight) {
            								lightKeys.push(useIds ? lights[i].id : lights[i].key);
            						}
            				}
            				if (lightKeys.length > 0) {
            						lightKeys.sort();
            						hash = hash32Fnv1a(lightKeys);
            						lightKeys.length = 0;
            				}
            				return hash;
            		}
            		getLightHash(isClustered) {
            				if (this._lightHashDirty) {
            						this._lightHashDirty = false;
            						this._lightHash = this.evaluateLightHash(!isClustered, true, false);
            				}
            				return this._lightHash;
            		}
            		getLightIdHash() {
            				if (this._lightIdHashDirty) {
            						this._lightIdHashDirty = false;
            						this._lightIdHash = this.evaluateLightHash(true, false, true);
            				}
            				return this._lightIdHash;
            		}
            		addCamera(camera) {
            				if (!this.camerasSet.has(camera.camera)) {
            						this.camerasSet.add(camera.camera);
            						this.cameras.push(camera);
            						this._dirtyComposition = true;
            				}
            		}
            		removeCamera(camera) {
            				if (this.camerasSet.has(camera.camera)) {
            						this.camerasSet.delete(camera.camera);
            						var index = this.cameras.indexOf(camera);
            						this.cameras.splice(index, 1);
            						this._dirtyComposition = true;
            				}
            		}
            		clearCameras() {
            				this.cameras.length = 0;
            				this.camerasSet.clear();
            				this._dirtyComposition = true;
            		}
            		_calculateSortDistances(drawCalls, camPos, camFwd) {
            				var count = drawCalls.length;
            				var { x: px, y: py, z: pz } = camPos;
            				var { x: fx, y: fy, z: fz } = camFwd;
            				for(var i = 0; i < count; i++){
            						var drawCall = drawCalls[i];
            						var zDist = void 0;
            						if (drawCall.calculateSortDistance) {
            								zDist = drawCall.calculateSortDistance(drawCall, camPos, camFwd);
            						} else {
            								var meshPos = drawCall.aabb.center;
            								zDist = (meshPos.x - px) * fx + (meshPos.y - py) * fy + (meshPos.z - pz) * fz;
            						}
            						var bucket = drawCall._drawBucket * 1e9;
            						drawCall._sortKeyDynamic = bucket + zDist;
            				}
            		}
            		getCulledInstances(camera) {
            				var instances = this._visibleInstances.get(camera);
            				if (!instances) {
            						instances = new CulledInstances();
            						this._visibleInstances.set(camera, instances);
            				}
            				return instances;
            		}
            		sortVisible(camera, transparent) {
            				var sortMode = transparent ? this.transparentSortMode : this.opaqueSortMode;
            				if (sortMode === SORTMODE_NONE) {
            						return;
            				}
            				var culledInstances = this.getCulledInstances(camera);
            				var instances = transparent ? culledInstances.transparent : culledInstances.opaque;
            				var cameraNode = camera.node;
            				if (sortMode === SORTMODE_CUSTOM) {
            						var sortPos = cameraNode.getPosition();
            						var sortDir = cameraNode.forward;
            						if (this.customCalculateSortValues) {
            								this.customCalculateSortValues(instances, instances.length, sortPos, sortDir);
            						}
            						if (this.customSortCallback) {
            								instances.sort(this.customSortCallback);
            						}
            				} else {
            						if (sortMode === SORTMODE_BACK2FRONT || sortMode === SORTMODE_FRONT2BACK) {
            								var sortPos1 = cameraNode.getPosition();
            								var sortDir1 = cameraNode.forward;
            								this._calculateSortDistances(instances, sortPos1, sortDir1);
            						}
            						instances.sort(sortCallbacks[sortMode]);
            				}
            		}
            		constructor(options = {}){
            				this.meshInstances = [];
            				this.meshInstancesSet = new Set();
            				this.shadowCasters = [];
            				this.shadowCastersSet = new Set();
            				this._visibleInstances = new WeakMap();
            				this._lights = [];
            				this._lightsSet = new Set();
            				this._clusteredLightsSet = new Set();
            				this._splitLights = [
            						[],
            						[],
            						[]
            				];
            				this._splitLightsDirty = true;
            				this.requiresLightCube = false;
            				this.cameras = [];
            				this.camerasSet = new Set();
            				this._dirtyComposition = false;
            				if (options.id !== undefined) {
            						this.id = options.id;
            						layerCounter = Math.max(this.id + 1, layerCounter);
            				} else {
            						this.id = layerCounter++;
            				}
            				this.name = options.name;
            				var _options_enabled;
            				this._enabled = (_options_enabled = options.enabled) != null ? _options_enabled : true;
            				this._refCounter = this._enabled ? 1 : 0;
            				var _options_opaqueSortMode;
            				this.opaqueSortMode = (_options_opaqueSortMode = options.opaqueSortMode) != null ? _options_opaqueSortMode : SORTMODE_MATERIALMESH;
            				var _options_transparentSortMode;
            				this.transparentSortMode = (_options_transparentSortMode = options.transparentSortMode) != null ? _options_transparentSortMode : SORTMODE_BACK2FRONT;
            				if (options.renderTarget) {
            						this.renderTarget = options.renderTarget;
            				}
            				this._clearColorBuffer = !!options.clearColorBuffer;
            				this._clearDepthBuffer = !!options.clearDepthBuffer;
            				this._clearStencilBuffer = !!options.clearStencilBuffer;
            				this.onEnable = options.onEnable;
            				this.onDisable = options.onDisable;
            				if (this._enabled && this.onEnable) {
            						this.onEnable();
            				}
            				this.customSortCallback = null;
            				this.customCalculateSortValues = null;
            				this._lightHash = 0;
            				this._lightHashDirty = false;
            				this._lightIdHash = 0;
            				this._lightIdHashDirty = false;
            				this._shaderVersion = -1;
            		}
            }
            
            var cmpPriority = (a, b)=>a.priority - b.priority;
            var sortPriority = (arr)=>arr.sort(cmpPriority);
            
            class LayerComposition extends EventHandler {
            		destroy() {
            				this.destroyRenderActions();
            		}
            		destroyRenderActions() {
            				this._renderActions.forEach((ra)=>ra.destroy());
            				this._renderActions.length = 0;
            		}
            		markDirty() {
            				this._dirty = true;
            		}
            		_update() {
            				var len = this.layerList.length;
            				if (!this._dirty) {
            						for(var i = 0; i < len; i++){
            								if (this.layerList[i]._dirtyComposition) {
            										this._dirty = true;
            										break;
            								}
            						}
            				}
            				if (this._dirty) {
            						this._dirty = false;
            						this.cameras.length = 0;
            						for(var i1 = 0; i1 < len; i1++){
            								var layer = this.layerList[i1];
            								layer._dirtyComposition = false;
            								for(var j = 0; j < layer.cameras.length; j++){
            										var camera = layer.cameras[j];
            										var index = this.cameras.indexOf(camera);
            										if (index < 0) {
            												this.cameras.push(camera);
            										}
            								}
            						}
            						if (this.cameras.length > 1) {
            								sortPriority(this.cameras);
            						}
            						var cameraLayers = [];
            						var renderActionCount = 0;
            						this.destroyRenderActions();
            						for(var i2 = 0; i2 < this.cameras.length; i2++){
            								var camera1 = this.cameras[i2];
            								cameraLayers.length = 0;
            								if (camera1.camera.renderPasses.length > 0) {
            										this.addDummyRenderAction(renderActionCount, camera1);
            										renderActionCount++;
            										continue;
            								}
            								var cameraFirstRenderAction = true;
            								var cameraFirstRenderActionIndex = renderActionCount;
            								var lastRenderAction = null;
            								var postProcessMarked = false;
            								for(var j1 = 0; j1 < len; j1++){
            										var layer1 = this.layerList[j1];
            										var isLayerEnabled = layer1.enabled && this.subLayerEnabled[j1];
            										if (isLayerEnabled) {
            												if (layer1.cameras.length > 0) {
            														if (camera1.layers.indexOf(layer1.id) >= 0) {
            																cameraLayers.push(layer1);
            																if (!postProcessMarked && layer1.id === camera1.disablePostEffectsLayer) {
            																		postProcessMarked = true;
            																		if (lastRenderAction) {
            																				lastRenderAction.triggerPostprocess = true;
            																		}
            																}
            																var isTransparent = this.subLayerList[j1];
            																lastRenderAction = this.addRenderAction(renderActionCount, layer1, isTransparent, camera1, cameraFirstRenderAction, postProcessMarked);
            																renderActionCount++;
            																cameraFirstRenderAction = false;
            														}
            												}
            										}
            								}
            								if (cameraFirstRenderActionIndex < renderActionCount) {
            										lastRenderAction.lastCameraUse = true;
            								}
            								if (!postProcessMarked && lastRenderAction) {
            										lastRenderAction.triggerPostprocess = true;
            								}
            								if (camera1.renderTarget && camera1.postEffectsEnabled) {
            										this.propagateRenderTarget(cameraFirstRenderActionIndex - 1, camera1);
            								}
            						}
            						this._logRenderActions();
            				}
            		}
            		getNextRenderAction(renderActionIndex) {
            				var renderAction = new RenderAction();
            				this._renderActions.push(renderAction);
            				return renderAction;
            		}
            		addDummyRenderAction(renderActionIndex, camera) {
            				var renderAction = this.getNextRenderAction(renderActionIndex);
            				renderAction.camera = camera;
            				renderAction.useCameraPasses = true;
            		}
            		addRenderAction(renderActionIndex, layer, isTransparent, camera, cameraFirstRenderAction, postProcessMarked) {
            				var rt = layer.id !== LAYERID_DEPTH ? camera.renderTarget : null;
            				var used = false;
            				var renderActions = this._renderActions;
            				for(var i = renderActionIndex - 1; i >= 0; i--){
            						if (renderActions[i].camera === camera && renderActions[i].renderTarget === rt) {
            								used = true;
            								break;
            						}
            				}
            				if (postProcessMarked && camera.postEffectsEnabled) {
            						rt = null;
            				}
            				var renderAction = this.getNextRenderAction(renderActionIndex);
            				renderAction.triggerPostprocess = false;
            				renderAction.layer = layer;
            				renderAction.transparent = isTransparent;
            				renderAction.camera = camera;
            				renderAction.renderTarget = rt;
            				renderAction.firstCameraUse = cameraFirstRenderAction;
            				renderAction.lastCameraUse = false;
            				var needsCameraClear = cameraFirstRenderAction || !used;
            				var needsLayerClear = layer.clearColorBuffer || layer.clearDepthBuffer || layer.clearStencilBuffer;
            				if (needsCameraClear || needsLayerClear) {
            						renderAction.setupClears(needsCameraClear ? camera : undefined, layer);
            				}
            				return renderAction;
            		}
            		propagateRenderTarget(startIndex, fromCamera) {
            				for(var a = startIndex; a >= 0; a--){
            						var ra = this._renderActions[a];
            						var layer = ra.layer;
            						if (ra.renderTarget && layer.id !== LAYERID_DEPTH) {
            								break;
            						}
            						if (layer.id === LAYERID_DEPTH) {
            								continue;
            						}
            						if (ra.useCameraPasses) {
            								break;
            						}
            						var thisCamera = ra == null ? void 0 : ra.camera.camera;
            						if (thisCamera) {
            								if (!fromCamera.camera.rect.equals(thisCamera.rect) || !fromCamera.camera.scissorRect.equals(thisCamera.scissorRect)) {
            										break;
            								}
            						}
            						ra.renderTarget = fromCamera.renderTarget;
            				}
            		}
            		_logRenderActions() {}
            		_isLayerAdded(layer) {
            				var found = this.layerIdMap.get(layer.id) === layer;
            				return found;
            		}
            		_isSublayerAdded(layer, transparent) {
            				var map = transparent ? this.layerTransparentIndexMap : this.layerOpaqueIndexMap;
            				if (map.get(layer) !== undefined) {
            						return true;
            				}
            				return false;
            		}
            		push(layer) {
            				if (this._isLayerAdded(layer)) return;
            				this.layerList.push(layer);
            				this.layerList.push(layer);
            				this._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;
            				this._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;
            				this.subLayerEnabled.push(true);
            				this.subLayerEnabled.push(true);
            				this._updateLayerMaps();
            				this._dirty = true;
            				this.fire('add', layer);
            		}
            		insert(layer, index) {
            				if (this._isLayerAdded(layer)) return;
            				this.layerList.splice(index, 0, layer, layer);
            				this.subLayerList.splice(index, 0, false, true);
            				var count = this.layerList.length;
            				this._updateOpaqueOrder(index, count - 1);
            				this._updateTransparentOrder(index, count - 1);
            				this.subLayerEnabled.splice(index, 0, true, true);
            				this._updateLayerMaps();
            				this._dirty = true;
            				this.fire('add', layer);
            		}
            		remove(layer) {
            				var id = this.layerList.indexOf(layer);
            				delete this._opaqueOrder[id];
            				delete this._transparentOrder[id];
            				while(id >= 0){
            						this.layerList.splice(id, 1);
            						this.subLayerList.splice(id, 1);
            						this.subLayerEnabled.splice(id, 1);
            						id = this.layerList.indexOf(layer);
            						this._dirty = true;
            						this.fire('remove', layer);
            				}
            				var count = this.layerList.length;
            				this._updateOpaqueOrder(0, count - 1);
            				this._updateTransparentOrder(0, count - 1);
            				this._updateLayerMaps();
            		}
            		pushOpaque(layer) {
            				if (this._isSublayerAdded(layer, false)) return;
            				this.layerList.push(layer);
            				this._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;
            				this.subLayerEnabled.push(true);
            				this._updateLayerMaps();
            				this._dirty = true;
            				this.fire('add', layer);
            		}
            		insertOpaque(layer, index) {
            				if (this._isSublayerAdded(layer, false)) return;
            				this.layerList.splice(index, 0, layer);
            				this.subLayerList.splice(index, 0, false);
            				var count = this.subLayerList.length;
            				this._updateOpaqueOrder(index, count - 1);
            				this.subLayerEnabled.splice(index, 0, true);
            				this._updateLayerMaps();
            				this._dirty = true;
            				this.fire('add', layer);
            		}
            		removeOpaque(layer) {
            				for(var i = 0, len = this.layerList.length; i < len; i++){
            						if (this.layerList[i] === layer && !this.subLayerList[i]) {
            								this.layerList.splice(i, 1);
            								this.subLayerList.splice(i, 1);
            								len--;
            								this._updateOpaqueOrder(i, len - 1);
            								this.subLayerEnabled.splice(i, 1);
            								this._dirty = true;
            								if (this.layerList.indexOf(layer) < 0) {
            										this.fire('remove', layer);
            								}
            								break;
            						}
            				}
            				this._updateLayerMaps();
            		}
            		pushTransparent(layer) {
            				if (this._isSublayerAdded(layer, true)) return;
            				this.layerList.push(layer);
            				this._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;
            				this.subLayerEnabled.push(true);
            				this._updateLayerMaps();
            				this._dirty = true;
            				this.fire('add', layer);
            		}
            		insertTransparent(layer, index) {
            				if (this._isSublayerAdded(layer, true)) return;
            				this.layerList.splice(index, 0, layer);
            				this.subLayerList.splice(index, 0, true);
            				var count = this.subLayerList.length;
            				this._updateTransparentOrder(index, count - 1);
            				this.subLayerEnabled.splice(index, 0, true);
            				this._updateLayerMaps();
            				this._dirty = true;
            				this.fire('add', layer);
            		}
            		removeTransparent(layer) {
            				for(var i = 0, len = this.layerList.length; i < len; i++){
            						if (this.layerList[i] === layer && this.subLayerList[i]) {
            								this.layerList.splice(i, 1);
            								this.subLayerList.splice(i, 1);
            								len--;
            								this._updateTransparentOrder(i, len - 1);
            								this.subLayerEnabled.splice(i, 1);
            								this._dirty = true;
            								if (this.layerList.indexOf(layer) < 0) {
            										this.fire('remove', layer);
            								}
            								break;
            						}
            				}
            				this._updateLayerMaps();
            		}
            		getOpaqueIndex(layer) {
            				var _this_layerOpaqueIndexMap_get;
            				return (_this_layerOpaqueIndexMap_get = this.layerOpaqueIndexMap.get(layer)) != null ? _this_layerOpaqueIndexMap_get : -1;
            		}
            		getTransparentIndex(layer) {
            				var _this_layerTransparentIndexMap_get;
            				return (_this_layerTransparentIndexMap_get = this.layerTransparentIndexMap.get(layer)) != null ? _this_layerTransparentIndexMap_get : -1;
            		}
            		isEnabled(layer, transparent) {
            				if (layer.enabled) {
            						var index = transparent ? this.getTransparentIndex(layer) : this.getOpaqueIndex(layer);
            						if (index >= 0) {
            								return this.subLayerEnabled[index];
            						}
            				}
            				return false;
            		}
            		_updateLayerMaps() {
            				this.layerIdMap.clear();
            				this.layerNameMap.clear();
            				this.layerOpaqueIndexMap.clear();
            				this.layerTransparentIndexMap.clear();
            				for(var i = 0; i < this.layerList.length; i++){
            						var layer = this.layerList[i];
            						this.layerIdMap.set(layer.id, layer);
            						this.layerNameMap.set(layer.name, layer);
            						var subLayerIndexMap = this.subLayerList[i] ? this.layerTransparentIndexMap : this.layerOpaqueIndexMap;
            						subLayerIndexMap.set(layer, i);
            				}
            		}
            		getLayerById(id) {
            				var _this_layerIdMap_get;
            				return (_this_layerIdMap_get = this.layerIdMap.get(id)) != null ? _this_layerIdMap_get : null;
            		}
            		getLayerByName(name) {
            				var _this_layerNameMap_get;
            				return (_this_layerNameMap_get = this.layerNameMap.get(name)) != null ? _this_layerNameMap_get : null;
            		}
            		_updateOpaqueOrder(startIndex, endIndex) {
            				for(var i = startIndex; i <= endIndex; i++){
            						if (this.subLayerList[i] === false) {
            								this._opaqueOrder[this.layerList[i].id] = i;
            						}
            				}
            		}
            		_updateTransparentOrder(startIndex, endIndex) {
            				for(var i = startIndex; i <= endIndex; i++){
            						if (this.subLayerList[i] === true) {
            								this._transparentOrder[this.layerList[i].id] = i;
            						}
            				}
            		}
            		_sortLayersDescending(layersA, layersB, order) {
            				var topLayerA = -1;
            				var topLayerB = -1;
            				for(var i = 0, len = layersA.length; i < len; i++){
            						var id = layersA[i];
            						if (order.hasOwnProperty(id)) {
            								topLayerA = Math.max(topLayerA, order[id]);
            						}
            				}
            				for(var i1 = 0, len1 = layersB.length; i1 < len1; i1++){
            						var id1 = layersB[i1];
            						if (order.hasOwnProperty(id1)) {
            								topLayerB = Math.max(topLayerB, order[id1]);
            						}
            				}
            				if (topLayerA === -1 && topLayerB !== -1) {
            						return 1;
            				} else if (topLayerB === -1 && topLayerA !== -1) {
            						return -1;
            				}
            				return topLayerB - topLayerA;
            		}
            		sortTransparentLayers(layersA, layersB) {
            				return this._sortLayersDescending(layersA, layersB, this._transparentOrder);
            		}
            		sortOpaqueLayers(layersA, layersB) {
            				return this._sortLayersDescending(layersA, layersB, this._opaqueOrder);
            		}
            		constructor(name = 'Untitled'){
            				super(), this.layerList = [], this.layerIdMap = new Map(), this.layerNameMap = new Map(), this.layerOpaqueIndexMap = new Map(), this.layerTransparentIndexMap = new Map(), this.subLayerList = [], this.subLayerEnabled = [], this.cameras = [], this._renderActions = [], this._dirty = false;
            				this.name = name;
            				this._opaqueOrder = {};
            				this._transparentOrder = {};
            		}
            }
            
            var tmpVec = new Vec3();
            var tmpBiases = {
            		bias: 0,
            		normalBias: 0
            };
            var tmpColor = new Color();
            var chanId = {
            		r: 0,
            		g: 1,
            		b: 2,
            		a: 3
            };
            var lightTypes = {
            		'directional': LIGHTTYPE_DIRECTIONAL,
            		'omni': LIGHTTYPE_OMNI,
            		'point': LIGHTTYPE_OMNI,
            		'spot': LIGHTTYPE_SPOT
            };
            var directionalCascades = [
            		[
            				new Vec4(0, 0, 1, 1)
            		],
            		[
            				new Vec4(0, 0, 0.5, 0.5),
            				new Vec4(0, 0.5, 0.5, 0.5)
            		],
            		[
            				new Vec4(0, 0, 0.5, 0.5),
            				new Vec4(0, 0.5, 0.5, 0.5),
            				new Vec4(0.5, 0, 0.5, 0.5)
            		],
            		[
            				new Vec4(0, 0, 0.5, 0.5),
            				new Vec4(0, 0.5, 0.5, 0.5),
            				new Vec4(0.5, 0, 0.5, 0.5),
            				new Vec4(0.5, 0.5, 0.5, 0.5)
            		]
            ];
            var channelMap = {
            		'rrr': 1,
            		'ggg': 2,
            		'bbb': 4,
            		'aaa': 8,
            		'rgb': 7
            };
            var id = 0;
            class LightRenderData {
            		destroy() {
            				this.viewBindGroups.forEach((bg)=>{
            						bg.defaultUniformBuffer.destroy();
            						bg.destroy();
            				});
            				this.viewBindGroups.length = 0;
            		}
            		get shadowBuffer() {
            				var rt = this.shadowCamera.renderTarget;
            				if (rt) {
            						return this.light._isPcf ? rt.depthBuffer : rt.colorBuffer;
            				}
            				return null;
            		}
            		constructor(camera, face, light){
            				this.light = light;
            				this.camera = camera;
            				this.shadowCamera = ShadowRenderer.createShadowCamera(light._shadowType, light._type, face);
            				this.shadowMatrix = new Mat4();
            				this.shadowViewport = new Vec4(0, 0, 1, 1);
            				this.shadowScissor = new Vec4(0, 0, 1, 1);
            				this.projectionCompensation = 0;
            				this.face = face;
            				this.visibleCasters = [];
            				this.viewBindGroups = [];
            		}
            }
            class Light {
            		destroy() {
            				this._destroyShadowMap();
            				this.releaseRenderData();
            				this._renderData = null;
            		}
            		releaseRenderData() {
            				if (this._renderData) {
            						for(var i = 0; i < this._renderData.length; i++){
            								this._renderData[i].destroy();
            						}
            						this._renderData.length = 0;
            				}
            		}
            		addLayer(layer) {
            				this.layers.add(layer);
            		}
            		removeLayer(layer) {
            				this.layers.delete(layer);
            		}
            		set shadowSamples(value) {
            				this._softShadowParams[0] = value;
            		}
            		get shadowSamples() {
            				return this._softShadowParams[0];
            		}
            		set shadowBlockerSamples(value) {
            				this._softShadowParams[1] = value;
            		}
            		get shadowBlockerSamples() {
            				return this._softShadowParams[1];
            		}
            		set shadowBias(value) {
            				if (this._shadowBias !== value) {
            						this._shadowBias = value;
            						this._updateShadowBias();
            				}
            		}
            		get shadowBias() {
            				return this._shadowBias;
            		}
            		set numCascades(value) {
            				if (!this.cascades || this.numCascades !== value) {
            						this.cascades = directionalCascades[value - 1];
            						this._shadowMatrixPalette = new Float32Array(4 * 16);
            						this._shadowCascadeDistances = new Float32Array(4);
            						this._destroyShadowMap();
            						this.updateKey();
            				}
            		}
            		get numCascades() {
            				return this.cascades.length;
            		}
            		set cascadeBlend(value) {
            				if (this._cascadeBlend !== value) {
            						this._cascadeBlend = value;
            						this.updateKey();
            				}
            		}
            		get cascadeBlend() {
            				return this._cascadeBlend;
            		}
            		set shadowMap(shadowMap) {
            				if (this._shadowMap !== shadowMap) {
            						this._destroyShadowMap();
            						this._shadowMap = shadowMap;
            				}
            		}
            		get shadowMap() {
            				return this._shadowMap;
            		}
            		set mask(value) {
            				if (this._mask !== value) {
            						this._mask = value;
            						this.updateKey();
            						this.updateClusteredFlags();
            				}
            		}
            		get mask() {
            				return this._mask;
            		}
            		get numShadowFaces() {
            				var type = this._type;
            				if (type === LIGHTTYPE_DIRECTIONAL) {
            						return this.numCascades;
            				} else if (type === LIGHTTYPE_OMNI) {
            						return 6;
            				}
            				return 1;
            		}
            		set type(value) {
            				if (this._type === value) {
            						return;
            				}
            				this._type = value;
            				this._destroyShadowMap();
            				this._updateShadowBias();
            				this.updateKey();
            				this.updateClusteredFlags();
            				var stype = this._shadowType;
            				this._shadowType = null;
            				this.shadowUpdateOverrides = null;
            				this.shadowType = stype;
            		}
            		get type() {
            				return this._type;
            		}
            		set shape(value) {
            				if (this._shape === value) {
            						return;
            				}
            				this._shape = value;
            				this._destroyShadowMap();
            				this.updateKey();
            				this.updateClusteredFlags();
            				var stype = this._shadowType;
            				this._shadowType = null;
            				this.shadowType = stype;
            		}
            		get shape() {
            				return this._shape;
            		}
            		set usePhysicalUnits(value) {
            				if (this._usePhysicalUnits !== value) {
            						this._usePhysicalUnits = value;
            						this._updateLinearColor();
            				}
            		}
            		get usePhysicalUnits() {
            				return this._usePhysicalUnits;
            		}
            		set shadowType(value) {
            				if (this._shadowType === value) {
            						return;
            				}
            				var shadowInfo = shadowTypeInfo.get(value);
            				if (!shadowInfo) {
            						value = SHADOW_PCF3_32F;
            				}
            				var device = this.device;
            				if (value === SHADOW_PCSS_32F && !device.textureFloatRenderable && !device.textureHalfFloatRenderable) {
            						value = SHADOW_PCF3_32F;
            				}
            				if (this._type === LIGHTTYPE_OMNI && value !== SHADOW_PCF1_32F && value !== SHADOW_PCF3_32F && value !== SHADOW_PCF1_16F && value !== SHADOW_PCF3_16F && value !== SHADOW_PCSS_32F) {
            						value = SHADOW_PCF3_32F;
            				}
            				if (value === SHADOW_VSM_32F && (!device.textureFloatRenderable || !device.textureFloatFilterable)) {
            						value = SHADOW_VSM_16F;
            				}
            				if (value === SHADOW_VSM_16F && !device.textureHalfFloatRenderable) {
            						value = SHADOW_PCF3_32F;
            				}
            				shadowInfo = shadowTypeInfo.get(value);
            				var _shadowInfo_vsm;
            				this._isVsm = (_shadowInfo_vsm = shadowInfo == null ? void 0 : shadowInfo.vsm) != null ? _shadowInfo_vsm : false;
            				var _shadowInfo_pcf;
            				this._isPcf = (_shadowInfo_pcf = shadowInfo == null ? void 0 : shadowInfo.pcf) != null ? _shadowInfo_pcf : false;
            				this._shadowType = value;
            				this._destroyShadowMap();
            				this.updateKey();
            		}
            		get shadowType() {
            				return this._shadowType;
            		}
            		set enabled(value) {
            				if (this._enabled !== value) {
            						this._enabled = value;
            						this.layersDirty();
            				}
            		}
            		get enabled() {
            				return this._enabled;
            		}
            		set castShadows(value) {
            				if (this._castShadows !== value) {
            						this._castShadows = value;
            						this._destroyShadowMap();
            						this.layersDirty();
            						this.updateKey();
            				}
            		}
            		get castShadows() {
            				return this._castShadows && this._mask !== MASK_BAKE && this._mask !== 0;
            		}
            		set shadowIntensity(value) {
            				if (this._shadowIntensity !== value) {
            						this._shadowIntensity = value;
            						this.updateKey();
            				}
            		}
            		get shadowIntensity() {
            				return this._shadowIntensity;
            		}
            		get bakeShadows() {
            				return this._castShadows && this._mask === MASK_BAKE;
            		}
            		set shadowResolution(value) {
            				if (this._shadowResolution !== value) {
            						if (this._type === LIGHTTYPE_OMNI) {
            								value = Math.min(value, this.device.maxCubeMapSize);
            						} else {
            								value = Math.min(value, this.device.maxTextureSize);
            						}
            						this._shadowResolution = value;
            						this._destroyShadowMap();
            				}
            		}
            		get shadowResolution() {
            				return this._shadowResolution;
            		}
            		set vsmBlurSize(value) {
            				if (this._vsmBlurSize === value) {
            						return;
            				}
            				if (value % 2 === 0) value++;
            				this._vsmBlurSize = value;
            		}
            		get vsmBlurSize() {
            				return this._vsmBlurSize;
            		}
            		set normalOffsetBias(value) {
            				if (this._normalOffsetBias !== value) {
            						var dirty = !this._normalOffsetBias && value || this._normalOffsetBias && !value;
            						this._normalOffsetBias = value;
            						if (dirty) {
            								this.updateKey();
            						}
            				}
            		}
            		get normalOffsetBias() {
            				return this._normalOffsetBias;
            		}
            		set falloffMode(value) {
            				if (this._falloffMode === value) {
            						return;
            				}
            				this._falloffMode = value;
            				this.updateKey();
            				this.updateClusteredFlags();
            		}
            		get falloffMode() {
            				return this._falloffMode;
            		}
            		set innerConeAngle(value) {
            				if (this._innerConeAngle === value) {
            						return;
            				}
            				this._innerConeAngle = value;
            				this._innerConeAngleCos = Math.cos(value * Math.PI / 180);
            				this.updateClusterData(false, true);
            				if (this._usePhysicalUnits) {
            						this._updateLinearColor();
            				}
            		}
            		get innerConeAngle() {
            				return this._innerConeAngle;
            		}
            		set outerConeAngle(value) {
            				if (this._outerConeAngle === value) {
            						return;
            				}
            				this._outerConeAngle = value;
            				this._updateOuterAngle(value);
            				if (this._usePhysicalUnits) {
            						this._updateLinearColor();
            				}
            		}
            		get outerConeAngle() {
            				return this._outerConeAngle;
            		}
            		set penumbraSize(value) {
            				this._penumbraSize = value;
            				this._softShadowParams[2] = value;
            		}
            		get penumbraSize() {
            				return this._penumbraSize;
            		}
            		set penumbraFalloff(value) {
            				this._softShadowParams[3] = value;
            		}
            		get penumbraFalloff() {
            				return this._softShadowParams[3];
            		}
            		_updateOuterAngle(angle) {
            				var radAngle = angle * Math.PI / 180;
            				this._outerConeAngleCos = Math.cos(radAngle);
            				this._outerConeAngleSin = Math.sin(radAngle);
            				this.updateClusterData(false, true);
            		}
            		set intensity(value) {
            				if (this._intensity !== value) {
            						this._intensity = value;
            						this._updateLinearColor();
            				}
            		}
            		get intensity() {
            				return this._intensity;
            		}
            		set affectSpecularity(value) {
            				if (this._type === LIGHTTYPE_DIRECTIONAL) {
            						this._affectSpecularity = value;
            						this.updateKey();
            				}
            		}
            		get affectSpecularity() {
            				return this._affectSpecularity;
            		}
            		set luminance(value) {
            				if (this._luminance !== value) {
            						this._luminance = value;
            						this._updateLinearColor();
            				}
            		}
            		get luminance() {
            				return this._luminance;
            		}
            		get cookieMatrix() {
            				if (!this._cookieMatrix) {
            						this._cookieMatrix = new Mat4();
            				}
            				return this._cookieMatrix;
            		}
            		get atlasViewport() {
            				if (!this._atlasViewport) {
            						this._atlasViewport = new Vec4(0, 0, 1, 1);
            				}
            				return this._atlasViewport;
            		}
            		set cookie(value) {
            				if (this._cookie === value) {
            						return;
            				}
            				this._cookie = value;
            				this.updateKey();
            		}
            		get cookie() {
            				return this._cookie;
            		}
            		set cookieFalloff(value) {
            				if (this._cookieFalloff === value) {
            						return;
            				}
            				this._cookieFalloff = value;
            				this.updateKey();
            		}
            		get cookieFalloff() {
            				return this._cookieFalloff;
            		}
            		set cookieChannel(value) {
            				if (this._cookieChannel === value) {
            						return;
            				}
            				if (value.length < 3) {
            						var chr = value.charAt(value.length - 1);
            						var addLen = 3 - value.length;
            						for(var i = 0; i < addLen; i++){
            								value += chr;
            						}
            				}
            				this._cookieChannel = value;
            				this.updateKey();
            				this.updateClusteredFlags();
            		}
            		get cookieChannel() {
            				return this._cookieChannel;
            		}
            		set cookieTransform(value) {
            				if (this._cookieTransform === value) {
            						return;
            				}
            				this._cookieTransform = value;
            				this._cookieTransformSet = !!value;
            				if (value && !this._cookieOffset) {
            						this.cookieOffset = new Vec2();
            						this._cookieOffsetSet = false;
            				}
            				this.updateKey();
            		}
            		get cookieTransform() {
            				return this._cookieTransform;
            		}
            		set cookieOffset(value) {
            				if (this._cookieOffset === value) {
            						return;
            				}
            				var xformNew = !!(this._cookieTransformSet || value);
            				if (xformNew && !value && this._cookieOffset) {
            						this._cookieOffset.set(0, 0);
            				} else {
            						this._cookieOffset = value;
            				}
            				this._cookieOffsetSet = !!value;
            				if (value && !this._cookieTransform) {
            						this.cookieTransform = new Vec4(1, 1, 0, 0);
            						this._cookieTransformSet = false;
            				}
            				this.updateKey();
            		}
            		get cookieOffset() {
            				return this._cookieOffset;
            		}
            		beginFrame() {
            				this.visibleThisFrame = this._type === LIGHTTYPE_DIRECTIONAL && this._enabled;
            				this.maxScreenSize = 0;
            				this.atlasViewportAllocated = false;
            				this.atlasSlotUpdated = false;
            		}
            		_destroyShadowMap() {
            				this.releaseRenderData();
            				if (this._shadowMap) {
            						if (!this._shadowMap.cached) {
            								this._shadowMap.destroy();
            						}
            						this._shadowMap = null;
            				}
            				if (this.shadowUpdateMode === SHADOWUPDATE_NONE) {
            						this.shadowUpdateMode = SHADOWUPDATE_THISFRAME;
            				}
            				if (this.shadowUpdateOverrides) {
            						for(var i = 0; i < this.shadowUpdateOverrides.length; i++){
            								if (this.shadowUpdateOverrides[i] === SHADOWUPDATE_NONE) {
            										this.shadowUpdateOverrides[i] = SHADOWUPDATE_THISFRAME;
            								}
            						}
            				}
            		}
            		getRenderData(camera, face) {
            				for(var i = 0; i < this._renderData.length; i++){
            						var current = this._renderData[i];
            						if (current.camera === camera && current.face === face) {
            								return current;
            						}
            				}
            				var rd = new LightRenderData(camera, face, this);
            				this._renderData.push(rd);
            				return rd;
            		}
            		clone() {
            				var clone = new Light(this.device, this.clusteredLighting);
            				clone.type = this._type;
            				clone.setColor(this._color);
            				clone.intensity = this._intensity;
            				clone.affectSpecularity = this._affectSpecularity;
            				clone.luminance = this._luminance;
            				clone.castShadows = this.castShadows;
            				clone._enabled = this._enabled;
            				clone.attenuationStart = this.attenuationStart;
            				clone.attenuationEnd = this.attenuationEnd;
            				clone.falloffMode = this._falloffMode;
            				clone.shadowType = this._shadowType;
            				clone.vsmBlurSize = this._vsmBlurSize;
            				clone.vsmBlurMode = this.vsmBlurMode;
            				clone.vsmBias = this.vsmBias;
            				clone.shadowUpdateMode = this.shadowUpdateMode;
            				clone.mask = this.mask;
            				if (this.shadowUpdateOverrides) {
            						clone.shadowUpdateOverrides = this.shadowUpdateOverrides.slice();
            				}
            				clone.innerConeAngle = this._innerConeAngle;
            				clone.outerConeAngle = this._outerConeAngle;
            				clone.numCascades = this.numCascades;
            				clone.cascadeDistribution = this.cascadeDistribution;
            				clone.cascadeBlend = this._cascadeBlend;
            				clone.shape = this._shape;
            				clone.shadowDepthState.copy(this.shadowDepthState);
            				clone.shadowBias = this.shadowBias;
            				clone.normalOffsetBias = this._normalOffsetBias;
            				clone.shadowResolution = this._shadowResolution;
            				clone.shadowDistance = this.shadowDistance;
            				clone.shadowIntensity = this.shadowIntensity;
            				clone.shadowSamples = this.shadowSamples;
            				clone.shadowBlockerSamples = this.shadowBlockerSamples;
            				clone.penumbraSize = this.penumbraSize;
            				clone.penumbraFalloff = this.penumbraFalloff;
            				return clone;
            		}
            		static getLightUnitConversion(type, outerAngle, innerAngle) {
            				if (outerAngle === void 0) outerAngle = Math.PI / 4;
            				if (innerAngle === void 0) innerAngle = 0;
            				switch(type){
            						case LIGHTTYPE_SPOT:
            								{
            										var falloffEnd = Math.cos(outerAngle);
            										var falloffStart = Math.cos(innerAngle);
            										return 2 * Math.PI * (1 - falloffStart + (falloffStart - falloffEnd) / 2.0);
            								}
            						case LIGHTTYPE_OMNI:
            								return 4 * Math.PI;
            						case LIGHTTYPE_DIRECTIONAL:
            								return 1;
            				}
            		}
            		_getUniformBiasValues(lightRenderData) {
            				var farClip = lightRenderData.shadowCamera._farClip;
            				switch(this._type){
            						case LIGHTTYPE_OMNI:
            								tmpBiases.bias = this.shadowBias;
            								tmpBiases.normalBias = this._normalOffsetBias;
            								break;
            						case LIGHTTYPE_SPOT:
            								if (this._isVsm) {
            										tmpBiases.bias = -1e-5 * 20;
            								} else {
            										tmpBiases.bias = this.shadowBias * 20;
            								}
            								tmpBiases.normalBias = this._isVsm ? this.vsmBias / (this.attenuationEnd / 7.0) : this._normalOffsetBias;
            								break;
            						case LIGHTTYPE_DIRECTIONAL:
            								if (this._isVsm) {
            										tmpBiases.bias = -1e-5 * 20;
            								} else {
            										tmpBiases.bias = this.shadowBias / farClip * 100;
            								}
            								tmpBiases.normalBias = this._isVsm ? this.vsmBias / (farClip / 7.0) : this._normalOffsetBias;
            								break;
            				}
            				return tmpBiases;
            		}
            		getColor() {
            				return this._color;
            		}
            		getBoundingSphere(sphere) {
            				if (this._type === LIGHTTYPE_SPOT) {
            						var size = this.attenuationEnd;
            						var angle = this._outerConeAngle;
            						var cosAngle = this._outerConeAngleCos;
            						var node = this._node;
            						tmpVec.copy(node.up);
            						if (angle > 45) {
            								sphere.radius = size * this._outerConeAngleSin;
            								tmpVec.mulScalar(-size * cosAngle);
            						} else {
            								sphere.radius = size / (2 * cosAngle);
            								tmpVec.mulScalar(-sphere.radius);
            						}
            						sphere.center.add2(node.getPosition(), tmpVec);
            				} else if (this._type === LIGHTTYPE_OMNI) {
            						sphere.center = this._node.getPosition();
            						sphere.radius = this.attenuationEnd;
            				}
            		}
            		getBoundingBox(box) {
            				if (this._type === LIGHTTYPE_SPOT) {
            						var range = this.attenuationEnd;
            						var angle = this._outerConeAngle;
            						var node = this._node;
            						var scl = Math.abs(Math.sin(angle * math.DEG_TO_RAD) * range);
            						box.center.set(0, -range * 0.5, 0);
            						box.halfExtents.set(scl, range * 0.5, scl);
            						box.setFromTransformedAabb(box, node.getWorldTransform(), true);
            				} else if (this._type === LIGHTTYPE_OMNI) {
            						box.center.copy(this._node.getPosition());
            						box.halfExtents.set(this.attenuationEnd, this.attenuationEnd, this.attenuationEnd);
            				}
            		}
            		_updateShadowBias() {
            				if (this._type === LIGHTTYPE_OMNI && !this.clusteredLighting) {
            						this.shadowDepthState.depthBias = 0;
            						this.shadowDepthState.depthBiasSlope = 0;
            				} else {
            						var bias = this.shadowBias * -1e3;
            						this.shadowDepthState.depthBias = bias;
            						this.shadowDepthState.depthBiasSlope = bias;
            				}
            		}
            		_updateLinearColor() {
            				var intensity = this._intensity;
            				if (this._usePhysicalUnits) {
            						intensity = this._luminance / Light.getLightUnitConversion(this._type, this._outerConeAngle * math.DEG_TO_RAD, this._innerConeAngle * math.DEG_TO_RAD);
            				}
            				var color = this._color;
            				var colorLinear = this._colorLinear;
            				if (intensity >= 1) {
            						tmpColor.linear(color).mulScalar(intensity);
            				} else {
            						tmpColor.copy(color).mulScalar(intensity).linear();
            				}
            				colorLinear[0] = tmpColor.r;
            				colorLinear[1] = tmpColor.g;
            				colorLinear[2] = tmpColor.b;
            				this.updateClusterData(true);
            		}
            		setColor() {
            				if (arguments.length === 1) {
            						this._color.set(arguments[0].r, arguments[0].g, arguments[0].b);
            				} else if (arguments.length === 3) {
            						this._color.set(arguments[0], arguments[1], arguments[2]);
            				}
            				this._updateLinearColor();
            		}
            		layersDirty() {
            				this.layers.forEach((layer)=>{
            						if (layer.hasLight(this)) {
            								layer.markLightsDirty();
            						}
            				});
            		}
            		updateKey() {
            				var key = this._type << 29 | this._shadowType << 25 | this._falloffMode << 23 | (this._normalOffsetBias !== 0.0 ? 1 : 0) << 22 | (this._cookie ? 1 : 0) << 21 | (this._cookieFalloff ? 1 : 0) << 20 | chanId[this._cookieChannel.charAt(0)] << 18 | (this._cookieTransform ? 1 : 0) << 12 | this._shape << 10 | (this.numCascades > 0 ? 1 : 0) << 9 | (this._cascadeBlend > 0 ? 1 : 0) << 8 | (this.affectSpecularity ? 1 : 0) << 7 | this.mask << 6 | (this._castShadows ? 1 : 0) << 3;
            				if (this._cookieChannel.length === 3) {
            						key |= chanId[this._cookieChannel.charAt(1)] << 16;
            						key |= chanId[this._cookieChannel.charAt(2)] << 14;
            				}
            				if (key !== this.key) {
            						this.layersDirty();
            				}
            				this.key = key;
            		}
            		updateClusteredFlags() {
            				var isDynamic = !!(this.mask & MASK_AFFECT_DYNAMIC);
            				var isLightmapped = !!(this.mask & MASK_AFFECT_LIGHTMAPPED);
            				var _channelMap_this__cookieChannel;
            				this.clusteredFlags = (this.type === LIGHTTYPE_SPOT ? 1 : 0) << 30 | (this._shape & 0x3) << 28 | (this._falloffMode & 0x1) << 27 | ((_channelMap_this__cookieChannel = channelMap[this._cookieChannel]) != null ? _channelMap_this__cookieChannel : 0) << 23 | (isDynamic ? 1 : 0) << 22 | (isLightmapped ? 1 : 0) << 21;
            		}
            		getClusteredFlags(castShadows, useCookie) {
            				return this.clusteredFlags | ((castShadows ? Math.floor(this.shadowIntensity * 255) : 0) & 0xFF) << 0 | ((useCookie ? Math.floor(this.cookieIntensity * 255) : 0) & 0xFF) << 8;
            		}
            		updateClusterData(updateColor, updateAngles) {
            				var { clusteredData16 } = this;
            				var float2Half = FloatPacking.float2Half;
            				if (updateColor) {
            						clusteredData16[0] = float2Half(math.clamp(this._colorLinear[0] / LIGHT_COLOR_DIVIDER, 0, 65504));
            						clusteredData16[1] = float2Half(math.clamp(this._colorLinear[1] / LIGHT_COLOR_DIVIDER, 0, 65504));
            						clusteredData16[2] = float2Half(math.clamp(this._colorLinear[2] / LIGHT_COLOR_DIVIDER, 0, 65504));
            				}
            				if (updateAngles) {
            						clusteredData16[4] = float2Half(this._innerConeAngleCos);
            						clusteredData16[5] = float2Half(this._outerConeAngleCos);
            				}
            		}
            		constructor(graphicsDevice, clusteredLighting){
            				this.layers = new Set();
            				this.shadowDepthState = DepthState.DEFAULT.clone();
            				this.clusteredFlags = 0;
            				this.clusteredData = new Uint32Array(3);
            				this.clusteredData16 = new Uint16Array(this.clusteredData.buffer);
            				this.device = graphicsDevice;
            				this.clusteredLighting = clusteredLighting;
            				this.id = id++;
            				this._type = LIGHTTYPE_DIRECTIONAL;
            				this._color = new Color(0.8, 0.8, 0.8);
            				this._intensity = 1;
            				this._affectSpecularity = true;
            				this._luminance = 0;
            				this._castShadows = false;
            				this._enabled = false;
            				this._mask = MASK_AFFECT_DYNAMIC;
            				this.isStatic = false;
            				this.key = 0;
            				this.bakeDir = true;
            				this.bakeNumSamples = 1;
            				this.bakeArea = 0;
            				this.attenuationStart = 10;
            				this.attenuationEnd = 10;
            				this._falloffMode = LIGHTFALLOFF_LINEAR;
            				this._shadowType = SHADOW_PCF3_32F;
            				this._vsmBlurSize = 11;
            				this.vsmBlurMode = BLUR_GAUSSIAN;
            				this.vsmBias = 0.01 * 0.25;
            				this._cookie = null;
            				this.cookieIntensity = 1;
            				this._cookieFalloff = true;
            				this._cookieChannel = 'rgb';
            				this._cookieTransform = null;
            				this._cookieTransformUniform = new Float32Array(4);
            				this._cookieOffset = null;
            				this._cookieOffsetUniform = new Float32Array(2);
            				this._cookieTransformSet = false;
            				this._cookieOffsetSet = false;
            				this._innerConeAngle = 40;
            				this._outerConeAngle = 45;
            				this.cascades = null;
            				this._shadowMatrixPalette = null;
            				this._shadowCascadeDistances = null;
            				this.numCascades = 1;
            				this._cascadeBlend = 0;
            				this.cascadeDistribution = 0.5;
            				this._shape = LIGHTSHAPE_PUNCTUAL;
            				this._colorLinear = new Float32Array(3);
            				this._updateLinearColor();
            				this._position = new Vec3(0, 0, 0);
            				this._direction = new Vec3(0, 0, 0);
            				this._innerConeAngleCos = Math.cos(this._innerConeAngle * Math.PI / 180);
            				this._updateOuterAngle(this._outerConeAngle);
            				this._usePhysicalUnits = undefined;
            				this._shadowMap = null;
            				this._shadowRenderParams = [];
            				this._shadowCameraParams = [];
            				this.shadowDistance = 40;
            				this._shadowResolution = 1024;
            				this._shadowBias = -5e-4;
            				this._shadowIntensity = 1.0;
            				this._normalOffsetBias = 0.0;
            				this.shadowUpdateMode = SHADOWUPDATE_REALTIME;
            				this.shadowUpdateOverrides = null;
            				this._isVsm = false;
            				this._isPcf = true;
            				this._softShadowParams = new Float32Array(4);
            				this.shadowSamples = 16;
            				this.shadowBlockerSamples = 16;
            				this.penumbraSize = 1.0;
            				this.penumbraFalloff = 1.0;
            				this._cookieMatrix = null;
            				this._atlasViewport = null;
            				this.atlasViewportAllocated = false;
            				this.atlasVersion = 0;
            				this.atlasSlotIndex = 0;
            				this.atlasSlotUpdated = false;
            				this._node = null;
            				this._renderData = [];
            				this.visibleThisFrame = false;
            				this.maxScreenSize = 0;
            				this._updateShadowBias();
            		}
            }
            
            class LightingParams {
            		applySettings(render) {
            				var _render_lightingShadowsEnabled;
            				this.shadowsEnabled = (_render_lightingShadowsEnabled = render.lightingShadowsEnabled) != null ? _render_lightingShadowsEnabled : this.shadowsEnabled;
            				var _render_lightingCookiesEnabled;
            				this.cookiesEnabled = (_render_lightingCookiesEnabled = render.lightingCookiesEnabled) != null ? _render_lightingCookiesEnabled : this.cookiesEnabled;
            				var _render_lightingAreaLightsEnabled;
            				this.areaLightsEnabled = (_render_lightingAreaLightsEnabled = render.lightingAreaLightsEnabled) != null ? _render_lightingAreaLightsEnabled : this.areaLightsEnabled;
            				var _render_lightingShadowAtlasResolution;
            				this.shadowAtlasResolution = (_render_lightingShadowAtlasResolution = render.lightingShadowAtlasResolution) != null ? _render_lightingShadowAtlasResolution : this.shadowAtlasResolution;
            				var _render_lightingCookieAtlasResolution;
            				this.cookieAtlasResolution = (_render_lightingCookieAtlasResolution = render.lightingCookieAtlasResolution) != null ? _render_lightingCookieAtlasResolution : this.cookieAtlasResolution;
            				var _render_lightingMaxLightsPerCell;
            				this.maxLightsPerCell = (_render_lightingMaxLightsPerCell = render.lightingMaxLightsPerCell) != null ? _render_lightingMaxLightsPerCell : this.maxLightsPerCell;
            				var _render_lightingShadowType;
            				this.shadowType = (_render_lightingShadowType = render.lightingShadowType) != null ? _render_lightingShadowType : this.shadowType;
            				if (render.lightingCells) {
            						this.cells = new Vec3(render.lightingCells);
            				}
            		}
            		set cells(value) {
            				this._cells.copy(value);
            		}
            		get cells() {
            				return this._cells;
            		}
            		set maxLightsPerCell(value) {
            				this._maxLightsPerCell = math.clamp(value, 1, 255);
            		}
            		get maxLightsPerCell() {
            				return this._maxLightsPerCell;
            		}
            		set cookieAtlasResolution(value) {
            				this._cookieAtlasResolution = math.clamp(value, 32, this._maxTextureSize);
            		}
            		get cookieAtlasResolution() {
            				return this._cookieAtlasResolution;
            		}
            		set shadowAtlasResolution(value) {
            				this._shadowAtlasResolution = math.clamp(value, 32, this._maxTextureSize);
            		}
            		get shadowAtlasResolution() {
            				return this._shadowAtlasResolution;
            		}
            		set shadowType(value) {
            				if (this._shadowType !== value) {
            						this._shadowType = value;
            						this._dirtyLightsFnc();
            				}
            		}
            		get shadowType() {
            				return this._shadowType;
            		}
            		set cookiesEnabled(value) {
            				if (this._cookiesEnabled !== value) {
            						this._cookiesEnabled = value;
            						this._dirtyLightsFnc();
            				}
            		}
            		get cookiesEnabled() {
            				return this._cookiesEnabled;
            		}
            		set areaLightsEnabled(value) {
            				if (this._supportsAreaLights) {
            						if (this._areaLightsEnabled !== value) {
            								this._areaLightsEnabled = value;
            								this._dirtyLightsFnc();
            						}
            				}
            		}
            		get areaLightsEnabled() {
            				return this._areaLightsEnabled;
            		}
            		set shadowsEnabled(value) {
            				if (this._shadowsEnabled !== value) {
            						this._shadowsEnabled = value;
            						this._dirtyLightsFnc();
            				}
            		}
            		get shadowsEnabled() {
            				return this._shadowsEnabled;
            		}
            		constructor(supportsAreaLights, maxTextureSize, dirtyLightsFnc){
            				this._areaLightsEnabled = false;
            				this._cells = new Vec3(10, 3, 10);
            				this._maxLightsPerCell = 255;
            				this._shadowsEnabled = true;
            				this._shadowType = SHADOW_PCF3_32F;
            				this._shadowAtlasResolution = 2048;
            				this._cookiesEnabled = false;
            				this._cookieAtlasResolution = 2048;
            				this.atlasSplit = null;
            				this._supportsAreaLights = supportsAreaLights;
            				this._maxTextureSize = maxTextureSize;
            				this._dirtyLightsFnc = dirtyLightsFnc;
            		}
            }
            
            var blendStateAdditive = new BlendState(true, BLENDEQUATION_ADD, BLENDMODE_ONE, BLENDMODE_ONE);
            class MorphInstance {
            		destroy() {
            				this.shader = null;
            				var morph = this.morph;
            				if (morph) {
            						this.morph = null;
            						morph.decRefCount();
            						if (morph.refCount < 1) {
            								morph.destroy();
            						}
            				}
            				if (this.rtPositions) {
            						this.rtPositions.destroy();
            						this.rtPositions = null;
            				}
            				if (this.texturePositions) {
            						this.texturePositions.destroy();
            						this.texturePositions = null;
            				}
            				if (this.rtNormals) {
            						this.rtNormals.destroy();
            						this.rtNormals = null;
            				}
            				if (this.textureNormals) {
            						this.textureNormals.destroy();
            						this.textureNormals = null;
            				}
            		}
            		clone() {
            				return new MorphInstance(this.morph);
            		}
            		_getWeightIndex(key) {
            				if (typeof key === 'string') {
            						var index = this._weightMap.get(key);
            						return index;
            				}
            				return key;
            		}
            		getWeight(key) {
            				var index = this._getWeightIndex(key);
            				return this._weights[index];
            		}
            		setWeight(key, weight) {
            				var index = this._getWeightIndex(key);
            				this._weights[index] = weight;
            				this._dirty = true;
            		}
            		_getShader(count) {
            				var shader = this.shaderCache[count];
            				if (!shader) {
            						var wgsl = this.device.isWebGPU;
            						var chunks = wgsl ? shaderChunksWGSL : shaderChunks;
            						var defines = new Map();
            						defines.set('MORPH_TEXTURE_COUNT', count);
            						defines.set('{MORPH_TEXTURE_COUNT}', count);
            						if (this.morph.intRenderFormat) defines.set('MORPH_INT', '');
            						var includes = new Map();
            						includes.set('morphDeclarationPS', chunks.morphDeclarationPS);
            						includes.set('morphEvaluationPS', chunks.morphEvaluationPS);
            						var outputType = this.morph.intRenderFormat ? 'uvec4' : 'vec4';
            						shader = createShaderFromCode(this.device, chunks.morphVS, chunks.morphPS, "textureMorph" + count, {
            								vertex_position: SEMANTIC_POSITION
            						}, {
            								shaderLanguage: wgsl ? SHADERLANGUAGE_WGSL : SHADERLANGUAGE_GLSL,
            								fragmentIncludes: includes,
            								fragmentDefines: defines,
            								fragmentOutputTypes: [
            										outputType
            								]
            						});
            						this.shaderCache[count] = shader;
            				}
            				return shader;
            		}
            		_updateTextureRenderTarget(renderTarget, srcTextureName, isPos) {
            				var device = this.device;
            				var submitBatch = (usedCount, blending)=>{
            						this.morphFactor.setValue(this._shaderMorphWeights);
            						device.setBlendState(blending ? blendStateAdditive : BlendState.NOBLEND);
            						var shader = this._getShader(usedCount);
            						drawQuadWithShader(device, renderTarget, shader);
            				};
            				this.setAabbUniforms(isPos);
            				var usedCount = 0;
            				var blending = false;
            				var count = this._activeTargets.length;
            				for(var i = 0; i < count; i++){
            						var activeTarget = this._activeTargets[i];
            						var tex = activeTarget.target[srcTextureName];
            						if (tex) {
            								this["morphBlendTex" + usedCount].setValue(tex);
            								this._shaderMorphWeights[usedCount] = activeTarget.weight;
            								usedCount++;
            								if (usedCount >= this.maxSubmitCount) {
            										submitBatch(usedCount, blending);
            										usedCount = 0;
            										blending = true;
            								}
            						}
            				}
            				if (usedCount > 0 || count === 0 && !this.zeroTextures) {
            						submitBatch(usedCount, blending);
            				}
            		}
            		_updateTextureMorph() {
            				this.device;
            				if (this._activeTargets.length > 0 || !this.zeroTextures) {
            						if (this.rtPositions) {
            								this._updateTextureRenderTarget(this.rtPositions, 'texturePositions', true);
            						}
            						if (this.rtNormals) {
            								this._updateTextureRenderTarget(this.rtNormals, 'textureNormals', false);
            						}
            						this.zeroTextures = this._activeTargets.length === 0;
            				}
            		}
            		setAabbUniforms(isPos) {
            				if (isPos === void 0) isPos = true;
            				this.aabbSizeId.setValue(isPos ? this._aabbSize : this._aabbNrmSize);
            				this.aabbMinId.setValue(isPos ? this._aabbMin : this._aabbNrmMin);
            		}
            		prepareRendering(device) {
            				this.setAabbUniforms();
            		}
            		update() {
            				this._dirty = false;
            				var targets = this.morph._targets;
            				var activeCount = 0;
            				var epsilon = 0.00001;
            				for(var i = 0; i < targets.length; i++){
            						var absWeight = Math.abs(this.getWeight(i));
            						if (absWeight > epsilon) {
            								if (this._activeTargets.length <= activeCount) {
            										this._activeTargets[activeCount] = {};
            								}
            								var activeTarget = this._activeTargets[activeCount++];
            								activeTarget.absWeight = absWeight;
            								activeTarget.weight = this.getWeight(i);
            								activeTarget.target = targets[i];
            						}
            				}
            				this._activeTargets.length = activeCount;
            				if (this.morph.intRenderFormat) {
            						if (this._activeTargets.length > this.maxSubmitCount) {
            								this._activeTargets.sort((l, r)=>{
            										return l.absWeight < r.absWeight ? 1 : r.absWeight < l.absWeight ? -1 : 0;
            								});
            								this._activeTargets.length = this.maxSubmitCount;
            						}
            				}
            				this._updateTextureMorph();
            		}
            		constructor(morph){
            				this.shaderCache = [];
            				this.morph = morph;
            				morph.incRefCount();
            				this.device = morph.device;
            				this._weights = [];
            				this._weightMap = new Map();
            				for(var v = 0; v < morph._targets.length; v++){
            						var target = morph._targets[v];
            						if (target.name) {
            								this._weightMap.set(target.name, v);
            						}
            						this.setWeight(v, target.defaultWeight);
            				}
            				this._activeTargets = [];
            				this.maxSubmitCount = this.device.maxTextures;
            				this._shaderMorphWeights = new Float32Array(this.maxSubmitCount);
            				var createRT = (name, textureVar)=>{
            						this[textureVar] = morph._createTexture(name, morph._renderTextureFormat);
            						return new RenderTarget({
            								colorBuffer: this[textureVar],
            								depth: false
            						});
            				};
            				if (morph.morphPositions) {
            						this.rtPositions = createRT('MorphRTPos', 'texturePositions');
            				}
            				if (morph.morphNormals) {
            						this.rtNormals = createRT('MorphRTNrm', 'textureNormals');
            				}
            				this._textureParams = new Float32Array([
            						morph.morphTextureWidth,
            						morph.morphTextureHeight
            				]);
            				var halfSize = morph.aabb.halfExtents;
            				this._aabbSize = new Float32Array([
            						halfSize.x * 4,
            						halfSize.y * 4,
            						halfSize.z * 4
            				]);
            				var min = morph.aabb.getMin();
            				this._aabbMin = new Float32Array([
            						min.x * 2,
            						min.y * 2,
            						min.z * 2
            				]);
            				this._aabbNrmSize = new Float32Array([
            						2,
            						2,
            						2
            				]);
            				this._aabbNrmMin = new Float32Array([
            						-1,
            						-1,
            						-1
            				]);
            				this.aabbSizeId = this.device.scope.resolve('aabbSize');
            				this.aabbMinId = this.device.scope.resolve('aabbMin');
            				for(var i = 0; i < this.maxSubmitCount; i++){
            						this["morphBlendTex" + i] = this.device.scope.resolve("morphBlendTex" + i);
            				}
            				this.morphFactor = this.device.scope.resolve('morphFactor[0]');
            				this.zeroTextures = false;
            		}
            }
            
            class Model {
            		getGraph() {
            				return this.graph;
            		}
            		setGraph(graph) {
            				this.graph = graph;
            		}
            		getCameras() {
            				return this.cameras;
            		}
            		setCameras(cameras) {
            				this.cameras = cameras;
            		}
            		getLights() {
            				return this.lights;
            		}
            		setLights(lights) {
            				this.lights = lights;
            		}
            		getMaterials() {
            				var materials = [];
            				for(var i = 0; i < this.meshInstances.length; i++){
            						var meshInstance = this.meshInstances[i];
            						if (materials.indexOf(meshInstance.material) === -1) {
            								materials.push(meshInstance.material);
            						}
            				}
            				return materials;
            		}
            		clone() {
            				var srcNodes = [];
            				var cloneNodes = [];
            				var _duplicate = function _duplicate1(node) {
            						var newNode = node.clone();
            						srcNodes.push(node);
            						cloneNodes.push(newNode);
            						for(var idx = 0; idx < node._children.length; idx++){
            								newNode.addChild(_duplicate(node._children[idx]));
            						}
            						return newNode;
            				};
            				var cloneGraph = _duplicate(this.graph);
            				var cloneMeshInstances = [];
            				var cloneSkinInstances = [];
            				var cloneMorphInstances = [];
            				for(var i = 0; i < this.skinInstances.length; i++){
            						var skin = this.skinInstances[i].skin;
            						var cloneSkinInstance = new SkinInstance(skin);
            						var bones = [];
            						for(var j = 0; j < skin.boneNames.length; j++){
            								var boneName = skin.boneNames[j];
            								var bone = cloneGraph.findByName(boneName);
            								bones.push(bone);
            						}
            						cloneSkinInstance.bones = bones;
            						cloneSkinInstances.push(cloneSkinInstance);
            				}
            				for(var i1 = 0; i1 < this.morphInstances.length; i1++){
            						var morph = this.morphInstances[i1].morph;
            						var cloneMorphInstance = new MorphInstance(morph);
            						cloneMorphInstances.push(cloneMorphInstance);
            				}
            				for(var i2 = 0; i2 < this.meshInstances.length; i2++){
            						var meshInstance = this.meshInstances[i2];
            						var nodeIndex = srcNodes.indexOf(meshInstance.node);
            						var cloneMeshInstance = new MeshInstance(meshInstance.mesh, meshInstance.material, cloneNodes[nodeIndex]);
            						if (meshInstance.skinInstance) {
            								var skinInstanceIndex = this.skinInstances.indexOf(meshInstance.skinInstance);
            								cloneMeshInstance.skinInstance = cloneSkinInstances[skinInstanceIndex];
            						}
            						if (meshInstance.morphInstance) {
            								var morphInstanceIndex = this.morphInstances.indexOf(meshInstance.morphInstance);
            								cloneMeshInstance.morphInstance = cloneMorphInstances[morphInstanceIndex];
            						}
            						cloneMeshInstances.push(cloneMeshInstance);
            				}
            				var clone = new Model();
            				clone.graph = cloneGraph;
            				clone.meshInstances = cloneMeshInstances;
            				clone.skinInstances = cloneSkinInstances;
            				clone.morphInstances = cloneMorphInstances;
            				clone.getGraph().syncHierarchy();
            				return clone;
            		}
            		destroy() {
            				var meshInstances = this.meshInstances;
            				for(var i = 0; i < meshInstances.length; i++){
            						meshInstances[i].destroy();
            				}
            				this.meshInstances.length = 0;
            		}
            		generateWireframe() {
            				MeshInstance._prepareRenderStyleForArray(this.meshInstances, RENDERSTYLE_WIREFRAME);
            		}
            		constructor(){
            				this.graph = null;
            				this.meshInstances = [];
            				this.skinInstances = [];
            				this.morphInstances = [];
            				this.cameras = [];
            				this.lights = [];
            				this._shadersVersion = 0;
            				this._immutable = false;
            		}
            }
            
            class Morph extends RefCountedObject {
            		get aabb() {
            				if (!this._aabb) {
            						var min = new Vec3();
            						var max = new Vec3();
            						for(var i = 0; i < this._targets.length; i++){
            								var targetAabb = this._targets[i].aabb;
            								min.min(targetAabb.getMin());
            								max.max(targetAabb.getMax());
            						}
            						this._aabb = new BoundingBox();
            						this._aabb.setMinMax(min, max);
            				}
            				return this._aabb;
            		}
            		get morphPositions() {
            				return this._morphPositions;
            		}
            		get morphNormals() {
            				return this._morphNormals;
            		}
            		_init() {
            				this._initTextureBased();
            				for(var i = 0; i < this._targets.length; i++){
            						this._targets[i]._postInit();
            				}
            		}
            		_findSparseSet(deltaArrays, ids, usedDataIndices) {
            				var freeIndex = 1;
            				var dataCount = deltaArrays[0].length;
            				for(var v = 0; v < dataCount; v += 3){
            						var vertexUsed = false;
            						for(var i = 0; i < deltaArrays.length; i++){
            								var data = deltaArrays[i];
            								if (data[v] !== 0 || data[v + 1] !== 0 || data[v + 2] !== 0) {
            										vertexUsed = true;
            										break;
            								}
            						}
            						if (vertexUsed) {
            								ids.push(freeIndex);
            								usedDataIndices.push(v / 3);
            								freeIndex++;
            						} else {
            								ids.push(0);
            						}
            				}
            				return freeIndex;
            		}
            		_initTextureBased() {
            				var deltaArrays = [], deltaInfos = [];
            				for(var i = 0; i < this._targets.length; i++){
            						var target = this._targets[i];
            						if (target.options.deltaPositions) {
            								deltaArrays.push(target.options.deltaPositions);
            								deltaInfos.push({
            										target: target,
            										name: 'texturePositions'
            								});
            						}
            						if (target.options.deltaNormals) {
            								deltaArrays.push(target.options.deltaNormals);
            								deltaInfos.push({
            										target: target,
            										name: 'textureNormals'
            								});
            						}
            				}
            				var ids = [], usedDataIndices = [];
            				var freeIndex = this._findSparseSet(deltaArrays, ids, usedDataIndices);
            				var maxTextureSize = this.device.maxTextureSize;
            				var morphTextureWidth = Math.ceil(Math.sqrt(freeIndex));
            				morphTextureWidth = Math.min(morphTextureWidth, maxTextureSize);
            				var morphTextureHeight = Math.ceil(freeIndex / morphTextureWidth);
            				if (morphTextureHeight > maxTextureSize) {
            						return false;
            				}
            				this.morphTextureWidth = morphTextureWidth;
            				this.morphTextureHeight = morphTextureHeight;
            				var halfFloat = false;
            				var float2Half = FloatPacking.float2Half;
            				if (this._textureFormat === PIXELFORMAT_RGBA16F) {
            						halfFloat = true;
            				}
            				var textures = [];
            				for(var i1 = 0; i1 < deltaArrays.length; i1++){
            						textures.push(this._createTexture('MorphTarget', this._textureFormat));
            				}
            				for(var i2 = 0; i2 < deltaArrays.length; i2++){
            						var data = deltaArrays[i2];
            						var texture = textures[i2];
            						var textureData = texture.lock();
            						if (halfFloat) {
            								for(var v = 0; v < usedDataIndices.length; v++){
            										var index = usedDataIndices[v] * 3;
            										var dstIndex = v * 4 + 4;
            										textureData[dstIndex] = float2Half(data[index]);
            										textureData[dstIndex + 1] = float2Half(data[index + 1]);
            										textureData[dstIndex + 2] = float2Half(data[index + 2]);
            								}
            						} else {
            								for(var v1 = 0; v1 < usedDataIndices.length; v1++){
            										var index1 = usedDataIndices[v1] * 3;
            										var dstIndex1 = v1 * 4 + 4;
            										textureData[dstIndex1] = data[index1];
            										textureData[dstIndex1 + 1] = data[index1 + 1];
            										textureData[dstIndex1 + 2] = data[index1 + 2];
            								}
            						}
            						texture.unlock();
            						var target1 = deltaInfos[i2].target;
            						target1._setTexture(deltaInfos[i2].name, texture);
            				}
            				var formatDesc = [
            						{
            								semantic: SEMANTIC_ATTR15,
            								components: 1,
            								type: TYPE_UINT32,
            								asInt: true
            						}
            				];
            				this.vertexBufferIds = new VertexBuffer(this.device, new VertexFormat(this.device, formatDesc, ids.length), ids.length, {
            						data: new Uint32Array(ids)
            				});
            				return true;
            		}
            		destroy() {
            				var _this_vertexBufferIds;
            				(_this_vertexBufferIds = this.vertexBufferIds) == null ? void 0 : _this_vertexBufferIds.destroy();
            				this.vertexBufferIds = null;
            				for(var i = 0; i < this._targets.length; i++){
            						this._targets[i].destroy();
            				}
            				this._targets.length = 0;
            		}
            		get targets() {
            				return this._targets;
            		}
            		_updateMorphFlags() {
            				this._morphPositions = false;
            				this._morphNormals = false;
            				for(var i = 0; i < this._targets.length; i++){
            						var target = this._targets[i];
            						if (target.morphPositions) {
            								this._morphPositions = true;
            						}
            						if (target.morphNormals) {
            								this._morphNormals = true;
            						}
            				}
            		}
            		_createTexture(name, format) {
            				return new Texture(this.device, {
            						width: this.morphTextureWidth,
            						height: this.morphTextureHeight,
            						format: format,
            						cubemap: false,
            						mipmaps: false,
            						minFilter: FILTER_NEAREST,
            						magFilter: FILTER_NEAREST,
            						addressU: ADDRESS_CLAMP_TO_EDGE,
            						addressV: ADDRESS_CLAMP_TO_EDGE,
            						name: name
            				});
            		}
            		constructor(targets, graphicsDevice, { preferHighPrecision = false } = {}){
            				super();
            				this.device = graphicsDevice;
            				var device = graphicsDevice;
            				this.preferHighPrecision = preferHighPrecision;
            				this._targets = targets.slice();
            				var renderableHalf = device.textureHalfFloatRenderable ? PIXELFORMAT_RGBA16F : undefined;
            				var renderableFloat = device.textureFloatRenderable ? PIXELFORMAT_RGBA32F : undefined;
            				this._renderTextureFormat = this.preferHighPrecision ? renderableFloat != null ? renderableFloat : renderableHalf : renderableHalf != null ? renderableHalf : renderableFloat;
            				var _this__renderTextureFormat;
            				this._renderTextureFormat = (_this__renderTextureFormat = this._renderTextureFormat) != null ? _this__renderTextureFormat : PIXELFORMAT_RGBA16U;
            				this.intRenderFormat = isIntegerPixelFormat(this._renderTextureFormat);
            				this._textureFormat = this.preferHighPrecision ? PIXELFORMAT_RGBA32F : PIXELFORMAT_RGBA16F;
            				this._init();
            				this._updateMorphFlags();
            		}
            }
            
            class MorphTarget {
            		destroy() {
            				var _this_texturePositions, _this_textureNormals;
            				(_this_texturePositions = this.texturePositions) == null ? void 0 : _this_texturePositions.destroy();
            				this.texturePositions = null;
            				(_this_textureNormals = this.textureNormals) == null ? void 0 : _this_textureNormals.destroy();
            				this.textureNormals = null;
            		}
            		get name() {
            				return this._name;
            		}
            		get defaultWeight() {
            				return this._defaultWeight;
            		}
            		get aabb() {
            				if (!this._aabb) {
            						this._aabb = new BoundingBox();
            						if (this.deltaPositions) {
            								this._aabb.compute(this.deltaPositions);
            						}
            				}
            				return this._aabb;
            		}
            		get morphPositions() {
            				return !!this.texturePositions;
            		}
            		get morphNormals() {
            				return !!this.textureNormals;
            		}
            		clone() {
            				return new MorphTarget(this.options);
            		}
            		_postInit() {
            				if (!this.options.preserveData) {
            						this.options = null;
            				}
            				this.used = true;
            		}
            		_setTexture(name, texture) {
            				this[name] = texture;
            		}
            		constructor(options){
            				this.used = false;
            				this.options = options;
            				this._name = options.name;
            				this._defaultWeight = options.defaultWeight || 0;
            				this._aabb = options.aabb;
            				this.deltaPositions = options.deltaPositions;
            		}
            }
            
            var nonUniformScale;
            var uniformScale = 1;
            var particleTexChannels$1 = 4;
            var rotMat = new Mat4();
            var rotMatInv = new Mat4();
            var randomPosTformed = new Vec3();
            var randomPos = new Vec3();
            var rndFactor3Vec = new Vec3();
            var particlePosPrev = new Vec3();
            var velocityVec = new Vec3();
            var localVelocityVec = new Vec3();
            var velocityVec2 = new Vec3();
            var localVelocityVec2 = new Vec3();
            var radialVelocityVec = new Vec3();
            var particlePos = new Vec3();
            var particleFinalPos = new Vec3();
            var moveDirVec = new Vec3();
            var tmpVec3$1 = new Vec3();
            function frac(f) {
            		return f - Math.floor(f);
            }
            function saturate$1(x) {
            		return Math.max(Math.min(x, 1), 0);
            }
            function glMod(x, y) {
            		return x - y * Math.floor(x / y);
            }
            function encodeFloatRGBA(v) {
            		var encX = frac(v);
            		var encY = frac(255.0 * v);
            		var encZ = frac(65025.0 * v);
            		var encW = frac(160581375.0 * v);
            		encX -= encY / 255.0;
            		encY -= encZ / 255.0;
            		encZ -= encW / 255.0;
            		encW -= encW / 255.0;
            		return [
            				encX,
            				encY,
            				encZ,
            				encW
            		];
            }
            function encodeFloatRG(v) {
            		var encX = frac(v);
            		var encY = frac(255.0 * v);
            		encX -= encY / 255.0;
            		encY -= encY / 255.0;
            		return [
            				encX,
            				encY
            		];
            }
            class ParticleCPUUpdater {
            		calcSpawnPosition(particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i) {
            				var emitter = this._emitter;
            				var rX = Math.random();
            				var rY = Math.random();
            				var rZ = Math.random();
            				var rW = Math.random();
            				if (emitter.useCpu) {
            						particleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rX;
            						particleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rY;
            						particleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * 2 * particleTexChannels$1] = rZ;
            				}
            				randomPos.x = rX - 0.5;
            				randomPos.y = rY - 0.5;
            				randomPos.z = rZ - 0.5;
            				if (emitter.emitterShape === EMITTERSHAPE_BOX) {
            						var max = Math.max(Math.abs(randomPos.x), Math.max(Math.abs(randomPos.y), Math.abs(randomPos.z)));
            						var edgeX = max + (0.5 - max) * extentsInnerRatioUniform[0];
            						var edgeY = max + (0.5 - max) * extentsInnerRatioUniform[1];
            						var edgeZ = max + (0.5 - max) * extentsInnerRatioUniform[2];
            						randomPos.x = edgeX * (max === Math.abs(randomPos.x) ? Math.sign(randomPos.x) : 2 * randomPos.x);
            						randomPos.y = edgeY * (max === Math.abs(randomPos.y) ? Math.sign(randomPos.y) : 2 * randomPos.y);
            						randomPos.z = edgeZ * (max === Math.abs(randomPos.z) ? Math.sign(randomPos.z) : 2 * randomPos.z);
            						if (!emitter.localSpace) {
            								randomPosTformed.copy(emitterPos).add(spawnMatrix.transformPoint(randomPos));
            						} else {
            								randomPosTformed.copy(spawnMatrix.transformPoint(randomPos));
            						}
            				} else {
            						randomPos.normalize();
            						var spawnBoundsSphereInnerRatio = emitter.emitterRadius === 0 ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius;
            						var r = rW * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;
            						if (!emitter.localSpace) {
            								randomPosTformed.copy(emitterPos).add(randomPos.mulScalar(r * emitter.emitterRadius));
            						} else {
            								randomPosTformed.copy(randomPos.mulScalar(r * emitter.emitterRadius));
            						}
            				}
            				var particleRate = math.lerp(emitter.rate, emitter.rate2, rX);
            				var startSpawnTime = -particleRate * i;
            				if (emitter.pack8) {
            						var packX = (randomPosTformed.x - emitter.worldBounds.center.x) / emitter.worldBoundsSize.x + 0.5;
            						var packY = (randomPosTformed.y - emitter.worldBounds.center.y) / emitter.worldBoundsSize.y + 0.5;
            						var packZ = (randomPosTformed.z - emitter.worldBounds.center.z) / emitter.worldBoundsSize.z + 0.5;
            						var packA = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);
            						packA = packA % (Math.PI * 2) / (Math.PI * 2);
            						var rg0 = encodeFloatRG(packX);
            						particleTex[i * particleTexChannels$1] = rg0[0];
            						particleTex[i * particleTexChannels$1 + 1] = rg0[1];
            						var ba0 = encodeFloatRG(packY);
            						particleTex[i * particleTexChannels$1 + 2] = ba0[0];
            						particleTex[i * particleTexChannels$1 + 3] = ba0[1];
            						var rg1 = encodeFloatRG(packZ);
            						particleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * particleTexChannels$1] = rg1[0];
            						particleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * particleTexChannels$1] = rg1[1];
            						var ba1 = encodeFloatRG(packA);
            						particleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * particleTexChannels$1] = ba1[0];
            						particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = ba1[1];
            						var a2 = 1.0;
            						particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1 * 2] = a2;
            						var maxNegLife = Math.max(emitter.lifetime, (emitter.numParticles - 1.0) * Math.max(emitter.rate, emitter.rate2));
            						var maxPosLife = emitter.lifetime + 1.0;
            						startSpawnTime = (startSpawnTime + maxNegLife) / (maxNegLife + maxPosLife);
            						var rgba3 = encodeFloatRGBA(startSpawnTime);
            						particleTex[i * particleTexChannels$1 + 0 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[0];
            						particleTex[i * particleTexChannels$1 + 1 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[1];
            						particleTex[i * particleTexChannels$1 + 2 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[2];
            						particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1 * 3] = rgba3[3];
            				} else {
            						particleTex[i * particleTexChannels$1] = randomPosTformed.x;
            						particleTex[i * particleTexChannels$1 + 1] = randomPosTformed.y;
            						particleTex[i * particleTexChannels$1 + 2] = randomPosTformed.z;
            						particleTex[i * particleTexChannels$1 + 3] = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);
            						particleTex[i * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = startSpawnTime;
            				}
            		}
            		update(data, vbToSort, particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop) {
            				var a, b, c;
            				var emitter = this._emitter;
            				if (emitter.meshInstance.node) {
            						var fullMat = emitter.meshInstance.node.worldTransform;
            						for(var j = 0; j < 12; j++){
            								rotMat.data[j] = fullMat.data[j];
            						}
            						rotMatInv.copy(rotMat);
            						rotMatInv.invert();
            						nonUniformScale = emitter.meshInstance.node.localScale;
            						uniformScale = Math.max(Math.max(nonUniformScale.x, nonUniformScale.y), nonUniformScale.z);
            				}
            				emitterPos = emitter.meshInstance.node === null || emitter.localSpace ? Vec3.ZERO : emitter.meshInstance.node.getPosition();
            				var posCam = emitter.camera ? emitter.camera._node.getPosition() : Vec3.ZERO;
            				var vertSize = !emitter.useMesh ? 15 : 17;
            				var cf, cc;
            				var rotSpeed, rotSpeed2, scale2, alpha, alpha2, radialSpeed, radialSpeed2;
            				var precision1 = emitter.precision - 1;
            				for(var i = 0; i < emitter.numParticles; i++){
            						var id = Math.floor(emitter.vbCPU[i * emitter.numParticleVerts * (emitter.useMesh ? 6 : 4) + 3]);
            						var rndFactor = particleTex[id * particleTexChannels$1 + 0 + emitter.numParticlesPot * 2 * particleTexChannels$1];
            						rndFactor3Vec.x = rndFactor;
            						rndFactor3Vec.y = particleTex[id * particleTexChannels$1 + 1 + emitter.numParticlesPot * 2 * particleTexChannels$1];
            						rndFactor3Vec.z = particleTex[id * particleTexChannels$1 + 2 + emitter.numParticlesPot * 2 * particleTexChannels$1];
            						var particleRate = emitter.rate + (emitter.rate2 - emitter.rate) * rndFactor;
            						var particleLifetime = emitter.lifetime;
            						var life = particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] + delta;
            						var nlife = saturate$1(life / particleLifetime);
            						var scale = 0;
            						var alphaDiv = 0;
            						var angle = 0;
            						var respawn = life - delta <= 0.0 || life >= particleLifetime;
            						if (respawn) {
            								this.calcSpawnPosition(particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, id);
            						}
            						var particleEnabled = life > 0.0 && life < particleLifetime;
            						if (particleEnabled) {
            								c = nlife * precision1;
            								cf = Math.floor(c);
            								cc = Math.ceil(c);
            								c %= 1;
            								a = emitter.qRotSpeed[cf];
            								b = emitter.qRotSpeed[cc];
            								rotSpeed = a + (b - a) * c;
            								a = emitter.qRotSpeed2[cf];
            								b = emitter.qRotSpeed2[cc];
            								rotSpeed2 = a + (b - a) * c;
            								a = emitter.qScale[cf];
            								b = emitter.qScale[cc];
            								scale = a + (b - a) * c;
            								a = emitter.qScale2[cf];
            								b = emitter.qScale2[cc];
            								scale2 = a + (b - a) * c;
            								a = emitter.qAlpha[cf];
            								b = emitter.qAlpha[cc];
            								alpha = a + (b - a) * c;
            								a = emitter.qAlpha2[cf];
            								b = emitter.qAlpha2[cc];
            								alpha2 = a + (b - a) * c;
            								a = emitter.qRadialSpeed[cf];
            								b = emitter.qRadialSpeed[cc];
            								radialSpeed = a + (b - a) * c;
            								a = emitter.qRadialSpeed2[cf];
            								b = emitter.qRadialSpeed2[cc];
            								radialSpeed2 = a + (b - a) * c;
            								radialSpeed += (radialSpeed2 - radialSpeed) * (rndFactor * 100.0 % 1.0);
            								particlePosPrev.x = particleTex[id * particleTexChannels$1];
            								particlePosPrev.y = particleTex[id * particleTexChannels$1 + 1];
            								particlePosPrev.z = particleTex[id * particleTexChannels$1 + 2];
            								if (!emitter.localSpace) {
            										radialVelocityVec.copy(particlePosPrev).sub(emitterPos);
            								} else {
            										radialVelocityVec.copy(particlePosPrev);
            								}
            								radialVelocityVec.normalize().mulScalar(radialSpeed);
            								cf *= 3;
            								cc *= 3;
            								a = emitter.qLocalVelocity[cf];
            								b = emitter.qLocalVelocity[cc];
            								localVelocityVec.x = a + (b - a) * c;
            								a = emitter.qLocalVelocity[cf + 1];
            								b = emitter.qLocalVelocity[cc + 1];
            								localVelocityVec.y = a + (b - a) * c;
            								a = emitter.qLocalVelocity[cf + 2];
            								b = emitter.qLocalVelocity[cc + 2];
            								localVelocityVec.z = a + (b - a) * c;
            								a = emitter.qLocalVelocity2[cf];
            								b = emitter.qLocalVelocity2[cc];
            								localVelocityVec2.x = a + (b - a) * c;
            								a = emitter.qLocalVelocity2[cf + 1];
            								b = emitter.qLocalVelocity2[cc + 1];
            								localVelocityVec2.y = a + (b - a) * c;
            								a = emitter.qLocalVelocity2[cf + 2];
            								b = emitter.qLocalVelocity2[cc + 2];
            								localVelocityVec2.z = a + (b - a) * c;
            								a = emitter.qVelocity[cf];
            								b = emitter.qVelocity[cc];
            								velocityVec.x = a + (b - a) * c;
            								a = emitter.qVelocity[cf + 1];
            								b = emitter.qVelocity[cc + 1];
            								velocityVec.y = a + (b - a) * c;
            								a = emitter.qVelocity[cf + 2];
            								b = emitter.qVelocity[cc + 2];
            								velocityVec.z = a + (b - a) * c;
            								a = emitter.qVelocity2[cf];
            								b = emitter.qVelocity2[cc];
            								velocityVec2.x = a + (b - a) * c;
            								a = emitter.qVelocity2[cf + 1];
            								b = emitter.qVelocity2[cc + 1];
            								velocityVec2.y = a + (b - a) * c;
            								a = emitter.qVelocity2[cf + 2];
            								b = emitter.qVelocity2[cc + 2];
            								velocityVec2.z = a + (b - a) * c;
            								localVelocityVec.x += (localVelocityVec2.x - localVelocityVec.x) * rndFactor3Vec.x;
            								localVelocityVec.y += (localVelocityVec2.y - localVelocityVec.y) * rndFactor3Vec.y;
            								localVelocityVec.z += (localVelocityVec2.z - localVelocityVec.z) * rndFactor3Vec.z;
            								if (emitter.initialVelocity > 0) {
            										if (emitter.emitterShape === EMITTERSHAPE_SPHERE) {
            												randomPos.copy(rndFactor3Vec).mulScalar(2).sub(Vec3.ONE).normalize();
            												localVelocityVec.add(randomPos.mulScalar(emitter.initialVelocity));
            										} else {
            												localVelocityVec.add(Vec3.FORWARD.mulScalar(emitter.initialVelocity));
            										}
            								}
            								velocityVec.x += (velocityVec2.x - velocityVec.x) * rndFactor3Vec.x;
            								velocityVec.y += (velocityVec2.y - velocityVec.y) * rndFactor3Vec.y;
            								velocityVec.z += (velocityVec2.z - velocityVec.z) * rndFactor3Vec.z;
            								rotSpeed += (rotSpeed2 - rotSpeed) * rndFactor3Vec.y;
            								scale = (scale + (scale2 - scale) * (rndFactor * 10000.0 % 1.0)) * uniformScale;
            								alphaDiv = (alpha2 - alpha) * (rndFactor * 1000.0 % 1.0);
            								if (emitter.meshInstance.node) {
            										if (!emitter.localSpace) {
            												rotMat.transformPoint(localVelocityVec, localVelocityVec);
            										} else {
            												localVelocityVec.x /= nonUniformScale.x;
            												localVelocityVec.y /= nonUniformScale.y;
            												localVelocityVec.z /= nonUniformScale.z;
            										}
            								}
            								if (!emitter.localSpace) {
            										localVelocityVec.add(velocityVec.mul(nonUniformScale));
            										localVelocityVec.add(radialVelocityVec.mul(nonUniformScale));
            								} else {
            										rotMatInv.transformPoint(velocityVec, velocityVec);
            										localVelocityVec.add(velocityVec).add(radialVelocityVec);
            								}
            								moveDirVec.copy(localVelocityVec);
            								particlePos.copy(particlePosPrev).add(localVelocityVec.mulScalar(delta));
            								particleFinalPos.copy(particlePos);
            								particleTex[id * particleTexChannels$1] = particleFinalPos.x;
            								particleTex[id * particleTexChannels$1 + 1] = particleFinalPos.y;
            								particleTex[id * particleTexChannels$1 + 2] = particleFinalPos.z;
            								particleTex[id * particleTexChannels$1 + 3] += rotSpeed * delta;
            								if (emitter.wrap && emitter.wrapBounds) {
            										if (!emitter.localSpace) {
            												particleFinalPos.sub(emitterPos);
            										}
            										particleFinalPos.x = glMod(particleFinalPos.x, emitter.wrapBounds.x) - emitter.wrapBounds.x * 0.5;
            										particleFinalPos.y = glMod(particleFinalPos.y, emitter.wrapBounds.y) - emitter.wrapBounds.y * 0.5;
            										particleFinalPos.z = glMod(particleFinalPos.z, emitter.wrapBounds.z) - emitter.wrapBounds.z * 0.5;
            										if (!emitter.localSpace) {
            												particleFinalPos.add(emitterPos);
            										}
            								}
            								if (emitter.sort > 0) {
            										if (emitter.sort === 1) {
            												tmpVec3$1.copy(particleFinalPos).sub(posCam);
            												emitter.particleDistance[id] = -(tmpVec3$1.x * tmpVec3$1.x + tmpVec3$1.y * tmpVec3$1.y + tmpVec3$1.z * tmpVec3$1.z);
            										} else if (emitter.sort === 2) {
            												emitter.particleDistance[id] = life;
            										} else if (emitter.sort === 3) {
            												emitter.particleDistance[id] = -life;
            										}
            								}
            						}
            						if (isOnStop) {
            								if (life < 0) {
            										particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = -1;
            								}
            						} else {
            								if (life >= particleLifetime) {
            										life -= Math.max(particleLifetime, (emitter.numParticles - 1) * particleRate);
            										particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = emitter.loop ? 1 : -1;
            								}
            								if (life < 0 && emitter.loop) {
            										particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] = 1;
            								}
            						}
            						if (particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * 2 * particleTexChannels$1] < 0) {
            								particleEnabled = false;
            						}
            						particleTex[id * particleTexChannels$1 + 3 + emitter.numParticlesPot * particleTexChannels$1] = life;
            						for(var v = 0; v < emitter.numParticleVerts; v++){
            								var vbOffset = (i * emitter.numParticleVerts + v) * (emitter.useMesh ? 6 : 4);
            								var quadX = emitter.vbCPU[vbOffset];
            								var quadY = emitter.vbCPU[vbOffset + 1];
            								var quadZ = emitter.vbCPU[vbOffset + 2];
            								if (!particleEnabled) {
            										quadX = quadY = quadZ = 0;
            								}
            								var w = i * emitter.numParticleVerts * vertSize + v * vertSize;
            								data[w] = particleFinalPos.x;
            								data[w + 1] = particleFinalPos.y;
            								data[w + 2] = particleFinalPos.z;
            								data[w + 3] = nlife;
            								data[w + 4] = emitter.alignToMotion ? angle : particleTex[id * particleTexChannels$1 + 3];
            								data[w + 5] = scale;
            								data[w + 6] = alphaDiv;
            								data[w + 7] = moveDirVec.x;
            								data[w + 8] = quadX;
            								data[w + 9] = quadY;
            								data[w + 10] = quadZ;
            								data[w + 11] = moveDirVec.y;
            								data[w + 12] = id;
            								data[w + 13] = moveDirVec.z;
            								data[w + 14] = emitter.vbCPU[vbOffset + 3];
            								if (emitter.useMesh) {
            										data[w + 15] = emitter.vbCPU[vbOffset + 4];
            										data[w + 16] = emitter.vbCPU[vbOffset + 5];
            								}
            						}
            				}
            				if (emitter.sort > PARTICLESORT_NONE && emitter.camera) {
            						var vbStride = emitter.useMesh ? 6 : 4;
            						var particleDistance = emitter.particleDistance;
            						for(var i1 = 0; i1 < emitter.numParticles; i1++){
            								vbToSort[i1][0] = i1;
            								vbToSort[i1][1] = particleDistance[Math.floor(emitter.vbCPU[i1 * emitter.numParticleVerts * vbStride + 3])];
            						}
            						emitter.vbOld.set(emitter.vbCPU);
            						vbToSort.sort((p1, p2)=>{
            								return p1[1] - p2[1];
            						});
            						for(var i2 = 0; i2 < emitter.numParticles; i2++){
            								var src = vbToSort[i2][0] * emitter.numParticleVerts * vbStride;
            								var dest = i2 * emitter.numParticleVerts * vbStride;
            								for(var j1 = 0; j1 < emitter.numParticleVerts * vbStride; j1++){
            										emitter.vbCPU[dest + j1] = emitter.vbOld[src + j1];
            								}
            						}
            				}
            		}
            		constructor(emitter){
            				this._emitter = emitter;
            		}
            }
            
            var spawnMatrix3 = new Mat3();
            var emitterMatrix3 = new Mat3();
            var emitterMatrix3Inv = new Mat3();
            class ParticleGPUUpdater {
            		_setInputBounds() {
            				this.inBoundsSizeUniform[0] = this._emitter.prevWorldBoundsSize.x;
            				this.inBoundsSizeUniform[1] = this._emitter.prevWorldBoundsSize.y;
            				this.inBoundsSizeUniform[2] = this._emitter.prevWorldBoundsSize.z;
            				this.constantInBoundsSize.setValue(this.inBoundsSizeUniform);
            				this.inBoundsCenterUniform[0] = this._emitter.prevWorldBoundsCenter.x;
            				this.inBoundsCenterUniform[1] = this._emitter.prevWorldBoundsCenter.y;
            				this.inBoundsCenterUniform[2] = this._emitter.prevWorldBoundsCenter.z;
            				this.constantInBoundsCenter.setValue(this.inBoundsCenterUniform);
            		}
            		randomize() {
            				this.frameRandomUniform[0] = Math.random();
            				this.frameRandomUniform[1] = Math.random();
            				this.frameRandomUniform[2] = Math.random();
            		}
            		update(device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop) {
            				var emitter = this._emitter;
            				device.setBlendState(BlendState.NOBLEND);
            				device.setDepthState(DepthState.NODEPTH);
            				device.setCullMode(CULLFACE_NONE);
            				this.randomize();
            				this.constantGraphSampleSize.setValue(1.0 / emitter.precision);
            				this.constantGraphNumSamples.setValue(emitter.precision);
            				this.constantNumParticles.setValue(emitter.numParticles);
            				this.constantNumParticlesPot.setValue(emitter.numParticlesPot);
            				this.constantInternalTex0.setValue(emitter.internalTex0);
            				this.constantInternalTex1.setValue(emitter.internalTex1);
            				this.constantInternalTex2.setValue(emitter.internalTex2);
            				this.constantInternalTex3.setValue(emitter.internalTex3);
            				var node = emitter.meshInstance.node;
            				var emitterScale = node === null ? Vec3.ONE : node.localScale;
            				if (emitter.pack8) {
            						this.worldBoundsMulUniform[0] = emitter.worldBoundsMul.x;
            						this.worldBoundsMulUniform[1] = emitter.worldBoundsMul.y;
            						this.worldBoundsMulUniform[2] = emitter.worldBoundsMul.z;
            						this.constantOutBoundsMul.setValue(this.worldBoundsMulUniform);
            						this.worldBoundsAddUniform[0] = emitter.worldBoundsAdd.x;
            						this.worldBoundsAddUniform[1] = emitter.worldBoundsAdd.y;
            						this.worldBoundsAddUniform[2] = emitter.worldBoundsAdd.z;
            						this.constantOutBoundsAdd.setValue(this.worldBoundsAddUniform);
            						this._setInputBounds();
            						var maxVel = emitter.maxVel * Math.max(Math.max(emitterScale.x, emitterScale.y), emitterScale.z);
            						maxVel = Math.max(maxVel, 1);
            						this.constantMaxVel.setValue(maxVel);
            				}
            				var emitterPos = node === null || emitter.localSpace ? Vec3.ZERO : node.getPosition();
            				var emitterMatrix = node === null ? Mat4.IDENTITY : node.getWorldTransform();
            				if (emitter.emitterShape === EMITTERSHAPE_BOX) {
            						spawnMatrix3.setFromMat4(spawnMatrix);
            						this.constantSpawnBounds.setValue(spawnMatrix3.data);
            						this.constantSpawnPosInnerRatio.setValue(extentsInnerRatioUniform);
            				} else {
            						this.constantSpawnBoundsSphere.setValue(emitter.emitterRadius);
            						this.constantSpawnBoundsSphereInnerRatio.setValue(emitter.emitterRadius === 0 ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius);
            				}
            				this.constantInitialVelocity.setValue(emitter.initialVelocity);
            				emitterMatrix3.setFromMat4(emitterMatrix);
            				emitterMatrix3Inv.invertMat4(emitterMatrix);
            				this.emitterPosUniform[0] = emitterPos.x;
            				this.emitterPosUniform[1] = emitterPos.y;
            				this.emitterPosUniform[2] = emitterPos.z;
            				this.constantEmitterPos.setValue(this.emitterPosUniform);
            				this.constantFrameRandom.setValue(this.frameRandomUniform);
            				this.constantDelta.setValue(delta);
            				this.constantRate.setValue(emitter.rate);
            				this.constantRateDiv.setValue(emitter.rate2 - emitter.rate);
            				this.constantStartAngle.setValue(emitter.startAngle * math.DEG_TO_RAD);
            				this.constantStartAngle2.setValue(emitter.startAngle2 * math.DEG_TO_RAD);
            				this.constantSeed.setValue(emitter.seed);
            				this.constantLifetime.setValue(emitter.lifetime);
            				this.emitterScaleUniform[0] = emitterScale.x;
            				this.emitterScaleUniform[1] = emitterScale.y;
            				this.emitterScaleUniform[2] = emitterScale.z;
            				this.constantEmitterScale.setValue(this.emitterScaleUniform);
            				this.constantEmitterMatrix.setValue(emitterMatrix3.data);
            				this.constantEmitterMatrixInv.setValue(emitterMatrix3Inv.data);
            				this.constantLocalVelocityDivMult.setValue(emitter.localVelocityUMax);
            				this.constantVelocityDivMult.setValue(emitter.velocityUMax);
            				this.constantRotSpeedDivMult.setValue(emitter.rotSpeedUMax[0]);
            				var texIN = emitter.swapTex ? emitter.particleTexOUT : emitter.particleTexIN;
            				texIN = emitter.beenReset ? emitter.particleTexStart : texIN;
            				var texOUT = emitter.swapTex ? emitter.particleTexIN : emitter.particleTexOUT;
            				this.constantParticleTexIN.setValue(texIN);
            				drawQuadWithShader(device, emitter.swapTex ? emitter.rtParticleTexIN : emitter.rtParticleTexOUT, !isOnStop ? emitter.loop ? emitter.shaderParticleUpdateRespawn : emitter.shaderParticleUpdateNoRespawn : emitter.shaderParticleUpdateOnStop);
            				emitter.material.setParameter('particleTexOUT', texIN);
            				emitter.material.setParameter('particleTexIN', texOUT);
            				emitter.beenReset = false;
            				emitter.swapTex = !emitter.swapTex;
            				emitter.prevWorldBoundsSize.copy(emitter.worldBoundsSize);
            				emitter.prevWorldBoundsCenter.copy(emitter.worldBounds.center);
            				if (emitter.pack8) {
            						this._setInputBounds();
            				}
            		}
            		constructor(emitter, gd){
            				this._emitter = emitter;
            				this.frameRandomUniform = new Float32Array(3);
            				this.emitterPosUniform = new Float32Array(3);
            				this.emitterScaleUniform = new Float32Array([
            						1,
            						1,
            						1
            				]);
            				this.worldBoundsMulUniform = new Float32Array(3);
            				this.worldBoundsAddUniform = new Float32Array(3);
            				this.inBoundsSizeUniform = new Float32Array(3);
            				this.inBoundsCenterUniform = new Float32Array(3);
            				this.constantParticleTexIN = gd.scope.resolve('particleTexIN');
            				this.constantParticleTexOUT = gd.scope.resolve('particleTexOUT');
            				this.constantEmitterPos = gd.scope.resolve('emitterPos');
            				this.constantEmitterScale = gd.scope.resolve('emitterScale');
            				this.constantSpawnBounds = gd.scope.resolve('spawnBounds');
            				this.constantSpawnPosInnerRatio = gd.scope.resolve('spawnPosInnerRatio');
            				this.constantSpawnBoundsSphere = gd.scope.resolve('spawnBoundsSphere');
            				this.constantSpawnBoundsSphereInnerRatio = gd.scope.resolve('spawnBoundsSphereInnerRatio');
            				this.constantInitialVelocity = gd.scope.resolve('initialVelocity');
            				this.constantFrameRandom = gd.scope.resolve('frameRandom');
            				this.constantDelta = gd.scope.resolve('delta');
            				this.constantRate = gd.scope.resolve('rate');
            				this.constantRateDiv = gd.scope.resolve('rateDiv');
            				this.constantLifetime = gd.scope.resolve('lifetime');
            				this.constantGraphSampleSize = gd.scope.resolve('graphSampleSize');
            				this.constantGraphNumSamples = gd.scope.resolve('graphNumSamples');
            				this.constantInternalTex0 = gd.scope.resolve('internalTex0');
            				this.constantInternalTex1 = gd.scope.resolve('internalTex1');
            				this.constantInternalTex2 = gd.scope.resolve('internalTex2');
            				this.constantInternalTex3 = gd.scope.resolve('internalTex3');
            				this.constantEmitterMatrix = gd.scope.resolve('emitterMatrix');
            				this.constantEmitterMatrixInv = gd.scope.resolve('emitterMatrixInv');
            				this.constantNumParticles = gd.scope.resolve('numParticles');
            				this.constantNumParticlesPot = gd.scope.resolve('numParticlesPot');
            				this.constantLocalVelocityDivMult = gd.scope.resolve('localVelocityDivMult');
            				this.constantVelocityDivMult = gd.scope.resolve('velocityDivMult');
            				this.constantRotSpeedDivMult = gd.scope.resolve('rotSpeedDivMult');
            				this.constantSeed = gd.scope.resolve('seed');
            				this.constantStartAngle = gd.scope.resolve('startAngle');
            				this.constantStartAngle2 = gd.scope.resolve('startAngle2');
            				this.constantOutBoundsMul = gd.scope.resolve('outBoundsMul');
            				this.constantOutBoundsAdd = gd.scope.resolve('outBoundsAdd');
            				this.constantInBoundsSize = gd.scope.resolve('inBoundsSize');
            				this.constantInBoundsCenter = gd.scope.resolve('inBoundsCenter');
            				this.constantMaxVel = gd.scope.resolve('maxVel');
            				this.constantFaceTangent = gd.scope.resolve('faceTangent');
            				this.constantFaceBinorm = gd.scope.resolve('faceBinorm');
            		}
            }
            
            function _extends$f() {
            		_extends$f = Object.assign || function(target) {
            				for(var i = 1; i < arguments.length; i++){
            						var source = arguments[i];
            						for(var key in source){
            								if (Object.prototype.hasOwnProperty.call(source, key)) {
            										target[key] = source[key];
            								}
            						}
            				}
            				return target;
            		};
            		return _extends$f.apply(this, arguments);
            }
            var normalTypeNames = [
            		'NONE',
            		'VERTEX',
            		'MAP'
            ];
            class ShaderGeneratorParticle extends ShaderGenerator {
            		generateKey(options) {
            				var definesHash = ShaderGenerator.definesHash(options.defines);
            				var key = "particle_" + definesHash + "_";
            				for(var prop in options){
            						if (options.hasOwnProperty(prop)) {
            								key += options[prop];
            						}
            				}
            				return key;
            		}
            		createVertexDefines(options) {
            				var vDefines = new Map(options.defines);
            				if (options.mesh) vDefines.set('USE_MESH', '');
            				if (options.localSpace) vDefines.set('LOCAL_SPACE', '');
            				if (options.screenSpace) vDefines.set('SCREEN_SPACE', '');
            				if (options.animTex) vDefines.set('ANIMTEX', '');
            				if (options.soft > 0) vDefines.set('SOFT', '');
            				if (options.stretch > 0.0) vDefines.set('STRETCH', '');
            				if (options.customFace) vDefines.set('CUSTOM_FACE', '');
            				if (options.pack8) vDefines.set('PACK8', '');
            				if (options.localSpace) vDefines.set('LOCAL_SPACE', '');
            				if (options.animTexLoop) vDefines.set('ANIMTEX_LOOP', '');
            				if (options.wrap) vDefines.set('WRAP', '');
            				if (options.alignToMotion) vDefines.set('ALIGN_TO_MOTION', '');
            				vDefines.set('NORMAL', normalTypeNames[options.normal]);
            				return vDefines;
            		}
            		createFragmentDefines(options) {
            				var fDefines = new Map(options.defines);
            				if (options.soft > 0) fDefines.set('SOFT', '');
            				if (options.halflambert) fDefines.set('HALF_LAMBERT', '');
            				fDefines.set('NORMAL', normalTypeNames[options.normal]);
            				fDefines.set('BLEND', blendNames[options.blend]);
            				return fDefines;
            		}
            		createShaderDefinition(device, options) {
            				var vDefines = this.createVertexDefines(options);
            				var fDefines = this.createFragmentDefines(options);
            				var executionDefine = "PARTICLE_" + (options.useCpu ? 'CPU' : 'GPU') + "\n";
            				vDefines.set(executionDefine, '');
            				fDefines.set(executionDefine, '');
            				var includes = new Map(Object.entries(_extends$f({}, shaderChunks, options.chunks)));
            				return ShaderUtils.createDefinition(device, {
            						name: 'ParticleShader',
            						vertexCode: shaderChunks.particle_shaderVS,
            						fragmentCode: shaderChunks.particle_shaderPS,
            						fragmentDefines: fDefines,
            						fragmentIncludes: includes,
            						vertexIncludes: includes,
            						vertexDefines: vDefines
            				});
            		}
            }
            var particle = new ShaderGeneratorParticle();
            
            class ParticleMaterial extends Material {
            		getShaderVariant(params) {
            				var { device, scene, cameraShaderParams } = params;
            				var { emitter } = this;
            				var _cameraShaderParams_shaderOutputGamma, _cameraShaderParams_toneMapping;
            				var options = {
            						defines: getCoreDefines(this, params),
            						pass: SHADER_FORWARD,
            						useCpu: this.emitter.useCpu,
            						normal: emitter.lighting ? emitter.normalMap !== null ? 2 : 1 : 0,
            						halflambert: this.emitter.halfLambert,
            						stretch: this.emitter.stretch,
            						alignToMotion: this.emitter.alignToMotion,
            						soft: this.emitter.depthSoftening,
            						mesh: this.emitter.useMesh,
            						gamma: (_cameraShaderParams_shaderOutputGamma = cameraShaderParams == null ? void 0 : cameraShaderParams.shaderOutputGamma) != null ? _cameraShaderParams_shaderOutputGamma : GAMMA_NONE,
            						toneMap: (_cameraShaderParams_toneMapping = cameraShaderParams == null ? void 0 : cameraShaderParams.toneMapping) != null ? _cameraShaderParams_toneMapping : TONEMAP_LINEAR,
            						fog: scene && !this.emitter.noFog ? scene.fog.type : 'none',
            						wrap: this.emitter.wrap && this.emitter.wrapBounds,
            						localSpace: this.emitter.localSpace,
            						screenSpace: emitter.inTools ? false : this.emitter.screenSpace,
            						blend: this.emitter.blendType,
            						animTex: this.emitter._isAnimated(),
            						animTexLoop: this.emitter.animLoop,
            						pack8: this.emitter.pack8,
            						customFace: this.emitter.orientation !== PARTICLEORIENTATION_SCREEN
            				};
            				var processingOptions = new ShaderProcessorOptions(params.viewUniformFormat, params.viewBindGroupFormat, params.vertexFormat);
            				var library = getProgramLibrary(device);
            				library.register('particle', particle);
            				return library.getProgram('particle', options, processingOptions, this.userId);
            		}
            		constructor(emitter){
            				super(), this.emitter = null;
            				this.emitter = emitter;
            		}
            }
            
            var particleVerts = [
            		[
            				-1,
            				-1
            		],
            		[
            				1,
            				-1
            		],
            		[
            				1,
            				1
            		],
            		[
            				-1,
            				1
            		]
            ];
            function _createTexture(device, width, height, pixelData, format, mult8Bit, filter) {
            		if (format === void 0) format = PIXELFORMAT_RGBA32F;
            		var mipFilter = FILTER_NEAREST;
            		if (filter && (format === PIXELFORMAT_RGBA8 || format === PIXELFORMAT_SRGBA8)) {
            				mipFilter = FILTER_LINEAR;
            		}
            		var texture = new Texture(device, {
            				width: width,
            				height: height,
            				format: format,
            				cubemap: false,
            				mipmaps: false,
            				minFilter: mipFilter,
            				magFilter: mipFilter,
            				addressU: ADDRESS_CLAMP_TO_EDGE,
            				addressV: ADDRESS_CLAMP_TO_EDGE,
            				name: 'ParticleSystemTexture'
            		});
            		var pixels = texture.lock();
            		if (format === PIXELFORMAT_RGBA8 || format === PIXELFORMAT_SRGBA8) {
            				var temp = new Uint8Array(pixelData.length);
            				for(var i = 0; i < pixelData.length; i++){
            						temp[i] = pixelData[i] * mult8Bit * 255;
            				}
            				pixelData = temp;
            		}
            		pixels.set(pixelData);
            		texture.unlock();
            		return texture;
            }
            function saturate(x) {
            		return Math.max(Math.min(x, 1), 0);
            }
            var default0Curve = new Curve([
            		0,
            		0,
            		1,
            		0
            ]);
            var default1Curve = new Curve([
            		0,
            		1,
            		1,
            		1
            ]);
            var default0Curve3 = new CurveSet([
            		0,
            		0,
            		1,
            		0
            ], [
            		0,
            		0,
            		1,
            		0
            ], [
            		0,
            		0,
            		1,
            		0
            ]);
            var default1Curve3 = new CurveSet([
            		0,
            		1,
            		1,
            		1
            ], [
            		0,
            		1,
            		1,
            		1
            ], [
            		0,
            		1,
            		1,
            		1
            ]);
            var particleTexHeight = 2;
            var particleTexChannels = 4;
            var extentsInnerRatioUniform = new Float32Array(3);
            var spawnMatrix = new Mat4();
            var tmpVec3 = new Vec3();
            var bMin = new Vec3();
            var bMax = new Vec3();
            var setPropertyTarget;
            var setPropertyOptions;
            function setProperty(pName, defaultVal) {
            		if (setPropertyOptions[pName] !== undefined && setPropertyOptions[pName] !== null) {
            				setPropertyTarget[pName] = setPropertyOptions[pName];
            		} else {
            				setPropertyTarget[pName] = defaultVal;
            		}
            }
            function pack3NFloats(a, b, c) {
            		var packed = a * 255 << 16 | b * 255 << 8 | c * 255;
            		return packed / (1 << 24);
            }
            function packTextureXYZ_NXYZ(qXYZ, qXYZ2) {
            		var num = qXYZ.length / 3;
            		var colors = new Array(num * 4);
            		for(var i = 0; i < num; i++){
            				colors[i * 4] = qXYZ[i * 3];
            				colors[i * 4 + 1] = qXYZ[i * 3 + 1];
            				colors[i * 4 + 2] = qXYZ[i * 3 + 2];
            				colors[i * 4 + 3] = pack3NFloats(qXYZ2[i * 3], qXYZ2[i * 3 + 1], qXYZ2[i * 3 + 2]);
            		}
            		return colors;
            }
            function packTextureRGBA(qRGB, qA) {
            		var colors = new Array(qA.length * 4);
            		for(var i = 0; i < qA.length; i++){
            				colors[i * 4] = qRGB[i * 3];
            				colors[i * 4 + 1] = qRGB[i * 3 + 1];
            				colors[i * 4 + 2] = qRGB[i * 3 + 2];
            				colors[i * 4 + 3] = qA[i];
            		}
            		return colors;
            }
            function packTexture5Floats(qA, qB, qC, qD, qE) {
            		var colors = new Array(qA.length * 4);
            		for(var i = 0; i < qA.length; i++){
            				colors[i * 4] = qA[i];
            				colors[i * 4 + 1] = qB[i];
            				colors[i * 4 + 2] = 0;
            				colors[i * 4 + 3] = pack3NFloats(qC[i], qD[i], qE[i]);
            		}
            		return colors;
            }
            function packTexture2Floats(qA, qB) {
            		var colors = new Array(qA.length * 4);
            		for(var i = 0; i < qA.length; i++){
            				colors[i * 4] = qA[i];
            				colors[i * 4 + 1] = qB[i];
            				colors[i * 4 + 2] = 0;
            				colors[i * 4 + 3] = 0;
            		}
            		return colors;
            }
            function calcEndTime(emitter) {
            		var interval = Math.max(emitter.rate, emitter.rate2) * emitter.numParticles + emitter.lifetime;
            		return Date.now() + interval * 1000;
            }
            function subGraph(A, B) {
            		var r = new Float32Array(A.length);
            		for(var i = 0; i < A.length; i++){
            				r[i] = A[i] - B[i];
            		}
            		return r;
            }
            function maxUnsignedGraphValue(A, outUMax) {
            		var chans = outUMax.length;
            		var values = A.length / chans;
            		for(var i = 0; i < values; i++){
            				for(var j = 0; j < chans; j++){
            						var a = Math.abs(A[i * chans + j]);
            						outUMax[j] = Math.max(outUMax[j], a);
            				}
            		}
            }
            function normalizeGraph(A, uMax) {
            		var chans = uMax.length;
            		var values = A.length / chans;
            		for(var i = 0; i < values; i++){
            				for(var j = 0; j < chans; j++){
            						A[i * chans + j] /= uMax[j] === 0 ? 1 : uMax[j];
            						A[i * chans + j] *= 0.5;
            						A[i * chans + j] += 0.5;
            				}
            		}
            }
            function divGraphFrom2Curves(curve1, curve2, outUMax) {
            		var sub = subGraph(curve2, curve1);
            		maxUnsignedGraphValue(sub, outUMax);
            		normalizeGraph(sub, outUMax);
            		return sub;
            }
            var particleEmitterDeviceCache = new DeviceCache();
            class ParticleEmitter {
            		get defaultParamTexture() {
            				return particleEmitterDeviceCache.get(this.graphicsDevice, ()=>{
            						var resolution = 16;
            						var centerPoint = resolution * 0.5 + 0.5;
            						var dtex = new Float32Array(resolution * resolution * 4);
            						for(var y = 0; y < resolution; y++){
            								for(var x = 0; x < resolution; x++){
            										var xgrad = x + 1 - centerPoint;
            										var ygrad = y + 1 - centerPoint;
            										var c = saturate(1 - saturate(Math.sqrt(xgrad * xgrad + ygrad * ygrad) / resolution) - 0.5);
            										var p = y * resolution + x;
            										dtex[p * 4] = 1;
            										dtex[p * 4 + 1] = 1;
            										dtex[p * 4 + 2] = 1;
            										dtex[p * 4 + 3] = c;
            								}
            						}
            						var texture = _createTexture(this.graphicsDevice, resolution, resolution, dtex, PIXELFORMAT_SRGBA8, 1.0, true);
            						texture.minFilter = FILTER_LINEAR;
            						texture.magFilter = FILTER_LINEAR;
            						return texture;
            				});
            		}
            		onChangeCamera() {
            				this.resetMaterial();
            		}
            		calculateBoundsMad() {
            				this.worldBoundsMul.x = 1.0 / this.worldBoundsSize.x;
            				this.worldBoundsMul.y = 1.0 / this.worldBoundsSize.y;
            				this.worldBoundsMul.z = 1.0 / this.worldBoundsSize.z;
            				this.worldBoundsAdd.copy(this.worldBounds.center).mul(this.worldBoundsMul).mulScalar(-1);
            				this.worldBoundsAdd.x += 0.5;
            				this.worldBoundsAdd.y += 0.5;
            				this.worldBoundsAdd.z += 0.5;
            		}
            		calculateWorldBounds() {
            				if (!this.node) return;
            				this.prevWorldBoundsSize.copy(this.worldBoundsSize);
            				this.prevWorldBoundsCenter.copy(this.worldBounds.center);
            				if (!this.useCpu) {
            						var recalculateLocalBounds = false;
            						if (this.emitterShape === EMITTERSHAPE_BOX) {
            								recalculateLocalBounds = !this.emitterExtents.equals(this.prevEmitterExtents);
            						} else {
            								recalculateLocalBounds = !(this.emitterRadius === this.prevEmitterRadius);
            						}
            						if (recalculateLocalBounds) {
            								this.calculateLocalBounds();
            						}
            				}
            				var nodeWT = this.node.getWorldTransform();
            				if (this.localSpace) {
            						this.worldBoundsNoTrail.copy(this.localBounds);
            				} else {
            						this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, nodeWT);
            				}
            				this.worldBoundsTrail[0].add(this.worldBoundsNoTrail);
            				this.worldBoundsTrail[1].add(this.worldBoundsNoTrail);
            				var now = this.simTimeTotal;
            				if (now >= this.timeToSwitchBounds) {
            						this.worldBoundsTrail[0].copy(this.worldBoundsTrail[1]);
            						this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);
            						this.timeToSwitchBounds = now + this.lifetime;
            				}
            				this.worldBounds.copy(this.worldBoundsTrail[0]);
            				this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);
            				if (this.localSpace) {
            						this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);
            						this.meshInstance.mesh.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);
            				} else {
            						this.meshInstance.aabb.copy(this.worldBounds);
            						this.meshInstance.mesh.aabb.copy(this.worldBounds);
            				}
            				this.meshInstance._aabbVer = 1 - this.meshInstance._aabbVer;
            				if (this.pack8) this.calculateBoundsMad();
            		}
            		resetWorldBounds() {
            				if (!this.node) return;
            				this.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());
            				this.worldBoundsTrail[0].copy(this.worldBoundsNoTrail);
            				this.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);
            				this.worldBounds.copy(this.worldBoundsTrail[0]);
            				this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);
            				this.prevWorldBoundsSize.copy(this.worldBoundsSize);
            				this.prevWorldBoundsCenter.copy(this.worldBounds.center);
            				this.simTimeTotal = 0;
            				this.timeToSwitchBounds = 0;
            		}
            		calculateLocalBounds() {
            				var minx = Number.MAX_VALUE;
            				var miny = Number.MAX_VALUE;
            				var minz = Number.MAX_VALUE;
            				var maxx = -Number.MAX_VALUE;
            				var maxy = -Number.MAX_VALUE;
            				var maxz = -Number.MAX_VALUE;
            				var maxR = 0;
            				var maxScale = 0;
            				var stepWeight = this.lifetime / this.precision;
            				var wVels = [
            						this.qVelocity,
            						this.qVelocity2
            				];
            				var lVels = [
            						this.qLocalVelocity,
            						this.qLocalVelocity2
            				];
            				var accumX = [
            						0,
            						0
            				];
            				var accumY = [
            						0,
            						0
            				];
            				var accumZ = [
            						0,
            						0
            				];
            				var accumR = [
            						0,
            						0
            				];
            				var accumW = [
            						0,
            						0
            				];
            				var x, y, z;
            				for(var i = 0; i < this.precision + 1; i++){
            						var index = Math.min(i, this.precision - 1);
            						for(var j = 0; j < 2; j++){
            								x = lVels[j][index * 3 + 0] * stepWeight + accumX[j];
            								y = lVels[j][index * 3 + 1] * stepWeight + accumY[j];
            								z = lVels[j][index * 3 + 2] * stepWeight + accumZ[j];
            								minx = Math.min(x, minx);
            								miny = Math.min(y, miny);
            								minz = Math.min(z, minz);
            								maxx = Math.max(x, maxx);
            								maxy = Math.max(y, maxy);
            								maxz = Math.max(z, maxz);
            								accumX[j] = x;
            								accumY[j] = y;
            								accumZ[j] = z;
            						}
            						for(var j1 = 0; j1 < 2; j1++){
            								accumW[j1] += stepWeight * Math.sqrt(wVels[j1][index * 3 + 0] * wVels[j1][index * 3 + 0] + wVels[j1][index * 3 + 1] * wVels[j1][index * 3 + 1] + wVels[j1][index * 3 + 2] * wVels[j1][index * 3 + 2]);
            						}
            						accumR[0] += this.qRadialSpeed[index] * stepWeight;
            						accumR[1] += this.qRadialSpeed2[index] * stepWeight;
            						maxR = Math.max(maxR, Math.max(Math.abs(accumR[0]), Math.abs(accumR[1])));
            						maxScale = Math.max(maxScale, this.qScale[index]);
            				}
            				if (this.emitterShape === EMITTERSHAPE_BOX) {
            						x = this.emitterExtents.x * 0.5;
            						y = this.emitterExtents.y * 0.5;
            						z = this.emitterExtents.z * 0.5;
            				} else {
            						x = this.emitterRadius;
            						y = this.emitterRadius;
            						z = this.emitterRadius;
            				}
            				var w = Math.max(accumW[0], accumW[1]);
            				bMin.x = minx - maxScale - x - maxR - w;
            				bMin.y = miny - maxScale - y - maxR - w;
            				bMin.z = minz - maxScale - z - maxR - w;
            				bMax.x = maxx + maxScale + x + maxR + w;
            				bMax.y = maxy + maxScale + y + maxR + w;
            				bMax.z = maxz + maxScale + z + maxR + w;
            				this.localBounds.setMinMax(bMin, bMax);
            		}
            		rebuild() {
            				var gd = this.graphicsDevice;
            				if (this.colorMap === null) this.colorMap = this.defaultParamTexture;
            				this.spawnBounds = this.emitterShape === EMITTERSHAPE_BOX ? this.emitterExtents : this.emitterRadius;
            				this.useCpu = this.useCpu || this.sort > PARTICLESORT_NONE || gd.maxVertexTextures <= 1 || gd.fragmentUniformsCount < 64 || gd.forceCpuParticles;
            				this._destroyResources();
            				this.pack8 = (this.pack8 || !gd.textureFloatRenderable) && !this.useCpu;
            				particleTexHeight = this.useCpu || this.pack8 ? 4 : 2;
            				this.useMesh = !!this.mesh;
            				this.numParticlesPot = math.nextPowerOfTwo(this.numParticles);
            				this.rebuildGraphs();
            				this.calculateLocalBounds();
            				this.resetWorldBounds();
            				if (this.node) {
            						this.worldBounds.setFromTransformedAabb(this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());
            						this.worldBoundsTrail[0].copy(this.worldBounds);
            						this.worldBoundsTrail[1].copy(this.worldBounds);
            						this.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);
            						this.prevWorldBoundsSize.copy(this.worldBoundsSize);
            						this.prevWorldBoundsCenter.copy(this.worldBounds.center);
            						if (this.pack8) this.calculateBoundsMad();
            				}
            				this.vbToSort = new Array(this.numParticles);
            				for(var iSort = 0; iSort < this.numParticles; iSort++)this.vbToSort[iSort] = [
            						0,
            						0
            				];
            				this.particleDistance = new Float32Array(this.numParticles);
            				this._gpuUpdater.randomize();
            				this.particleTex = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);
            				var emitterPos = this.node === null || this.localSpace ? Vec3.ZERO : this.node.getPosition();
            				if (this.emitterShape === EMITTERSHAPE_BOX) {
            						if (this.node === null || this.localSpace) {
            								spawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.spawnBounds);
            						} else {
            								spawnMatrix.setTRS(Vec3.ZERO, this.node.getRotation(), tmpVec3.copy(this.spawnBounds).mul(this.node.localScale));
            						}
            						extentsInnerRatioUniform[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;
            						extentsInnerRatioUniform[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;
            						extentsInnerRatioUniform[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;
            				}
            				for(var i = 0; i < this.numParticles; i++){
            						this._cpuUpdater.calcSpawnPosition(this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i);
            						if (this.useCpu) this.particleTex[i * particleTexChannels + 3 + this.numParticlesPot * 2 * particleTexChannels] = 1;
            				}
            				this.particleTexStart = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);
            				for(var i1 = 0; i1 < this.particleTexStart.length; i1++){
            						this.particleTexStart[i1] = this.particleTex[i1];
            				}
            				if (!this.useCpu) {
            						if (this.pack8) {
            								this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_RGBA8, 1, false);
            								this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_RGBA8, 1, false);
            								this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart, PIXELFORMAT_RGBA8, 1, false);
            						} else {
            								this.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);
            								this.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);
            								this.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart);
            						}
            						this.rtParticleTexIN = new RenderTarget({
            								colorBuffer: this.particleTexIN,
            								depth: false
            						});
            						this.rtParticleTexOUT = new RenderTarget({
            								colorBuffer: this.particleTexOUT,
            								depth: false
            						});
            						this.swapTex = false;
            				}
            				var defines = new Map();
            				if (this.localSpace) defines.set('LOCAL_SPACE', '');
            				if (this.pack8) defines.set('PACK8', '');
            				if (this.emitterShape === EMITTERSHAPE_BOX) defines.set('EMITTERSHAPE_BOX', '');
            				var includes = new Map(Object.entries(shaderChunks));
            				var shaderCodeRespawn = "#define RESPAWN\n " + shaderChunks.particle_simulationPS;
            				var shaderCodeNoRespawn = "#define NO_RESPAWN\n " + shaderChunks.particle_simulationPS;
            				var shaderCodeOnStop = "#define ON_STOP\n " + shaderChunks.particle_simulationPS;
            				var params = "Shape:" + this.emitterShape + "-Pack:" + this.pack8 + "-Local:" + this.localSpace;
            				this.shaderParticleUpdateRespawn = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeRespawn, "ParticleUpdateRespawn-" + params, undefined, false, {
            						fragmentDefines: defines,
            						fragmentIncludes: includes
            				});
            				this.shaderParticleUpdateNoRespawn = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeNoRespawn, "ParticleUpdateNoRespawn-" + params, undefined, false, {
            						fragmentDefines: defines,
            						fragmentIncludes: includes
            				});
            				this.shaderParticleUpdateOnStop = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeOnStop, "ParticleUpdateStop-" + params, undefined, false, {
            						fragmentDefines: defines,
            						fragmentIncludes: includes
            				});
            				this.numParticleVerts = this.useMesh ? this.mesh.vertexBuffer.numVertices : 4;
            				this.numParticleIndices = this.useMesh ? this.mesh.indexBuffer[0].numIndices : 6;
            				this._allocate(this.numParticles);
            				var mesh = new Mesh(gd);
            				mesh.vertexBuffer = this.vertexBuffer;
            				mesh.indexBuffer[0] = this.indexBuffer;
            				mesh.primitive[0].type = PRIMITIVE_TRIANGLES;
            				mesh.primitive[0].base = 0;
            				mesh.primitive[0].count = this.numParticles * this.numParticleIndices;
            				mesh.primitive[0].indexed = true;
            				this.material = this._createMaterial();
            				this.resetMaterial();
            				var wasVisible = this.meshInstance ? this.meshInstance.visible : true;
            				this.meshInstance = new MeshInstance(mesh, this.material, this.node);
            				this.meshInstance.pick = false;
            				this.meshInstance.updateKey();
            				this.meshInstance.cull = true;
            				if (this.localSpace) {
            						this.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, this.node.getWorldTransform());
            				} else {
            						this.meshInstance.aabb.copy(this.worldBounds);
            				}
            				this.meshInstance._updateAabb = false;
            				this.meshInstance.visible = wasVisible;
            				this._setMaterialTextures();
            				this.resetTime();
            				this.addTime(0, false);
            				if (this.preWarm) this.prewarm(this.lifetime);
            		}
            		_isAnimated() {
            				return this.animNumFrames >= 1 && (this.animTilesX > 1 || this.animTilesY > 1) && (this.colorMap && this.colorMap !== this.defaultParamTexture || this.normalMap);
            		}
            		rebuildGraphs() {
            				var precision = this.precision;
            				var gd = this.graphicsDevice;
            				this.qLocalVelocity = this.localVelocityGraph.quantize(precision);
            				this.qVelocity = this.velocityGraph.quantize(precision);
            				this.qColor = this.colorGraph.quantizeClamped(precision, 0, 1);
            				this.qRotSpeed = this.rotationSpeedGraph.quantize(precision);
            				this.qScale = this.scaleGraph.quantize(precision);
            				this.qAlpha = this.alphaGraph.quantize(precision);
            				this.qRadialSpeed = this.radialSpeedGraph.quantize(precision);
            				this.qLocalVelocity2 = this.localVelocityGraph2.quantize(precision);
            				this.qVelocity2 = this.velocityGraph2.quantize(precision);
            				this.qColor2 = this.colorGraph2.quantizeClamped(precision, 0, 1);
            				this.qRotSpeed2 = this.rotationSpeedGraph2.quantize(precision);
            				this.qScale2 = this.scaleGraph2.quantize(precision);
            				this.qAlpha2 = this.alphaGraph2.quantize(precision);
            				this.qRadialSpeed2 = this.radialSpeedGraph2.quantize(precision);
            				for(var i = 0; i < precision; i++){
            						this.qRotSpeed[i] *= math.DEG_TO_RAD;
            						this.qRotSpeed2[i] *= math.DEG_TO_RAD;
            				}
            				this.localVelocityUMax = new Float32Array(3);
            				this.velocityUMax = new Float32Array(3);
            				this.colorUMax = new Float32Array(3);
            				this.rotSpeedUMax = [
            						0
            				];
            				this.scaleUMax = [
            						0
            				];
            				this.alphaUMax = [
            						0
            				];
            				this.radialSpeedUMax = [
            						0
            				];
            				this.qLocalVelocityDiv = divGraphFrom2Curves(this.qLocalVelocity, this.qLocalVelocity2, this.localVelocityUMax);
            				this.qVelocityDiv = divGraphFrom2Curves(this.qVelocity, this.qVelocity2, this.velocityUMax);
            				this.qColorDiv = divGraphFrom2Curves(this.qColor, this.qColor2, this.colorUMax);
            				this.qRotSpeedDiv = divGraphFrom2Curves(this.qRotSpeed, this.qRotSpeed2, this.rotSpeedUMax);
            				this.qScaleDiv = divGraphFrom2Curves(this.qScale, this.qScale2, this.scaleUMax);
            				this.qAlphaDiv = divGraphFrom2Curves(this.qAlpha, this.qAlpha2, this.alphaUMax);
            				this.qRadialSpeedDiv = divGraphFrom2Curves(this.qRadialSpeed, this.qRadialSpeed2, this.radialSpeedUMax);
            				if (this.pack8) {
            						var umax = [
            								0,
            								0,
            								0
            						];
            						maxUnsignedGraphValue(this.qVelocity, umax);
            						var umax2 = [
            								0,
            								0,
            								0
            						];
            						maxUnsignedGraphValue(this.qVelocity2, umax2);
            						var lumax = [
            								0,
            								0,
            								0
            						];
            						maxUnsignedGraphValue(this.qLocalVelocity, lumax);
            						var lumax2 = [
            								0,
            								0,
            								0
            						];
            						maxUnsignedGraphValue(this.qLocalVelocity2, lumax2);
            						var rumax = [
            								0
            						];
            						maxUnsignedGraphValue(this.qRadialSpeed, rumax);
            						var rumax2 = [
            								0
            						];
            						maxUnsignedGraphValue(this.qRadialSpeed2, rumax2);
            						var maxVel = Math.max(umax[0], umax2[0]);
            						maxVel = Math.max(maxVel, umax[1]);
            						maxVel = Math.max(maxVel, umax2[1]);
            						maxVel = Math.max(maxVel, umax[2]);
            						maxVel = Math.max(maxVel, umax2[2]);
            						var lmaxVel = Math.max(lumax[0], lumax2[0]);
            						lmaxVel = Math.max(lmaxVel, lumax[1]);
            						lmaxVel = Math.max(lmaxVel, lumax2[1]);
            						lmaxVel = Math.max(lmaxVel, lumax[2]);
            						lmaxVel = Math.max(lmaxVel, lumax2[2]);
            						var maxRad = Math.max(rumax[0], rumax2[0]);
            						this.maxVel = maxVel + lmaxVel + maxRad;
            				}
            				if (!this.useCpu) {
            						this.internalTex0 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qLocalVelocity, this.qLocalVelocityDiv));
            						this.internalTex1 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qVelocity, this.qVelocityDiv));
            						this.internalTex2 = _createTexture(gd, precision, 1, packTexture5Floats(this.qRotSpeed, this.qScale, this.qScaleDiv, this.qRotSpeedDiv, this.qAlphaDiv));
            						this.internalTex3 = _createTexture(gd, precision, 1, packTexture2Floats(this.qRadialSpeed, this.qRadialSpeedDiv));
            				}
            				this.colorParam = _createTexture(gd, precision, 1, packTextureRGBA(this.qColor, this.qAlpha), PIXELFORMAT_SRGBA8, 1.0, true);
            		}
            		_setMaterialTextures() {
            				if (this.colorMap) {
            						this.material.setParameter('colorMap', this.colorMap);
            						if (this.lighting && this.normalMap) {
            								this.material.setParameter('normalMap', this.normalMap);
            						}
            				}
            		}
            		_createMaterial() {
            				var material = new ParticleMaterial(this);
            				material.name = "EmitterMaterial:" + this.node.name;
            				material.cull = CULLFACE_NONE;
            				material.alphaWrite = false;
            				material.blendType = this.blendType;
            				material.depthWrite = this.depthWrite;
            				return material;
            		}
            		resetMaterial() {
            				var material = this.material;
            				material.setParameter('stretch', this.stretch);
            				if (this._isAnimated()) {
            						material.setParameter('animTexTilesParams', this.animTilesParams);
            						material.setParameter('animTexParams', this.animParams);
            						material.setParameter('animTexIndexParams', this.animIndexParams);
            				}
            				material.setParameter('colorMult', this.intensity);
            				if (!this.useCpu) {
            						material.setParameter('internalTex0', this.internalTex0);
            						material.setParameter('internalTex1', this.internalTex1);
            						material.setParameter('internalTex2', this.internalTex2);
            						material.setParameter('internalTex3', this.internalTex3);
            				}
            				material.setParameter('colorParam', this.colorParam);
            				material.setParameter('numParticles', this.numParticles);
            				material.setParameter('numParticlesPot', this.numParticlesPot);
            				material.setParameter('lifetime', this.lifetime);
            				material.setParameter('rate', this.rate);
            				material.setParameter('rateDiv', this.rate2 - this.rate);
            				material.setParameter('seed', this.seed);
            				material.setParameter('scaleDivMult', this.scaleUMax[0]);
            				material.setParameter('alphaDivMult', this.alphaUMax[0]);
            				material.setParameter('radialSpeedDivMult', this.radialSpeedUMax[0]);
            				material.setParameter('graphNumSamples', this.precision);
            				material.setParameter('graphSampleSize', 1.0 / this.precision);
            				material.setParameter('emitterScale', new Float32Array([
            						1,
            						1,
            						1
            				]));
            				if (this.pack8) {
            						this._gpuUpdater._setInputBounds();
            						material.setParameter('inBoundsSize', this._gpuUpdater.inBoundsSizeUniform);
            						material.setParameter('inBoundsCenter', this._gpuUpdater.inBoundsCenterUniform);
            						material.setParameter('maxVel', this.maxVel);
            				}
            				if (this.wrap && this.wrapBounds) {
            						this.wrapBoundsUniform[0] = this.wrapBounds.x;
            						this.wrapBoundsUniform[1] = this.wrapBounds.y;
            						this.wrapBoundsUniform[2] = this.wrapBounds.z;
            						material.setParameter('wrapBounds', this.wrapBoundsUniform);
            				}
            				this._setMaterialTextures();
            				if (this.depthSoftening > 0) {
            						material.setParameter('softening', 1.0 / (this.depthSoftening * this.depthSoftening * 100));
            				}
            				if (this.stretch > 0.0) material.cull = CULLFACE_NONE;
            				this._compParticleFaceParams();
            		}
            		_compParticleFaceParams() {
            				var tangent, binormal;
            				if (this.orientation === PARTICLEORIENTATION_SCREEN) {
            						tangent = new Float32Array([
            								1,
            								0,
            								0
            						]);
            						binormal = new Float32Array([
            								0,
            								0,
            								1
            						]);
            				} else {
            						var n;
            						if (this.orientation === PARTICLEORIENTATION_WORLD) {
            								n = this.particleNormal.normalize();
            						} else {
            								var emitterMat = this.node === null ? Mat4.IDENTITY : this.node.getWorldTransform();
            								n = emitterMat.transformVector(this.particleNormal).normalize();
            						}
            						var t = new Vec3(1, 0, 0);
            						if (Math.abs(t.dot(n)) === 1) {
            								t.set(0, 0, 1);
            						}
            						var b = new Vec3().cross(n, t).normalize();
            						t.cross(b, n).normalize();
            						tangent = new Float32Array([
            								t.x,
            								t.y,
            								t.z
            						]);
            						binormal = new Float32Array([
            								b.x,
            								b.y,
            								b.z
            						]);
            				}
            				this.material.setParameter('faceTangent', tangent);
            				this.material.setParameter('faceBinorm', binormal);
            		}
            		_allocate(numParticles) {
            				var psysVertCount = numParticles * this.numParticleVerts;
            				var psysIndexCount = numParticles * this.numParticleIndices;
            				if (this.vertexBuffer === undefined || this.vertexBuffer.getNumVertices() !== psysVertCount) {
            						var elements = [];
            						if (!this.useCpu) {
            								elements.push({
            										semantic: SEMANTIC_ATTR0,
            										components: 4,
            										type: TYPE_FLOAT32
            								});
            								if (this.useMesh) {
            										elements.push({
            												semantic: SEMANTIC_ATTR1,
            												components: 2,
            												type: TYPE_FLOAT32
            										});
            								}
            						} else {
            								elements.push({
            										semantic: SEMANTIC_ATTR0,
            										components: 4,
            										type: TYPE_FLOAT32
            								}, {
            										semantic: SEMANTIC_ATTR1,
            										components: 4,
            										type: TYPE_FLOAT32
            								}, {
            										semantic: SEMANTIC_ATTR2,
            										components: 4,
            										type: TYPE_FLOAT32
            								}, {
            										semantic: SEMANTIC_ATTR3,
            										components: 1,
            										type: TYPE_FLOAT32
            								}, {
            										semantic: SEMANTIC_ATTR4,
            										components: this.useMesh ? 4 : 2,
            										type: TYPE_FLOAT32
            								});
            						}
            						var vertexFormat = new VertexFormat(this.graphicsDevice, elements);
            						this.vertexBuffer = new VertexBuffer(this.graphicsDevice, vertexFormat, psysVertCount, {
            								usage: BUFFER_DYNAMIC
            						});
            						this.indexBuffer = new IndexBuffer(this.graphicsDevice, INDEXFORMAT_UINT32, psysIndexCount);
            						var data = new Float32Array(this.vertexBuffer.lock());
            						var meshData, stride, texCoordOffset;
            						if (this.useMesh) {
            								meshData = new Float32Array(this.mesh.vertexBuffer.lock());
            								stride = meshData.length / this.mesh.vertexBuffer.numVertices;
            								for(var elem = 0; elem < this.mesh.vertexBuffer.format.elements.length; elem++){
            										if (this.mesh.vertexBuffer.format.elements[elem].name === SEMANTIC_TEXCOORD0) {
            												texCoordOffset = this.mesh.vertexBuffer.format.elements[elem].offset / 4;
            												break;
            										}
            								}
            						}
            						for(var i = 0; i < psysVertCount; i++){
            								var id = Math.floor(i / this.numParticleVerts);
            								if (!this.useMesh) {
            										var vertID = i % 4;
            										data[i * 4] = particleVerts[vertID][0];
            										data[i * 4 + 1] = particleVerts[vertID][1];
            										data[i * 4 + 2] = 0;
            										data[i * 4 + 3] = id;
            								} else {
            										var vert = i % this.numParticleVerts;
            										data[i * 6] = meshData[vert * stride];
            										data[i * 6 + 1] = meshData[vert * stride + 1];
            										data[i * 6 + 2] = meshData[vert * stride + 2];
            										data[i * 6 + 3] = id;
            										data[i * 6 + 4] = meshData[vert * stride + texCoordOffset + 0];
            										data[i * 6 + 5] = 1.0 - meshData[vert * stride + texCoordOffset + 1];
            								}
            						}
            						if (this.useCpu) {
            								this.vbCPU = new Float32Array(data);
            								this.vbOld = new Float32Array(this.vbCPU.length);
            						}
            						this.vertexBuffer.unlock();
            						if (this.useMesh) {
            								this.mesh.vertexBuffer.unlock();
            						}
            						var dst = 0;
            						var indices = new Uint32Array(this.indexBuffer.lock());
            						if (this.useMesh) {
            								var ib = this.mesh.indexBuffer[0];
            								meshData = new typedArrayIndexFormats[ib.format](ib.lock());
            						}
            						for(var i1 = 0; i1 < numParticles; i1++){
            								if (!this.useMesh) {
            										var baseIndex = i1 * 4;
            										indices[dst++] = baseIndex;
            										indices[dst++] = baseIndex + 1;
            										indices[dst++] = baseIndex + 2;
            										indices[dst++] = baseIndex;
            										indices[dst++] = baseIndex + 2;
            										indices[dst++] = baseIndex + 3;
            								} else {
            										for(var j = 0; j < this.numParticleIndices; j++){
            												indices[i1 * this.numParticleIndices + j] = meshData[j] + i1 * this.numParticleVerts;
            										}
            								}
            						}
            						this.indexBuffer.unlock();
            						if (this.useMesh) this.mesh.indexBuffer[0].unlock();
            				}
            		}
            		reset() {
            				this.beenReset = true;
            				this.seed = Math.random();
            				this.material.setParameter('seed', this.seed);
            				if (this.useCpu) {
            						for(var i = 0; i < this.particleTexStart.length; i++){
            								this.particleTex[i] = this.particleTexStart[i];
            						}
            				} else {
            						this._setMaterialTextures();
            				}
            				this.resetWorldBounds();
            				this.resetTime();
            				var origLoop = this.loop;
            				this.loop = true;
            				this.addTime(0, false);
            				this.loop = origLoop;
            				if (this.preWarm) {
            						this.prewarm(this.lifetime);
            				}
            		}
            		prewarm(time) {
            				var lifetimeFraction = time / this.lifetime;
            				var iterations = Math.min(Math.floor(lifetimeFraction * this.precision), this.precision);
            				var stepDelta = time / iterations;
            				for(var i = 0; i < iterations; i++){
            						this.addTime(stepDelta, false);
            				}
            		}
            		resetTime() {
            				this.endTime = calcEndTime(this);
            		}
            		finishFrame() {
            				if (this.useCpu) this.vertexBuffer.unlock();
            		}
            		addTime(delta, isOnStop) {
            				var device = this.graphicsDevice;
            				this.simTimeTotal += delta;
            				this.calculateWorldBounds();
            				if (this._isAnimated()) {
            						var tilesParams = this.animTilesParams;
            						tilesParams[0] = 1.0 / this.animTilesX;
            						tilesParams[1] = 1.0 / this.animTilesY;
            						var params = this.animParams;
            						params[0] = this.animStartFrame;
            						params[1] = this.animNumFrames * this.animSpeed;
            						params[2] = this.animNumFrames - 1;
            						params[3] = this.animNumAnimations - 1;
            						var animIndexParams = this.animIndexParams;
            						animIndexParams[0] = this.animIndex;
            						animIndexParams[1] = this.randomizeAnimIndex;
            				}
            				if (this.scene) {
            						if (this.camera !== this.scene._activeCamera) {
            								this.camera = this.scene._activeCamera;
            								this.onChangeCamera();
            						}
            				}
            				if (this.emitterShape === EMITTERSHAPE_BOX) {
            						extentsInnerRatioUniform[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;
            						extentsInnerRatioUniform[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;
            						extentsInnerRatioUniform[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;
            						if (this.meshInstance.node === null) {
            								spawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.emitterExtents);
            						} else {
            								spawnMatrix.setTRS(Vec3.ZERO, this.meshInstance.node.getRotation(), tmpVec3.copy(this.emitterExtents).mul(this.meshInstance.node.localScale));
            						}
            				}
            				var emitterPos;
            				var emitterScale = this.meshInstance.node === null ? Vec3.ONE : this.meshInstance.node.localScale;
            				this.emitterScaleUniform[0] = emitterScale.x;
            				this.emitterScaleUniform[1] = emitterScale.y;
            				this.emitterScaleUniform[2] = emitterScale.z;
            				this.material.setParameter('emitterScale', this.emitterScaleUniform);
            				if (this.localSpace && this.meshInstance.node) {
            						emitterPos = this.meshInstance.node.getPosition();
            						this.emitterPosUniform[0] = emitterPos.x;
            						this.emitterPosUniform[1] = emitterPos.y;
            						this.emitterPosUniform[2] = emitterPos.z;
            						this.material.setParameter('emitterPos', this.emitterPosUniform);
            				}
            				this._compParticleFaceParams();
            				if (!this.useCpu) {
            						this._gpuUpdater.update(device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop);
            				} else {
            						var data = new Float32Array(this.vertexBuffer.lock());
            						this._cpuUpdater.update(data, this.vbToSort, this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop);
            				}
            				if (!this.loop) {
            						if (Date.now() > this.endTime) {
            								if (this.onFinished) this.onFinished();
            								this.meshInstance.visible = false;
            						}
            				}
            				if (this.meshInstance) {
            						this.meshInstance.drawOrder = this.drawOrder;
            				}
            		}
            		_destroyResources() {
            				var _this_particleTexIN, _this_particleTexOUT, _this_rtParticleTexIN, _this_rtParticleTexOUT, _this_internalTex0, _this_internalTex1, _this_internalTex2, _this_internalTex3, _this_colorParam, _this_vertexBuffer, _this_indexBuffer, _this_material;
            				(_this_particleTexIN = this.particleTexIN) == null ? void 0 : _this_particleTexIN.destroy();
            				this.particleTexIN = null;
            				(_this_particleTexOUT = this.particleTexOUT) == null ? void 0 : _this_particleTexOUT.destroy();
            				this.particleTexOUT = null;
            				if (this.particleTexStart && this.particleTexStart.destroy) {
            						this.particleTexStart.destroy();
            						this.particleTexStart = null;
            				}
            				(_this_rtParticleTexIN = this.rtParticleTexIN) == null ? void 0 : _this_rtParticleTexIN.destroy();
            				this.rtParticleTexIN = null;
            				(_this_rtParticleTexOUT = this.rtParticleTexOUT) == null ? void 0 : _this_rtParticleTexOUT.destroy();
            				this.rtParticleTexOUT = null;
            				(_this_internalTex0 = this.internalTex0) == null ? void 0 : _this_internalTex0.destroy();
            				this.internalTex0 = null;
            				(_this_internalTex1 = this.internalTex1) == null ? void 0 : _this_internalTex1.destroy();
            				this.internalTex1 = null;
            				(_this_internalTex2 = this.internalTex2) == null ? void 0 : _this_internalTex2.destroy();
            				this.internalTex2 = null;
            				(_this_internalTex3 = this.internalTex3) == null ? void 0 : _this_internalTex3.destroy();
            				this.internalTex3 = null;
            				(_this_colorParam = this.colorParam) == null ? void 0 : _this_colorParam.destroy();
            				this.colorParam = null;
            				(_this_vertexBuffer = this.vertexBuffer) == null ? void 0 : _this_vertexBuffer.destroy();
            				this.vertexBuffer = undefined;
            				(_this_indexBuffer = this.indexBuffer) == null ? void 0 : _this_indexBuffer.destroy();
            				this.indexBuffer = undefined;
            				(_this_material = this.material) == null ? void 0 : _this_material.destroy();
            				this.material = null;
            		}
            		destroy() {
            				this.camera = null;
            				this._destroyResources();
            		}
            		constructor(graphicsDevice, options){
            				this.material = null;
            				this.internalTex0 = null;
            				this.internalTex1 = null;
            				this.internalTex2 = null;
            				this.colorParam = null;
            				this.graphicsDevice = graphicsDevice;
            				var gd = graphicsDevice;
            				var precision = 32;
            				this.precision = precision;
            				this._addTimeTime = 0;
            				setPropertyTarget = this;
            				setPropertyOptions = options;
            				setProperty('numParticles', 1);
            				if (this.numParticles > graphicsDevice.maxTextureSize) {
            						this.numParticles = graphicsDevice.maxTextureSize;
            				}
            				setProperty('rate', 1);
            				setProperty('rate2', this.rate);
            				setProperty('lifetime', 50);
            				setProperty('emitterExtents', new Vec3(0, 0, 0));
            				setProperty('emitterExtentsInner', new Vec3(0, 0, 0));
            				setProperty('emitterRadius', 0);
            				setProperty('emitterRadiusInner', 0);
            				setProperty('emitterShape', EMITTERSHAPE_BOX);
            				setProperty('initialVelocity', 1);
            				setProperty('wrap', false);
            				setProperty('localSpace', false);
            				setProperty('screenSpace', false);
            				setProperty('wrapBounds', null);
            				setProperty('colorMap', this.defaultParamTexture);
            				setProperty('normalMap', null);
            				setProperty('loop', true);
            				setProperty('preWarm', false);
            				setProperty('sort', PARTICLESORT_NONE);
            				setProperty('mode', PARTICLEMODE_GPU);
            				setProperty('scene', null);
            				setProperty('lighting', false);
            				setProperty('halfLambert', false);
            				setProperty('intensity', 1.0);
            				setProperty('stretch', 0.0);
            				setProperty('alignToMotion', false);
            				setProperty('depthSoftening', 0);
            				setProperty('mesh', null);
            				setProperty('particleNormal', new Vec3(0, 1, 0));
            				setProperty('orientation', PARTICLEORIENTATION_SCREEN);
            				setProperty('depthWrite', false);
            				setProperty('noFog', false);
            				setProperty('blendType', BLEND_NORMAL);
            				setProperty('node', null);
            				setProperty('startAngle', 0);
            				setProperty('startAngle2', this.startAngle);
            				setProperty('animTilesX', 1);
            				setProperty('animTilesY', 1);
            				setProperty('animStartFrame', 0);
            				setProperty('animNumFrames', 1);
            				setProperty('animNumAnimations', 1);
            				setProperty('animIndex', 0);
            				setProperty('randomizeAnimIndex', false);
            				setProperty('animSpeed', 1);
            				setProperty('animLoop', true);
            				this._gpuUpdater = new ParticleGPUUpdater(this, gd);
            				this._cpuUpdater = new ParticleCPUUpdater(this);
            				this.emitterPosUniform = new Float32Array(3);
            				this.wrapBoundsUniform = new Float32Array(3);
            				this.emitterScaleUniform = new Float32Array([
            						1,
            						1,
            						1
            				]);
            				setProperty('colorGraph', default1Curve3);
            				setProperty('colorGraph2', this.colorGraph);
            				setProperty('scaleGraph', default1Curve);
            				setProperty('scaleGraph2', this.scaleGraph);
            				setProperty('alphaGraph', default1Curve);
            				setProperty('alphaGraph2', this.alphaGraph);
            				setProperty('localVelocityGraph', default0Curve3);
            				setProperty('localVelocityGraph2', this.localVelocityGraph);
            				setProperty('velocityGraph', default0Curve3);
            				setProperty('velocityGraph2', this.velocityGraph);
            				setProperty('rotationSpeedGraph', default0Curve);
            				setProperty('rotationSpeedGraph2', this.rotationSpeedGraph);
            				setProperty('radialSpeedGraph', default0Curve);
            				setProperty('radialSpeedGraph2', this.radialSpeedGraph);
            				this.animTilesParams = new Float32Array(2);
            				this.animParams = new Float32Array(4);
            				this.animIndexParams = new Float32Array(2);
            				this.vbToSort = null;
            				this.vbOld = null;
            				this.particleDistance = null;
            				this.camera = null;
            				this.swapTex = false;
            				this.useMesh = true;
            				this.useCpu = !graphicsDevice.supportsGpuParticles;
            				this.pack8 = true;
            				this.localBounds = new BoundingBox();
            				this.worldBoundsNoTrail = new BoundingBox();
            				this.worldBoundsTrail = [
            						new BoundingBox(),
            						new BoundingBox()
            				];
            				this.worldBounds = new BoundingBox();
            				this.worldBoundsSize = new Vec3();
            				this.prevWorldBoundsSize = new Vec3();
            				this.prevWorldBoundsCenter = new Vec3();
            				this.prevEmitterExtents = this.emitterExtents;
            				this.prevEmitterRadius = this.emitterRadius;
            				this.worldBoundsMul = new Vec3();
            				this.worldBoundsAdd = new Vec3();
            				this.timeToSwitchBounds = 0;
            				this.shaderParticleUpdateRespawn = null;
            				this.shaderParticleUpdateNoRespawn = null;
            				this.shaderParticleUpdateOnStop = null;
            				this.numParticleVerts = 0;
            				this.numParticleIndices = 0;
            				this.material = null;
            				this.meshInstance = null;
            				this.drawOrder = 0;
            				this.seed = Math.random();
            				this.fixedTimeStep = 1.0 / 60;
            				this.maxSubSteps = 10;
            				this.simTime = 0;
            				this.simTimeTotal = 0;
            				this.beenReset = false;
            				this._layer = null;
            				this.rebuild();
            		}
            }
            
            function _extends$e() {
            		_extends$e = Object.assign || function(target) {
            				for(var i = 1; i < arguments.length; i++){
            						var source = arguments[i];
            						for(var key in source){
            								if (Object.prototype.hasOwnProperty.call(source, key)) {
            										target[key] = source[key];
            								}
            						}
            				}
            				return target;
            		};
            		return _extends$e.apply(this, arguments);
            }
            class ShaderGeneratorShader extends ShaderGenerator {
            		generateKey(options) {
            				var desc = options.shaderDesc;
            				var vsHashGLSL = desc.vertexGLSL ? hashCode(desc.vertexGLSL) : 0;
            				var fsHashGLSL = desc.fragmentGLSL ? hashCode(desc.fragmentGLSL) : 0;
            				var vsHashWGSL = desc.vertexWGSL ? hashCode(desc.vertexWGSL) : 0;
            				var fsHashWGSL = desc.fragmentWGSL ? hashCode(desc.fragmentWGSL) : 0;
            				var definesHash = ShaderGenerator.definesHash(options.defines);
            				var key = desc.uniqueName + "_" + definesHash + "_" + vsHashGLSL + "_" + fsHashGLSL + "_" + vsHashWGSL + "_" + fsHashWGSL;
            				if (options.skin) key += '_skin';
            				if (options.useInstancing) key += '_inst';
            				if (options.useMorphPosition) key += '_morphp';
            				if (options.useMorphNormal) key += '_morphn';
            				if (options.useMorphTextureBasedInt) key += '_morphi';
            				return key;
            		}
            		createAttributesDefinition(definitionOptions, options) {
            				var srcAttributes = options.shaderDesc.attributes;
            				var attributes = srcAttributes ? _extends$e({}, srcAttributes) : undefined;
            				if (options.skin) {
            						attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
            						attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
            				}
            				if (options.useMorphPosition || options.useMorphNormal) {
            						attributes.morph_vertex_id = SEMANTIC_ATTR15;
            				}
            				definitionOptions.attributes = attributes;
            		}
            		createVertexDefinition(definitionOptions, options, sharedIncludes, wgsl) {
            				var desc = options.shaderDesc;
            				var includes = new Map(sharedIncludes);
            				includes.set('transformInstancingVS', '');
            				var defines = new Map(options.defines);
            				if (options.skin) defines.set('SKIN', true);
            				if (options.useInstancing) defines.set('INSTANCING', true);
            				if (options.useMorphPosition || options.useMorphNormal) {
            						defines.set('MORPHING', true);
            						if (options.useMorphTextureBasedInt) defines.set('MORPHING_INT', true);
            						if (options.useMorphPosition) defines.set('MORPHING_POSITION', true);
            						if (options.useMorphNormal) defines.set('MORPHING_NORMAL', true);
            				}
            				definitionOptions.vertexCode = wgsl ? desc.vertexWGSL : desc.vertexGLSL;
            				definitionOptions.vertexIncludes = includes;
            				definitionOptions.vertexDefines = defines;
            		}
            		createFragmentDefinition(definitionOptions, options, sharedIncludes, wgsl) {
            				var desc = options.shaderDesc;
            				var includes = new Map(sharedIncludes);
            				var defines = new Map(options.defines);
            				definitionOptions.fragmentCode = wgsl ? desc.fragmentWGSL : desc.fragmentGLSL;
            				definitionOptions.fragmentIncludes = includes;
            				definitionOptions.fragmentDefines = defines;
            		}
            		createShaderDefinition(device, options) {
            				var desc = options.shaderDesc;
            				var wgsl = device.isWebGPU && desc.vertexWGSL && desc.fragmentWGSL;
            				var definitionOptions = {
            						name: "ShaderMaterial-" + desc.uniqueName,
            						shaderLanguage: wgsl ? SHADERLANGUAGE_WGSL : SHADERLANGUAGE_GLSL,
            						fragmentOutputTypes: desc.fragmentOutputTypes,
            						meshUniformBufferFormat: desc.meshUniformBufferFormat,
            						meshBindGroupFormat: desc.meshBindGroupFormat
            				};
            				var chunks = wgsl ? shaderChunksWGSL : shaderChunks;
            				var sharedIncludes = new Map(Object.entries(_extends$e({}, chunks, options.chunks)));
            				this.createAttributesDefinition(definitionOptions, options);
            				this.createVertexDefinition(definitionOptions, options, sharedIncludes, wgsl);
            				this.createFragmentDefinition(definitionOptions, options, sharedIncludes, wgsl);
            				return ShaderUtils.createDefinition(device, definitionOptions);
            		}
            }
            var shaderGeneratorShader = new ShaderGeneratorShader();
            
            class ShaderMaterial extends Material {
            		set shaderDesc(value) {
            				this._shaderDesc = undefined;
            				if (value) {
            						this._shaderDesc = {
            								uniqueName: value.uniqueName,
            								attributes: value.attributes,
            								fragmentOutputTypes: value.fragmentOutputTypes,
            								vertexGLSL: value.vertexGLSL,
            								fragmentGLSL: value.fragmentGLSL,
            								vertexWGSL: value.vertexWGSL,
            								fragmentWGSL: value.fragmentWGSL
            						};
            						if (value.vertexCode || value.fragmentCode || value.shaderLanguage) {
            								var _value_shaderLanguage;
            								var language = (_value_shaderLanguage = value.shaderLanguage) != null ? _value_shaderLanguage : SHADERLANGUAGE_GLSL;
            								if (language === SHADERLANGUAGE_GLSL) {
            										this._shaderDesc.vertexGLSL = value.vertexCode;
            										this._shaderDesc.fragmentGLSL = value.fragmentCode;
            								} else if (language === SHADERLANGUAGE_WGSL) {
            										this._shaderDesc.vertexWGSL = value.vertexCode;
            										this._shaderDesc.fragmentWGSL = value.fragmentCode;
            								}
            						}
            				}
            				this.clearVariants();
            		}
            		get shaderDesc() {
            				return this._shaderDesc;
            		}
            		copy(source) {
            				super.copy(source);
            				this.shaderDesc = source.shaderDesc;
            				return this;
            		}
            		getShaderVariant(params) {
            				var { objDefs } = params;
            				var _this_chunks;
            				var options = {
            						defines: getCoreDefines(this, params),
            						skin: (objDefs & SHADERDEF_SKIN) !== 0,
            						useInstancing: (objDefs & SHADERDEF_INSTANCING) !== 0,
            						useMorphPosition: (objDefs & SHADERDEF_MORPH_POSITION) !== 0,
            						useMorphNormal: (objDefs & SHADERDEF_MORPH_NORMAL) !== 0,
            						useMorphTextureBasedInt: (objDefs & SHADERDEF_MORPH_TEXTURE_BASED_INT) !== 0,
            						pass: params.pass,
            						gamma: params.cameraShaderParams.shaderOutputGamma,
            						toneMapping: params.cameraShaderParams.toneMapping,
            						fog: params.cameraShaderParams.fog,
            						shaderDesc: this.shaderDesc,
            						chunks: (_this_chunks = this.chunks) != null ? _this_chunks : {}
            				};
            				var processingOptions = new ShaderProcessorOptions(params.viewUniformFormat, params.viewBindGroupFormat, params.vertexFormat);
            				var library = getProgramLibrary(params.device);
            				library.register('shader-material', shaderGeneratorShader);
            				return library.getProgram('shader-material', options, processingOptions, this.userId);
            		}
            		constructor(shaderDesc){
            				super();
            				this.shaderDesc = shaderDesc;
            		}
            }
            
            var decodeTable = {
            		'linear': 'decodeLinear',
            		'srgb': 'decodeGamma',
            		'rgbm': 'decodeRGBM',
            		'rgbe': 'decodeRGBE',
            		'rgbp': 'decodeRGBP',
            		'xy': 'unpackNormalXY',
            		'xyz': 'unpackNormalXYZ'
            };
            var encodeTable = {
            		'linear': 'encodeLinear',
            		'srgb': 'encodeGamma',
            		'rgbm': 'encodeRGBM',
            		'rgbe': 'encodeRGBE',
            		'rgbp': 'encodeRGBP'
            };
            class ChunkUtils {
            		static decodeFunc(encoding) {
            				var _decodeTable_encoding;
            				return (_decodeTable_encoding = decodeTable[encoding]) != null ? _decodeTable_encoding : 'decodeGamma';
            		}
            		static encodeFunc(encoding) {
            				var _encodeTable_encoding;
            				return (_encodeTable_encoding = encodeTable[encoding]) != null ? _encodeTable_encoding : 'encodeGamma';
            		}
            		static getScreenDepthChunk(device, cameraShaderParams) {
            				return "\n            " + (cameraShaderParams.sceneDepthMapLinear ? '#define SCENE_DEPTHMAP_LINEAR' : '') + "\n            " + (device.textureFloatRenderable ? '#define SCENE_DEPTHMAP_FLOAT' : '') + "\n            " + shaderChunks.screenDepthPS + "\n        ";
            		}
            }
            
            var calculateNormals = (positions, indices)=>{
            		var triangleCount = indices.length / 3;
            		var vertexCount = positions.length / 3;
            		var p1 = new Vec3();
            		var p2 = new Vec3();
            		var p3 = new Vec3();
            		var p1p2 = new Vec3();
            		var p1p3 = new Vec3();
            		var faceNormal = new Vec3();
            		var normals = [];
            		for(var i = 0; i < positions.length; i++){
            				normals[i] = 0;
            		}
            		for(var i1 = 0; i1 < triangleCount; i1++){
            				var i11 = indices[i1 * 3];
            				var i2 = indices[i1 * 3 + 1];
            				var i3 = indices[i1 * 3 + 2];
            				p1.set(positions[i11 * 3], positions[i11 * 3 + 1], positions[i11 * 3 + 2]);
            				p2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
            				p3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
            				p1p2.sub2(p2, p1);
            				p1p3.sub2(p3, p1);
            				faceNormal.cross(p1p2, p1p3).normalize();
            				normals[i11 * 3] += faceNormal.x;
            				normals[i11 * 3 + 1] += faceNormal.y;
            				normals[i11 * 3 + 2] += faceNormal.z;
            				normals[i2 * 3] += faceNormal.x;
            				normals[i2 * 3 + 1] += faceNormal.y;
            				normals[i2 * 3 + 2] += faceNormal.z;
            				normals[i3 * 3] += faceNormal.x;
            				normals[i3 * 3 + 1] += faceNormal.y;
            				normals[i3 * 3 + 2] += faceNormal.z;
            		}
            		for(var i4 = 0; i4 < vertexCount; i4++){
            				var nx = normals[i4 * 3];
            				var ny = normals[i4 * 3 + 1];
            				var nz = normals[i4 * 3 + 2];
            				var invLen = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);
            				normals[i4 * 3] *= invLen;
            				normals[i4 * 3 + 1] *= invLen;
            				normals[i4 * 3 + 2] *= invLen;
            		}
            		return normals;
            };
            var calculateTangents = (positions, normals, uvs, indices)=>{
            		var triangleCount = indices.length / 3;
            		var vertexCount = positions.length / 3;
            		var v1 = new Vec3();
            		var v2 = new Vec3();
            		var v3 = new Vec3();
            		var w1 = new Vec2();
            		var w2 = new Vec2();
            		var w3 = new Vec2();
            		var sdir = new Vec3();
            		var tdir = new Vec3();
            		var tan1 = new Float32Array(vertexCount * 3);
            		var tan2 = new Float32Array(vertexCount * 3);
            		var tangents = [];
            		for(var i = 0; i < triangleCount; i++){
            				var i1 = indices[i * 3];
            				var i2 = indices[i * 3 + 1];
            				var i3 = indices[i * 3 + 2];
            				v1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);
            				v2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);
            				v3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);
            				w1.set(uvs[i1 * 2], uvs[i1 * 2 + 1]);
            				w2.set(uvs[i2 * 2], uvs[i2 * 2 + 1]);
            				w3.set(uvs[i3 * 2], uvs[i3 * 2 + 1]);
            				var x1 = v2.x - v1.x;
            				var x2 = v3.x - v1.x;
            				var y1 = v2.y - v1.y;
            				var y2 = v3.y - v1.y;
            				var z1 = v2.z - v1.z;
            				var z2 = v3.z - v1.z;
            				var s1 = w2.x - w1.x;
            				var s2 = w3.x - w1.x;
            				var t1 = w2.y - w1.y;
            				var t2 = w3.y - w1.y;
            				var area = s1 * t2 - s2 * t1;
            				if (area === 0) {
            						sdir.set(0, 1, 0);
            						tdir.set(1, 0, 0);
            				} else {
            						var r = 1 / area;
            						sdir.set((t2 * x1 - t1 * x2) * r, (t2 * y1 - t1 * y2) * r, (t2 * z1 - t1 * z2) * r);
            						tdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);
            				}
            				tan1[i1 * 3 + 0] += sdir.x;
            				tan1[i1 * 3 + 1] += sdir.y;
            				tan1[i1 * 3 + 2] += sdir.z;
            				tan1[i2 * 3 + 0] += sdir.x;
            				tan1[i2 * 3 + 1] += sdir.y;
            				tan1[i2 * 3 + 2] += sdir.z;
            				tan1[i3 * 3 + 0] += sdir.x;
            				tan1[i3 * 3 + 1] += sdir.y;
            				tan1[i3 * 3 + 2] += sdir.z;
            				tan2[i1 * 3 + 0] += tdir.x;
            				tan2[i1 * 3 + 1] += tdir.y;
            				tan2[i1 * 3 + 2] += tdir.z;
            				tan2[i2 * 3 + 0] += tdir.x;
            				tan2[i2 * 3 + 1] += tdir.y;
            				tan2[i2 * 3 + 2] += tdir.z;
            				tan2[i3 * 3 + 0] += tdir.x;
            				tan2[i3 * 3 + 1] += tdir.y;
            				tan2[i3 * 3 + 2] += tdir.z;
            		}
            		var t11 = new Vec3();
            		var t21 = new Vec3();
            		var n = new Vec3();
            		var temp = new Vec3();
            		for(var i4 = 0; i4 < vertexCount; i4++){
            				n.set(normals[i4 * 3], normals[i4 * 3 + 1], normals[i4 * 3 + 2]);
            				t11.set(tan1[i4 * 3], tan1[i4 * 3 + 1], tan1[i4 * 3 + 2]);
            				t21.set(tan2[i4 * 3], tan2[i4 * 3 + 1], tan2[i4 * 3 + 2]);
            				var ndott = n.dot(t11);
            				temp.copy(n).mulScalar(ndott);
            				temp.sub2(t11, temp).normalize();
            				tangents[i4 * 4] = temp.x;
            				tangents[i4 * 4 + 1] = temp.y;
            				tangents[i4 * 4 + 2] = temp.z;
            				temp.cross(n, t11);
            				tangents[i4 * 4 + 3] = temp.dot(t21) < 0.0 ? -1 : 1.0;
            		}
            		return tangents;
            };
            
            class Geometry {
            		calculateNormals() {
            				this.normals = calculateNormals(this.positions, this.indices);
            		}
            		calculateTangents() {
            				this.tangents = calculateTangents(this.positions, this.normals, this.uvs, this.indices);
            		}
            }
            
            var primitiveUv1Padding$1 = 4.0 / 64;
            var primitiveUv1PaddingScale$1 = 1.0 - primitiveUv1Padding$1 * 2;
            class BoxGeometry extends Geometry {
            		constructor(opts = {}){
            				super();
            				var _opts_halfExtents;
            				var he = (_opts_halfExtents = opts.halfExtents) != null ? _opts_halfExtents : new Vec3(0.5, 0.5, 0.5);
            				var _opts_widthSegments;
            				var ws = (_opts_widthSegments = opts.widthSegments) != null ? _opts_widthSegments : 1;
            				var _opts_lengthSegments;
            				var ls = (_opts_lengthSegments = opts.lengthSegments) != null ? _opts_lengthSegments : 1;
            				var _opts_heightSegments;
            				var hs = (_opts_heightSegments = opts.heightSegments) != null ? _opts_heightSegments : 1;
            				var _opts_yOffset;
            				var yOffset = (_opts_yOffset = opts.yOffset) != null ? _opts_yOffset : 0;
            				var minY = -he.y + yOffset;
            				var maxY = he.y + yOffset;
            				var corners = [
            						new Vec3(-he.x, minY, he.z),
            						new Vec3(he.x, minY, he.z),
            						new Vec3(he.x, maxY, he.z),
            						new Vec3(-he.x, maxY, he.z),
            						new Vec3(he.x, minY, -he.z),
            						new Vec3(-he.x, minY, -he.z),
            						new Vec3(-he.x, maxY, -he.z),
            						new Vec3(he.x, maxY, -he.z)
            				];
            				var faceAxes = [
            						[
            								0,
            								1,
            								3
            						],
            						[
            								4,
            								5,
            								7
            						],
            						[
            								3,
            								2,
            								6
            						],
            						[
            								1,
            								0,
            								4
            						],
            						[
            								1,
            								4,
            								2
            						],
            						[
            								5,
            								0,
            								6
            						]
            				];
            				var faceNormals = [
            						[
            								0,
            								0,
            								1
            						],
            						[
            								0,
            								0,
            								-1
            						],
            						[
            								0,
            								1,
            								0
            						],
            						[
            								0,
            								-1,
            								0
            						],
            						[
            								1,
            								0,
            								0
            						],
            						[
            								-1,
            								0,
            								0
            						]
            				];
            				var sides = {
            						FRONT: 0,
            						BACK: 1,
            						TOP: 2,
            						BOTTOM: 3,
            						RIGHT: 4,
            						LEFT: 5
            				};
            				var positions = [];
            				var normals = [];
            				var uvs = [];
            				var indices = [];
            				var vcounter = 0;
            				var generateFace = (side, uSegments, vSegments)=>{
            						var temp1 = new Vec3();
            						var temp2 = new Vec3();
            						var temp3 = new Vec3();
            						var r = new Vec3();
            						for(var i = 0; i <= uSegments; i++){
            								for(var j = 0; j <= vSegments; j++){
            										temp1.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][1]], i / uSegments);
            										temp2.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][2]], j / vSegments);
            										temp3.sub2(temp2, corners[faceAxes[side][0]]);
            										r.add2(temp1, temp3);
            										var u = i / uSegments;
            										var v = j / vSegments;
            										positions.push(r.x, r.y, r.z);
            										normals.push(faceNormals[side][0], faceNormals[side][1], faceNormals[side][2]);
            										uvs.push(u, 1 - v);
            										u = u * primitiveUv1PaddingScale$1 + primitiveUv1Padding$1;
            										v = v * primitiveUv1PaddingScale$1 + primitiveUv1Padding$1;
            										u /= 3;
            										v /= 3;
            										u += side % 3 / 3;
            										v += Math.floor(side / 3) / 3;
            										if (i < uSegments && j < vSegments) {
            												indices.push(vcounter + vSegments + 1, vcounter + 1, vcounter);
            												indices.push(vcounter + vSegments + 1, vcounter + vSegments + 2, vcounter + 1);
            										}
            										vcounter++;
            								}
            						}
            				};
            				generateFace(sides.FRONT, ws, hs);
            				generateFace(sides.BACK, ws, hs);
            				generateFace(sides.TOP, ws, ls);
            				generateFace(sides.BOTTOM, ws, ls);
            				generateFace(sides.RIGHT, ls, hs);
            				generateFace(sides.LEFT, ls, hs);
            				this.positions = positions;
            				this.normals = normals;
            				this.uvs = uvs;
            				this.uvs1 = uvs;
            				this.indices = indices;
            				if (opts.calculateTangents) {
            						this.tangents = calculateTangents(positions, normals, uvs, indices);
            				}
            		}
            }
            
            class SphereGeometry extends Geometry {
            		constructor(opts = {}){
            				super();
            				var _opts_radius;
            				var radius = (_opts_radius = opts.radius) != null ? _opts_radius : 0.5;
            				var _opts_latitudeBands;
            				var latitudeBands = (_opts_latitudeBands = opts.latitudeBands) != null ? _opts_latitudeBands : 16;
            				var _opts_longitudeBands;
            				var longitudeBands = (_opts_longitudeBands = opts.longitudeBands) != null ? _opts_longitudeBands : 16;
            				var positions = [];
            				var normals = [];
            				var uvs = [];
            				var indices = [];
            				for(var lat = 0; lat <= latitudeBands; lat++){
            						var theta = lat * Math.PI / latitudeBands;
            						var sinTheta = Math.sin(theta);
            						var cosTheta = Math.cos(theta);
            						for(var lon = 0; lon <= longitudeBands; lon++){
            								var phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;
            								var sinPhi = Math.sin(phi);
            								var cosPhi = Math.cos(phi);
            								var x = cosPhi * sinTheta;
            								var y = cosTheta;
            								var z = sinPhi * sinTheta;
            								var u = 1 - lon / longitudeBands;
            								var v = 1 - lat / latitudeBands;
            								positions.push(x * radius, y * radius, z * radius);
            								normals.push(x, y, z);
            								uvs.push(u, 1 - v);
            						}
            				}
            				for(var lat1 = 0; lat1 < latitudeBands; ++lat1){
            						for(var lon1 = 0; lon1 < longitudeBands; ++lon1){
            								var first = lat1 * (longitudeBands + 1) + lon1;
            								var second = first + longitudeBands + 1;
            								indices.push(first + 1, second, first);
            								indices.push(first + 1, second + 1, second);
            						}
            				}
            				this.positions = positions;
            				this.normals = normals;
            				this.uvs = uvs;
            				this.uvs1 = uvs;
            				this.indices = indices;
            				if (opts.calculateTangents) {
            						this.tangents = calculateTangents(positions, normals, uvs, indices);
            				}
            		}
            }
            
            class DomeGeometry extends SphereGeometry {
            		constructor(opts = {}){
            				var radius = 0.5;
            				var _opts_latitudeBands;
            				var latitudeBands = (_opts_latitudeBands = opts.latitudeBands) != null ? _opts_latitudeBands : 16;
            				var _opts_longitudeBands;
            				var longitudeBands = (_opts_longitudeBands = opts.longitudeBands) != null ? _opts_longitudeBands : 16;
            				super({
            						radius,
            						latitudeBands,
            						longitudeBands
            				});
            				var bottomLimit = 0.1;
            				var curvatureRadius = 0.95;
            				var curvatureRadiusSq = curvatureRadius * curvatureRadius;
            				var positions = this.positions;
            				for(var i = 0; i < positions.length; i += 3){
            						var x = positions[i] / radius;
            						var y = positions[i + 1] / radius;
            						var z = positions[i + 2] / radius;
            						if (y < 0) {
            								y *= 0.3;
            								if (x * x + z * z < curvatureRadiusSq) {
            										y = -0.1;
            								}
            						}
            						y += bottomLimit;
            						y *= radius;
            						positions[i + 1] = y;
            				}
            		}
            }
            
            class SkyGeometry {
            		static create(device, type) {
            				switch(type){
            						case SKYTYPE_BOX:
            								return SkyGeometry.box(device);
            						case SKYTYPE_DOME:
            								return SkyGeometry.dome(device);
            				}
            				return SkyGeometry.infinite(device);
            		}
            		static infinite(device) {
            				return Mesh.fromGeometry(device, new BoxGeometry(device));
            		}
            		static box(device) {
            				return Mesh.fromGeometry(device, new BoxGeometry({
            						yOffset: 0.5
            				}));
            		}
            		static dome(device) {
            				var geom = new DomeGeometry({
            						latitudeBands: 50,
            						longitudeBands: 50
            				});
            				geom.normals = undefined;
            				geom.uvs = undefined;
            				return Mesh.fromGeometry(device, geom);
            		}
            }
            
            class SkyMesh {
            		destroy() {
            				if (this.meshInstance) {
            						if (this.skyLayer) {
            								this.skyLayer.removeMeshInstances([
            										this.meshInstance
            								]);
            						}
            						this.meshInstance.destroy();
            						this.meshInstance = null;
            				}
            		}
            		constructor(device, scene, node, texture, type){
            				this.meshInstance = null;
            				var material = new ShaderMaterial({
            						uniqueName: 'SkyMaterial',
            						vertexGLSL: shaderChunks.skyboxVS,
            						fragmentGLSL: shaderChunks.skyboxPS,
            						vertexWGSL: shaderChunksWGSL.skyboxVS,
            						fragmentWGSL: shaderChunksWGSL.skyboxPS,
            						attributes: {
            								aPosition: SEMANTIC_POSITION
            						}
            				});
            				material.setDefine('{SKYBOX_DECODE_FNC}', ChunkUtils.decodeFunc(texture.encoding));
            				if (type !== SKYTYPE_INFINITE) material.setDefine('SKYMESH', '');
            				if (texture.cubemap) material.setDefine('SKY_CUBEMAP', '');
            				material.setParameter('skyboxHighlightMultiplier', scene.skyboxHighlightMultiplier);
            				if (texture.cubemap) {
            						material.setParameter('texture_cubeMap', texture);
            				} else {
            						material.setParameter('texture_envAtlas', texture);
            						material.setParameter('mipLevel', scene.skyboxMip);
            				}
            				material.cull = CULLFACE_FRONT;
            				material.depthWrite = false;
            				var skyLayer = scene.layers.getLayerById(LAYERID_SKYBOX);
            				if (skyLayer) {
            						var mesh = SkyGeometry.create(device, type);
            						var meshInstance = new MeshInstance(mesh, material, node);
            						this.meshInstance = meshInstance;
            						meshInstance.cull = false;
            						meshInstance.pick = false;
            						skyLayer.addMeshInstances([
            								meshInstance
            						]);
            						this.skyLayer = skyLayer;
            				}
            		}
            }
            
            class Sky {
            		applySettings(render) {
            				var _render_skyType;
            				this.type = (_render_skyType = render.skyType) != null ? _render_skyType : SKYTYPE_INFINITE;
            				var _render_skyMeshPosition;
            				this.node.setLocalPosition(new Vec3((_render_skyMeshPosition = render.skyMeshPosition) != null ? _render_skyMeshPosition : [
            						0,
            						0,
            						0
            				]));
            				var _render_skyMeshRotation;
            				this.node.setLocalEulerAngles(new Vec3((_render_skyMeshRotation = render.skyMeshRotation) != null ? _render_skyMeshRotation : [
            						0,
            						0,
            						0
            				]));
            				var _render_skyMeshScale;
            				this.node.setLocalScale(new Vec3((_render_skyMeshScale = render.skyMeshScale) != null ? _render_skyMeshScale : [
            						1,
            						1,
            						1
            				]));
            				if (render.skyCenter) {
            						this._center = new Vec3(render.skyCenter);
            				}
            		}
            		set type(value) {
            				if (this._type !== value) {
            						this._type = value;
            						this.scene.updateShaders = true;
            						this.updateSkyMesh();
            				}
            		}
            		get type() {
            				return this._type;
            		}
            		set center(value) {
            				this._center.copy(value);
            		}
            		get center() {
            				return this._center;
            		}
            		updateSkyMesh() {
            				var texture = this.scene._getSkyboxTex();
            				if (texture) {
            						this.resetSkyMesh();
            						this.skyMesh = new SkyMesh(this.device, this.scene, this.node, texture, this.type);
            						this.scene.fire('set:skybox', texture);
            				}
            		}
            		resetSkyMesh() {
            				var _this_skyMesh;
            				(_this_skyMesh = this.skyMesh) == null ? void 0 : _this_skyMesh.destroy();
            				this.skyMesh = null;
            		}
            		update() {
            				if (this.type !== SKYTYPE_INFINITE) {
            						var { center, centerArray } = this;
            						var temp = new Vec3();
            						this.node.getWorldTransform().transformPoint(center, temp);
            						centerArray[0] = temp.x;
            						centerArray[1] = temp.y;
            						centerArray[2] = temp.z;
            						this.projectedSkydomeCenterId.setValue(centerArray);
            				}
            		}
            		constructor(scene){
            				this._type = SKYTYPE_INFINITE;
            				this._center = new Vec3(0, 1, 0);
            				this.skyMesh = null;
            				this.node = new GraphNode('SkyMeshNode');
            				this.device = scene.device;
            				this.scene = scene;
            				this.center = new Vec3(0, 1, 0);
            				this.centerArray = new Float32Array(3);
            				this.projectedSkydomeCenterId = this.device.scope.resolve('projectedSkydomeCenter');
            		}
            }
            
            var identityGraphNode = new GraphNode();
            identityGraphNode.worldTransform = Mat4.IDENTITY;
            identityGraphNode._dirtyWorld = identityGraphNode._dirtyNormal = false;
            class ImmediateBatch {
            		addLines(positions, color) {
            				var destPos = this.positions;
            				var count = positions.length;
            				for(var i = 0; i < count; i++){
            						var pos = positions[i];
            						destPos.push(pos.x, pos.y, pos.z);
            				}
            				var destCol = this.colors;
            				if (color.length) {
            						for(var i1 = 0; i1 < count; i1++){
            								var col = color[i1];
            								destCol.push(col.r, col.g, col.b, col.a);
            						}
            				} else {
            						for(var i2 = 0; i2 < count; i2++){
            								destCol.push(color.r, color.g, color.b, color.a);
            						}
            				}
            		}
            		addLinesArrays(positions, color) {
            				var destPos = this.positions;
            				for(var i = 0; i < positions.length; i += 3){
            						destPos.push(positions[i], positions[i + 1], positions[i + 2]);
            				}
            				var destCol = this.colors;
            				if (color.length) {
            						for(var i1 = 0; i1 < color.length; i1 += 4){
            								destCol.push(color[i1], color[i1 + 1], color[i1 + 2], color[i1 + 3]);
            						}
            				} else {
            						var count = positions.length / 3;
            						for(var i2 = 0; i2 < count; i2++){
            								destCol.push(color.r, color.g, color.b, color.a);
            						}
            				}
            		}
            		onPreRender(visibleList, transparent) {
            				if (this.positions.length > 0 && this.material.transparent === transparent) {
            						this.mesh.setPositions(this.positions);
            						this.mesh.setColors(this.colors);
            						this.mesh.update(PRIMITIVE_LINES, false);
            						if (!this.meshInstance) {
            								this.meshInstance = new MeshInstance(this.mesh, this.material, identityGraphNode);
            						}
            						visibleList.push(this.meshInstance);
            				}
            		}
            		clear() {
            				this.positions.length = 0;
            				this.colors.length = 0;
            		}
            		constructor(device, material, layer){
            				this.material = material;
            				this.layer = layer;
            				this.positions = [];
            				this.colors = [];
            				this.mesh = new Mesh(device);
            				this.meshInstance = null;
            		}
            }
            
            class ImmediateBatches {
            		getBatch(material, layer) {
            				var batch = this.map.get(material);
            				if (!batch) {
            						batch = new ImmediateBatch(this.device, material, layer);
            						this.map.set(material, batch);
            				}
            				return batch;
            		}
            		onPreRender(visibleList, transparent) {
            				this.map.forEach((batch)=>{
            						batch.onPreRender(visibleList, transparent);
            				});
            		}
            		clear() {
            				this.map.forEach((batch)=>batch.clear());
            		}
            		constructor(device){
            				this.device = device;
            				this.map = new Map();
            		}
            }
            
            var tempPoints = [];
            var vec = new Vec3();
            var lineShaderDesc = {
            		uniqueName: 'ImmediateLine',
            		vertexGLSL: shaderChunks.immediateLineVS,
            		fragmentGLSL: shaderChunks.immediateLinePS,
            		vertexWGSL: shaderChunksWGSL.immediateLineVS,
            		fragmentWGSL: shaderChunksWGSL.immediateLinePS,
            		attributes: {
            				vertex_position: SEMANTIC_POSITION,
            				vertex_color: SEMANTIC_COLOR
            		}
            };
            class Immediate {
            		createMaterial(depthTest) {
            				var material = new ShaderMaterial(lineShaderDesc);
            				material.blendType = BLEND_NORMAL;
            				material.depthTest = depthTest;
            				material.update();
            				return material;
            		}
            		get materialDepth() {
            				if (!this._materialDepth) {
            						this._materialDepth = this.createMaterial(true);
            				}
            				return this._materialDepth;
            		}
            		get materialNoDepth() {
            				if (!this._materialNoDepth) {
            						this._materialNoDepth = this.createMaterial(false);
            				}
            				return this._materialNoDepth;
            		}
            		getBatch(layer, depthTest) {
            				var batches = this.batchesMap.get(layer);
            				if (!batches) {
            						batches = new ImmediateBatches(this.device);
            						this.batchesMap.set(layer, batches);
            				}
            				this.allBatches.add(batches);
            				var material = depthTest ? this.materialDepth : this.materialNoDepth;
            				return batches.getBatch(material, layer);
            		}
            		getShaderDesc(id, fragment) {
            				if (!this.shaderDescs.has(id)) {
            						var vertex = "\n				attribute vec2 vertex_position;\n				uniform mat4 matrix_model;\n				varying vec2 uv0;\n				void main(void) {\n					gl_Position = matrix_model * vec4(vertex_position, 0, 1);\n					uv0 = vertex_position.xy + 0.5;\n				}\n			";
            						this.shaderDescs.set(id, {
            								uniqueName: "DebugShader:" + id,
            								vertexGLSL: vertex,
            								fragmentGLSL: fragment,
            								attributes: {
            										vertex_position: SEMANTIC_POSITION
            								}
            						});
            				}
            				return this.shaderDescs.get(id);
            		}
            		getTextureShaderDesc(encoding) {
            				var decodeFunc = ChunkUtils.decodeFunc(encoding);
            				return this.getShaderDesc("textureShader-" + encoding, '\n			#include "gammaPS"\n			varying vec2 uv0;\n			uniform sampler2D colorMap;\n			void main (void) {\n				vec3 linearColor = ' + decodeFunc + "(texture2D(colorMap, uv0));\n				gl_FragColor = vec4(gammaCorrectOutput(linearColor), 1);\n			}\n		");
            		}
            		getUnfilterableTextureShaderDesc() {
            				return this.getShaderDesc('textureShaderUnfilterable', "\n			varying vec2 uv0;\n			uniform highp sampler2D colorMap;\n			void main (void) {\n				ivec2 uv = ivec2(uv0 * textureSize(colorMap, 0));\n				gl_FragColor = vec4(texelFetch(colorMap, uv, 0).xyz, 1);\n			}\n		");
            		}
            		getDepthTextureShaderDesc() {
            				return this.getShaderDesc('depthTextureShader', "\n			" + shaderChunks.screenDepthPS + '\n			#include "gammaPS"\n			varying vec2 uv0;\n			void main() {\n				float depth = getLinearScreenDepth(getImageEffectUV(uv0)) * camera_params.x;\n				gl_FragColor = vec4(gammaCorrectOutput(vec3(depth)), 1.0);\n			}\n		');
            		}
            		getQuadMesh() {
            				if (!this.quadMesh) {
            						this.quadMesh = new Mesh(this.device);
            						this.quadMesh.setPositions([
            								-0.5,
            								-0.5,
            								0,
            								0.5,
            								-0.5,
            								0,
            								-0.5,
            								0.5,
            								0,
            								0.5,
            								0.5,
            								0
            						]);
            						this.quadMesh.update(PRIMITIVE_TRISTRIP);
            				}
            				return this.quadMesh;
            		}
            		drawMesh(material, matrix, mesh, meshInstance, layer) {
            				if (!meshInstance) {
            						var graphNode = this.getGraphNode(matrix);
            						meshInstance = new MeshInstance(mesh, material, graphNode);
            				}
            				var layerMeshInstances = this.layerMeshInstances.get(layer);
            				if (!layerMeshInstances) {
            						layerMeshInstances = [];
            						this.layerMeshInstances.set(layer, layerMeshInstances);
            				}
            				layerMeshInstances.push(meshInstance);
            		}
            		drawWireAlignedBox(min, max, color, depthTest, layer, mat) {
            				if (mat) {
            						var mulPoint = (x, y, z)=>{
            								vec.set(x, y, z);
            								mat.transformPoint(vec, vec);
            								tempPoints.push(vec.x, vec.y, vec.z);
            						};
            						mulPoint(min.x, min.y, min.z);
            						mulPoint(min.x, max.y, min.z);
            						mulPoint(min.x, max.y, min.z);
            						mulPoint(max.x, max.y, min.z);
            						mulPoint(max.x, max.y, min.z);
            						mulPoint(max.x, min.y, min.z);
            						mulPoint(max.x, min.y, min.z);
            						mulPoint(min.x, min.y, min.z);
            						mulPoint(min.x, min.y, max.z);
            						mulPoint(min.x, max.y, max.z);
            						mulPoint(min.x, max.y, max.z);
            						mulPoint(max.x, max.y, max.z);
            						mulPoint(max.x, max.y, max.z);
            						mulPoint(max.x, min.y, max.z);
            						mulPoint(max.x, min.y, max.z);
            						mulPoint(min.x, min.y, max.z);
            						mulPoint(min.x, min.y, min.z);
            						mulPoint(min.x, min.y, max.z);
            						mulPoint(min.x, max.y, min.z);
            						mulPoint(min.x, max.y, max.z);
            						mulPoint(max.x, max.y, min.z);
            						mulPoint(max.x, max.y, max.z);
            						mulPoint(max.x, min.y, min.z);
            						mulPoint(max.x, min.y, max.z);
            				} else {
            						tempPoints.push(min.x, min.y, min.z, min.x, max.y, min.z, min.x, max.y, min.z, max.x, max.y, min.z, max.x, max.y, min.z, max.x, min.y, min.z, max.x, min.y, min.z, min.x, min.y, min.z, min.x, min.y, max.z, min.x, max.y, max.z, min.x, max.y, max.z, max.x, max.y, max.z, max.x, max.y, max.z, max.x, min.y, max.z, max.x, min.y, max.z, min.x, min.y, max.z, min.x, min.y, min.z, min.x, min.y, max.z, min.x, max.y, min.z, min.x, max.y, max.z, max.x, max.y, min.z, max.x, max.y, max.z, max.x, min.y, min.z, max.x, min.y, max.z);
            				}
            				var batch = this.getBatch(layer, depthTest);
            				batch.addLinesArrays(tempPoints, color);
            				tempPoints.length = 0;
            		}
            		drawWireSphere(center, radius, color, numSegments, depthTest, layer) {
            				var step = 2 * Math.PI / numSegments;
            				var angle = 0;
            				for(var i = 0; i < numSegments; i++){
            						var sin0 = Math.sin(angle);
            						var cos0 = Math.cos(angle);
            						angle += step;
            						var sin1 = Math.sin(angle);
            						var cos1 = Math.cos(angle);
            						tempPoints.push(center.x + radius * sin0, center.y, center.z + radius * cos0);
            						tempPoints.push(center.x + radius * sin1, center.y, center.z + radius * cos1);
            						tempPoints.push(center.x + radius * sin0, center.y + radius * cos0, center.z);
            						tempPoints.push(center.x + radius * sin1, center.y + radius * cos1, center.z);
            						tempPoints.push(center.x, center.y + radius * sin0, center.z + radius * cos0);
            						tempPoints.push(center.x, center.y + radius * sin1, center.z + radius * cos1);
            				}
            				var batch = this.getBatch(layer, depthTest);
            				batch.addLinesArrays(tempPoints, color);
            				tempPoints.length = 0;
            		}
            		getGraphNode(matrix) {
            				var graphNode = new GraphNode('ImmediateDebug');
            				graphNode.worldTransform = matrix;
            				graphNode._dirtyWorld = graphNode._dirtyNormal = false;
            				return graphNode;
            		}
            		onPreRenderLayer(layer, visibleList, transparent) {
            				this.batchesMap.forEach((batches, batchLayer)=>{
            						if (batchLayer === layer) {
            								batches.onPreRender(visibleList, transparent);
            						}
            				});
            				if (!this.updatedLayers.has(layer)) {
            						this.updatedLayers.add(layer);
            						var meshInstances = this.layerMeshInstances.get(layer);
            						if (meshInstances) {
            								for(var i = 0; i < meshInstances.length; i++){
            										visibleList.push(meshInstances[i]);
            								}
            								meshInstances.length = 0;
            						}
            				}
            		}
            		onPostRender() {
            				this.allBatches.forEach((batch)=>batch.clear());
            				this.allBatches.clear();
            				this.updatedLayers.clear();
            		}
            		constructor(device){
            				this.shaderDescs = new Map();
            				this.device = device;
            				this.quadMesh = null;
            				this.textureShader = null;
            				this.depthTextureShader = null;
            				this.cubeLocalPos = null;
            				this.cubeWorldPos = null;
            				this.batchesMap = new Map();
            				this.allBatches = new Set();
            				this.updatedLayers = new Set();
            				this._materialDepth = null;
            				this._materialNoDepth = null;
            				this.layerMeshInstances = new Map();
            		}
            }
            
            var _goldenAngle = 2.399963229728653;
            var random = {
            		circlePoint (point) {
            				var r = Math.sqrt(Math.random());
            				var theta = Math.random() * 2 * Math.PI;
            				point.x = r * Math.cos(theta);
            				point.y = r * Math.sin(theta);
            		},
            		circlePointDeterministic (point, index, numPoints) {
            				var theta = index * _goldenAngle;
            				var r = Math.sqrt(index) / Math.sqrt(numPoints);
            				point.x = r * Math.cos(theta);
            				point.y = r * Math.sin(theta);
            		},
            		spherePointDeterministic (point, index, numPoints, start, end) {
            				if (start === void 0) start = 0;
            				if (end === void 0) end = 1;
            				start = 1 - 2 * start;
            				end = 1 - 2 * end;
            				var y = math.lerp(start, end, index / numPoints);
            				var radius = Math.sqrt(1 - y * y);
            				var theta = _goldenAngle * index;
            				point.x = Math.cos(theta) * radius;
            				point.y = y;
            				point.z = Math.sin(theta) * radius;
            		},
            		radicalInverse (i) {
            				var bits = (i << 16 | i >>> 16) >>> 0;
            				bits = ((bits & 0x55555555) << 1 | (bits & 0xAAAAAAAA) >>> 1) >>> 0;
            				bits = ((bits & 0x33333333) << 2 | (bits & 0xCCCCCCCC) >>> 2) >>> 0;
            				bits = ((bits & 0x0F0F0F0F) << 4 | (bits & 0xF0F0F0F0) >>> 4) >>> 0;
            				bits = ((bits & 0x00FF00FF) << 8 | (bits & 0xFF00FF00) >>> 8) >>> 0;
            				return bits * 2.3283064365386963e-10;
            		}
            };
            
            var getProjectionName = (projection)=>{
            		switch(projection){
            				case TEXTUREPROJECTION_CUBE:
            						return 'Cubemap';
            				case TEXTUREPROJECTION_OCTAHEDRAL:
            						return 'Octahedral';
            				default:
            						return 'Equirect';
            		}
            };
            var packFloat32ToRGBA8 = (value, array, offset)=>{
            		if (value <= 0) {
            				array[offset + 0] = 0;
            				array[offset + 1] = 0;
            				array[offset + 2] = 0;
            				array[offset + 3] = 0;
            		} else if (value >= 1.0) {
            				array[offset + 0] = 255;
            				array[offset + 1] = 0;
            				array[offset + 2] = 0;
            				array[offset + 3] = 0;
            		} else {
            				var encX = 1 * value % 1;
            				var encY = 255 * value % 1;
            				var encZ = 65025 * value % 1;
            				var encW = 16581375.0 * value % 1;
            				encX -= encY / 255;
            				encY -= encZ / 255;
            				encZ -= encW / 255;
            				array[offset + 0] = Math.min(255, Math.floor(encX * 256));
            				array[offset + 1] = Math.min(255, Math.floor(encY * 256));
            				array[offset + 2] = Math.min(255, Math.floor(encZ * 256));
            				array[offset + 3] = Math.min(255, Math.floor(encW * 256));
            		}
            };
            var packSamples = (samples)=>{
            		var numSamples = samples.length;
            		var w = Math.min(numSamples, 512);
            		var h = Math.ceil(numSamples / w);
            		var data = new Uint8Array(w * h * 4);
            		var off = 0;
            		for(var i = 0; i < numSamples; i += 4){
            				packFloat32ToRGBA8(samples[i + 0] * 0.5 + 0.5, data, off + 0);
            				packFloat32ToRGBA8(samples[i + 1] * 0.5 + 0.5, data, off + 4);
            				packFloat32ToRGBA8(samples[i + 2] * 0.5 + 0.5, data, off + 8);
            				packFloat32ToRGBA8(samples[i + 3] / 8, data, off + 12);
            				off += 16;
            		}
            		return {
            				width: w,
            				height: h,
            				data: data
            		};
            };
            var hemisphereSamplePhong = (dstVec, x, y, specularPower)=>{
            		var phi = y * 2 * Math.PI;
            		var cosTheta = Math.pow(1 - x, 1 / (specularPower + 1));
            		var sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
            		dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();
            };
            var hemisphereSampleLambert = (dstVec, x, y)=>{
            		var phi = y * 2 * Math.PI;
            		var cosTheta = Math.sqrt(1 - x);
            		var sinTheta = Math.sqrt(x);
            		dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();
            };
            var hemisphereSampleGGX = (dstVec, x, y, a)=>{
            		var phi = y * 2 * Math.PI;
            		var cosTheta = Math.sqrt((1 - x) / (1 + (a * a - 1) * x));
            		var sinTheta = Math.sqrt(1 - cosTheta * cosTheta);
            		dstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();
            };
            var D_GGX = (NoH, linearRoughness)=>{
            		var a = NoH * linearRoughness;
            		var k = linearRoughness / (1.0 - NoH * NoH + a * a);
            		return k * k * (1 / Math.PI);
            };
            var generatePhongSamples = (numSamples, specularPower)=>{
            		var H = new Vec3();
            		var result = [];
            		for(var i = 0; i < numSamples; ++i){
            				hemisphereSamplePhong(H, i / numSamples, random.radicalInverse(i), specularPower);
            				result.push(H.x, H.y, H.z, 0);
            		}
            		return result;
            };
            var generateLambertSamples = (numSamples, sourceTotalPixels)=>{
            		var pixelsPerSample = sourceTotalPixels / numSamples;
            		var H = new Vec3();
            		var result = [];
            		for(var i = 0; i < numSamples; ++i){
            				hemisphereSampleLambert(H, i / numSamples, random.radicalInverse(i));
            				var pdf = H.z / Math.PI;
            				var mipLevel = 0.5 * Math.log2(pixelsPerSample / pdf);
            				result.push(H.x, H.y, H.z, mipLevel);
            		}
            		return result;
            };
            var requiredSamplesGGX = {
            		'16': {
            				'2': 26,
            				'8': 20,
            				'32': 17,
            				'128': 16,
            				'512': 16
            		},
            		'32': {
            				'2': 53,
            				'8': 40,
            				'32': 34,
            				'128': 32,
            				'512': 32
            		},
            		'128': {
            				'2': 214,
            				'8': 163,
            				'32': 139,
            				'128': 130,
            				'512': 128
            		},
            		'1024': {
            				'2': 1722,
            				'8': 1310,
            				'32': 1114,
            				'128': 1041,
            				'512': 1025
            		}
            };
            var getRequiredSamplesGGX = (numSamples, specularPower)=>{
            		var table = requiredSamplesGGX[numSamples];
            		return table && table[specularPower] || numSamples;
            };
            var generateGGXSamples = (numSamples, specularPower, sourceTotalPixels)=>{
            		var pixelsPerSample = sourceTotalPixels / numSamples;
            		var roughness = 1 - Math.log2(specularPower) / 11.0;
            		var a = roughness * roughness;
            		var H = new Vec3();
            		var L = new Vec3();
            		var N = new Vec3(0, 0, 1);
            		var result = [];
            		var requiredSamples = getRequiredSamplesGGX(numSamples, specularPower);
            		for(var i = 0; i < requiredSamples; ++i){
            				hemisphereSampleGGX(H, i / requiredSamples, random.radicalInverse(i), a);
            				var NoH = H.z;
            				L.set(H.x, H.y, H.z).mulScalar(2 * NoH).sub(N);
            				if (L.z > 0) {
            						var pdf = D_GGX(Math.min(1, NoH), a) / 4 + 0.001;
            						var mipLevel = 0.5 * Math.log2(pixelsPerSample / pdf);
            						result.push(L.x, L.y, L.z, mipLevel);
            				}
            		}
            		while(result.length < numSamples * 4){
            				result.push(0, 0, 0, 0);
            		}
            		return result;
            };
            var createSamplesTex = (device, name, samples)=>{
            		var packedSamples = packSamples(samples);
            		return new Texture(device, {
            				name: name,
            				width: packedSamples.width,
            				height: packedSamples.height,
            				mipmaps: false,
            				minFilter: FILTER_NEAREST,
            				magFilter: FILTER_NEAREST,
            				levels: [
            						packedSamples.data
            				]
            		});
            };
            class SimpleCache {
            		destroy() {
            				if (this.destroyContent) {
            						this.map.forEach((value, key)=>{
            								value.destroy();
            						});
            				}
            		}
            		get(key, missFunc) {
            				if (!this.map.has(key)) {
            						var result = missFunc();
            						this.map.set(key, result);
            						return result;
            				}
            				return this.map.get(key);
            		}
            		constructor(destroyContent = true){
            				this.map = new Map();
            				this.destroyContent = destroyContent;
            		}
            }
            var samplesCache = new SimpleCache(false);
            var deviceCache$1 = new DeviceCache();
            var getCachedTexture = (device, key, getSamplesFnc)=>{
            		var cache = deviceCache$1.get(device, ()=>{
            				return new SimpleCache();
            		});
            		return cache.get(key, ()=>{
            				return createSamplesTex(device, key, samplesCache.get(key, getSamplesFnc));
            		});
            };
            var generateLambertSamplesTex = (device, numSamples, sourceTotalPixels)=>{
            		var key = "lambert-samples-" + numSamples + "-" + sourceTotalPixels;
            		return getCachedTexture(device, key, ()=>{
            				return generateLambertSamples(numSamples, sourceTotalPixels);
            		});
            };
            var generatePhongSamplesTex = (device, numSamples, specularPower)=>{
            		var key = "phong-samples-" + numSamples + "-" + specularPower;
            		return getCachedTexture(device, key, ()=>{
            				return generatePhongSamples(numSamples, specularPower);
            		});
            };
            var generateGGXSamplesTex = (device, numSamples, specularPower, sourceTotalPixels)=>{
            		var key = "ggx-samples-" + numSamples + "-" + specularPower + "-" + sourceTotalPixels;
            		return getCachedTexture(device, key, ()=>{
            				return generateGGXSamples(numSamples, specularPower, sourceTotalPixels);
            		});
            };
            function reprojectTexture(source, target, options) {
            		if (options === void 0) options = {};
            		var _options_rect, _options_rect1;
            		var _options_seamPixels;
            		var seamPixels = (_options_seamPixels = options.seamPixels) != null ? _options_seamPixels : 0;
            		var _options_rect_z;
            		var innerWidth = ((_options_rect_z = (_options_rect = options.rect) == null ? void 0 : _options_rect.z) != null ? _options_rect_z : target.width) - seamPixels * 2;
            		var _options_rect_w;
            		var innerHeight = ((_options_rect_w = (_options_rect1 = options.rect) == null ? void 0 : _options_rect1.w) != null ? _options_rect_w : target.height) - seamPixels * 2;
            		if (innerWidth < 1 || innerHeight < 1) {
            				return false;
            		}
            		var funcNames = {
            				'none': 'reproject',
            				'lambert': 'prefilterSamplesUnweighted',
            				'phong': 'prefilterSamplesUnweighted',
            				'ggx': 'prefilterSamples'
            		};
            		var specularPower = options.hasOwnProperty('specularPower') ? options.specularPower : 1;
            		var face = options.hasOwnProperty('face') ? options.face : null;
            		var distribution = options.hasOwnProperty('distribution') ? options.distribution : specularPower === 1 ? 'none' : 'phong';
            		var processFunc = funcNames[distribution] || 'reproject';
            		var prefilterSamples = processFunc.startsWith('prefilterSamples');
            		var decodeFunc = ChunkUtils.decodeFunc(source.encoding);
            		var encodeFunc = ChunkUtils.encodeFunc(target.encoding);
            		var sourceFunc = "sample" + getProjectionName(source.projection);
            		var targetFunc = "getDirection" + getProjectionName(target.projection);
            		var numSamples = options.hasOwnProperty('numSamples') ? options.numSamples : 1024;
            		var shaderKey = processFunc + "_" + decodeFunc + "_" + encodeFunc + "_" + sourceFunc + "_" + targetFunc + "_" + numSamples;
            		var device = source.device;
            		var shader = getProgramLibrary(device).getCachedShader(shaderKey);
            		if (!shader) {
            				var defines = "\n            " + (prefilterSamples ? '#define USE_SAMPLES_TEX' : '') + "\n            " + (source.cubemap ? '#define CUBEMAP_SOURCE' : '') + "\n            #define {PROCESS_FUNC} " + processFunc + "\n            #define {DECODE_FUNC} " + decodeFunc + "\n            #define {ENCODE_FUNC} " + encodeFunc + "\n            #define {SOURCE_FUNC} " + sourceFunc + "\n            #define {TARGET_FUNC} " + targetFunc + "\n            #define {NUM_SAMPLES} " + numSamples + "\n            #define {NUM_SAMPLES_SQRT} " + Math.round(Math.sqrt(numSamples)).toFixed(1) + "\n        ";
            				var wgsl = device.isWebGPU;
            				var chunks = wgsl ? shaderChunksWGSL : shaderChunks;
            				var includes = new Map();
            				includes.set('decodePS', chunks.decodePS);
            				includes.set('encodePS', chunks.encodePS);
            				var vert = chunks.reprojectVS;
            				var frag = chunks.reprojectPS;
            				shader = createShaderFromCode(device, vert, "\n                " + defines + "\n                " + frag + "\n            ", shaderKey, {
            						vertex_position: SEMANTIC_POSITION
            				}, {
            						fragmentIncludes: includes,
            						shaderLanguage: wgsl ? SHADERLANGUAGE_WGSL : SHADERLANGUAGE_GLSL
            				});
            		}
            		device.setBlendState(BlendState.NOBLEND);
            		var constantSource = device.scope.resolve(source.cubemap ? 'sourceCube' : 'sourceTex');
            		constantSource.setValue(source);
            		var constantParams = device.scope.resolve('params');
            		var uvModParam = device.scope.resolve('uvMod');
            		if (seamPixels > 0) {
            				uvModParam.setValue([
            						(innerWidth + seamPixels * 2) / innerWidth,
            						(innerHeight + seamPixels * 2) / innerHeight,
            						-seamPixels / innerWidth,
            						-seamPixels / innerHeight
            				]);
            		} else {
            				uvModParam.setValue([
            						1,
            						1,
            						0,
            						0
            				]);
            		}
            		var params = [
            				0,
            				target.width * target.height * (target.cubemap ? 6 : 1),
            				source.width * source.height * (source.cubemap ? 6 : 1)
            		];
            		if (prefilterSamples) {
            				var sourceTotalPixels = source.width * source.height * (source.cubemap ? 6 : 1);
            				var samplesTex = distribution === 'ggx' ? generateGGXSamplesTex(device, numSamples, specularPower, sourceTotalPixels) : distribution === 'lambert' ? generateLambertSamplesTex(device, numSamples, sourceTotalPixels) : generatePhongSamplesTex(device, numSamples, specularPower);
            				device.scope.resolve('samplesTex').setValue(samplesTex);
            				device.scope.resolve('samplesTexInverseSize').setValue([
            						1.0 / samplesTex.width,
            						1.0 / samplesTex.height
            				]);
            		}
            		for(var f = 0; f < (target.cubemap ? 6 : 1); f++){
            				if (face === null || f === face) {
            						var renderTarget = new RenderTarget({
            								colorBuffer: target,
            								face: f,
            								depth: false,
            								flipY: device.isWebGPU
            						});
            						params[0] = f;
            						constantParams.setValue(params);
            						drawQuadWithShader(device, renderTarget, shader, options == null ? void 0 : options.rect);
            						renderTarget.destroy();
            				}
            		}
            		return true;
            }
            
            var calcLevels = (width, height)=>{
            		if (height === void 0) height = 0;
            		return 1 + Math.floor(Math.log2(Math.max(width, height)));
            };
            var supportsFloat16 = (device)=>{
            		return device.textureHalfFloatRenderable;
            };
            var supportsFloat32 = (device)=>{
            		return device.textureFloatRenderable;
            };
            var lightingSourcePixelFormat = (device)=>{
            		return supportsFloat16(device) ? PIXELFORMAT_RGBA16F : supportsFloat32(device) ? PIXELFORMAT_RGBA32F : PIXELFORMAT_RGBA8;
            };
            var lightingPixelFormat = (device)=>{
            		return PIXELFORMAT_RGBA8;
            };
            var createCubemap = (device, size, format, mipmaps)=>{
            		return new Texture(device, {
            				name: "lighting-" + size,
            				cubemap: true,
            				width: size,
            				height: size,
            				format: format,
            				type: TEXTURETYPE_RGBP ,
            				addressU: ADDRESS_CLAMP_TO_EDGE,
            				addressV: ADDRESS_CLAMP_TO_EDGE,
            				mipmaps: false
            		});
            };
            class EnvLighting {
            		static generateSkyboxCubemap(source, size) {
            				var device = source.device;
            				var result = createCubemap(device, size || (source.cubemap ? source.width : source.width / 4), PIXELFORMAT_RGBA8);
            				reprojectTexture(source, result, {
            						numSamples: 1024
            				});
            				return result;
            		}
            		static generateLightingSource(source, options) {
            				var device = source.device;
            				var format = lightingSourcePixelFormat(device);
            				var result = (options == null ? void 0 : options.target) || new Texture(device, {
            						name: 'lighting-source',
            						cubemap: true,
            						width: (options == null ? void 0 : options.size) || 128,
            						height: (options == null ? void 0 : options.size) || 128,
            						format: format,
            						type: format === PIXELFORMAT_RGBA8 ? TEXTURETYPE_RGBP : TEXTURETYPE_DEFAULT,
            						addressU: ADDRESS_CLAMP_TO_EDGE,
            						addressV: ADDRESS_CLAMP_TO_EDGE,
            						mipmaps: true
            				});
            				reprojectTexture(source, result, {
            						numSamples: source.mipmaps ? 1 : 1024
            				});
            				return result;
            		}
            		static generateAtlas(source, options) {
            				var device = source.device;
            				var format = lightingPixelFormat();
            				var result = (options == null ? void 0 : options.target) || new Texture(device, {
            						name: 'envAtlas',
            						width: (options == null ? void 0 : options.size) || 512,
            						height: (options == null ? void 0 : options.size) || 512,
            						format: format,
            						type: TEXTURETYPE_RGBP ,
            						projection: TEXTUREPROJECTION_EQUIRECT,
            						addressU: ADDRESS_CLAMP_TO_EDGE,
            						addressV: ADDRESS_CLAMP_TO_EDGE,
            						mipmaps: false
            				});
            				var s = result.width / 512;
            				var rect = new Vec4(0, 0, 512 * s, 256 * s);
            				var levels = calcLevels(256) - calcLevels(4);
            				for(var i = 0; i < levels; ++i){
            						reprojectTexture(source, result, {
            								numSamples: 1,
            								rect: rect,
            								seamPixels: s
            						});
            						rect.x += rect.w;
            						rect.y += rect.w;
            						rect.z = Math.max(1, Math.floor(rect.z * 0.5));
            						rect.w = Math.max(1, Math.floor(rect.w * 0.5));
            				}
            				rect.set(0, 256 * s, 256 * s, 128 * s);
            				for(var i1 = 1; i1 < 7; ++i1){
            						reprojectTexture(source, result, {
            								numSamples: (options == null ? void 0 : options.numReflectionSamples) || 1024,
            								distribution: (options == null ? void 0 : options.distribution) || 'ggx',
            								specularPower: Math.max(1, 2048 >> i1 * 2),
            								rect: rect,
            								seamPixels: s
            						});
            						rect.y += rect.w;
            						rect.z = Math.max(1, Math.floor(rect.z * 0.5));
            						rect.w = Math.max(1, Math.floor(rect.w * 0.5));
            				}
            				rect.set(128 * s, (256 + 128) * s, 64 * s, 32 * s);
            				reprojectTexture(source, result, {
            						numSamples: (options == null ? void 0 : options.numAmbientSamples) || 2048,
            						distribution: 'lambert',
            						rect: rect,
            						seamPixels: s
            				});
            				return result;
            		}
            		static generatePrefilteredAtlas(sources, options) {
            				var device = sources[0].device;
            				var format = sources[0].format;
            				var type = sources[0].type;
            				var result = (options == null ? void 0 : options.target) || new Texture(device, {
            						name: 'envPrefilteredAtlas',
            						width: (options == null ? void 0 : options.size) || 512,
            						height: (options == null ? void 0 : options.size) || 512,
            						format: format,
            						type: type,
            						projection: TEXTUREPROJECTION_EQUIRECT,
            						addressU: ADDRESS_CLAMP_TO_EDGE,
            						addressV: ADDRESS_CLAMP_TO_EDGE,
            						mipmaps: false
            				});
            				var s = result.width / 512;
            				var rect = new Vec4(0, 0, 512 * s, 256 * s);
            				var levels = calcLevels(512);
            				for(var i = 0; i < levels; ++i){
            						reprojectTexture(sources[0], result, {
            								numSamples: 1,
            								rect: rect,
            								seamPixels: s
            						});
            						rect.x += rect.w;
            						rect.y += rect.w;
            						rect.z = Math.max(1, Math.floor(rect.z * 0.5));
            						rect.w = Math.max(1, Math.floor(rect.w * 0.5));
            				}
            				rect.set(0, 256 * s, 256 * s, 128 * s);
            				for(var i1 = 1; i1 < sources.length; ++i1){
            						reprojectTexture(sources[i1], result, {
            								numSamples: 1,
            								rect: rect,
            								seamPixels: s
            						});
            						rect.y += rect.w;
            						rect.z = Math.max(1, Math.floor(rect.z * 0.5));
            						rect.w = Math.max(1, Math.floor(rect.w * 0.5));
            				}
            				rect.set(128 * s, (256 + 128) * s, 64 * s, 32 * s);
            				if (options == null ? void 0 : options.legacyAmbient) {
            						reprojectTexture(sources[5], result, {
            								numSamples: 1,
            								rect: rect,
            								seamPixels: s
            						});
            				} else {
            						reprojectTexture(sources[0], result, {
            								numSamples: (options == null ? void 0 : options.numSamples) || 2048,
            								distribution: 'lambert',
            								rect: rect,
            								seamPixels: s
            						});
            				}
            				return result;
            		}
            }
            
            class FogParams {
            		constructor(){
            				this.type = FOG_NONE;
            				this.color = new Color(0, 0, 0);
            				this.density = 0;
            				this.start = 1;
            				this.end = 1000;
            		}
            }
            
            class Scene extends EventHandler {
            		get defaultDrawLayer() {
            				return this.layers.getLayerById(LAYERID_IMMEDIATE);
            		}
            		set ambientBakeNumSamples(value) {
            				this._ambientBakeNumSamples = math.clamp(Math.floor(value), 1, 255);
            		}
            		get ambientBakeNumSamples() {
            				return this._ambientBakeNumSamples;
            		}
            		set ambientBakeSpherePart(value) {
            				this._ambientBakeSpherePart = math.clamp(value, 0.001, 1);
            		}
            		get ambientBakeSpherePart() {
            				return this._ambientBakeSpherePart;
            		}
            		set clusteredLightingEnabled(value) {
            				if (this.device.isWebGPU && !value) {
            						return;
            				}
            				if (!this._clusteredLightingEnabled && value) {
            						console.error('Turning on disabled clustered lighting is not currently supported');
            						return;
            				}
            				this._clusteredLightingEnabled = value;
            		}
            		get clusteredLightingEnabled() {
            				return this._clusteredLightingEnabled;
            		}
            		set envAtlas(value) {
            				if (value !== this._envAtlas) {
            						this._envAtlas = value;
            						if (value) {
            								value.addressU = ADDRESS_CLAMP_TO_EDGE;
            								value.addressV = ADDRESS_CLAMP_TO_EDGE;
            								value.minFilter = FILTER_LINEAR;
            								value.magFilter = FILTER_LINEAR;
            								value.mipmaps = false;
            						}
            						this._prefilteredCubemaps = [];
            						if (this._internalEnvAtlas) {
            								this._internalEnvAtlas.destroy();
            								this._internalEnvAtlas = null;
            						}
            						this._resetSkyMesh();
            				}
            		}
            		get envAtlas() {
            				return this._envAtlas;
            		}
            		set layers(layers) {
            				var prev = this._layers;
            				this._layers = layers;
            				this.fire('set:layers', prev, layers);
            		}
            		get layers() {
            				return this._layers;
            		}
            		get sky() {
            				return this._sky;
            		}
            		get lighting() {
            				return this._lightingParams;
            		}
            		get fog() {
            				return this._fogParams;
            		}
            		set lightmapFilterRange(value) {
            				this._lightmapFilterRange = Math.max(value, 0.001);
            		}
            		get lightmapFilterRange() {
            				return this._lightmapFilterRange;
            		}
            		set lightmapFilterSmoothness(value) {
            				this._lightmapFilterSmoothness = Math.max(value, 0.001);
            		}
            		get lightmapFilterSmoothness() {
            				return this._lightmapFilterSmoothness;
            		}
            		set prefilteredCubemaps(value) {
            				value = value || [];
            				var cubemaps = this._prefilteredCubemaps;
            				var changed = cubemaps.length !== value.length || cubemaps.some((c, i)=>c !== value[i]);
            				if (changed) {
            						var complete = value.length === 6 && value.every((c)=>!!c);
            						if (complete) {
            								this._internalEnvAtlas = EnvLighting.generatePrefilteredAtlas(value, {
            										target: this._internalEnvAtlas
            								});
            								this._envAtlas = this._internalEnvAtlas;
            						} else {
            								if (this._internalEnvAtlas) {
            										this._internalEnvAtlas.destroy();
            										this._internalEnvAtlas = null;
            								}
            								this._envAtlas = null;
            						}
            						this._prefilteredCubemaps = value.slice();
            						this._resetSkyMesh();
            				}
            		}
            		get prefilteredCubemaps() {
            				return this._prefilteredCubemaps;
            		}
            		set skybox(value) {
            				if (value !== this._skyboxCubeMap) {
            						this._skyboxCubeMap = value;
            						this._resetSkyMesh();
            				}
            		}
            		get skybox() {
            				return this._skyboxCubeMap;
            		}
            		set skyboxIntensity(value) {
            				if (value !== this._skyboxIntensity) {
            						this._skyboxIntensity = value;
            						this._resetSkyMesh();
            				}
            		}
            		get skyboxIntensity() {
            				return this._skyboxIntensity;
            		}
            		set skyboxLuminance(value) {
            				if (value !== this._skyboxLuminance) {
            						this._skyboxLuminance = value;
            						this._resetSkyMesh();
            				}
            		}
            		get skyboxLuminance() {
            				return this._skyboxLuminance;
            		}
            		set skyboxMip(value) {
            				if (value !== this._skyboxMip) {
            						this._skyboxMip = value;
            						this._resetSkyMesh();
            				}
            		}
            		get skyboxMip() {
            				return this._skyboxMip;
            		}
            		set skyboxHighlightMultiplier(value) {
            				if (value !== this._skyboxHighlightMultiplier) {
            						this._skyboxHighlightMultiplier = value;
            						this._resetSkyMesh();
            				}
            		}
            		get skyboxHighlightMultiplier() {
            				return this._skyboxHighlightMultiplier;
            		}
            		set skyboxRotation(value) {
            				if (!this._skyboxRotation.equals(value)) {
            						var isIdentity = value.equals(Quat.IDENTITY);
            						this._skyboxRotation.copy(value);
            						if (isIdentity) {
            								this._skyboxRotationMat3.setIdentity();
            						} else {
            								this._skyboxRotationMat4.setTRS(Vec3.ZERO, value, Vec3.ONE);
            								this._skyboxRotationMat3.invertMat4(this._skyboxRotationMat4);
            						}
            						if (!this._skyboxRotationShaderInclude && !isIdentity) {
            								this._skyboxRotationShaderInclude = true;
            								this._resetSkyMesh();
            						}
            				}
            		}
            		get skyboxRotation() {
            				return this._skyboxRotation;
            		}
            		destroy() {
            				this._resetSkyMesh();
            				this.root = null;
            				this.off();
            		}
            		drawLine(start, end, color, depthTest, layer) {
            				if (color === void 0) color = Color.WHITE;
            				if (depthTest === void 0) depthTest = true;
            				if (layer === void 0) layer = this.defaultDrawLayer;
            				var batch = this.immediate.getBatch(layer, depthTest);
            				batch.addLines([
            						start,
            						end
            				], [
            						color,
            						color
            				]);
            		}
            		drawLines(positions, colors, depthTest, layer) {
            				if (depthTest === void 0) depthTest = true;
            				if (layer === void 0) layer = this.defaultDrawLayer;
            				var batch = this.immediate.getBatch(layer, depthTest);
            				batch.addLines(positions, colors);
            		}
            		drawLineArrays(positions, colors, depthTest, layer) {
            				if (depthTest === void 0) depthTest = true;
            				if (layer === void 0) layer = this.defaultDrawLayer;
            				var batch = this.immediate.getBatch(layer, depthTest);
            				batch.addLinesArrays(positions, colors);
            		}
            		applySettings(settings) {
            				var physics = settings.physics;
            				var render = settings.render;
            				this._gravity.set(physics.gravity[0], physics.gravity[1], physics.gravity[2]);
            				this.ambientLight.set(render.global_ambient[0], render.global_ambient[1], render.global_ambient[2]);
            				this.ambientLuminance = render.ambientLuminance;
            				this.fog.type = render.fog;
            				this.fog.color.set(render.fog_color[0], render.fog_color[1], render.fog_color[2]);
            				this.fog.start = render.fog_start;
            				this.fog.end = render.fog_end;
            				this.fog.density = render.fog_density;
            				this.lightmapSizeMultiplier = render.lightmapSizeMultiplier;
            				this.lightmapMaxResolution = render.lightmapMaxResolution;
            				this.lightmapMode = render.lightmapMode;
            				this.exposure = render.exposure;
            				var _render_skyboxIntensity;
            				this._skyboxIntensity = (_render_skyboxIntensity = render.skyboxIntensity) != null ? _render_skyboxIntensity : 1;
            				var _render_skyboxLuminance;
            				this._skyboxLuminance = (_render_skyboxLuminance = render.skyboxLuminance) != null ? _render_skyboxLuminance : 20000;
            				var _render_skyboxMip;
            				this._skyboxMip = (_render_skyboxMip = render.skyboxMip) != null ? _render_skyboxMip : 0;
            				if (render.skyboxRotation) {
            						this.skyboxRotation = new Quat().setFromEulerAngles(render.skyboxRotation[0], render.skyboxRotation[1], render.skyboxRotation[2]);
            				}
            				this.sky.applySettings(render);
            				var _render_clusteredLightingEnabled;
            				this.clusteredLightingEnabled = (_render_clusteredLightingEnabled = render.clusteredLightingEnabled) != null ? _render_clusteredLightingEnabled : false;
            				this.lighting.applySettings(render);
            				[
            						'lightmapFilterEnabled',
            						'lightmapFilterRange',
            						'lightmapFilterSmoothness',
            						'ambientBake',
            						'ambientBakeNumSamples',
            						'ambientBakeSpherePart',
            						'ambientBakeOcclusionBrightness',
            						'ambientBakeOcclusionContrast'
            				].forEach((setting)=>{
            						if (render.hasOwnProperty(setting)) {
            								this[setting] = render[setting];
            						}
            				});
            				this._resetSkyMesh();
            		}
            		_getSkyboxTex() {
            				var cubemaps = this._prefilteredCubemaps;
            				if (this._skyboxMip) {
            						var skyboxMapping = [
            								0,
            								1,
            								3,
            								4,
            								5,
            								6
            						];
            						return cubemaps[skyboxMapping[this._skyboxMip]] || this._envAtlas || cubemaps[0] || this._skyboxCubeMap;
            				}
            				return this._skyboxCubeMap || cubemaps[0] || this._envAtlas;
            		}
            		_updateSkyMesh() {
            				if (!this.sky.skyMesh) {
            						this.sky.updateSkyMesh();
            				}
            				this.sky.update();
            		}
            		_resetSkyMesh() {
            				this.sky.resetSkyMesh();
            				this.updateShaders = true;
            		}
            		setSkybox(cubemaps) {
            				if (!cubemaps) {
            						this.skybox = null;
            						this.envAtlas = null;
            				} else {
            						this.skybox = cubemaps[0] || null;
            						if (cubemaps[1] && !cubemaps[1].cubemap) {
            								this.envAtlas = cubemaps[1];
            						} else {
            								this.prefilteredCubemaps = cubemaps.slice(1);
            						}
            				}
            		}
            		get lightmapPixelFormat() {
            				return this.lightmapHDR && this.device.getRenderableHdrFormat() || PIXELFORMAT_RGBA8;
            		}
            		constructor(graphicsDevice){
            				super(), this.ambientBake = false, this.ambientBakeOcclusionBrightness = 0, this.ambientBakeOcclusionContrast = 0, this.ambientLight = new Color(0, 0, 0), this.ambientLuminance = 0, this.exposure = 1, this.lightmapSizeMultiplier = 1, this.lightmapMaxResolution = 2048, this.lightmapMode = BAKE_COLORDIR, this.lightmapFilterEnabled = false, this.lightmapHDR = false, this.root = null, this.physicalUnits = false, this._envAtlas = null, this._skyboxCubeMap = null, this._fogParams = new FogParams(), this.forcePassThroughSpecular = false;
            				this.device = graphicsDevice;
            				this._gravity = new Vec3(0, -9.8, 0);
            				this._layers = null;
            				this._prefilteredCubemaps = [];
            				this._internalEnvAtlas = null;
            				this._skyboxIntensity = 1;
            				this._skyboxLuminance = 0;
            				this._skyboxMip = 0;
            				this._skyboxHighlightMultiplier = 1;
            				this._skyboxRotationShaderInclude = false;
            				this._skyboxRotation = new Quat();
            				this._skyboxRotationMat3 = new Mat3();
            				this._skyboxRotationMat4 = new Mat4();
            				this._ambientBakeNumSamples = 1;
            				this._ambientBakeSpherePart = 0.4;
            				this._lightmapFilterRange = 10;
            				this._lightmapFilterSmoothness = 0.2;
            				this._clusteredLightingEnabled = true;
            				this._lightingParams = new LightingParams(this.device.supportsAreaLights, this.device.maxTextureSize, ()=>{
            						this.updateShaders = true;
            				});
            				this._sky = new Sky(this);
            				this._stats = {
            						meshInstances: 0,
            						lights: 0,
            						dynamicLights: 0,
            						bakedLights: 0,
            						updateShadersTime: 0
            				};
            				this.updateShaders = true;
            				this._shaderVersion = 0;
            				this.immediate = new Immediate(this.device);
            		}
            }
            Scene.EVENT_SETLAYERS = 'set:layers';
            Scene.EVENT_SETSKYBOX = 'set:skybox';
            Scene.EVENT_PRERENDER = 'prerender';
            Scene.EVENT_POSTRENDER = 'postrender';
            Scene.EVENT_PRERENDER_LAYER = 'prerender:layer';
            Scene.EVENT_POSTRENDER_LAYER = 'postrender:layer';
            Scene.EVENT_PRECULL = 'precull';
            Scene.EVENT_POSTCULL = 'postcull';
            
            class Skin {
            		constructor(graphicsDevice, ibp, boneNames){
            				this.device = graphicsDevice;
            				this.inverseBindPose = ibp;
            				this.boneNames = boneNames;
            		}
            }
            
            var spriteNormals = [
            		0,
            		0,
            		1,
            		0,
            		0,
            		1,
            		0,
            		0,
            		1,
            		0,
            		0,
            		1
            ];
            var spriteIndices = [
            		0,
            		1,
            		3,
            		2,
            		3,
            		1
            ];
            class Sprite extends EventHandler {
            		set frameKeys(value) {
            				this._frameKeys = value;
            				if (this._atlas && this._frameKeys) {
            						if (this._updatingProperties) {
            								this._meshesDirty = true;
            						} else {
            								this._createMeshes();
            						}
            				}
            				this.fire('set:frameKeys', value);
            		}
            		get frameKeys() {
            				return this._frameKeys;
            		}
            		set atlas(value) {
            				if (value === this._atlas) return;
            				if (this._atlas) {
            						this._atlas.off('set:frames', this._onSetFrames, this);
            						this._atlas.off('set:frame', this._onFrameChanged, this);
            						this._atlas.off('remove:frame', this._onFrameRemoved, this);
            				}
            				this._atlas = value;
            				if (this._atlas && this._frameKeys) {
            						this._atlas.on('set:frames', this._onSetFrames, this);
            						this._atlas.on('set:frame', this._onFrameChanged, this);
            						this._atlas.on('remove:frame', this._onFrameRemoved, this);
            						if (this._updatingProperties) {
            								this._meshesDirty = true;
            						} else {
            								this._createMeshes();
            						}
            				}
            				this.fire('set:atlas', value);
            		}
            		get atlas() {
            				return this._atlas;
            		}
            		set pixelsPerUnit(value) {
            				if (this._pixelsPerUnit === value) return;
            				this._pixelsPerUnit = value;
            				this.fire('set:pixelsPerUnit', value);
            				if (this._atlas && this._frameKeys && this.renderMode === SPRITE_RENDERMODE_SIMPLE) {
            						if (this._updatingProperties) {
            								this._meshesDirty = true;
            						} else {
            								this._createMeshes();
            						}
            				}
            		}
            		get pixelsPerUnit() {
            				return this._pixelsPerUnit;
            		}
            		set renderMode(value) {
            				if (this._renderMode === value) {
            						return;
            				}
            				var prev = this._renderMode;
            				this._renderMode = value;
            				this.fire('set:renderMode', value);
            				if (prev === SPRITE_RENDERMODE_SIMPLE || value === SPRITE_RENDERMODE_SIMPLE) {
            						if (this._atlas && this._frameKeys) {
            								if (this._updatingProperties) {
            										this._meshesDirty = true;
            								} else {
            										this._createMeshes();
            								}
            						}
            				}
            		}
            		get renderMode() {
            				return this._renderMode;
            		}
            		get meshes() {
            				return this._meshes;
            		}
            		_createMeshes() {
            				var len = this._meshes.length;
            				for(var i = 0; i < len; i++){
            						var mesh = this._meshes[i];
            						if (mesh) {
            								mesh.destroy();
            						}
            				}
            				var count = this._frameKeys.length;
            				this._meshes = new Array(count);
            				var createMeshFunc = this.renderMode === SPRITE_RENDERMODE_SLICED || this._renderMode === SPRITE_RENDERMODE_TILED ? this._create9SliceMesh : this._createSimpleMesh;
            				for(var i1 = 0; i1 < count; i1++){
            						var frame = this._atlas.frames[this._frameKeys[i1]];
            						this._meshes[i1] = frame ? createMeshFunc.call(this, frame) : null;
            				}
            				this.fire('set:meshes');
            		}
            		_createSimpleMesh(frame) {
            				var rect = frame.rect;
            				var texWidth = this._atlas.texture.width;
            				var texHeight = this._atlas.texture.height;
            				var w = rect.z / this._pixelsPerUnit;
            				var h = rect.w / this._pixelsPerUnit;
            				var hp = frame.pivot.x;
            				var vp = frame.pivot.y;
            				var positions = [
            						-hp * w,
            						-vp * h,
            						0,
            						(1 - hp) * w,
            						-vp * h,
            						0,
            						(1 - hp) * w,
            						(1 - vp) * h,
            						0,
            						-hp * w,
            						(1 - vp) * h,
            						0
            				];
            				var lu = rect.x / texWidth;
            				var bv = 1.0 - rect.y / texHeight;
            				var ru = (rect.x + rect.z) / texWidth;
            				var tv = 1.0 - (rect.y + rect.w) / texHeight;
            				var uvs = [
            						lu,
            						bv,
            						ru,
            						bv,
            						ru,
            						tv,
            						lu,
            						tv
            				];
            				var geom = new Geometry();
            				geom.positions = positions;
            				geom.normals = spriteNormals;
            				geom.uvs = uvs;
            				geom.indices = spriteIndices;
            				return Mesh.fromGeometry(this._device, geom);
            		}
            		_create9SliceMesh() {
            				var he = Vec2.ONE;
            				var ws = 3;
            				var ls = 3;
            				var positions = [];
            				var normals = [];
            				var uvs = [];
            				var indices = [];
            				var vcounter = 0;
            				for(var i = 0; i <= ws; i++){
            						var u = i === 0 || i === ws ? 0 : 1;
            						for(var j = 0; j <= ls; j++){
            								var x = -he.x + 2.0 * he.x * (i <= 1 ? 0 : 3) / ws;
            								var y = 0.0;
            								var z = -(-he.y + 2.0 * he.y * (j <= 1 ? 0 : 3) / ls);
            								var v = j === 0 || j === ls ? 0 : 1;
            								positions.push(-x, y, z);
            								normals.push(0.0, 1.0, 0.0);
            								uvs.push(u, v);
            								if (i < ws && j < ls) {
            										indices.push(vcounter + ls + 1, vcounter + 1, vcounter);
            										indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);
            								}
            								vcounter++;
            						}
            				}
            				var geom = new Geometry();
            				geom.positions = positions;
            				geom.normals = normals;
            				geom.uvs = uvs;
            				geom.indices = indices;
            				return Mesh.fromGeometry(this._device, geom);
            		}
            		_onSetFrames(frames) {
            				if (this._updatingProperties) {
            						this._meshesDirty = true;
            				} else {
            						this._createMeshes();
            				}
            		}
            		_onFrameChanged(frameKey, frame) {
            				var idx = this._frameKeys.indexOf(frameKey);
            				if (idx < 0) return;
            				if (frame) {
            						if (this.renderMode === SPRITE_RENDERMODE_SIMPLE) {
            								this._meshes[idx] = this._createSimpleMesh(frame);
            						}
            				} else {
            						this._meshes[idx] = null;
            				}
            				this.fire('set:meshes');
            		}
            		_onFrameRemoved(frameKey) {
            				var idx = this._frameKeys.indexOf(frameKey);
            				if (idx < 0) return;
            				this._meshes[idx] = null;
            				this.fire('set:meshes');
            		}
            		startUpdate() {
            				this._updatingProperties = true;
            				this._meshesDirty = false;
            		}
            		endUpdate() {
            				this._updatingProperties = false;
            				if (this._meshesDirty && this._atlas && this._frameKeys) {
            						this._createMeshes();
            				}
            				this._meshesDirty = false;
            		}
            		destroy() {
            				for (var mesh of this._meshes){
            						if (mesh) {
            								mesh.destroy();
            						}
            				}
            				this._meshes.length = 0;
            		}
            		constructor(device, options){
            				super();
            				this._device = device;
            				this._pixelsPerUnit = options && options.pixelsPerUnit !== undefined ? options.pixelsPerUnit : 1;
            				this._renderMode = options && options.renderMode !== undefined ? options.renderMode : SPRITE_RENDERMODE_SIMPLE;
            				this._atlas = options && options.atlas !== undefined ? options.atlas : null;
            				this._frameKeys = options && options.frameKeys !== undefined ? options.frameKeys : null;
            				this._meshes = [];
            				this._updatingProperties = false;
            				this._meshesDirty = false;
            				if (this._atlas && this._frameKeys) {
            						this._createMeshes();
            				}
            		}
            }
            
            class TextureAtlas extends EventHandler {
            		set texture(value) {
            				this._texture = value;
            				this.fire('set:texture', value);
            		}
            		get texture() {
            				return this._texture;
            		}
            		set frames(value) {
            				this._frames = value;
            				this.fire('set:frames', value);
            		}
            		get frames() {
            				return this._frames;
            		}
            		setFrame(key, data) {
            				var frame = this._frames[key];
            				if (!frame) {
            						frame = {
            								rect: data.rect.clone(),
            								pivot: data.pivot.clone(),
            								border: data.border.clone()
            						};
            						this._frames[key] = frame;
            				} else {
            						frame.rect.copy(data.rect);
            						frame.pivot.copy(data.pivot);
            						frame.border.copy(data.border);
            				}
            				this.fire('set:frame', key.toString(), frame);
            		}
            		removeFrame(key) {
            				var frame = this._frames[key];
            				if (frame) {
            						delete this._frames[key];
            						this.fire('remove:frame', key.toString(), frame);
            				}
            		}
            		destroy() {
            				if (this._texture) {
            						this._texture.destroy();
            				}
            		}
            		constructor(){
            				super();
            				this._texture = null;
            				this._frames = null;
            		}
            }
            
            class Key {
            		constructor(time, position, rotation, scale){
            				this.time = time;
            				this.position = position;
            				this.rotation = rotation;
            				this.scale = scale;
            		}
            }
            class Node {
            		constructor(){
            				this._name = '';
            				this._keys = [];
            		}
            }
            class Animation {
            		getNode(name) {
            				return this._nodeDict[name];
            		}
            		addNode(node) {
            				this._nodes.push(node);
            				this._nodeDict[node._name] = node;
            		}
            		get nodes() {
            				return this._nodes;
            		}
            		constructor(){
            				this.name = '';
            				this.duration = 0;
            				this._nodes = [];
            				this._nodeDict = {};
            		}
            }
            
            class InterpolatedKey {
            		getTarget() {
            				return this._targetNode;
            		}
            		setTarget(node) {
            				this._targetNode = node;
            		}
            		constructor(){
            				this._written = false;
            				this._name = '';
            				this._keyFrames = [];
            				this._quat = new Quat();
            				this._pos = new Vec3();
            				this._scale = new Vec3();
            				this._targetNode = null;
            		}
            }
            class Skeleton {
            		set animation(value) {
            				this._animation = value;
            				this.currentTime = 0;
            		}
            		get animation() {
            				return this._animation;
            		}
            		set currentTime(value) {
            				this._time = value;
            				var numNodes = this._interpolatedKeys.length;
            				for(var i = 0; i < numNodes; i++){
            						var node = this._interpolatedKeys[i];
            						var nodeName = node._name;
            						this._currKeyIndices[nodeName] = 0;
            				}
            				this.addTime(0);
            				this.updateGraph();
            		}
            		get currentTime() {
            				return this._time;
            		}
            		get numNodes() {
            				return this._interpolatedKeys.length;
            		}
            		addTime(delta) {
            				if (this._animation !== null) {
            						var nodes = this._animation._nodes;
            						var duration = this._animation.duration;
            						if (this._time === duration && !this.looping) {
            								return;
            						}
            						this._time += delta;
            						if (this._time > duration) {
            								this._time = this.looping ? 0.0 : duration;
            								for(var i = 0; i < nodes.length; i++){
            										var node = nodes[i];
            										var nodeName = node._name;
            										this._currKeyIndices[nodeName] = 0;
            								}
            						} else if (this._time < 0) {
            								this._time = this.looping ? duration : 0.0;
            								for(var i1 = 0; i1 < nodes.length; i1++){
            										var node1 = nodes[i1];
            										var nodeName1 = node1._name;
            										this._currKeyIndices[nodeName1] = node1._keys.length - 2;
            								}
            						}
            						var offset = delta >= 0 ? 1 : -1;
            						for(var i2 = 0; i2 < nodes.length; i2++){
            								var node2 = nodes[i2];
            								var nodeName2 = node2._name;
            								var keys = node2._keys;
            								var interpKey = this._interpolatedKeyDict[nodeName2];
            								if (interpKey === undefined) {
            										continue;
            								}
            								var foundKey = false;
            								if (keys.length !== 1) {
            										for(var currKeyIndex = this._currKeyIndices[nodeName2]; currKeyIndex < keys.length - 1 && currKeyIndex >= 0; currKeyIndex += offset){
            												var k1 = keys[currKeyIndex];
            												var k2 = keys[currKeyIndex + 1];
            												if (k1.time <= this._time && k2.time >= this._time) {
            														var alpha = (this._time - k1.time) / (k2.time - k1.time);
            														interpKey._pos.lerp(k1.position, k2.position, alpha);
            														interpKey._quat.slerp(k1.rotation, k2.rotation, alpha);
            														interpKey._scale.lerp(k1.scale, k2.scale, alpha);
            														interpKey._written = true;
            														this._currKeyIndices[nodeName2] = currKeyIndex;
            														foundKey = true;
            														break;
            												}
            										}
            								}
            								if (keys.length === 1 || !foundKey && this._time === 0.0 && this.looping) {
            										interpKey._pos.copy(keys[0].position);
            										interpKey._quat.copy(keys[0].rotation);
            										interpKey._scale.copy(keys[0].scale);
            										interpKey._written = true;
            								}
            						}
            				}
            		}
            		blend(skel1, skel2, alpha) {
            				var numNodes = this._interpolatedKeys.length;
            				for(var i = 0; i < numNodes; i++){
            						var key1 = skel1._interpolatedKeys[i];
            						var key2 = skel2._interpolatedKeys[i];
            						var dstKey = this._interpolatedKeys[i];
            						if (key1._written && key2._written) {
            								dstKey._quat.slerp(key1._quat, skel2._interpolatedKeys[i]._quat, alpha);
            								dstKey._pos.lerp(key1._pos, skel2._interpolatedKeys[i]._pos, alpha);
            								dstKey._scale.lerp(key1._scale, key2._scale, alpha);
            								dstKey._written = true;
            						} else if (key1._written) {
            								dstKey._quat.copy(key1._quat);
            								dstKey._pos.copy(key1._pos);
            								dstKey._scale.copy(key1._scale);
            								dstKey._written = true;
            						} else if (key2._written) {
            								dstKey._quat.copy(key2._quat);
            								dstKey._pos.copy(key2._pos);
            								dstKey._scale.copy(key2._scale);
            								dstKey._written = true;
            						}
            				}
            		}
            		setGraph(graph) {
            				this.graph = graph;
            				if (graph) {
            						for(var i = 0; i < this._interpolatedKeys.length; i++){
            								var interpKey = this._interpolatedKeys[i];
            								var graphNode = graph.findByName(interpKey._name);
            								this._interpolatedKeys[i].setTarget(graphNode);
            						}
            				} else {
            						for(var i1 = 0; i1 < this._interpolatedKeys.length; i1++){
            								this._interpolatedKeys[i1].setTarget(null);
            						}
            				}
            		}
            		updateGraph() {
            				if (this.graph) {
            						for(var i = 0; i < this._interpolatedKeys.length; i++){
            								var interpKey = this._interpolatedKeys[i];
            								if (interpKey._written) {
            										var transform = interpKey.getTarget();
            										transform.localPosition.copy(interpKey._pos);
            										transform.localRotation.copy(interpKey._quat);
            										transform.localScale.copy(interpKey._scale);
            										if (!transform._dirtyLocal) {
            												transform._dirtifyLocal();
            										}
            										interpKey._written = false;
            								}
            						}
            				}
            		}
            		constructor(graph){
            				this.looping = true;
            				this._animation = null;
            				this._time = 0;
            				this._interpolatedKeys = [];
            				this._interpolatedKeyDict = {};
            				this._currKeyIndices = {};
            				this.graph = null;
            				var addInterpolatedKeys = (node)=>{
            						var interpKey = new InterpolatedKey();
            						interpKey._name = node.name;
            						this._interpolatedKeys.push(interpKey);
            						this._interpolatedKeyDict[node.name] = interpKey;
            						this._currKeyIndices[node.name] = 0;
            						for(var i = 0; i < node._children.length; i++){
            								addInterpolatedKeys(node._children[i]);
            						}
            				};
            				addInterpolatedKeys(graph);
            		}
            }
            
            class LitShaderOptions {
            		constructor(){
            				this.hasTangents = false;
            				this.chunks = {};
            				this.pass = 0;
            				this.alphaTest = false;
            				this.blendType = BLEND_NONE;
            				this.separateAmbient = false;
            				this.screenSpace = false;
            				this.skin = false;
            				this.batch = false;
            				this.useInstancing = false;
            				this.useMorphPosition = false;
            				this.useMorphNormal = false;
            				this.useMorphTextureBasedInt = false;
            				this.nineSlicedMode = 0;
            				this.clusteredLightingEnabled = true;
            				this.clusteredLightingCookiesEnabled = false;
            				this.clusteredLightingShadowsEnabled = false;
            				this.clusteredLightingShadowType = 0;
            				this.clusteredLightingAreaLightsEnabled = false;
            				this.vertexColors = false;
            				this.lightMapEnabled = false;
            				this.dirLightMapEnabled = false;
            				this.useHeights = false;
            				this.useNormals = false;
            				this.useClearCoatNormals = false;
            				this.useAo = false;
            				this.diffuseMapEnabled = false;
            				this.customFragmentShader = null;
            				this.pixelSnap = false;
            				this.ambientSH = false;
            				this.ssao = false;
            				this.twoSidedLighting = false;
            				this.occludeDirect = false;
            				this.occludeSpecular = 0;
            				this.occludeSpecularFloat = false;
            				this.useMsdf = false;
            				this.msdfTextAttribute = false;
            				this.alphaToCoverage = false;
            				this.opacityFadesSpecular = false;
            				this.opacityDither = DITHER_NONE;
            				this.opacityShadowDither = DITHER_NONE;
            				this.cubeMapProjection = 0;
            				this.useSpecular = false;
            				this.useSpecularityFactor = false;
            				this.enableGGXSpecular = false;
            				this.fresnelModel = 0;
            				this.useRefraction = false;
            				this.useClearCoat = false;
            				this.useSheen = false;
            				this.useIridescence = false;
            				this.useMetalness = false;
            				this.useDynamicRefraction = false;
            				this.dispersion = false;
            				this.fog = FOG_NONE;
            				this.gamma = GAMMA_NONE;
            				this.toneMap = -1;
            				this.reflectionSource = REFLECTIONSRC_NONE;
            				this.reflectionEncoding = null;
            				this.reflectionCubemapEncoding = null;
            				this.ambientSource = 'constant';
            				this.ambientEncoding = null;
            				this.skyboxIntensity = 1.0;
            				this.useCubeMapRotation = false;
            				this.lightMapWithoutAmbient = false;
            				this.lights = [];
            				this.noShadow = false;
            				this.lightMaskDynamic = 0x0;
            				this.userAttributes = {};
            				this.linearDepth = false;
            				this.shadowCatcher = false;
            		}
            }
            
            class LitMaterialOptionsBuilder {
            		static update(litOptions, material, scene, renderParams, objDefs, pass, sortedLights) {
            				LitMaterialOptionsBuilder.updateSharedOptions(litOptions, material, scene, objDefs, pass);
            				LitMaterialOptionsBuilder.updateMaterialOptions(litOptions, material);
            				LitMaterialOptionsBuilder.updateEnvOptions(litOptions, material, scene, renderParams);
            				LitMaterialOptionsBuilder.updateLightingOptions(litOptions, material, objDefs, sortedLights);
            		}
            		static updateSharedOptions(litOptions, material, scene, objDefs, pass) {
            				litOptions.chunks = material.chunks;
            				litOptions.pass = pass;
            				litOptions.alphaTest = material.alphaTest > 0;
            				litOptions.blendType = material.blendType;
            				litOptions.screenSpace = objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0;
            				litOptions.skin = objDefs && (objDefs & SHADERDEF_SKIN) !== 0;
            				litOptions.useInstancing = objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0;
            				litOptions.useMorphPosition = objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0;
            				litOptions.useMorphNormal = objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0;
            				litOptions.useMorphTextureBasedInt = objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED_INT) !== 0;
            				litOptions.hasTangents = objDefs && (objDefs & SHADERDEF_TANGENTS) !== 0;
            				litOptions.nineSlicedMode = material.nineSlicedMode || SPRITE_RENDERMODE_SIMPLE;
            				if (material.useLighting && scene.clusteredLightingEnabled) {
            						litOptions.clusteredLightingEnabled = true;
            						litOptions.clusteredLightingCookiesEnabled = scene.lighting.cookiesEnabled;
            						litOptions.clusteredLightingShadowsEnabled = scene.lighting.shadowsEnabled;
            						litOptions.clusteredLightingShadowType = scene.lighting.shadowType;
            						litOptions.clusteredLightingAreaLightsEnabled = scene.lighting.areaLightsEnabled;
            				} else {
            						litOptions.clusteredLightingEnabled = false;
            						litOptions.clusteredLightingCookiesEnabled = false;
            						litOptions.clusteredLightingShadowsEnabled = false;
            						litOptions.clusteredLightingAreaLightsEnabled = false;
            				}
            		}
            		static updateMaterialOptions(litOptions, material) {
            				litOptions.separateAmbient = false;
            				litOptions.customFragmentShader = null;
            				litOptions.pixelSnap = material.pixelSnap;
            				litOptions.ambientSH = material.ambientSH;
            				litOptions.twoSidedLighting = material.twoSidedLighting;
            				litOptions.occludeDirect = material.occludeDirect;
            				litOptions.occludeSpecular = material.occludeSpecular;
            				litOptions.occludeSpecularFloat = material.occludeSpecularIntensity !== 1.0;
            				litOptions.useMsdf = false;
            				litOptions.msdfTextAttribute = false;
            				litOptions.alphaToCoverage = material.alphaToCoverage;
            				litOptions.opacityFadesSpecular = material.opacityFadesSpecular;
            				litOptions.opacityDither = material.opacityDither;
            				litOptions.cubeMapProjection = CUBEPROJ_NONE;
            				litOptions.useSpecular = material.hasSpecular;
            				litOptions.useSpecularityFactor = material.hasSpecularityFactor;
            				litOptions.enableGGXSpecular = material.ggxSpecular;
            				litOptions.fresnelModel = material.fresnelModel;
            				litOptions.useRefraction = material.hasRefraction;
            				litOptions.useClearCoat = material.hasClearCoat;
            				litOptions.useSheen = material.hasSheen;
            				litOptions.useIridescence = material.hasIrridescence;
            				litOptions.useMetalness = material.hasMetalness;
            				litOptions.useDynamicRefraction = material.dynamicRefraction;
            				litOptions.dispersion = material.dispersion > 0;
            				litOptions.vertexColors = false;
            				litOptions.lightMapEnabled = material.hasLighting;
            				litOptions.dirLightMapEnabled = material.dirLightMap;
            				litOptions.useHeights = material.hasHeights;
            				litOptions.useNormals = material.hasNormals;
            				litOptions.useClearCoatNormals = material.hasClearCoatNormals;
            				litOptions.useAo = material.hasAo;
            				litOptions.diffuseMapEnabled = material.hasDiffuseMap;
            		}
            		static updateEnvOptions(litOptions, material, scene, renderParams) {
            				litOptions.fog = material.useFog ? renderParams.fog : FOG_NONE;
            				litOptions.gamma = renderParams.shaderOutputGamma;
            				litOptions.toneMap = material.useTonemap ? renderParams.toneMapping : TONEMAP_NONE;
            				if (material.useSkybox && scene.envAtlas && scene.skybox) {
            						litOptions.reflectionSource = REFLECTIONSRC_ENVATLASHQ;
            						litOptions.reflectionEncoding = scene.envAtlas.encoding;
            						litOptions.reflectionCubemapEncoding = scene.skybox.encoding;
            				} else if (material.useSkybox && scene.envAtlas) {
            						litOptions.reflectionSource = REFLECTIONSRC_ENVATLAS;
            						litOptions.reflectionEncoding = scene.envAtlas.encoding;
            				} else if (material.useSkybox && scene.skybox) {
            						litOptions.reflectionSource = REFLECTIONSRC_CUBEMAP;
            						litOptions.reflectionEncoding = scene.skybox.encoding;
            				} else {
            						litOptions.reflectionSource = REFLECTIONSRC_NONE;
            						litOptions.reflectionEncoding = null;
            				}
            				if (material.ambientSH) {
            						litOptions.ambientSource = AMBIENTSRC_AMBIENTSH;
            						litOptions.ambientEncoding = null;
            				} else if (litOptions.reflectionSource !== REFLECTIONSRC_NONE && scene.envAtlas) {
            						litOptions.ambientSource = AMBIENTSRC_ENVALATLAS;
            						litOptions.ambientEncoding = scene.envAtlas.encoding;
            				} else {
            						litOptions.ambientSource = AMBIENTSRC_CONSTANT;
            						litOptions.ambientEncoding = null;
            				}
            				var hasSkybox = litOptions.reflectionSource !== REFLECTIONSRC_NONE;
            				litOptions.skyboxIntensity = hasSkybox;
            				litOptions.useCubeMapRotation = hasSkybox && scene._skyboxRotationShaderInclude;
            		}
            		static updateLightingOptions(litOptions, material, objDefs, sortedLights) {
            				litOptions.lightMapWithoutAmbient = false;
            				if (material.useLighting) {
            						var lightsFiltered = [];
            						var mask = objDefs ? objDefs >> 16 : MASK_AFFECT_DYNAMIC;
            						litOptions.lightMaskDynamic = !!(mask & MASK_AFFECT_DYNAMIC);
            						litOptions.lightMapWithoutAmbient = false;
            						if (sortedLights) {
            								LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_DIRECTIONAL, sortedLights[LIGHTTYPE_DIRECTIONAL], lightsFiltered, mask);
            								LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_OMNI, sortedLights[LIGHTTYPE_OMNI], lightsFiltered, mask);
            								LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_SPOT, sortedLights[LIGHTTYPE_SPOT], lightsFiltered, mask);
            						}
            						litOptions.lights = lightsFiltered;
            				} else {
            						litOptions.lights = [];
            				}
            				if (litOptions.lights.length === 0 || (objDefs & SHADERDEF_NOSHADOW) !== 0) {
            						litOptions.noShadow = true;
            				}
            		}
            		static collectLights(lType, lights, lightsFiltered, mask) {
            				for(var i = 0; i < lights.length; i++){
            						var light = lights[i];
            						if (light.enabled) {
            								if (light.mask & mask) {
            										lightsFiltered.push(light);
            								}
            						}
            				}
            		}
            }
            
            var builtinAttributes = {
            		vertex_normal: SEMANTIC_NORMAL,
            		vertex_tangent: SEMANTIC_TANGENT,
            		vertex_texCoord0: SEMANTIC_TEXCOORD0,
            		vertex_texCoord1: SEMANTIC_TEXCOORD1,
            		vertex_color: SEMANTIC_COLOR,
            		vertex_boneWeights: SEMANTIC_BLENDWEIGHT,
            		vertex_boneIndices: SEMANTIC_BLENDINDICES
            };
            var varyingsWGSLTypes = new Map([
            		[
            				'vec4',
            				'vec4f'
            		],
            		[
            				'vec3',
            				'vec3f'
            		],
            		[
            				'vec2',
            				'vec2f'
            		],
            		[
            				'float',
            				'f32'
            		]
            ]);
            class LitShader {
            		fDefineSet(condition, name, value) {
            				if (value === void 0) value = '';
            				if (condition) {
            						this.fDefines.set(name, value);
            				}
            		}
            		generateVertexShader(useUv, useUnmodifiedUv, mapTransforms) {
            				var { options, vDefines, attributes } = this;
            				var varyings = new Map();
            				varyings.set('vPositionW', 'vec3');
            				if (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED || options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
            						vDefines.set('NINESLICED', true);
            				}
            				if (this.options.linearDepth) {
            						vDefines.set('LINEAR_DEPTH', true);
            						varyings.set('vLinearDepth', 'float');
            				}
            				if (this.needsNormal) vDefines.set('NORMALS', true);
            				if (this.options.useInstancing) {
            						if (this.chunks.transformInstancingVS === shaderChunks.transformInstancingVS) {
            								attributes.instance_line1 = SEMANTIC_ATTR12;
            								attributes.instance_line2 = SEMANTIC_ATTR13;
            								attributes.instance_line3 = SEMANTIC_ATTR14;
            								attributes.instance_line4 = SEMANTIC_ATTR15;
            						}
            				}
            				if (this.needsNormal) {
            						attributes.vertex_normal = SEMANTIC_NORMAL;
            						varyings.set('vNormalW', 'vec3');
            						if (options.hasTangents && (options.useHeights || options.useNormals || options.useClearCoatNormals || options.enableGGXSpecular)) {
            								vDefines.set('TANGENTS', true);
            								attributes.vertex_tangent = SEMANTIC_TANGENT;
            								varyings.set('vTangentW', 'vec3');
            								varyings.set('vBinormalW', 'vec3');
            						} else if (options.enableGGXSpecular) {
            								vDefines.set('GGX_SPECULAR', true);
            								varyings.set('vObjectSpaceUpW', 'vec3');
            						}
            				}
            				var maxUvSets = 2;
            				for(var i = 0; i < maxUvSets; i++){
            						if (useUv[i]) {
            								vDefines.set("UV" + i, true);
            								attributes["vertex_texCoord" + i] = "TEXCOORD" + i;
            						}
            						if (useUnmodifiedUv[i]) {
            								vDefines.set("UV" + i + "_UNMODIFIED", true);
            								varyings.set("vUv" + i, 'vec2');
            						}
            				}
            				var numTransforms = 0;
            				var transformDone = new Set();
            				mapTransforms.forEach((mapTransform)=>{
            						var { id, uv, name } = mapTransform;
            						var checkId = id + uv * 100;
            						if (!transformDone.has(checkId)) {
            								transformDone.add(checkId);
            								varyings.set("vUV" + uv + "_" + id, 'vec2');
            								var varName = "texture_" + name + "MapTransform";
            								vDefines.set("{TRANSFORM_NAME_" + numTransforms + "}", varName);
            								vDefines.set("{TRANSFORM_UV_" + numTransforms + "}", uv);
            								vDefines.set("{TRANSFORM_ID_" + numTransforms + "}", id);
            								numTransforms++;
            						}
            				});
            				vDefines.set('UV_TRANSFORMS_COUNT', numTransforms);
            				if (options.vertexColors) {
            						attributes.vertex_color = SEMANTIC_COLOR;
            						vDefines.set('VERTEX_COLOR', true);
            						varyings.set('vVertexColor', 'vec4');
            				}
            				if (options.useMsdf && options.msdfTextAttribute) {
            						attributes.vertex_outlineParameters = SEMANTIC_ATTR8;
            						attributes.vertex_shadowParameters = SEMANTIC_ATTR9;
            						vDefines.set('MSDF', true);
            				}
            				if (options.useMorphPosition || options.useMorphNormal) {
            						vDefines.set('MORPHING', true);
            						if (options.useMorphTextureBasedInt) vDefines.set('MORPHING_INT', true);
            						if (options.useMorphPosition) vDefines.set('MORPHING_POSITION', true);
            						if (options.useMorphNormal) vDefines.set('MORPHING_NORMAL', true);
            						attributes.morph_vertex_id = SEMANTIC_ATTR15;
            				}
            				if (options.skin) {
            						attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;
            						if (options.batch) {
            								vDefines.set('BATCH', true);
            						} else {
            								attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;
            								vDefines.set('SKIN', true);
            						}
            				}
            				if (options.useInstancing) vDefines.set('INSTANCING', true);
            				if (options.screenSpace) vDefines.set('SCREENSPACE', true);
            				if (options.pixelSnap) vDefines.set('PIXELSNAP', true);
            				varyings.forEach((type, name)=>{
            						vDefines.set("VARYING_" + name.toUpperCase(), true);
            						this.varyingsCode += this.shaderLanguage === SHADERLANGUAGE_WGSL ? "varying " + name + ": " + varyingsWGSLTypes.get(type) + ";\n" : "varying " + type + " " + name + ";\n";
            				});
            				this.vshader = "\n            " + this.varyingsCode + '\n            #include "litMainVS"\n        ';
            		}
            		_setupLightingDefines(hasAreaLights, clusteredLightingEnabled) {
            				var fDefines = this.fDefines;
            				var options = this.options;
            				this.fDefines.set('LIGHT_COUNT', options.lights.length);
            				if (hasAreaLights) fDefines.set('AREA_LIGHTS', true);
            				if (clusteredLightingEnabled && this.lighting) {
            						fDefines.set('LIT_CLUSTERED_LIGHTS', true);
            						if (options.clusteredLightingCookiesEnabled) fDefines.set('CLUSTER_COOKIES', true);
            						if (options.clusteredLightingAreaLightsEnabled) fDefines.set('CLUSTER_AREALIGHTS', true);
            						if (options.lightMaskDynamic) fDefines.set('CLUSTER_MESH_DYNAMIC_LIGHTS', true);
            						if (options.clusteredLightingShadowsEnabled && !options.noShadow) {
            								var clusteredShadowInfo = shadowTypeInfo.get(options.clusteredLightingShadowType);
            								fDefines.set('CLUSTER_SHADOWS', true);
            								fDefines.set("SHADOW_KIND_" + clusteredShadowInfo.kind, true);
            								fDefines.set("CLUSTER_SHADOW_TYPE_" + clusteredShadowInfo.kind, true);
            						}
            				}
            				for(var i = 0; i < options.lights.length; i++){
            						var light = options.lights[i];
            						var lightType = light._type;
            						if (clusteredLightingEnabled && lightType !== LIGHTTYPE_DIRECTIONAL) {
            								continue;
            						}
            						var lightShape = hasAreaLights && light._shape ? light._shape : LIGHTSHAPE_PUNCTUAL;
            						var shadowType = light._shadowType;
            						var castShadow = light.castShadows && !options.noShadow;
            						var shadowInfo = shadowTypeInfo.get(shadowType);
            						fDefines.set("LIGHT" + i, true);
            						fDefines.set("LIGHT" + i + "TYPE", "" + lightTypeNames[lightType]);
            						fDefines.set("LIGHT" + i + "SHADOWTYPE", "" + shadowInfo.name);
            						fDefines.set("LIGHT" + i + "SHAPE", "" + lightShapeNames[lightShape]);
            						fDefines.set("LIGHT" + i + "FALLOFF", "" + lightFalloffNames[light._falloffMode]);
            						if (light.affectSpecularity) fDefines.set("LIGHT" + i + "AFFECT_SPECULARITY", true);
            						if (light._cookie) {
            								if (lightType === LIGHTTYPE_SPOT && !light._cookie._cubemap || lightType === LIGHTTYPE_OMNI && light._cookie._cubemap) {
            										fDefines.set("LIGHT" + i + "COOKIE", true);
            										fDefines.set("{LIGHT" + i + "COOKIE_CHANNEL}", light._cookieChannel);
            										if (lightType === LIGHTTYPE_SPOT) {
            												if (light._cookieTransform) fDefines.set("LIGHT" + i + "COOKIE_TRANSFORM", true);
            												if (light._cookieFalloff) fDefines.set("LIGHT" + i + "COOKIE_FALLOFF", true);
            										}
            								}
            						}
            						if (castShadow) {
            								fDefines.set("LIGHT" + i + "CASTSHADOW", true);
            								if (shadowInfo.pcf) fDefines.set("LIGHT" + i + "SHADOW_PCF", true);
            								if (light._normalOffsetBias && !light._isVsm) fDefines.set("LIGHT" + i + "_SHADOW_SAMPLE_NORMAL_OFFSET", true);
            								if (lightType === LIGHTTYPE_DIRECTIONAL) {
            										fDefines.set("LIGHT" + i + "_SHADOW_SAMPLE_ORTHO", true);
            										if (light.cascadeBlend > 0) fDefines.set("LIGHT" + i + "_SHADOW_CASCADE_BLEND", true);
            										if (light.numCascades > 1) fDefines.set("LIGHT" + i + "_SHADOW_CASCADES", true);
            								}
            								if (shadowInfo.pcf || shadowInfo.pcss || this.device.isWebGPU) fDefines.set("LIGHT" + i + "_SHADOW_SAMPLE_SOURCE_ZBUFFER", true);
            								if (lightType === LIGHTTYPE_OMNI) fDefines.set("LIGHT" + i + "_SHADOW_SAMPLE_POINT", true);
            						}
            						if (castShadow) {
            								fDefines.set("SHADOW_KIND_" + shadowInfo.kind, true);
            								if (lightType === LIGHTTYPE_DIRECTIONAL) fDefines.set('SHADOW_DIRECTIONAL', true);
            						}
            				}
            		}
            		prepareForwardPass(lightingUv) {
            				var { options } = this;
            				var clusteredAreaLights = options.clusteredLightingEnabled && options.clusteredLightingAreaLightsEnabled;
            				var hasAreaLights = clusteredAreaLights || options.lights.some((light)=>{
            						return light._shape && light._shape !== LIGHTSHAPE_PUNCTUAL;
            				});
            				var addAmbient = !options.lightMapEnabled || options.lightMapWithoutAmbient;
            				var hasTBN = this.needsNormal && (options.useNormals || options.useClearCoatNormals || options.enableGGXSpecular && !options.useHeights);
            				if (options.useSpecular) {
            						this.fDefineSet(true, 'LIT_SPECULAR');
            						this.fDefineSet(this.reflections, 'LIT_REFLECTIONS');
            						this.fDefineSet(options.useClearCoat, 'LIT_CLEARCOAT');
            						this.fDefineSet(options.fresnelModel > 0, 'LIT_SPECULAR_FRESNEL');
            						this.fDefineSet(options.useSheen, 'LIT_SHEEN');
            						this.fDefineSet(options.useIridescence, 'LIT_IRIDESCENCE');
            				}
            				this.fDefineSet(this.lighting && options.useSpecular || this.reflections, 'LIT_SPECULAR_OR_REFLECTION');
            				this.fDefineSet(this.needsSceneColor, 'LIT_SCENE_COLOR');
            				this.fDefineSet(this.needsScreenSize, 'LIT_SCREEN_SIZE');
            				this.fDefineSet(this.needsTransforms, 'LIT_TRANSFORMS');
            				this.fDefineSet(this.needsNormal, 'LIT_NEEDS_NORMAL');
            				this.fDefineSet(this.lighting, 'LIT_LIGHTING');
            				this.fDefineSet(options.useMetalness, 'LIT_METALNESS');
            				this.fDefineSet(options.enableGGXSpecular, 'LIT_GGX_SPECULAR');
            				this.fDefineSet(options.useSpecularityFactor, 'LIT_SPECULARITY_FACTOR');
            				this.fDefineSet(options.useCubeMapRotation, 'CUBEMAP_ROTATION');
            				this.fDefineSet(options.occludeSpecularFloat, 'LIT_OCCLUDE_SPECULAR_FLOAT');
            				this.fDefineSet(options.separateAmbient, 'LIT_SEPARATE_AMBIENT');
            				this.fDefineSet(options.twoSidedLighting, 'LIT_TWO_SIDED_LIGHTING');
            				this.fDefineSet(options.lightMapEnabled, 'LIT_LIGHTMAP');
            				this.fDefineSet(options.dirLightMapEnabled, 'LIT_DIR_LIGHTMAP');
            				this.fDefineSet(options.skyboxIntensity > 0, 'LIT_SKYBOX_INTENSITY');
            				this.fDefineSet(options.clusteredLightingShadowsEnabled, 'LIT_CLUSTERED_SHADOWS');
            				this.fDefineSet(options.clusteredLightingAreaLightsEnabled, 'LIT_CLUSTERED_AREA_LIGHTS');
            				this.fDefineSet(hasTBN, 'LIT_TBN');
            				this.fDefineSet(addAmbient, 'LIT_ADD_AMBIENT');
            				this.fDefineSet(options.hasTangents, 'LIT_TANGENTS');
            				this.fDefineSet(options.useNormals, 'LIT_USE_NORMALS');
            				this.fDefineSet(options.useClearCoatNormals, 'LIT_USE_CLEARCOAT_NORMALS');
            				this.fDefineSet(options.useRefraction, 'LIT_REFRACTION');
            				this.fDefineSet(options.useDynamicRefraction, 'LIT_DYNAMIC_REFRACTION');
            				this.fDefineSet(options.dispersion, 'LIT_DISPERSION');
            				this.fDefineSet(options.useHeights, 'LIT_HEIGHTS');
            				this.fDefineSet(options.opacityFadesSpecular, 'LIT_OPACITY_FADES_SPECULAR');
            				this.fDefineSet(options.alphaToCoverage, 'LIT_ALPHA_TO_COVERAGE');
            				this.fDefineSet(options.alphaTest, 'LIT_ALPHA_TEST');
            				this.fDefineSet(options.useMsdf, 'LIT_MSDF');
            				this.fDefineSet(options.ssao, 'LIT_SSAO');
            				this.fDefineSet(options.useAo, 'LIT_AO');
            				this.fDefineSet(options.occludeDirect, 'LIT_OCCLUDE_DIRECT');
            				this.fDefineSet(options.msdfTextAttribute, 'LIT_MSDF_TEXT_ATTRIBUTE');
            				this.fDefineSet(options.diffuseMapEnabled, 'LIT_DIFFUSE_MAP');
            				this.fDefineSet(options.shadowCatcher, 'LIT_SHADOW_CATCHER');
            				this.fDefineSet(true, 'LIT_FRESNEL_MODEL', fresnelNames[options.fresnelModel]);
            				this.fDefineSet(true, 'LIT_NONE_SLICE_MODE', spriteRenderModeNames[options.nineSlicedMode]);
            				this.fDefineSet(true, 'LIT_BLEND_TYPE', blendNames[options.blendType]);
            				this.fDefineSet(true, 'LIT_CUBEMAP_PROJECTION', cubemaProjectionNames[options.cubeMapProjection]);
            				this.fDefineSet(true, 'LIT_OCCLUDE_SPECULAR', specularOcclusionNames[options.occludeSpecular]);
            				this.fDefineSet(true, 'LIT_REFLECTION_SOURCE', reflectionSrcNames[options.reflectionSource]);
            				this.fDefineSet(true, 'LIT_AMBIENT_SOURCE', ambientSrcNames[options.ambientSource]);
            				this.fDefineSet(true, '{lightingUv}', lightingUv != null ? lightingUv : '');
            				this.fDefineSet(true, '{reflectionDecode}', ChunkUtils.decodeFunc(options.reflectionEncoding));
            				this.fDefineSet(true, '{reflectionCubemapDecode}', ChunkUtils.decodeFunc(options.reflectionCubemapEncoding));
            				this.fDefineSet(true, '{ambientDecode}', ChunkUtils.decodeFunc(options.ambientEncoding));
            				this._setupLightingDefines(hasAreaLights, options.clusteredLightingEnabled);
            		}
            		prepareShadowPass() {
            				var { options } = this;
            				var lightType = this.shaderPassInfo.lightType;
            				var shadowType = this.shaderPassInfo.shadowType;
            				var shadowInfo = shadowTypeInfo.get(shadowType);
            				var usePerspectiveDepth = lightType === LIGHTTYPE_DIRECTIONAL || !shadowInfo.vsm && lightType === LIGHTTYPE_SPOT;
            				this.fDefineSet(usePerspectiveDepth, 'PERSPECTIVE_DEPTH');
            				this.fDefineSet(true, 'LIGHT_TYPE', "" + lightTypeNames[lightType]);
            				this.fDefineSet(true, 'SHADOW_TYPE', "" + shadowInfo.name);
            				this.fDefineSet(options.alphaTest, 'LIT_ALPHA_TEST');
            		}
            		generateFragmentShader(frontendDecl, frontendCode, lightingUv) {
            				var options = this.options;
            				if (options.pass === SHADER_PICK || options.pass === SHADER_DEPTH || options.pass === SHADER_PREPASS) {
            						this.fshader = "\n\n                " + this.varyingsCode + "\n                " + frontendDecl + "\n                " + frontendCode + '\n                #include "litOtherMainPS"\n            ';
            				} else if (this.shadowPass) {
            						this.prepareShadowPass();
            						this.fshader = "\n                " + this.varyingsCode + "\n                " + frontendDecl + "\n                " + frontendCode + '\n                #include "litShadowMainPS"\n            ';
            				} else if (options.customFragmentShader) {
            						this.fshader = "\n                " + options.customFragmentShader + "\n            ";
            				} else {
            						this.prepareForwardPass(lightingUv);
            						this.fshader = "\n                " + this.varyingsCode + "\n                " + frontendDecl + '\n                #include "litForwardDeclarationPS"\n                #include "litForwardPreCodePS"\n                ' + frontendCode + '\n                #include "litForwardPostCodePS"\n                #include "litForwardBackendPS"\n                #include "litForwardMainPS"\n            ';
            				}
            		}
            		constructor(device, options, shaderLanguage){
            				this.varyingsCode = '';
            				this.device = device;
            				this.options = options;
            				this.shaderLanguage = shaderLanguage;
            				this.attributes = {
            						vertex_position: SEMANTIC_POSITION
            				};
            				if (options.userAttributes) {
            						for (var [semantic, name] of Object.entries(options.userAttributes)){
            								this.attributes[name] = semantic;
            						}
            				}
            				var languageChunks = shaderLanguage === SHADERLANGUAGE_GLSL ? shaderChunks : shaderChunksWGSL;
            				if (options.chunks) {
            						var userChunks = options.chunks;
            						this.chunks = Object.create(languageChunks);
            						for(var chunkName in languageChunks){
            								if (userChunks.hasOwnProperty(chunkName)) {
            										var chunk = userChunks[chunkName];
            										for(var a in builtinAttributes){
            												if (builtinAttributes.hasOwnProperty(a) && chunk.indexOf(a) >= 0) {
            														this.attributes[a] = builtinAttributes[a];
            												}
            										}
            										this.chunks[chunkName] = chunk;
            								}
            						}
            				} else {
            						this.chunks = languageChunks;
            				}
            				this.shaderPassInfo = ShaderPass.get(this.device).getByIndex(options.pass);
            				this.shadowPass = this.shaderPassInfo.isShadow;
            				this.lighting = options.lights.length > 0 || options.dirLightMapEnabled || options.clusteredLightingEnabled;
            				this.reflections = options.reflectionSource !== REFLECTIONSRC_NONE;
            				this.needsNormal = this.lighting || this.reflections || options.useSpecular || options.ambientSH || options.useHeights || options.enableGGXSpecular || options.clusteredLightingEnabled && !this.shadowPass || options.useClearCoatNormals;
            				this.needsNormal = this.needsNormal && !this.shadowPass;
            				this.needsSceneColor = options.useDynamicRefraction;
            				this.needsScreenSize = options.useDynamicRefraction;
            				this.needsTransforms = options.useDynamicRefraction;
            				this.vshader = null;
            				this.vDefines = new Map();
            				this.fDefines = new Map();
            				this.fshader = null;
            		}
            }
            
            var LitOptionsUtils = {
            		generateKey (options) {
            				return "lit" + Object.keys(options).sort().map((key)=>{
            						if (key === 'chunks') {
            								return LitOptionsUtils.generateChunksKey(options);
            						} else if (key === 'lights') {
            								return LitOptionsUtils.generateLightsKey(options);
            						}
            						return key + options[key];
            				}).join('\n');
            		},
            		generateLightsKey (options) {
            				return "lights:" + options.lights.map((light)=>{
            						return !options.clusteredLightingEnabled || light._type === LIGHTTYPE_DIRECTIONAL ? "" + light.key + "," : '';
            				}).join('');
            		},
            		generateChunksKey (options) {
            				var _options_chunks;
            				return "chunks:\n" + Object.keys((_options_chunks = options.chunks) != null ? _options_chunks : {}).sort().map((key)=>key + options.chunks[key]).join('');
            		}
            };
            
            class StandardMaterialOptions {
            		get pass() {
            				return this.litOptions.pass;
            		}
            		constructor(){
            				this.defines = new Map();
            				this.forceUv1 = false;
            				this.specularTint = false;
            				this.metalnessTint = false;
            				this.glossTint = false;
            				this.emissiveEncoding = 'linear';
            				this.lightMapEncoding = 'linear';
            				this.packedNormal = false;
            				this.normalDetailPackedNormal = false;
            				this.clearCoatPackedNormal = false;
            				this.glossInvert = false;
            				this.sheenGlossInvert = false;
            				this.clearCoatGlossInvert = false;
            				this.useAO = false;
            				this.litOptions = new LitShaderOptions();
            		}
            }
            
            function _extends$d() {
            		_extends$d = Object.assign || function(target) {
            				for(var i = 1; i < arguments.length; i++){
            						var source = arguments[i];
            						for(var key in source){
            								if (Object.prototype.hasOwnProperty.call(source, key)) {
            										target[key] = source[key];
            								}
            						}
            				}
            				return target;
            		};
            		return _extends$d.apply(this, arguments);
            }
            var _matTex2D = [];
            var buildPropertiesList = (options)=>{
            		return Object.keys(options).filter((key)=>key !== 'litOptions').sort();
            };
            class ShaderGeneratorStandard extends ShaderGenerator {
            		generateKey(options) {
            				var props;
            				if (options === this.optionsContextMin) {
            						if (!this.propsMin) this.propsMin = buildPropertiesList(options);
            						props = this.propsMin;
            				} else if (options === this.optionsContext) {
            						if (!this.props) this.props = buildPropertiesList(options);
            						props = this.props;
            				} else {
            						props = buildPropertiesList(options);
            				}
            				var definesHash = ShaderGenerator.definesHash(options.defines);
            				var key = "standard:\n" + definesHash + "\n" + props.map((prop)=>prop + options[prop]).join('\n') + LitOptionsUtils.generateKey(options.litOptions);
            				return key;
            		}
            		_getUvSourceExpression(transformPropName, uVPropName, options) {
            				var transformId = options[transformPropName];
            				var uvChannel = options[uVPropName];
            				var isMainPass = options.litOptions.pass === SHADER_FORWARD;
            				var expression;
            				if (isMainPass && options.litOptions.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {
            						expression = 'nineSlicedUv';
            				} else if (isMainPass && options.litOptions.nineSlicedMode === SPRITE_RENDERMODE_TILED) {
            						expression = 'nineSlicedUv';
            				} else {
            						if (transformId === 0) {
            								expression = "vUv" + uvChannel;
            						} else {
            								expression = "vUV" + uvChannel + "_" + transformId;
            						}
            						if (options.heightMap && transformPropName !== 'heightMapTransform') {
            								expression += ' + dUvOffset';
            						}
            				}
            				return expression;
            		}
            		_validateMapChunk(propName, chunkName, chunks) {}
            		_addMapDefines(fDefines, propName, chunkName, options, chunks, mapping, encoding) {
            				if (encoding === void 0) encoding = null;
            				var mapPropName = "" + propName + "Map";
            				var propNameCaps = propName.toUpperCase();
            				var uVPropName = "" + mapPropName + "Uv";
            				var identifierPropName = "" + mapPropName + "Identifier";
            				var transformPropName = "" + mapPropName + "Transform";
            				var channelPropName = "" + mapPropName + "Channel";
            				var vertexColorChannelPropName = "" + propName + "VertexColorChannel";
            				var tintPropName = "" + propName + "Tint";
            				var vertexColorPropName = "" + propName + "VertexColor";
            				var detailModePropName = "" + propName + "Mode";
            				var invertName = "" + propName + "Invert";
            				var tintOption = options[tintPropName];
            				var vertexColorOption = options[vertexColorPropName];
            				var textureOption = options[mapPropName];
            				var textureIdentifier = options[identifierPropName];
            				var detailModeOption = options[detailModePropName];
            				var chunkCode = chunks[chunkName];
            				if (textureOption) {
            						fDefines.set("STD_" + propNameCaps + "_TEXTURE", '');
            						var uv = this._getUvSourceExpression(transformPropName, uVPropName, options);
            						fDefines.set("{STD_" + propNameCaps + "_TEXTURE_UV}", uv);
            						fDefines.set("{STD_" + propNameCaps + "_TEXTURE_CHANNEL}", options[channelPropName]);
            						var textureId = "{STD_" + propNameCaps + "_TEXTURE_NAME}";
            						if (chunkCode.includes(textureId)) {
            								var samplerName = "texture_" + mapPropName;
            								var alias = mapping[textureIdentifier];
            								if (alias) {
            										samplerName = alias;
            								} else {
            										mapping[textureIdentifier] = samplerName;
            										fDefines.set("STD_" + propNameCaps + "_TEXTURE_ALLOCATE", '');
            								}
            								fDefines.set(textureId, samplerName);
            						}
            						if (encoding) {
            								var textureDecode = options[channelPropName] === 'aaa' ? 'passThrough' : ChunkUtils.decodeFunc(encoding);
            								fDefines.set("{STD_" + propNameCaps + "_TEXTURE_DECODE}", textureDecode);
            						}
            				}
            				if (vertexColorOption) {
            						fDefines.set("STD_" + propNameCaps + "_VERTEX", '');
            						fDefines.set("{STD_" + propNameCaps + "_VERTEX_CHANNEL}", options[vertexColorChannelPropName]);
            				}
            				if (detailModeOption) {
            						fDefines.set("{STD_" + propNameCaps + "_DETAILMODE}", detailModeOption);
            				}
            				if (tintOption) {
            						fDefines.set("STD_" + propNameCaps + "_CONSTANT", '');
            				}
            				if (!!options[invertName]) {
            						fDefines.set("STD_" + propNameCaps + "_INVERT", '');
            				}
            		}
            		_correctChannel(p, chan, _matTex2D) {
            				if (_matTex2D[p] > 0) {
            						if (_matTex2D[p] < chan.length) {
            								return chan.substring(0, _matTex2D[p]);
            						} else if (_matTex2D[p] > chan.length) {
            								var str = chan;
            								var chr = str.charAt(str.length - 1);
            								var addLen = _matTex2D[p] - str.length;
            								for(var i = 0; i < addLen; i++)str += chr;
            								return str;
            						}
            						return chan;
            				}
            		}
            		createVertexShader(litShader, options) {
            				var useUv = [];
            				var useUnmodifiedUv = [];
            				var mapTransforms = [];
            				var maxUvSets = 2;
            				for(var p in _matTex2D){
            						var mapName = "" + p + "Map";
            						if (options["" + p + "VertexColor"]) {
            								var colorChannelName = "" + p + "VertexColorChannel";
            								options[colorChannelName] = this._correctChannel(p, options[colorChannelName], _matTex2D);
            						}
            						if (options[mapName]) {
            								var channelName = "" + mapName + "Channel";
            								var transformName = "" + mapName + "Transform";
            								var uvName = "" + mapName + "Uv";
            								options[uvName] = Math.min(options[uvName], maxUvSets - 1);
            								options[channelName] = this._correctChannel(p, options[channelName], _matTex2D);
            								var uvSet = options[uvName];
            								useUv[uvSet] = true;
            								useUnmodifiedUv[uvSet] = useUnmodifiedUv[uvSet] || options[mapName] && !options[transformName];
            								if (options[transformName]) {
            										mapTransforms.push({
            												name: p,
            												id: options[transformName],
            												uv: options[uvName]
            										});
            								}
            						}
            				}
            				if (options.forceUv1) {
            						useUv[1] = true;
            						useUnmodifiedUv[1] = useUnmodifiedUv[1] !== undefined ? useUnmodifiedUv[1] : true;
            				}
            				litShader.generateVertexShader(useUv, useUnmodifiedUv, mapTransforms);
            		}
            		prepareFragmentDefines(options, fDefines, shaderPassInfo) {
            				var fDefineSet = (condition, name, value)=>{
            						if (value === void 0) value = '';
            						if (condition) {
            								fDefines.set(name, value);
            						}
            				};
            				fDefineSet(options.lightMap, 'STD_LIGHTMAP', '');
            				fDefineSet(options.lightVertexColor, 'STD_LIGHT_VERTEX_COLOR', '');
            				fDefineSet(options.dirLightMap && options.litOptions.useSpecular, 'STD_LIGHTMAP_DIR', '');
            				fDefineSet(options.heightMap, 'STD_HEIGHT_MAP', '');
            				fDefineSet(options.useSpecularColor, 'STD_SPECULAR_COLOR', '');
            				fDefineSet(options.aoMap || options.aoVertexColor || options.useAO, 'STD_AO', '');
            				fDefineSet(true, 'STD_OPACITY_DITHER', ditherNames[shaderPassInfo.isForward ? options.litOptions.opacityDither : options.litOptions.opacityShadowDither]);
            		}
            		createShaderDefinition(device, options) {
            				var shaderPassInfo = ShaderPass.get(device).getByIndex(options.litOptions.pass);
            				var isForwardPass = shaderPassInfo.isForward;
            				var litShader = new LitShader(device, options.litOptions, SHADERLANGUAGE_GLSL);
            				this.createVertexShader(litShader, options);
            				var textureMapping = {};
            				options.litOptions.fresnelModel = options.litOptions.fresnelModel === 0 ? FRESNEL_SCHLICK : options.litOptions.fresnelModel;
            				var fDefines = litShader.fDefines;
            				this.prepareFragmentDefines(options, fDefines, shaderPassInfo);
            				var lightingUv = '';
            				if (isForwardPass) {
            						if (options.heightMap) {
            								this._addMapDefines(fDefines, 'height', 'parallaxPS', options, litShader.chunks, textureMapping);
            						}
            						if (options.litOptions.blendType !== BLEND_NONE || options.litOptions.alphaTest || options.litOptions.alphaToCoverage || options.litOptions.opacityDither !== DITHER_NONE) {
            								this._addMapDefines(fDefines, 'opacity', 'opacityPS', options, litShader.chunks, textureMapping);
            						}
            						if (litShader.needsNormal) {
            								if (options.normalMap || options.clearCoatNormalMap) {
            										if (!options.litOptions.hasTangents) {
            												var baseName = options.normalMap ? 'normalMap' : 'clearCoatNormalMap';
            												lightingUv = this._getUvSourceExpression("" + baseName + "Transform", "" + baseName + "Uv", options);
            										}
            								}
            								this._addMapDefines(fDefines, 'normalDetail', 'normalMapPS', options, litShader.chunks, textureMapping, options.normalDetailPackedNormal ? 'xy' : 'xyz');
            								this._addMapDefines(fDefines, 'normal', 'normalMapPS', options, litShader.chunks, textureMapping, options.packedNormal ? 'xy' : 'xyz');
            						}
            						if (options.diffuseDetail) {
            								this._addMapDefines(fDefines, 'diffuseDetail', 'diffusePS', options, litShader.chunks, textureMapping, options.diffuseDetailEncoding);
            						}
            						this._addMapDefines(fDefines, 'diffuse', 'diffusePS', options, litShader.chunks, textureMapping, options.diffuseEncoding);
            						if (options.litOptions.useRefraction) {
            								this._addMapDefines(fDefines, 'refraction', 'transmissionPS', options, litShader.chunks, textureMapping);
            								this._addMapDefines(fDefines, 'thickness', 'thicknessPS', options, litShader.chunks, textureMapping);
            						}
            						if (options.litOptions.useIridescence) {
            								this._addMapDefines(fDefines, 'iridescence', 'iridescencePS', options, litShader.chunks, textureMapping);
            								this._addMapDefines(fDefines, 'iridescenceThickness', 'iridescenceThicknessPS', options, litShader.chunks, textureMapping);
            						}
            						if (litShader.lighting && options.litOptions.useSpecular || litShader.reflections) {
            								if (options.litOptions.useSheen) {
            										this._addMapDefines(fDefines, 'sheen', 'sheenPS', options, litShader.chunks, textureMapping, options.sheenEncoding);
            										this._addMapDefines(fDefines, 'sheenGloss', 'sheenGlossPS', options, litShader.chunks, textureMapping);
            								}
            								if (options.litOptions.useMetalness) {
            										this._addMapDefines(fDefines, 'metalness', 'metalnessPS', options, litShader.chunks, textureMapping);
            										this._addMapDefines(fDefines, 'ior', 'iorPS', options, litShader.chunks, textureMapping);
            								}
            								if (options.litOptions.useSpecularityFactor) {
            										this._addMapDefines(fDefines, 'specularityFactor', 'specularityFactorPS', options, litShader.chunks, textureMapping);
            								}
            								if (options.useSpecularColor) {
            										this._addMapDefines(fDefines, 'specular', 'specularPS', options, litShader.chunks, textureMapping, options.specularEncoding);
            								}
            								this._addMapDefines(fDefines, 'gloss', 'glossPS', options, litShader.chunks, textureMapping);
            						}
            						if (options.aoDetail) {
            								this._addMapDefines(fDefines, 'aoDetail', 'aoPS', options, litShader.chunks, textureMapping);
            						}
            						if (options.aoMap || options.aoVertexColor || options.useAO) {
            								this._addMapDefines(fDefines, 'ao', 'aoPS', options, litShader.chunks, textureMapping);
            						}
            						this._addMapDefines(fDefines, 'emissive', 'emissivePS', options, litShader.chunks, textureMapping, options.emissiveEncoding);
            						if (options.litOptions.useClearCoat) {
            								this._addMapDefines(fDefines, 'clearCoat', 'clearCoatPS', options, litShader.chunks, textureMapping);
            								this._addMapDefines(fDefines, 'clearCoatGloss', 'clearCoatGlossPS', options, litShader.chunks, textureMapping);
            								this._addMapDefines(fDefines, 'clearCoatNormal', 'clearCoatNormalPS', options, litShader.chunks, textureMapping, options.clearCoatPackedNormal ? 'xy' : 'xyz');
            						}
            						if (options.lightMap || options.lightVertexColor) {
            								this._addMapDefines(fDefines, 'light', 'lightmapPS', options, litShader.chunks, textureMapping, options.lightMapEncoding);
            						}
            				} else {
            						var opacityShadowDither = options.litOptions.opacityShadowDither;
            						if (options.litOptions.alphaTest || opacityShadowDither) {
            								this._addMapDefines(fDefines, 'opacity', 'opacityPS', options, litShader.chunks, textureMapping);
            						}
            				}
            				litShader.generateFragmentShader(litShader.chunks.stdDeclarationPS, litShader.chunks.stdFrontEndPS, lightingUv);
            				var includes = new Map(Object.entries(_extends$d({}, Object.getPrototypeOf(litShader.chunks), litShader.chunks, options.litOptions.chunks)));
            				var vDefines = litShader.vDefines;
            				options.defines.forEach((value, key)=>vDefines.set(key, value));
            				options.defines.forEach((value, key)=>fDefines.set(key, value));
            				var definition = ShaderUtils.createDefinition(device, {
            						name: 'StandardShader',
            						attributes: litShader.attributes,
            						vertexCode: litShader.vshader,
            						fragmentCode: litShader.fshader,
            						vertexIncludes: includes,
            						fragmentIncludes: includes,
            						fragmentDefines: fDefines,
            						vertexDefines: vDefines
            				});
            				if (litShader.shaderPassInfo.isForward) {
            						definition.tag = SHADERTAG_MATERIAL;
            				}
            				return definition;
            		}
            		constructor(...args){
            				super(...args), this.optionsContext = new StandardMaterialOptions(), this.optionsContextMin = new StandardMaterialOptions();
            		}
            }
            var standard = new ShaderGeneratorStandard();
            
            var arraysEqual = (a, b)=>{
            		if (a.length !== b.length) {
            				return false;
            		}
            		for(var i = 0; i < a.length; ++i){
            				if (a[i] !== b[i]) {
            						return false;
            				}
            		}
            		return true;
            };
            var notWhite = (color)=>{
            		return color.r !== 1 || color.g !== 1 || color.b !== 1;
            };
            var notBlack = (color)=>{
            		return color.r !== 0 || color.g !== 0 || color.b !== 0;
            };
            class StandardMaterialOptionsBuilder {
            		updateMinRef(options, scene, stdMat, objDefs, pass, sortedLights) {
            				this._updateSharedOptions(options, scene, stdMat, objDefs, pass);
            				this._updateMinOptions(options, stdMat, pass);
            				this._updateUVOptions(options, stdMat, objDefs, true);
            		}
            		updateRef(options, scene, cameraShaderParams, stdMat, objDefs, pass, sortedLights) {
            				this._updateSharedOptions(options, scene, stdMat, objDefs, pass);
            				this._updateEnvOptions(options, stdMat, scene, cameraShaderParams);
            				this._updateMaterialOptions(options, stdMat, scene);
            				options.litOptions.hasTangents = objDefs && (objDefs & SHADERDEF_TANGENTS) !== 0;
            				this._updateLightOptions(options, scene, stdMat, objDefs, sortedLights);
            				this._updateUVOptions(options, stdMat, objDefs, false, cameraShaderParams);
            		}
            		_updateSharedOptions(options, scene, stdMat, objDefs, pass) {
            				options.forceUv1 = stdMat.forceUv1;
            				if (stdMat.userAttributes) {
            						options.litOptions.userAttributes = Object.fromEntries(stdMat.userAttributes.entries());
            				}
            				options.litOptions.chunks = stdMat.chunks || {};
            				options.litOptions.pass = pass;
            				options.litOptions.alphaTest = stdMat.alphaTest > 0;
            				options.litOptions.blendType = stdMat.blendType;
            				options.litOptions.screenSpace = objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0;
            				options.litOptions.skin = objDefs && (objDefs & SHADERDEF_SKIN) !== 0;
            				options.litOptions.batch = objDefs && (objDefs & SHADERDEF_BATCH) !== 0;
            				options.litOptions.useInstancing = objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0;
            				options.litOptions.useMorphPosition = objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0;
            				options.litOptions.useMorphNormal = objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0;
            				options.litOptions.useMorphTextureBasedInt = objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED_INT) !== 0;
            				options.litOptions.nineSlicedMode = stdMat.nineSlicedMode || 0;
            				if (scene.clusteredLightingEnabled && stdMat.useLighting) {
            						options.litOptions.clusteredLightingEnabled = true;
            						options.litOptions.clusteredLightingCookiesEnabled = scene.lighting.cookiesEnabled;
            						options.litOptions.clusteredLightingShadowsEnabled = scene.lighting.shadowsEnabled;
            						options.litOptions.clusteredLightingShadowType = scene.lighting.shadowType;
            						options.litOptions.clusteredLightingAreaLightsEnabled = scene.lighting.areaLightsEnabled;
            				} else {
            						options.litOptions.clusteredLightingEnabled = false;
            						options.litOptions.clusteredLightingCookiesEnabled = false;
            						options.litOptions.clusteredLightingShadowsEnabled = false;
            						options.litOptions.clusteredLightingAreaLightsEnabled = false;
            				}
            		}
            		_updateUVOptions(options, stdMat, objDefs, minimalOptions, cameraShaderParams) {
            				var hasUv0 = false;
            				var hasUv1 = false;
            				var hasVcolor = false;
            				if (objDefs) {
            						hasUv0 = (objDefs & SHADERDEF_UV0) !== 0;
            						hasUv1 = (objDefs & SHADERDEF_UV1) !== 0;
            						hasVcolor = (objDefs & SHADERDEF_VCOLOR) !== 0;
            				}
            				options.litOptions.vertexColors = false;
            				this._mapXForms = [];
            				var uniqueTextureMap = {};
            				for(var p in _matTex2D){
            						this._updateTexOptions(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions, uniqueTextureMap);
            				}
            				this._mapXForms = null;
            				options.litOptions.ssao = cameraShaderParams == null ? void 0 : cameraShaderParams.ssaoEnabled;
            				options.useAO = options.litOptions.ssao;
            				options.litOptions.lightMapEnabled = options.lightMap;
            				options.litOptions.dirLightMapEnabled = options.dirLightMap;
            				options.litOptions.useHeights = options.heightMap;
            				options.litOptions.useNormals = options.normalMap;
            				options.litOptions.useClearCoatNormals = options.clearCoatNormalMap;
            				options.litOptions.useAo = options.aoMap || options.aoVertexColor || options.litOptions.ssao;
            				options.litOptions.diffuseMapEnabled = options.diffuseMap;
            		}
            		_updateTexOptions(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions, uniqueTextureMap) {
            				var isOpacity = p === 'opacity';
            				if (!minimalOptions || isOpacity) {
            						var mname = "" + p + "Map";
            						var vname = "" + p + "VertexColor";
            						var vcname = "" + p + "VertexColorChannel";
            						var cname = "" + mname + "Channel";
            						var tname = "" + mname + "Transform";
            						var uname = "" + mname + "Uv";
            						var iname = "" + mname + "Identifier";
            						if (p !== 'light') {
            								options[mname] = false;
            								options[iname] = undefined;
            								options[cname] = '';
            								options[tname] = 0;
            								options[uname] = 0;
            						}
            						options[vname] = false;
            						options[vcname] = '';
            						if (isOpacity && stdMat.blendType === BLEND_NONE && stdMat.alphaTest === 0.0 && !stdMat.alphaToCoverage && stdMat.opacityDither === DITHER_NONE) {
            								return;
            						}
            						if (p !== 'height' && stdMat[vname]) {
            								if (hasVcolor) {
            										options[vname] = stdMat[vname];
            										options[vcname] = stdMat[vcname];
            										options.litOptions.vertexColors = true;
            								}
            						}
            						if (stdMat[mname]) {
            								var allow = true;
            								if (stdMat[uname] === 0 && !hasUv0) allow = false;
            								if (stdMat[uname] === 1 && !hasUv1) allow = false;
            								if (allow) {
            										var mapId = stdMat[mname].id;
            										var identifier = uniqueTextureMap[mapId];
            										if (identifier === undefined) {
            												uniqueTextureMap[mapId] = p;
            												identifier = p;
            										}
            										options[mname] = !!stdMat[mname];
            										options[iname] = identifier;
            										options[tname] = this._getMapTransformID(stdMat.getUniform(tname), stdMat[uname]);
            										options[cname] = stdMat[cname];
            										options[uname] = stdMat[uname];
            								}
            						}
            				}
            		}
            		_updateMinOptions(options, stdMat, pass) {
            				var isPrepass = pass === SHADER_PREPASS;
            				options.litOptions.opacityShadowDither = isPrepass ? stdMat.opacityDither : stdMat.opacityShadowDither;
            				options.litOptions.linearDepth = isPrepass;
            				options.litOptions.lights = [];
            		}
            		_updateMaterialOptions(options, stdMat, scene) {
            				var _stdMat_diffuseMap, _stdMat_diffuseDetailMap, _stdMat_emissiveMap, _stdMat_lightMap, _stdMat_specularMap, _stdMat_sheenMap;
            				var useSpecular = !!(stdMat.useMetalness || stdMat.specularMap || stdMat.sphereMap || stdMat.cubeMap || notBlack(stdMat.specular) || stdMat.specularityFactor > 0 && stdMat.useMetalness || stdMat.enableGGXSpecular || stdMat.clearCoat > 0);
            				var useSpecularColor = !stdMat.useMetalness || stdMat.useMetalnessSpecularColor;
            				var specularTint = useSpecular && (stdMat.specularTint || !stdMat.specularMap && !stdMat.specularVertexColor) && notWhite(stdMat.specular);
            				var specularityFactorTint = useSpecular && stdMat.useMetalnessSpecularColor && (stdMat.specularityFactorTint || stdMat.specularityFactor < 1 && !stdMat.specularityFactorMap);
            				var isPackedNormalMap = (texture)=>texture ? texture.format === PIXELFORMAT_DXT5 || texture.type === TEXTURETYPE_SWIZZLEGGGR : false;
            				var equalish = (a, b)=>Math.abs(a - b) < 1e-4;
            				options.specularTint = specularTint;
            				options.specularityFactorTint = specularityFactorTint;
            				options.metalnessTint = stdMat.useMetalness && stdMat.metalness < 1;
            				options.glossTint = true;
            				options.diffuseEncoding = (_stdMat_diffuseMap = stdMat.diffuseMap) == null ? void 0 : _stdMat_diffuseMap.encoding;
            				options.diffuseDetailEncoding = (_stdMat_diffuseDetailMap = stdMat.diffuseDetailMap) == null ? void 0 : _stdMat_diffuseDetailMap.encoding;
            				options.emissiveEncoding = (_stdMat_emissiveMap = stdMat.emissiveMap) == null ? void 0 : _stdMat_emissiveMap.encoding;
            				options.lightMapEncoding = (_stdMat_lightMap = stdMat.lightMap) == null ? void 0 : _stdMat_lightMap.encoding;
            				options.packedNormal = isPackedNormalMap(stdMat.normalMap);
            				options.refractionTint = equalish(stdMat.refraction, 1.0);
            				options.refractionIndexTint = equalish(stdMat.refractionIndex, 1.0 / 1.5);
            				options.thicknessTint = stdMat.useDynamicRefraction && stdMat.thickness !== 1.0;
            				options.specularEncoding = (_stdMat_specularMap = stdMat.specularMap) == null ? void 0 : _stdMat_specularMap.encoding;
            				options.sheenEncoding = (_stdMat_sheenMap = stdMat.sheenMap) == null ? void 0 : _stdMat_sheenMap.encoding;
            				options.aoMapUv = stdMat.aoUvSet;
            				options.aoDetail = !!stdMat.aoDetailMap;
            				options.diffuseDetail = !!stdMat.diffuseDetailMap;
            				options.normalDetail = !!stdMat.normalMap;
            				options.normalDetailPackedNormal = isPackedNormalMap(stdMat.normalDetailMap);
            				options.diffuseDetailMode = stdMat.diffuseDetailMode;
            				options.aoDetailMode = stdMat.aoDetailMode;
            				options.clearCoatTint = equalish(stdMat.clearCoat, 1.0);
            				options.clearCoatGloss = !!stdMat.clearCoatGloss;
            				options.clearCoatGlossTint = stdMat.clearCoatGloss !== 1.0;
            				options.clearCoatPackedNormal = isPackedNormalMap(stdMat.clearCoatNormalMap);
            				options.iorTint = equalish(stdMat.refractionIndex, 1.0 / 1.5);
            				if (scene.forcePassThroughSpecular) {
            						options.specularEncoding = 'linear';
            						options.sheenEncoding = 'linear';
            				}
            				options.iridescenceTint = stdMat.iridescence !== 1.0;
            				options.glossInvert = stdMat.glossInvert;
            				options.sheenGlossInvert = stdMat.sheenGlossInvert;
            				options.clearCoatGlossInvert = stdMat.clearCoatGlossInvert;
            				options.useSpecularColor = useSpecularColor;
            				options.litOptions.separateAmbient = false;
            				options.litOptions.customFragmentShader = stdMat.customFragmentShader;
            				options.litOptions.pixelSnap = stdMat.pixelSnap;
            				options.litOptions.ambientSH = !!stdMat.ambientSH;
            				options.litOptions.twoSidedLighting = stdMat.twoSidedLighting;
            				options.litOptions.occludeSpecular = stdMat.occludeSpecular;
            				options.litOptions.occludeSpecularFloat = stdMat.occludeSpecularIntensity !== 1.0;
            				options.litOptions.useMsdf = !!stdMat.msdfMap;
            				options.litOptions.msdfTextAttribute = !!stdMat.msdfTextAttribute;
            				options.litOptions.alphaToCoverage = stdMat.alphaToCoverage;
            				options.litOptions.opacityFadesSpecular = stdMat.opacityFadesSpecular;
            				options.litOptions.opacityDither = stdMat.opacityDither;
            				options.litOptions.cubeMapProjection = stdMat.cubeMapProjection;
            				options.litOptions.occludeDirect = stdMat.occludeDirect;
            				options.litOptions.useSpecular = useSpecular;
            				options.litOptions.useSpecularityFactor = (specularityFactorTint || !!stdMat.specularityFactorMap) && stdMat.useMetalnessSpecularColor;
            				options.litOptions.enableGGXSpecular = stdMat.enableGGXSpecular;
            				options.litOptions.fresnelModel = stdMat.fresnelModel;
            				options.litOptions.useRefraction = (stdMat.refraction || !!stdMat.refractionMap) && (stdMat.useDynamicRefraction || options.litOptions.reflectionSource !== REFLECTIONSRC_NONE);
            				options.litOptions.useClearCoat = !!stdMat.clearCoat;
            				options.litOptions.useSheen = stdMat.useSheen;
            				options.litOptions.useIridescence = stdMat.useIridescence && stdMat.iridescence !== 0.0;
            				options.litOptions.useMetalness = stdMat.useMetalness;
            				options.litOptions.useDynamicRefraction = stdMat.useDynamicRefraction;
            				options.litOptions.dispersion = stdMat.dispersion > 0;
            				options.litOptions.shadowCatcher = stdMat.shadowCatcher;
            		}
            		_updateEnvOptions(options, stdMat, scene, cameraShaderParams) {
            				options.litOptions.fog = stdMat.useFog ? cameraShaderParams.fog : FOG_NONE;
            				options.litOptions.gamma = cameraShaderParams.shaderOutputGamma;
            				options.litOptions.toneMap = stdMat.useTonemap ? cameraShaderParams.toneMapping : TONEMAP_NONE;
            				var usingSceneEnv = false;
            				if (stdMat.envAtlas && stdMat.cubeMap) {
            						options.litOptions.reflectionSource = REFLECTIONSRC_ENVATLASHQ;
            						options.litOptions.reflectionEncoding = stdMat.envAtlas.encoding;
            						options.litOptions.reflectionCubemapEncoding = stdMat.cubeMap.encoding;
            				} else if (stdMat.envAtlas) {
            						options.litOptions.reflectionSource = REFLECTIONSRC_ENVATLAS;
            						options.litOptions.reflectionEncoding = stdMat.envAtlas.encoding;
            				} else if (stdMat.cubeMap) {
            						options.litOptions.reflectionSource = REFLECTIONSRC_CUBEMAP;
            						options.litOptions.reflectionEncoding = stdMat.cubeMap.encoding;
            				} else if (stdMat.sphereMap) {
            						options.litOptions.reflectionSource = REFLECTIONSRC_SPHEREMAP;
            						options.litOptions.reflectionEncoding = stdMat.sphereMap.encoding;
            				} else if (stdMat.useSkybox && scene.envAtlas && scene.skybox) {
            						options.litOptions.reflectionSource = REFLECTIONSRC_ENVATLASHQ;
            						options.litOptions.reflectionEncoding = scene.envAtlas.encoding;
            						options.litOptions.reflectionCubemapEncoding = scene.skybox.encoding;
            						usingSceneEnv = true;
            				} else if (stdMat.useSkybox && scene.envAtlas) {
            						options.litOptions.reflectionSource = REFLECTIONSRC_ENVATLAS;
            						options.litOptions.reflectionEncoding = scene.envAtlas.encoding;
            						usingSceneEnv = true;
            				} else if (stdMat.useSkybox && scene.skybox) {
            						options.litOptions.reflectionSource = REFLECTIONSRC_CUBEMAP;
            						options.litOptions.reflectionEncoding = scene.skybox.encoding;
            						usingSceneEnv = true;
            				} else {
            						options.litOptions.reflectionSource = REFLECTIONSRC_NONE;
            						options.litOptions.reflectionEncoding = null;
            				}
            				if (stdMat.ambientSH) {
            						options.litOptions.ambientSource = AMBIENTSRC_AMBIENTSH;
            						options.litOptions.ambientEncoding = null;
            				} else {
            						var envAtlas = stdMat.envAtlas || (stdMat.useSkybox && scene.envAtlas ? scene.envAtlas : null);
            						if (envAtlas && !stdMat.sphereMap) {
            								options.litOptions.ambientSource = AMBIENTSRC_ENVALATLAS;
            								options.litOptions.ambientEncoding = envAtlas.encoding;
            						} else {
            								options.litOptions.ambientSource = AMBIENTSRC_CONSTANT;
            								options.litOptions.ambientEncoding = null;
            						}
            				}
            				options.litOptions.skyboxIntensity = usingSceneEnv;
            				options.litOptions.useCubeMapRotation = usingSceneEnv && scene._skyboxRotationShaderInclude;
            		}
            		_updateLightOptions(options, scene, stdMat, objDefs, sortedLights) {
            				options.lightMap = false;
            				options.lightMapChannel = '';
            				options.lightMapUv = 0;
            				options.lightMapTransform = 0;
            				options.litOptions.lightMapWithoutAmbient = false;
            				options.dirLightMap = false;
            				if (objDefs) {
            						options.litOptions.noShadow = (objDefs & SHADERDEF_NOSHADOW) !== 0;
            						if ((objDefs & SHADERDEF_LM) !== 0) {
            								options.lightMapEncoding = scene.lightmapPixelFormat === PIXELFORMAT_RGBA8 ? 'rgbm' : 'linear';
            								options.lightMap = true;
            								options.lightMapChannel = 'rgb';
            								options.lightMapUv = 1;
            								options.lightMapTransform = 0;
            								options.litOptions.lightMapWithoutAmbient = !stdMat.lightMap;
            								if ((objDefs & SHADERDEF_DIRLM) !== 0) {
            										options.dirLightMap = true;
            								}
            								if ((objDefs & SHADERDEF_LMAMBIENT) !== 0) {
            										options.litOptions.lightMapWithoutAmbient = false;
            								}
            						}
            				}
            				if (stdMat.useLighting) {
            						var lightsFiltered = [];
            						var mask = objDefs ? objDefs >> 16 : MASK_AFFECT_DYNAMIC;
            						options.litOptions.lightMaskDynamic = !!(mask & MASK_AFFECT_DYNAMIC);
            						if (sortedLights) {
            								LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_DIRECTIONAL, sortedLights[LIGHTTYPE_DIRECTIONAL], lightsFiltered, mask);
            								LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_OMNI, sortedLights[LIGHTTYPE_OMNI], lightsFiltered, mask);
            								LitMaterialOptionsBuilder.collectLights(LIGHTTYPE_SPOT, sortedLights[LIGHTTYPE_SPOT], lightsFiltered, mask);
            						}
            						options.litOptions.lights = lightsFiltered;
            				} else {
            						options.litOptions.lights = [];
            				}
            				if (options.litOptions.lights.length === 0) {
            						options.litOptions.noShadow = true;
            				}
            		}
            		_getMapTransformID(xform, uv) {
            				if (!xform) return 0;
            				var xforms = this._mapXForms[uv];
            				if (!xforms) {
            						xforms = [];
            						this._mapXForms[uv] = xforms;
            				}
            				for(var i = 0; i < xforms.length; i++){
            						if (arraysEqual(xforms[i][0].value, xform[0].value) && arraysEqual(xforms[i][1].value, xform[1].value)) {
            								return i + 1;
            						}
            				}
            				return xforms.push(xform);
            		}
            		constructor(){
            				this._mapXForms = null;
            		}
            }
            
            function _extends$c() {
            		_extends$c = Object.assign || function(target) {
            				for(var i = 1; i < arguments.length; i++){
            						var source = arguments[i];
            						for(var key in source){
            								if (Object.prototype.hasOwnProperty.call(source, key)) {
            										target[key] = source[key];
            								}
            						}
            				}
            				return target;
            		};
            		return _extends$c.apply(this, arguments);
            }
            function _textureParameter(name, channel, vertexColor) {
            		if (channel === void 0) channel = true;
            		if (vertexColor === void 0) vertexColor = true;
            		var result = {};
            		result["" + name + "Map"] = 'texture';
            		result["" + name + "MapTiling"] = 'vec2';
            		result["" + name + "MapOffset"] = 'vec2';
            		result["" + name + "MapRotation"] = 'number';
            		result["" + name + "MapUv"] = 'number';
            		if (channel) {
            				result["" + name + "MapChannel"] = 'string';
            				if (vertexColor) {
            						result["" + name + "VertexColor"] = 'boolean';
            						result["" + name + "VertexColorChannel"] = 'string';
            				}
            		}
            		return result;
            }
            var standardMaterialParameterTypes = _extends$c({
            		name: 'string',
            		chunks: 'chunks',
            		mappingFormat: 'string',
            		_engine: 'boolean',
            		ambient: 'rgb'
            }, _textureParameter('ao'), _textureParameter('aoDetail', true, false), {
            		aoDetailMode: 'string',
            		diffuse: 'rgb'
            }, _textureParameter('diffuse'), _textureParameter('diffuseDetail', true, false), {
            		diffuseDetailMode: 'string',
            		specular: 'rgb',
            		specularTint: 'boolean'
            }, _textureParameter('specular'), {
            		occludeSpecular: 'enum:occludeSpecular',
            		specularityFactor: 'number',
            		specularityFactorTint: 'boolean'
            }, _textureParameter('specularityFactor'), {
            		useMetalness: 'boolean',
            		metalness: 'number',
            		enableGGXSpecular: 'boolean',
            		anisotropy: 'number',
            		metalnessTint: 'boolean'
            }, _textureParameter('metalness'), {
            		useMetalnessSpecularColor: 'boolean',
            		shininess: 'number',
            		gloss: 'number',
            		glossInvert: 'boolean'
            }, _textureParameter('gloss'), {
            		clearCoat: 'number'
            }, _textureParameter('clearCoat'), {
            		clearCoatGloss: 'number',
            		clearCoatGlossInvert: 'boolean'
            }, _textureParameter('clearCoatGloss'), {
            		clearCoatBumpiness: 'number'
            }, _textureParameter('clearCoatNormal', false), {
            		useSheen: 'boolean',
            		sheen: 'rgb'
            }, _textureParameter('sheen'), {
            		sheenGloss: 'number',
            		sheenGlossInvert: 'boolean'
            }, _textureParameter('sheenGloss'), {
            		fresnelModel: 'number',
            		emissive: 'rgb'
            }, _textureParameter('emissive'), {
            		emissiveIntensity: 'number'
            }, _textureParameter('normal', false), {
            		bumpiness: 'number'
            }, _textureParameter('normalDetail', false), {
            		normalDetailMapBumpiness: 'number'
            }, _textureParameter('height', true, false), {
            		heightMapFactor: 'number',
            		alphaToCoverage: 'boolean',
            		alphaTest: 'number',
            		alphaFade: 'number',
            		opacity: 'number'
            }, _textureParameter('opacity'), {
            		opacityFadesSpecular: 'boolean',
            		opacityDither: 'string',
            		opacityShadowDither: 'string',
            		reflectivity: 'number',
            		refraction: 'number',
            		refractionTint: 'boolean'
            }, _textureParameter('refraction'), {
            		refractionIndex: 'number',
            		dispersion: 'number',
            		thickness: 'number',
            		thicknessTint: 'boolean'
            }, _textureParameter('thickness'), {
            		attenuation: 'rgb',
            		attenuationDistance: 'number',
            		useDynamicRefraction: 'boolean',
            		sphereMap: 'texture',
            		cubeMap: 'cubemap',
            		cubeMapProjection: 'number',
            		cubeMapProjectionBox: 'boundingbox',
            		useIridescence: 'boolean',
            		iridescence: 'number',
            		iridescenceTint: 'boolean'
            }, _textureParameter('iridescence'), {
            		iridescenceThicknessTint: 'boolean',
            		iridescenceThicknessMin: 'number',
            		iridescenceThicknessMax: 'number',
            		iridescenceRefractionIndex: 'number'
            }, _textureParameter('iridescenceThickness'), _textureParameter('light'), {
            		depthTest: 'boolean',
            		depthFunc: 'enum:depthFunc',
            		depthWrite: 'boolean',
            		depthBias: 'number',
            		slopeDepthBias: 'number',
            		cull: 'enum:cull',
            		blendType: 'enum:blendType',
            		useFog: 'boolean',
            		useLighting: 'boolean',
            		useSkybox: 'boolean',
            		useTonemap: 'boolean',
            		envAtlas: 'texture',
            		twoSidedLighting: 'boolean',
            		shadowCatcher: 'boolean'
            });
            var standardMaterialTextureParameters = [];
            for(var key in standardMaterialParameterTypes){
            		var type = standardMaterialParameterTypes[key];
            		if (type === 'texture') {
            				standardMaterialTextureParameters.push(key);
            		}
            }
            var standardMaterialCubemapParameters = [];
            for(var key1 in standardMaterialParameterTypes){
            		var type1 = standardMaterialParameterTypes[key1];
            		if (type1 === 'cubemap') {
            				standardMaterialCubemapParameters.push(key1);
            		}
            }
            var standardMaterialRemovedParameters = {
            		aoMapVertexColor: 'boolean',
            		diffuseMapTint: 'boolean',
            		diffuseMapVertexColor: 'boolean',
            		emissiveMapTint: 'boolean',
            		emissiveMapVertexColor: 'boolean',
            		glossMapVertexColor: 'boolean',
            		metalnessMapVertexColor: 'boolean',
            		opacityMapVertexColor: 'boolean',
            		specularAntialias: 'boolean',
            		specularMapTint: 'boolean',
            		specularMapVertexColor: 'boolean',
            		ambientTint: 'boolean',
            		emissiveTint: 'boolean',
            		diffuseTint: 'boolean',
            		sheenTint: 'boolean',
            		conserveEnergy: 'boolean',
            		useGamma: 'boolean',
            		useGammaTonemap: 'boolean',
            		sheenGlossTint: 'boolean'
            };
            
            var _props = {};
            var _uniforms = {};
            var _params = new Set();
            var _tempColor$2 = new Color();
            class StandardMaterial extends Material {
            		reset() {
            				Object.keys(_props).forEach((name)=>{
            						this["_" + name] = _props[name].value();
            				});
            				this._uniformCache = {};
            		}
            		copy(source) {
            				super.copy(source);
            				Object.keys(_props).forEach((k)=>{
            						this[k] = source[k];
            				});
            				this.userAttributes = new Map(source.userAttributes);
            				return this;
            		}
            		setAttribute(name, semantic) {
            				this.userAttributes.set(semantic, name);
            		}
            		_setParameter(name, value) {
            				_params.add(name);
            				this.setParameter(name, value);
            		}
            		_setParameters(parameters) {
            				parameters.forEach((v)=>{
            						this._setParameter(v.name, v.value);
            				});
            		}
            		_processParameters(paramsName) {
            				var prevParams = this[paramsName];
            				prevParams.forEach((param)=>{
            						if (!_params.has(param)) {
            								delete this.parameters[param];
            						}
            				});
            				this[paramsName] = _params;
            				_params = prevParams;
            				_params.clear();
            		}
            		_updateMap(p) {
            				var mname = "" + p + "Map";
            				var map = this[mname];
            				if (map) {
            						this._setParameter("texture_" + mname, map);
            						var tname = "" + mname + "Transform";
            						var uniform = this.getUniform(tname);
            						if (uniform) {
            								this._setParameters(uniform);
            						}
            				}
            		}
            		_allocUniform(name, allocFunc) {
            				var uniform = this._uniformCache[name];
            				if (!uniform) {
            						uniform = allocFunc();
            						this._uniformCache[name] = uniform;
            				}
            				return uniform;
            		}
            		getUniform(name, device, scene) {
            				return _uniforms[name](this, device, scene);
            		}
            		updateUniforms(device, scene) {
            				var getUniform = (name)=>{
            						return this.getUniform(name, device, scene);
            				};
            				this._setParameter('material_ambient', getUniform('ambient'));
            				this._setParameter('material_diffuse', getUniform('diffuse'));
            				this._setParameter('material_aoIntensity', this.aoIntensity);
            				if (this.useMetalness) {
            						if (!this.metalnessMap || this.metalness < 1) {
            								this._setParameter('material_metalness', this.metalness);
            						}
            						if (!this.specularMap || this.specularTint) {
            								this._setParameter('material_specular', getUniform('specular'));
            						}
            						if (!this.specularityFactorMap || this.specularityFactorTint) {
            								this._setParameter('material_specularityFactor', this.specularityFactor);
            						}
            						this._setParameter('material_sheen', getUniform('sheen'));
            						this._setParameter('material_sheenGloss', this.sheenGloss);
            						this._setParameter('material_refractionIndex', this.refractionIndex);
            				} else {
            						if (!this.specularMap || this.specularTint) {
            								this._setParameter('material_specular', getUniform('specular'));
            						}
            				}
            				if (this.enableGGXSpecular) {
            						this._setParameter('material_anisotropy', this.anisotropy);
            				}
            				if (this.clearCoat > 0) {
            						this._setParameter('material_clearCoat', this.clearCoat);
            						this._setParameter('material_clearCoatGloss', this.clearCoatGloss);
            						this._setParameter('material_clearCoatBumpiness', this.clearCoatBumpiness);
            				}
            				this._setParameter('material_gloss', this.gloss);
            				this._setParameter('material_emissive', getUniform('emissive'));
            				this._setParameter('material_emissiveIntensity', this.emissiveIntensity);
            				if (this.refraction > 0) {
            						this._setParameter('material_refraction', this.refraction);
            				}
            				if (this.dispersion > 0) {
            						this._setParameter('material_dispersion', this.dispersion);
            				}
            				if (this.useDynamicRefraction) {
            						this._setParameter('material_thickness', this.thickness);
            						this._setParameter('material_attenuation', getUniform('attenuation'));
            						this._setParameter('material_invAttenuationDistance', this.attenuationDistance === 0 ? 0 : 1.0 / this.attenuationDistance);
            				}
            				if (this.useIridescence) {
            						this._setParameter('material_iridescence', this.iridescence);
            						this._setParameter('material_iridescenceRefractionIndex', this.iridescenceRefractionIndex);
            						this._setParameter('material_iridescenceThicknessMin', this.iridescenceThicknessMin);
            						this._setParameter('material_iridescenceThicknessMax', this.iridescenceThicknessMax);
            				}
            				this._setParameter('material_opacity', this.opacity);
            				if (this.opacityFadesSpecular === false) {
            						this._setParameter('material_alphaFade', this.alphaFade);
            				}
            				if (this.occludeSpecular) {
            						this._setParameter('material_occludeSpecularIntensity', this.occludeSpecularIntensity);
            				}
            				if (this.cubeMapProjection === CUBEPROJ_BOX) {
            						this._setParameter(getUniform('cubeMapProjectionBox'));
            				}
            				for(var p in _matTex2D){
            						this._updateMap(p);
            				}
            				if (this.ambientSH) {
            						this._setParameter('ambientSH[0]', this.ambientSH);
            				}
            				if (this.normalMap) {
            						this._setParameter('material_bumpiness', this.bumpiness);
            				}
            				if (this.normalMap && this.normalDetailMap) {
            						this._setParameter('material_normalDetailMapBumpiness', this.normalDetailMapBumpiness);
            				}
            				if (this.heightMap) {
            						this._setParameter('material_heightMapFactor', getUniform('heightMapFactor'));
            				}
            				if (this.envAtlas && this.cubeMap) {
            						this._setParameter('texture_envAtlas', this.envAtlas);
            						this._setParameter('texture_cubeMap', this.cubeMap);
            				} else if (this.envAtlas) {
            						this._setParameter('texture_envAtlas', this.envAtlas);
            				} else if (this.cubeMap) {
            						this._setParameter('texture_cubeMap', this.cubeMap);
            				} else if (this.sphereMap) {
            						this._setParameter('texture_sphereMap', this.sphereMap);
            				}
            				this._setParameter('material_reflectivity', this.reflectivity);
            				this._processParameters('_activeParams');
            				super.updateUniforms(device, scene);
            		}
            		updateEnvUniforms(device, scene) {
            				var hasLocalEnvOverride = this.envAtlas || this.cubeMap || this.sphereMap;
            				if (!hasLocalEnvOverride && this.useSkybox) {
            						if (scene.envAtlas && scene.skybox) {
            								this._setParameter('texture_envAtlas', scene.envAtlas);
            								this._setParameter('texture_cubeMap', scene.skybox);
            						} else if (scene.envAtlas) {
            								this._setParameter('texture_envAtlas', scene.envAtlas);
            						} else if (scene.skybox) {
            								this._setParameter('texture_cubeMap', scene.skybox);
            						}
            				}
            				this._processParameters('_activeLightingParams');
            		}
            		getShaderVariant(params) {
            				var { device, scene, pass, objDefs, sortedLights, cameraShaderParams } = params;
            				this.updateEnvUniforms(device, scene);
            				var shaderPassInfo = ShaderPass.get(device).getByIndex(pass);
            				var minimalOptions = pass === SHADER_DEPTH || pass === SHADER_PICK || pass === SHADER_PREPASS || shaderPassInfo.isShadow;
            				var options = minimalOptions ? standard.optionsContextMin : standard.optionsContext;
            				options.defines = getCoreDefines(this, params);
            				if (minimalOptions) {
            						this.shaderOptBuilder.updateMinRef(options, scene, this, objDefs, pass, sortedLights);
            				} else {
            						this.shaderOptBuilder.updateRef(options, scene, cameraShaderParams, this, objDefs, pass, sortedLights);
            				}
            				if (!this.useFog) options.defines.set('FOG', 'NONE');
            				options.defines.set('TONEMAP', tonemapNames[options.litOptions.toneMap]);
            				if (this.onUpdateShader) {
            						options = this.onUpdateShader(options);
            				}
            				var processingOptions = new ShaderProcessorOptions(params.viewUniformFormat, params.viewBindGroupFormat, params.vertexFormat);
            				var library = getProgramLibrary(device);
            				library.register('standard', standard);
            				var shader = library.getProgram('standard', options, processingOptions, this.userId);
            				this._dirtyShader = false;
            				return shader;
            		}
            		destroy() {
            				for(var asset in this._assetReferences){
            						this._assetReferences[asset]._unbind();
            				}
            				this._assetReferences = null;
            				super.destroy();
            		}
            		constructor(){
            				super(), this.userAttributes = new Map();
            				this._assetReferences = {};
            				this._activeParams = new Set();
            				this._activeLightingParams = new Set();
            				this.shaderOptBuilder = new StandardMaterialOptionsBuilder();
            				this.reset();
            		}
            }
            StandardMaterial.TEXTURE_PARAMETERS = standardMaterialTextureParameters;
            StandardMaterial.CUBEMAP_PARAMETERS = standardMaterialCubemapParameters;
            var defineUniform = (name, getUniformFunc)=>{
            		_uniforms[name] = getUniformFunc;
            };
            var definePropInternal = (name, constructorFunc, setterFunc, getterFunc)=>{
            		Object.defineProperty(StandardMaterial.prototype, name, {
            				get: getterFunc || function() {
            						return this["_" + name];
            				},
            				set: setterFunc
            		});
            		_props[name] = {
            				value: constructorFunc
            		};
            };
            var defineValueProp = (prop)=>{
            		var internalName = "_" + prop.name;
            		var dirtyShaderFunc = prop.dirtyShaderFunc || (()=>true);
            		var setterFunc = function setterFunc(value) {
            				var oldValue = this[internalName];
            				if (oldValue !== value) {
            						this._dirtyShader = this._dirtyShader || dirtyShaderFunc(oldValue, value);
            						this[internalName] = value;
            				}
            		};
            		definePropInternal(prop.name, ()=>prop.defaultValue, setterFunc, prop.getterFunc);
            };
            var defineAggProp = (prop)=>{
            		var internalName = "_" + prop.name;
            		var dirtyShaderFunc = prop.dirtyShaderFunc || (()=>true);
            		var setterFunc = function setterFunc(value) {
            				var oldValue = this[internalName];
            				if (!oldValue.equals(value)) {
            						this._dirtyShader = this._dirtyShader || dirtyShaderFunc(oldValue, value);
            						this[internalName] = oldValue.copy(value);
            				}
            		};
            		definePropInternal(prop.name, ()=>prop.defaultValue.clone(), setterFunc, prop.getterFunc);
            };
            var defineProp = (prop)=>{
            		return prop.defaultValue && prop.defaultValue.clone ? defineAggProp(prop) : defineValueProp(prop);
            };
            function _defineTex2D(name, channel, vertexColor, uv) {
            		if (channel === void 0) channel = 'rgb';
            		if (vertexColor === void 0) vertexColor = true;
            		if (uv === void 0) uv = 0;
            		_matTex2D[name] = channel.length || -1;
            		defineProp({
            				name: "" + name + "Map",
            				defaultValue: null,
            				dirtyShaderFunc: (oldValue, newValue)=>{
            						return !!oldValue !== !!newValue || oldValue && (oldValue.type !== newValue.type || oldValue.format !== newValue.format);
            				}
            		});
            		defineProp({
            				name: "" + name + "MapTiling",
            				defaultValue: new Vec2(1, 1)
            		});
            		defineProp({
            				name: "" + name + "MapOffset",
            				defaultValue: new Vec2(0, 0)
            		});
            		defineProp({
            				name: "" + name + "MapRotation",
            				defaultValue: 0
            		});
            		defineProp({
            				name: "" + name + "MapUv",
            				defaultValue: uv
            		});
            		if (channel) {
            				defineProp({
            						name: "" + name + "MapChannel",
            						defaultValue: channel
            				});
            				if (vertexColor) {
            						defineProp({
            								name: "" + name + "VertexColor",
            								defaultValue: false
            						});
            						defineProp({
            								name: "" + name + "VertexColorChannel",
            								defaultValue: channel
            						});
            				}
            		}
            		var mapTiling = "" + name + "MapTiling";
            		var mapOffset = "" + name + "MapOffset";
            		var mapRotation = "" + name + "MapRotation";
            		var mapTransform = "" + name + "MapTransform";
            		defineUniform(mapTransform, (material, device, scene)=>{
            				var tiling = material[mapTiling];
            				var offset = material[mapOffset];
            				var rotation = material[mapRotation];
            				if (tiling.x === 1 && tiling.y === 1 && offset.x === 0 && offset.y === 0 && rotation === 0) {
            						return null;
            				}
            				var uniform = material._allocUniform(mapTransform, ()=>{
            						return [
            								{
            										name: "texture_" + mapTransform + "0",
            										value: new Float32Array(3)
            								},
            								{
            										name: "texture_" + mapTransform + "1",
            										value: new Float32Array(3)
            								}
            						];
            				});
            				var cr = Math.cos(rotation * math.DEG_TO_RAD);
            				var sr = Math.sin(rotation * math.DEG_TO_RAD);
            				var uniform0 = uniform[0].value;
            				uniform0[0] = cr * tiling.x;
            				uniform0[1] = -sr * tiling.y;
            				uniform0[2] = offset.x;
            				var uniform1 = uniform[1].value;
            				uniform1[0] = sr * tiling.x;
            				uniform1[1] = cr * tiling.y;
            				uniform1[2] = 1.0 - tiling.y - offset.y;
            				return uniform;
            		});
            }
            function _defineColor(name, defaultValue) {
            		defineProp({
            				name: name,
            				defaultValue: defaultValue,
            				getterFunc: function getterFunc() {
            						this._dirtyShader = true;
            						return this["_" + name];
            				}
            		});
            		defineUniform(name, (material, device, scene)=>{
            				var uniform = material._allocUniform(name, ()=>new Float32Array(3));
            				var color = material[name];
            				_tempColor$2.linear(color);
            				uniform[0] = _tempColor$2.r;
            				uniform[1] = _tempColor$2.g;
            				uniform[2] = _tempColor$2.b;
            				return uniform;
            		});
            }
            function _defineFloat(name, defaultValue, getUniformFunc) {
            		defineProp({
            				name: name,
            				defaultValue: defaultValue,
            				dirtyShaderFunc: (oldValue, newValue)=>{
            						return (oldValue === 0 || oldValue === 1) !== (newValue === 0 || newValue === 1);
            				}
            		});
            		defineUniform(name, getUniformFunc);
            }
            function _defineObject(name, getUniformFunc) {
            		defineProp({
            				name: name,
            				defaultValue: null,
            				dirtyShaderFunc: (oldValue, newValue)=>{
            						return !!oldValue === !!newValue;
            				}
            		});
            		defineUniform(name, getUniformFunc);
            }
            function _defineFlag(name, defaultValue) {
            		defineProp({
            				name: name,
            				defaultValue: defaultValue
            		});
            }
            function _defineMaterialProps() {
            		_defineColor('ambient', new Color(1, 1, 1));
            		_defineColor('diffuse', new Color(1, 1, 1));
            		_defineColor('specular', new Color(0, 0, 0));
            		_defineColor('emissive', new Color(0, 0, 0));
            		_defineColor('sheen', new Color(1, 1, 1));
            		_defineColor('attenuation', new Color(1, 1, 1));
            		_defineFloat('emissiveIntensity', 1);
            		_defineFloat('specularityFactor', 1);
            		_defineFloat('sheenGloss', 0.0);
            		_defineFloat('gloss', 0.25);
            		_defineFloat('aoIntensity', 1);
            		_defineFloat('heightMapFactor', 1, (material, device, scene)=>{
            				return material.heightMapFactor * 0.025;
            		});
            		_defineFloat('opacity', 1);
            		_defineFloat('alphaFade', 1);
            		_defineFloat('alphaTest', 0);
            		_defineFloat('bumpiness', 1);
            		_defineFloat('normalDetailMapBumpiness', 1);
            		_defineFloat('reflectivity', 1);
            		_defineFloat('occludeSpecularIntensity', 1);
            		_defineFloat('refraction', 0);
            		_defineFloat('refractionIndex', 1.0 / 1.5);
            		_defineFloat('dispersion', 0);
            		_defineFloat('thickness', 0);
            		_defineFloat('attenuationDistance', 0);
            		_defineFloat('metalness', 1);
            		_defineFloat('anisotropy', 0);
            		_defineFloat('clearCoat', 0);
            		_defineFloat('clearCoatGloss', 1);
            		_defineFloat('clearCoatBumpiness', 1);
            		_defineFloat('aoUvSet', 0, null);
            		_defineFloat('iridescence', 0);
            		_defineFloat('iridescenceRefractionIndex', 1.0 / 1.5);
            		_defineFloat('iridescenceThicknessMin', 0);
            		_defineFloat('iridescenceThicknessMax', 0);
            		_defineObject('ambientSH');
            		_defineObject('cubeMapProjectionBox', (material, device, scene)=>{
            				var uniform = material._allocUniform('cubeMapProjectionBox', ()=>{
            						return [
            								{
            										name: 'envBoxMin',
            										value: new Float32Array(3)
            								},
            								{
            										name: 'envBoxMax',
            										value: new Float32Array(3)
            								}
            						];
            				});
            				var bboxMin = material.cubeMapProjectionBox.getMin();
            				var minUniform = uniform[0].value;
            				minUniform[0] = bboxMin.x;
            				minUniform[1] = bboxMin.y;
            				minUniform[2] = bboxMin.z;
            				var bboxMax = material.cubeMapProjectionBox.getMax();
            				var maxUniform = uniform[1].value;
            				maxUniform[0] = bboxMax.x;
            				maxUniform[1] = bboxMax.y;
            				maxUniform[2] = bboxMax.z;
            				return uniform;
            		});
            		_defineFlag('specularTint', false);
            		_defineFlag('specularityFactorTint', false);
            		_defineFlag('useMetalness', false);
            		_defineFlag('useMetalnessSpecularColor', false);
            		_defineFlag('useSheen', false);
            		_defineFlag('enableGGXSpecular', false);
            		_defineFlag('occludeDirect', false);
            		_defineFlag('opacityFadesSpecular', true);
            		_defineFlag('occludeSpecular', SPECOCC_AO);
            		_defineFlag('fresnelModel', FRESNEL_SCHLICK);
            		_defineFlag('useDynamicRefraction', false);
            		_defineFlag('cubeMapProjection', CUBEPROJ_NONE);
            		_defineFlag('customFragmentShader', null);
            		_defineFlag('useFog', true);
            		_defineFlag('useLighting', true);
            		_defineFlag('useTonemap', true);
            		_defineFlag('useSkybox', true);
            		_defineFlag('forceUv1', false);
            		_defineFlag('pixelSnap', false);
            		_defineFlag('twoSidedLighting', false);
            		_defineFlag('nineSlicedMode', undefined);
            		_defineFlag('msdfTextAttribute', false);
            		_defineFlag('useIridescence', false);
            		_defineFlag('glossInvert', false);
            		_defineFlag('sheenGlossInvert', false);
            		_defineFlag('clearCoatGlossInvert', false);
            		_defineFlag('opacityDither', DITHER_NONE);
            		_defineFlag('opacityShadowDither', DITHER_NONE);
            		_defineFlag('shadowCatcher', false);
            		_defineTex2D('diffuse');
            		_defineTex2D('specular');
            		_defineTex2D('emissive');
            		_defineTex2D('thickness', 'g');
            		_defineTex2D('specularityFactor', 'g');
            		_defineTex2D('normal', '');
            		_defineTex2D('metalness', 'g');
            		_defineTex2D('gloss', 'g');
            		_defineTex2D('opacity', 'a');
            		_defineTex2D('refraction', 'g');
            		_defineTex2D('height', 'g', false);
            		_defineTex2D('ao', 'g');
            		_defineTex2D('light', 'rgb', true, 1);
            		_defineTex2D('msdf', '');
            		_defineTex2D('diffuseDetail', 'rgb', false);
            		_defineTex2D('normalDetail', '');
            		_defineTex2D('aoDetail', 'g', false);
            		_defineTex2D('clearCoat', 'g');
            		_defineTex2D('clearCoatGloss', 'g');
            		_defineTex2D('clearCoatNormal', '');
            		_defineTex2D('sheen', 'rgb');
            		_defineTex2D('sheenGloss', 'g');
            		_defineTex2D('iridescence', 'g');
            		_defineTex2D('iridescenceThickness', 'g');
            		_defineFlag('diffuseDetailMode', DETAILMODE_MUL);
            		_defineFlag('aoDetailMode', DETAILMODE_MUL);
            		_defineObject('cubeMap');
            		_defineObject('sphereMap');
            		_defineObject('envAtlas');
            		var getterFunc = function getterFunc() {
            				return this._prefilteredCubemaps;
            		};
            		var setterFunc = function setterFunc(value) {
            				var cubemaps = this._prefilteredCubemaps;
            				value = value || [];
            				var changed = false;
            				var complete = true;
            				for(var i = 0; i < 6; ++i){
            						var v = value[i] || null;
            						if (cubemaps[i] !== v) {
            								cubemaps[i] = v;
            								changed = true;
            						}
            						complete = complete && !!cubemaps[i];
            				}
            				if (changed) {
            						if (complete) {
            								this.envAtlas = EnvLighting.generatePrefilteredAtlas(cubemaps, {
            										target: this.envAtlas
            								});
            						} else {
            								if (this.envAtlas) {
            										this.envAtlas.destroy();
            										this.envAtlas = null;
            								}
            						}
            						this._dirtyShader = true;
            				}
            		};
            		var empty = [
            				null,
            				null,
            				null,
            				null,
            				null,
            				null
            		];
            		definePropInternal('prefilteredCubemaps', ()=>empty.slice(), setterFunc, getterFunc);
            }
            _defineMaterialProps();
            
            var primitiveUv1Padding = 4.0 / 64;
            var primitiveUv1PaddingScale = 1.0 - primitiveUv1Padding * 2;
            class ConeBaseGeometry extends Geometry {
            		constructor(baseRadius, peakRadius, height, heightSegments, capSegments, roundedCaps){
            				super();
            				var pos = new Vec3();
            				var bottomToTop = new Vec3();
            				var norm = new Vec3();
            				var top = new Vec3();
            				var bottom = new Vec3();
            				var tangent = new Vec3();
            				var positions = [];
            				var normals = [];
            				var uvs = [];
            				var uvs1 = [];
            				var indices = [];
            				var offset;
            				if (height > 0) {
            						for(var i = 0; i <= heightSegments; i++){
            								for(var j = 0; j <= capSegments; j++){
            										var theta = j / capSegments * 2 * Math.PI - Math.PI;
            										var sinTheta = Math.sin(theta);
            										var cosTheta = Math.cos(theta);
            										bottom.set(sinTheta * baseRadius, -height / 2, cosTheta * baseRadius);
            										top.set(sinTheta * peakRadius, height / 2, cosTheta * peakRadius);
            										pos.lerp(bottom, top, i / heightSegments);
            										bottomToTop.sub2(top, bottom).normalize();
            										tangent.set(cosTheta, 0, -sinTheta);
            										norm.cross(tangent, bottomToTop).normalize();
            										positions.push(pos.x, pos.y, pos.z);
            										normals.push(norm.x, norm.y, norm.z);
            										var u = j / capSegments;
            										var v = i / heightSegments;
            										uvs.push(u, 1 - v);
            										var _v = v;
            										v = u;
            										u = _v;
            										u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
            										v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
            										u /= 3;
            										uvs1.push(u, 1 - v);
            										if (i < heightSegments && j < capSegments) {
            												var first = i * (capSegments + 1) + j;
            												var second = i * (capSegments + 1) + (j + 1);
            												var third = (i + 1) * (capSegments + 1) + j;
            												var fourth = (i + 1) * (capSegments + 1) + (j + 1);
            												indices.push(first, second, third);
            												indices.push(second, fourth, third);
            										}
            								}
            						}
            				}
            				if (roundedCaps) {
            						var latitudeBands = Math.floor(capSegments / 2);
            						var longitudeBands = capSegments;
            						var capOffset = height / 2;
            						for(var lat = 0; lat <= latitudeBands; lat++){
            								var theta1 = lat * Math.PI * 0.5 / latitudeBands;
            								var sinTheta1 = Math.sin(theta1);
            								var cosTheta1 = Math.cos(theta1);
            								for(var lon = 0; lon <= longitudeBands; lon++){
            										var phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;
            										var sinPhi = Math.sin(phi);
            										var cosPhi = Math.cos(phi);
            										var x = cosPhi * sinTheta1;
            										var y = cosTheta1;
            										var z = sinPhi * sinTheta1;
            										var u1 = 1 - lon / longitudeBands;
            										var v1 = 1 - lat / latitudeBands;
            										positions.push(x * peakRadius, y * peakRadius + capOffset, z * peakRadius);
            										normals.push(x, y, z);
            										uvs.push(u1, 1 - v1);
            										u1 = u1 * primitiveUv1PaddingScale + primitiveUv1Padding;
            										v1 = v1 * primitiveUv1PaddingScale + primitiveUv1Padding;
            										u1 /= 3;
            										v1 /= 3;
            										u1 += 1.0 / 3;
            										uvs1.push(u1, 1 - v1);
            								}
            						}
            						offset = (heightSegments + 1) * (capSegments + 1);
            						for(var lat1 = 0; lat1 < latitudeBands; ++lat1){
            								for(var lon1 = 0; lon1 < longitudeBands; ++lon1){
            										var first1 = lat1 * (longitudeBands + 1) + lon1;
            										var second1 = first1 + longitudeBands + 1;
            										indices.push(offset + first1 + 1, offset + second1, offset + first1);
            										indices.push(offset + first1 + 1, offset + second1 + 1, offset + second1);
            								}
            						}
            						for(var lat2 = 0; lat2 <= latitudeBands; lat2++){
            								var theta2 = Math.PI * 0.5 + lat2 * Math.PI * 0.5 / latitudeBands;
            								var sinTheta2 = Math.sin(theta2);
            								var cosTheta2 = Math.cos(theta2);
            								for(var lon2 = 0; lon2 <= longitudeBands; lon2++){
            										var phi1 = lon2 * 2 * Math.PI / longitudeBands - Math.PI / 2;
            										var sinPhi1 = Math.sin(phi1);
            										var cosPhi1 = Math.cos(phi1);
            										var x1 = cosPhi1 * sinTheta2;
            										var y1 = cosTheta2;
            										var z1 = sinPhi1 * sinTheta2;
            										var u2 = 1 - lon2 / longitudeBands;
            										var v2 = 1 - lat2 / latitudeBands;
            										positions.push(x1 * peakRadius, y1 * peakRadius - capOffset, z1 * peakRadius);
            										normals.push(x1, y1, z1);
            										uvs.push(u2, 1 - v2);
            										u2 = u2 * primitiveUv1PaddingScale + primitiveUv1Padding;
            										v2 = v2 * primitiveUv1PaddingScale + primitiveUv1Padding;
            										u2 /= 3;
            										v2 /= 3;
            										u2 += 2.0 / 3;
            										uvs1.push(u2, 1 - v2);
            								}
            						}
            						offset = (heightSegments + 1) * (capSegments + 1) + (longitudeBands + 1) * (latitudeBands + 1);
            						for(var lat3 = 0; lat3 < latitudeBands; ++lat3){
            								for(var lon3 = 0; lon3 < longitudeBands; ++lon3){
            										var first2 = lat3 * (longitudeBands + 1) + lon3;
            										var second2 = first2 + longitudeBands + 1;
            										indices.push(offset + first2 + 1, offset + second2, offset + first2);
            										indices.push(offset + first2 + 1, offset + second2 + 1, offset + second2);
            								}
            						}
            				} else {
            						offset = (heightSegments + 1) * (capSegments + 1);
            						if (baseRadius > 0) {
            								for(var i1 = 0; i1 < capSegments; i1++){
            										var theta3 = i1 / capSegments * 2 * Math.PI;
            										var x2 = Math.sin(theta3);
            										var y2 = -height / 2;
            										var z2 = Math.cos(theta3);
            										var u3 = 1 - (x2 + 1) / 2;
            										var v3 = (z2 + 1) / 2;
            										positions.push(x2 * baseRadius, y2, z2 * baseRadius);
            										normals.push(0, -1, 0);
            										uvs.push(u3, 1 - v3);
            										u3 = u3 * primitiveUv1PaddingScale + primitiveUv1Padding;
            										v3 = v3 * primitiveUv1PaddingScale + primitiveUv1Padding;
            										u3 /= 3;
            										v3 /= 3;
            										u3 += 1 / 3;
            										uvs1.push(u3, 1 - v3);
            										if (i1 > 1) {
            												indices.push(offset, offset + i1, offset + i1 - 1);
            										}
            								}
            						}
            						offset += capSegments;
            						if (peakRadius > 0) {
            								for(var i2 = 0; i2 < capSegments; i2++){
            										var theta4 = i2 / capSegments * 2 * Math.PI;
            										var x3 = Math.sin(theta4);
            										var y3 = height / 2;
            										var z3 = Math.cos(theta4);
            										var u4 = 1 - (x3 + 1) / 2;
            										var v4 = (z3 + 1) / 2;
            										positions.push(x3 * peakRadius, y3, z3 * peakRadius);
            										normals.push(0, 1, 0);
            										uvs.push(u4, 1 - v4);
            										u4 = u4 * primitiveUv1PaddingScale + primitiveUv1Padding;
            										v4 = v4 * primitiveUv1PaddingScale + primitiveUv1Padding;
            										u4 /= 3;
            										v4 /= 3;
            										u4 += 2 / 3;
            										uvs1.push(u4, 1 - v4);
            										if (i2 > 1) {
            												indices.push(offset, offset + i2 - 1, offset + i2);
            										}
            								}
            						}
            				}
            				this.positions = positions;
            				this.normals = normals;
            				this.uvs = uvs;
            				this.uvs1 = uvs1;
            				this.indices = indices;
            		}
            }
            
            class CapsuleGeometry extends ConeBaseGeometry {
            		constructor(opts = {}){
            				var _opts_radius;
            				var radius = (_opts_radius = opts.radius) != null ? _opts_radius : 0.3;
            				var _opts_height;
            				var height = (_opts_height = opts.height) != null ? _opts_height : 1;
            				var _opts_heightSegments;
            				var heightSegments = (_opts_heightSegments = opts.heightSegments) != null ? _opts_heightSegments : 1;
            				var _opts_sides;
            				var sides = (_opts_sides = opts.sides) != null ? _opts_sides : 20;
            				super(radius, radius, height - 2 * radius, heightSegments, sides, true);
            				if (opts.calculateTangents) {
            						this.tangents = calculateTangents(this.positions, this.normals, this.uvs, this.indices);
            				}
            		}
            }
            
            class ConeGeometry extends ConeBaseGeometry {
            		constructor(opts = {}){
            				var _opts_baseRadius;
            				var baseRadius = (_opts_baseRadius = opts.baseRadius) != null ? _opts_baseRadius : 0.5;
            				var _opts_peakRadius;
            				var peakRadius = (_opts_peakRadius = opts.peakRadius) != null ? _opts_peakRadius : 0;
            				var _opts_height;
            				var height = (_opts_height = opts.height) != null ? _opts_height : 1;
            				var _opts_heightSegments;
            				var heightSegments = (_opts_heightSegments = opts.heightSegments) != null ? _opts_heightSegments : 5;
            				var _opts_capSegments;
            				var capSegments = (_opts_capSegments = opts.capSegments) != null ? _opts_capSegments : 18;
            				super(baseRadius, peakRadius, height, heightSegments, capSegments, false);
            				if (opts.calculateTangents) {
            						this.tangents = calculateTangents(this.positions, this.normals, this.uvs, this.indices);
            				}
            		}
            }
            
            class CylinderGeometry extends ConeBaseGeometry {
            		constructor(opts = {}){
            				var _opts_radius;
            				var radius = (_opts_radius = opts.radius) != null ? _opts_radius : 0.5;
            				var _opts_height;
            				var height = (_opts_height = opts.height) != null ? _opts_height : 1;
            				var _opts_heightSegments;
            				var heightSegments = (_opts_heightSegments = opts.heightSegments) != null ? _opts_heightSegments : 5;
            				var _opts_capSegments;
            				var capSegments = (_opts_capSegments = opts.capSegments) != null ? _opts_capSegments : 20;
            				super(radius, radius, height, heightSegments, capSegments, false);
            				if (opts.calculateTangents) {
            						this.tangents = calculateTangents(this.positions, this.normals, this.uvs, this.indices);
            				}
            		}
            }
            
            class PlaneGeometry extends Geometry {
            		constructor(opts = {}){
            				super();
            				var _opts_halfExtents;
            				var he = (_opts_halfExtents = opts.halfExtents) != null ? _opts_halfExtents : new Vec2(0.5, 0.5);
            				var _opts_widthSegments;
            				var ws = (_opts_widthSegments = opts.widthSegments) != null ? _opts_widthSegments : 5;
            				var _opts_lengthSegments;
            				var ls = (_opts_lengthSegments = opts.lengthSegments) != null ? _opts_lengthSegments : 5;
            				var positions = [];
            				var normals = [];
            				var uvs = [];
            				var indices = [];
            				var vcounter = 0;
            				for(var i = 0; i <= ws; i++){
            						for(var j = 0; j <= ls; j++){
            								var x = -he.x + 2 * he.x * i / ws;
            								var y = 0.0;
            								var z = -(-he.y + 2 * he.y * j / ls);
            								var u = i / ws;
            								var v = j / ls;
            								positions.push(x, y, z);
            								normals.push(0, 1, 0);
            								uvs.push(u, 1 - v);
            								if (i < ws && j < ls) {
            										indices.push(vcounter + ls + 1, vcounter + 1, vcounter);
            										indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);
            								}
            								vcounter++;
            						}
            				}
            				this.positions = positions;
            				this.normals = normals;
            				this.uvs = uvs;
            				this.uvs1 = uvs;
            				this.indices = indices;
            				if (opts.calculateTangents) {
            						this.tangents = calculateTangents(positions, normals, uvs, indices);
            				}
            		}
            }
            
            class TorusGeometry extends Geometry {
            		constructor(opts = {}){
            				super();
            				var _opts_tubeRadius;
            				var rc = (_opts_tubeRadius = opts.tubeRadius) != null ? _opts_tubeRadius : 0.2;
            				var _opts_ringRadius;
            				var rt = (_opts_ringRadius = opts.ringRadius) != null ? _opts_ringRadius : 0.3;
            				var _opts_sectorAngle;
            				var sectorAngle = ((_opts_sectorAngle = opts.sectorAngle) != null ? _opts_sectorAngle : 360) * math.DEG_TO_RAD;
            				var _opts_segments;
            				var segments = (_opts_segments = opts.segments) != null ? _opts_segments : 30;
            				var _opts_sides;
            				var sides = (_opts_sides = opts.sides) != null ? _opts_sides : 20;
            				var positions = [];
            				var normals = [];
            				var uvs = [];
            				var indices = [];
            				for(var i = 0; i <= sides; i++){
            						for(var j = 0; j <= segments; j++){
            								var x = Math.cos(sectorAngle * j / segments) * (rt + rc * Math.cos(2 * Math.PI * i / sides));
            								var y = Math.sin(2 * Math.PI * i / sides) * rc;
            								var z = Math.sin(sectorAngle * j / segments) * (rt + rc * Math.cos(2 * Math.PI * i / sides));
            								var nx = Math.cos(sectorAngle * j / segments) * Math.cos(2 * Math.PI * i / sides);
            								var ny = Math.sin(2 * Math.PI * i / sides);
            								var nz = Math.sin(sectorAngle * j / segments) * Math.cos(2 * Math.PI * i / sides);
            								var u = i / sides;
            								var v = 1 - j / segments;
            								positions.push(x, y, z);
            								normals.push(nx, ny, nz);
            								uvs.push(u, 1.0 - v);
            								if (i < sides && j < segments) {
            										var first = i * (segments + 1) + j;
            										var second = (i + 1) * (segments + 1) + j;
            										var third = i * (segments + 1) + (j + 1);
            										var fourth = (i + 1) * (segments + 1) + (j + 1);
            										indices.push(first, second, third);
            										indices.push(second, fourth, third);
            								}
            						}
            				}
            				this.positions = positions;
            				this.normals = normals;
            				this.uvs = uvs;
            				this.uvs1 = uvs;
            				this.indices = indices;
            				if (opts.calculateTangents) {
            						this.tangents = calculateTangents(positions, normals, uvs, indices);
            				}
            		}
            }
            
            class ProgramLibrary {
            		destroy() {
            				this.clearCache();
            		}
            		register(name, generator) {
            				if (!this._generators.has(name)) {
            						this._generators.set(name, generator);
            				}
            		}
            		unregister(name) {
            				if (this._generators.has(name)) {
            						this._generators.delete(name);
            				}
            		}
            		isRegistered(name) {
            				return this._generators.has(name);
            		}
            		generateShaderDefinition(generator, name, key, options) {
            				var def = this.definitionsCache.get(key);
            				if (!def) {
            						var _options_litOptions, _options_litOptions1;
            						var lights;
            						if ((_options_litOptions = options.litOptions) == null ? void 0 : _options_litOptions.lights) {
            								lights = options.litOptions.lights;
            								options.litOptions.lights = lights.map((l)=>{
            										var lcopy = l.clone ? l.clone() : l;
            										lcopy.key = l.key;
            										return lcopy;
            								});
            						}
            						this.storeNewProgram(name, options);
            						if ((_options_litOptions1 = options.litOptions) == null ? void 0 : _options_litOptions1.lights) {
            								options.litOptions.lights = lights;
            						}
            						if (this._precached) ;
            						var device = this._device;
            						def = generator.createShaderDefinition(device, options);
            						var _def_name;
            						def.name = (_def_name = def.name) != null ? _def_name : options.pass ? name + "-pass:" + options.pass : name;
            						this.definitionsCache.set(key, def);
            				}
            				return def;
            		}
            		getCachedShader(key) {
            				return this.processedCache.get(key);
            		}
            		setCachedShader(key, shader) {
            				this.processedCache.set(key, shader);
            		}
            		getProgram(name, options, processingOptions, userMaterialId) {
            				var generator = this._generators.get(name);
            				if (!generator) {
            						return null;
            				}
            				var generationKeyString = generator.generateKey(options);
            				var generationKey = hashCode(generationKeyString);
            				var processingKeyString = processingOptions.generateKey(this._device);
            				var processingKey = hashCode(processingKeyString);
            				var totalKey = generationKey + "#" + processingKey;
            				var processedShader = this.getCachedShader(totalKey);
            				if (!processedShader) {
            						var generatedShaderDef = this.generateShaderDefinition(generator, name, generationKey, options);
            						var passName = '';
            						var shaderPassInfo;
            						if (options.pass !== undefined) {
            								shaderPassInfo = ShaderPass.get(this._device).getByIndex(options.pass);
            								passName = "-" + shaderPassInfo.name;
            						}
            						this._device.fire('shader:generate', {
            								userMaterialId,
            								shaderPassInfo,
            								definition: generatedShaderDef
            						});
            						var shaderDefinition = {
            								name: "" + generatedShaderDef.name + passName + "-proc",
            								attributes: generatedShaderDef.attributes,
            								vshader: generatedShaderDef.vshader,
            								vincludes: generatedShaderDef.vincludes,
            								fincludes: generatedShaderDef.fincludes,
            								fshader: generatedShaderDef.fshader,
            								processingOptions: processingOptions,
            								shaderLanguage: generatedShaderDef.shaderLanguage,
            								meshUniformBufferFormat: generatedShaderDef.meshUniformBufferFormat,
            								meshBindGroupFormat: generatedShaderDef.meshBindGroupFormat
            						};
            						processedShader = new Shader(this._device, shaderDefinition);
            						this.setCachedShader(totalKey, processedShader);
            				}
            				return processedShader;
            		}
            		storeNewProgram(name, options) {
            				var opt = {};
            				if (name === 'standard') {
            						var defaultMat = this._getDefaultStdMatOptions(options.pass);
            						for(var p in options){
            								if (options.hasOwnProperty(p) && defaultMat[p] !== options[p] || p === 'pass') {
            										opt[p] = options[p];
            								}
            						}
            						for(var p1 in options.litOptions){
            								opt[p1] = options.litOptions[p1];
            						}
            				} else {
            						opt = options;
            				}
            				this._programsCollection.push(JSON.stringify({
            						name: name,
            						options: opt
            				}));
            		}
            		dumpPrograms() {
            				var text = 'let device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;\n';
            				text += 'let shaders = [';
            				if (this._programsCollection[0]) {
            						text += "\n	" + this._programsCollection[0];
            				}
            				for(var i = 1; i < this._programsCollection.length; ++i){
            						text += ",\n	" + this._programsCollection[i];
            				}
            				text += '\n];\n';
            				text += 'pc.getProgramLibrary(device).precompile(shaders);\n';
            				text += 'if (pc.version != "' + version + '" || pc.revision != "' + revision + '")\n';
            				text += '\tconsole.warn(\"precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine\");';
            				var element = document.createElement('a');
            				element.setAttribute('href', "data:text/plain;charset=utf-8," + encodeURIComponent(text));
            				element.setAttribute('download', 'precompile-shaders.js');
            				element.style.display = 'none';
            				document.body.appendChild(element);
            				element.click();
            				document.body.removeChild(element);
            		}
            		clearCache() {
            				this._isClearingCache = true;
            				this.processedCache.forEach((shader)=>{
            						shader.destroy();
            				});
            				this.processedCache.clear();
            				this._isClearingCache = false;
            		}
            		removeFromCache(shader) {
            				if (this._isClearingCache) {
            						return;
            				}
            				this.processedCache.forEach((cachedShader, key)=>{
            						if (shader === cachedShader) {
            								this.processedCache.delete(key);
            						}
            				});
            		}
            		_getDefaultStdMatOptions(pass) {
            				var shaderPassInfo = ShaderPass.get(this._device).getByIndex(pass);
            				return pass === SHADER_DEPTH || pass === SHADER_PICK || pass === SHADER_PREPASS || shaderPassInfo.isShadow ? this._defaultStdMatOptionMin : this._defaultStdMatOption;
            		}
            		precompile(cache) {
            				if (cache) {
            						var shaders = new Array(cache.length);
            						for(var i = 0; i < cache.length; i++){
            								if (cache[i].name === 'standard') {
            										var opt = cache[i].options;
            										var defaultMat = this._getDefaultStdMatOptions(opt.pass);
            										for(var p in defaultMat){
            												if (defaultMat.hasOwnProperty(p) && opt[p] === undefined) {
            														opt[p] = defaultMat[p];
            												}
            										}
            								}
            								shaders[i] = this.getProgram(cache[i].name, cache[i].options);
            						}
            				}
            				this._precached = true;
            		}
            		constructor(device, standardMaterial){
            				this.processedCache = new Map();
            				this.definitionsCache = new Map();
            				this._generators = new Map();
            				this._device = device;
            				this._isClearingCache = false;
            				this._precached = false;
            				this._programsCollection = [];
            				this._defaultStdMatOption = new StandardMaterialOptions();
            				this._defaultStdMatOptionMin = new StandardMaterialOptions();
            				var defaultCameraShaderParams = new CameraShaderParams();
            				standardMaterial.shaderOptBuilder.updateRef(this._defaultStdMatOption, {}, defaultCameraShaderParams, standardMaterial, null, [], SHADER_FORWARD, null);
            				standardMaterial.shaderOptBuilder.updateMinRef(this._defaultStdMatOptionMin, {}, standardMaterial, null, SHADER_SHADOW, null);
            				device.on('destroy:shader', (shader)=>{
            						this.removeFromCache(shader);
            				});
            		}
            }
            
            var bakeDirLmEndPS = "\n	vec4 dirLm = texture2D(texture_dirLightMap, vUv1);\n	if (bakeDir > 0.5) {\n		if (dAtten > 0.00001) {\n			dirLm.xyz = dirLm.xyz * 2.0 - vec3(1.0);\n			dAtten = saturate(dAtten);\n			gl_FragColor.rgb = normalize(dLightDirNormW.xyz*dAtten + dirLm.xyz*dirLm.w) * 0.5 + vec3(0.5);\n			gl_FragColor.a = dirLm.w + dAtten;\n			gl_FragColor.a = max(gl_FragColor.a, 1.0 / 255.0);\n		} else {\n			gl_FragColor = dirLm;\n		}\n	} else {\n		gl_FragColor.rgb = dirLm.xyz;\n		gl_FragColor.a = max(dirLm.w, dAtten > 0.00001? (1.0/255.0) : 0.0);\n	}\n";
            
            var bakeLmEndPS = "\n#ifdef LIGHTMAP_RGBM\n	gl_FragColor.rgb = dDiffuseLight;\n	gl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(0.5));\n	gl_FragColor.rgb /= 8.0;\n	gl_FragColor.a = clamp( max( max( gl_FragColor.r, gl_FragColor.g ), max( gl_FragColor.b, 1.0 / 255.0 ) ), 0.0,1.0 );\n	gl_FragColor.a = ceil(gl_FragColor.a * 255.0) / 255.0;\n	gl_FragColor.rgb /= gl_FragColor.a;\n#else\n	gl_FragColor = vec4(dDiffuseLight, 1.0);\n#endif\n";
            
            var dilatePS = "\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\nbool isUsed(vec4 pixel) {\n	#if HDR\n		return any(greaterThan(pixel.rgb, vec3(0.0)));\n	#else\n		return pixel.a > 0.0;\n	#endif\n}\nvoid main(void) {\n	vec4 c = texture2DLod(source, vUv0, 0.0);\n	c = isUsed(c) ? c : texture2DLod(source, vUv0 - pixelOffset, 0.0);\n	c = isUsed(c) ? c : texture2DLod(source, vUv0 + vec2(0, -pixelOffset.y), 0.0);\n	c = isUsed(c) ? c : texture2DLod(source, vUv0 + vec2(pixelOffset.x, -pixelOffset.y), 0.0);\n	c = isUsed(c) ? c : texture2DLod(source, vUv0 + vec2(-pixelOffset.x, 0), 0.0);\n	c = isUsed(c) ? c : texture2DLod(source, vUv0 + vec2(pixelOffset.x, 0), 0.0);\n	c = isUsed(c) ? c : texture2DLod(source, vUv0 + vec2(-pixelOffset.x, pixelOffset.y), 0.0);\n	c = isUsed(c) ? c : texture2DLod(source, vUv0 + vec2(0, pixelOffset.y), 0.0);\n	c = isUsed(c) ? c : texture2DLod(source, vUv0 + pixelOffset, 0.0);\n	gl_FragColor = c;\n}\n";
            
            var bilateralDeNoisePS = "\nfloat normpdf3(in vec3 v, in float sigma) {\n	return 0.39894 * exp(-0.5 * dot(v, v) / (sigma * sigma)) / sigma;\n}\nvec3 decodeRGBM(vec4 rgbm) {\n	vec3 color = (8.0 * rgbm.a) * rgbm.rgb;\n	return color * color;\n}\nfloat saturate(float x) {\n	return clamp(x, 0.0, 1.0);\n}\nvec4 encodeRGBM(vec3 color) {\n	vec4 encoded;\n	encoded.rgb = pow(color.rgb, vec3(0.5));\n	encoded.rgb *= 1.0 / 8.0;\n	encoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );\n	encoded.a = ceil(encoded.a * 255.0) / 255.0;\n	encoded.rgb /= encoded.a;\n	return encoded;\n}\nvec3 decode(vec4 pixel) {\n	#if HDR\n		return pixel.rgb;\n	#else\n		return decodeRGBM(pixel);\n	#endif\n}\nbool isUsed(vec4 pixel) {\n	#if HDR\n		return any(greaterThan(pixel.rgb, vec3(0.0)));\n	#else\n		return pixel.a > 0.0;\n	#endif\n}\n#define MSIZE 15\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\nuniform vec2 sigmas;\nuniform float bZnorm;\nuniform float kernel[MSIZE];\nvoid main(void) {\n	\n	vec4 pixel = texture2DLod(source, vUv0, 0.0);\n	if (!isUsed(pixel)) {\n		gl_FragColor = pixel;\n		return ;\n	}\n	float sigma = sigmas.x;\n	float bSigma = sigmas.y;\n	vec3 pixelHdr = decode(pixel);\n	vec3 accumulatedHdr = vec3(0.0);\n	float accumulatedFactor = 0.000001;\n	const int kSize = (MSIZE-1)/2;\n	for (int i = -kSize; i <= kSize; ++i) {\n		for (int j = -kSize; j <= kSize; ++j) {\n			\n			vec2 coord = vUv0 + vec2(float(i), float(j)) * pixelOffset;\n			vec4 pix = texture2DLod(source, coord, 0.0);\n			if (isUsed(pix)) {\n				vec3 hdr = decode(pix);\n				float factor = kernel[kSize + j] * kernel[kSize + i];\n				factor *= normpdf3(hdr - pixelHdr, bSigma) * bZnorm;\n				accumulatedHdr += factor * hdr;\n				accumulatedFactor += factor;\n			}\n		}\n	}\n	vec3 finalHDR = accumulatedHdr / accumulatedFactor;\n	#if HDR\n		gl_FragColor = vec4(finalHDR, 1.0);\n	#else\n		gl_FragColor = encodeRGBM(finalHDR);\n	#endif\n}\n";
            
            var shaderChunksLightmapper = {
            		bakeDirLmEndPS,
            		bakeLmEndPS,
            		dilatePS,
            		bilateralDeNoisePS
            };
            
            var mat4$1 = new Mat4();
            var quat$2 = new Quat();
            var aabb = new BoundingBox();
            var aabb2 = new BoundingBox();
            var debugColor = new Color(1, 1, 0, 0.4);
            var SH_C0$2 = 0.28209479177387814;
            class SplatIterator {
            		constructor(gsplatData, p, r, s, c){
            				var x = gsplatData.getProp('x');
            				var y = gsplatData.getProp('y');
            				var z = gsplatData.getProp('z');
            				var rx = gsplatData.getProp('rot_1');
            				var ry = gsplatData.getProp('rot_2');
            				var rz = gsplatData.getProp('rot_3');
            				var rw = gsplatData.getProp('rot_0');
            				var sx = gsplatData.getProp('scale_0');
            				var sy = gsplatData.getProp('scale_1');
            				var sz = gsplatData.getProp('scale_2');
            				var cr = gsplatData.getProp('f_dc_0');
            				var cg = gsplatData.getProp('f_dc_1');
            				var cb = gsplatData.getProp('f_dc_2');
            				var ca = gsplatData.getProp('opacity');
            				var sigmoid = (v)=>{
            						if (v > 0) {
            								return 1 / (1 + Math.exp(-v));
            						}
            						var t = Math.exp(v);
            						return t / (1 + t);
            				};
            				this.read = (i)=>{
            						if (p) {
            								p.x = x[i];
            								p.y = y[i];
            								p.z = z[i];
            						}
            						if (r) {
            								r.set(rx[i], ry[i], rz[i], rw[i]);
            						}
            						if (s) {
            								s.set(Math.exp(sx[i]), Math.exp(sy[i]), Math.exp(sz[i]));
            						}
            						if (c) {
            								c.set(0.5 + cr[i] * SH_C0$2, 0.5 + cg[i] * SH_C0$2, 0.5 + cb[i] * SH_C0$2, sigmoid(ca[i]));
            						}
            				};
            		}
            }
            var calcSplatMat = (result, p, r)=>{
            		quat$2.set(r.x, r.y, r.z, r.w).normalize();
            		result.setTRS(p, quat$2, Vec3.ONE);
            };
            class GSplatData {
            		static calcSplatAabb(result, p, r, s) {
            				calcSplatMat(mat4$1, p, r);
            				aabb.center.set(0, 0, 0);
            				aabb.halfExtents.set(s.x * 2, s.y * 2, s.z * 2);
            				result.setFromTransformedAabb(aabb, mat4$1);
            		}
            		getProp(name, elementName) {
            				if (elementName === void 0) elementName = 'vertex';
            				var _this_getElement_properties_find, _this_getElement;
            				return (_this_getElement = this.getElement(elementName)) == null ? void 0 : (_this_getElement_properties_find = _this_getElement.properties.find((p)=>p.name === name)) == null ? void 0 : _this_getElement_properties_find.storage;
            		}
            		getElement(name) {
            				return this.elements.find((e)=>e.name === name);
            		}
            		addProp(name, storage) {
            				this.getElement('vertex').properties.push({
            						type: 'float',
            						name,
            						storage,
            						byteSize: 4
            				});
            		}
            		createIter(p, r, s, c) {
            				return new SplatIterator(this, p, r, s, c);
            		}
            		calcAabb(result, pred) {
            				var mx, my, mz, Mx, My, Mz;
            				var first = true;
            				var x = this.getProp('x');
            				var y = this.getProp('y');
            				var z = this.getProp('z');
            				var sx = this.getProp('scale_0');
            				var sy = this.getProp('scale_1');
            				var sz = this.getProp('scale_2');
            				for(var i = 0; i < this.numSplats; ++i){
            						if (pred && !pred(i)) {
            								continue;
            						}
            						var px = x[i];
            						var py = y[i];
            						var pz = z[i];
            						var scale = Math.max(sx[i], sy[i], sz[i]);
            						if (!isFinite(px) || !isFinite(py) || !isFinite(pz) || !isFinite(scale)) {
            								continue;
            						}
            						var scaleVal = 2.0 * Math.exp(scale);
            						if (first) {
            								first = false;
            								mx = px - scaleVal;
            								my = py - scaleVal;
            								mz = pz - scaleVal;
            								Mx = px + scaleVal;
            								My = py + scaleVal;
            								Mz = pz + scaleVal;
            						} else {
            								mx = Math.min(mx, px - scaleVal);
            								my = Math.min(my, py - scaleVal);
            								mz = Math.min(mz, pz - scaleVal);
            								Mx = Math.max(Mx, px + scaleVal);
            								My = Math.max(My, py + scaleVal);
            								Mz = Math.max(Mz, pz + scaleVal);
            						}
            				}
            				if (!first) {
            						result.center.set((mx + Mx) * 0.5, (my + My) * 0.5, (mz + Mz) * 0.5);
            						result.halfExtents.set((Mx - mx) * 0.5, (My - my) * 0.5, (Mz - mz) * 0.5);
            				}
            				return !first;
            		}
            		calcAabbExact(result, pred) {
            				var p = new Vec3();
            				var r = new Quat();
            				var s = new Vec3();
            				var iter = this.createIter(p, r, s);
            				var first = true;
            				for(var i = 0; i < this.numSplats; ++i){
            						if (pred && !pred(i)) {
            								continue;
            						}
            						iter.read(i);
            						if (first) {
            								first = false;
            								GSplatData.calcSplatAabb(result, p, r, s);
            						} else {
            								GSplatData.calcSplatAabb(aabb2, p, r, s);
            								result.add(aabb2);
            						}
            				}
            				return !first;
            		}
            		getCenters(result) {
            				var x = this.getProp('x');
            				var y = this.getProp('y');
            				var z = this.getProp('z');
            				for(var i = 0; i < this.numSplats; ++i){
            						result[i * 3 + 0] = x[i];
            						result[i * 3 + 1] = y[i];
            						result[i * 3 + 2] = z[i];
            				}
            		}
            		calcFocalPoint(result, pred) {
            				var x = this.getProp('x');
            				var y = this.getProp('y');
            				var z = this.getProp('z');
            				var sx = this.getProp('scale_0');
            				var sy = this.getProp('scale_1');
            				var sz = this.getProp('scale_2');
            				result.x = 0;
            				result.y = 0;
            				result.z = 0;
            				var sum = 0;
            				for(var i = 0; i < this.numSplats; ++i){
            						if (pred && !pred(i)) {
            								continue;
            						}
            						var px = x[i];
            						var py = y[i];
            						var pz = z[i];
            						if (!isFinite(px) || !isFinite(py) || !isFinite(pz)) {
            								continue;
            						}
            						var weight = 1.0 / (1.0 + Math.exp(Math.max(sx[i], sy[i], sz[i])));
            						result.x += px * weight;
            						result.y += py * weight;
            						result.z += pz * weight;
            						sum += weight;
            				}
            				result.mulScalar(1 / sum);
            		}
            		renderWireframeBounds(scene, worldMat) {
            				var p = new Vec3();
            				var r = new Quat();
            				var s = new Vec3();
            				var min = new Vec3();
            				var max = new Vec3();
            				var iter = this.createIter(p, r, s);
            				for(var i = 0; i < this.numSplats; ++i){
            						iter.read(i);
            						calcSplatMat(mat4$1, p, r);
            						mat4$1.mul2(worldMat, mat4$1);
            						min.set(s.x * -2, s.y * -2, s.z * -2);
            						max.set(s.x * 2.0, s.y * 2.0, s.z * 2.0);
            						scene.immediate.drawWireAlignedBox(min, max, debugColor, true, scene.defaultDrawLayer, mat4$1);
            				}
            		}
            		get isCompressed() {
            				return false;
            		}
            		get shBands() {
            				var numProps = ()=>{
            						for(var i = 0; i < 45; ++i){
            								if (!this.getProp("f_rest_" + i)) {
            										return i;
            								}
            						}
            						return 45;
            				};
            				var sizes = {
            						9: 1,
            						24: 2,
            						45: 3
            				};
            				var _sizes_numProps;
            				return (_sizes_numProps = sizes[numProps()]) != null ? _sizes_numProps : 0;
            		}
            		calcMortonOrder() {
            				var calcMinMax = (arr)=>{
            						var min = arr[0];
            						var max = arr[0];
            						for(var i = 1; i < arr.length; i++){
            								if (arr[i] < min) min = arr[i];
            								if (arr[i] > max) max = arr[i];
            						}
            						return {
            								min,
            								max
            						};
            				};
            				var encodeMorton3 = (x, y, z)=>{
            						var Part1By2 = (x)=>{
            								x &= 0x000003ff;
            								x = (x ^ x << 16) & 0xff0000ff;
            								x = (x ^ x << 8) & 0x0300f00f;
            								x = (x ^ x << 4) & 0x030c30c3;
            								x = (x ^ x << 2) & 0x09249249;
            								return x;
            						};
            						return (Part1By2(z) << 2) + (Part1By2(y) << 1) + Part1By2(x);
            				};
            				var x = this.getProp('x');
            				var y = this.getProp('y');
            				var z = this.getProp('z');
            				var { min: minX, max: maxX } = calcMinMax(x);
            				var { min: minY, max: maxY } = calcMinMax(y);
            				var { min: minZ, max: maxZ } = calcMinMax(z);
            				var sizeX = minX === maxX ? 0 : 1024 / (maxX - minX);
            				var sizeY = minY === maxY ? 0 : 1024 / (maxY - minY);
            				var sizeZ = minZ === maxZ ? 0 : 1024 / (maxZ - minZ);
            				var codes = new Map();
            				for(var i = 0; i < this.numSplats; i++){
            						var ix = Math.floor((x[i] - minX) * sizeX);
            						var iy = Math.floor((y[i] - minY) * sizeY);
            						var iz = Math.floor((z[i] - minZ) * sizeZ);
            						var code = encodeMorton3(ix, iy, iz);
            						var val = codes.get(code);
            						if (val) {
            								val.push(i);
            						} else {
            								codes.set(code, [
            										i
            								]);
            						}
            				}
            				var keys = Array.from(codes.keys()).sort((a, b)=>a - b);
            				var indices = new Uint32Array(this.numSplats);
            				var idx = 0;
            				for(var i1 = 0; i1 < keys.length; ++i1){
            						var val1 = codes.get(keys[i1]);
            						for(var j = 0; j < val1.length; ++j){
            								indices[idx++] = val1[j];
            						}
            				}
            				return indices;
            		}
            		reorder(order) {
            				var cache = new Map();
            				var getStorage = (size)=>{
            						if (cache.has(size)) {
            								var buffer = cache.get(size);
            								cache.delete(size);
            								return buffer;
            						}
            						return new ArrayBuffer(size);
            				};
            				var returnStorage = (buffer)=>{
            						cache.set(buffer.byteLength, buffer);
            				};
            				var reorder = (data)=>{
            						var result = new data.constructor(getStorage(data.byteLength));
            						for(var i = 0; i < order.length; i++){
            								result[i] = data[order[i]];
            						}
            						returnStorage(data.buffer);
            						return result;
            				};
            				this.elements.forEach((element)=>{
            						element.properties.forEach((property)=>{
            								if (property.storage) {
            										property.storage = reorder(property.storage);
            								}
            						});
            				});
            		}
            		reorderData() {
            				this.reorder(this.calcMortonOrder());
            		}
            		constructor(elements){
            				this.elements = elements;
            				this.numSplats = this.getElement('vertex').count;
            		}
            }
            
            var createGSplatMaterial = (options)=>{
            		if (options === void 0) options = {};
            		var _options_dither;
            		var ditherEnum = (_options_dither = options.dither) != null ? _options_dither : DITHER_NONE;
            		var dither = ditherEnum !== DITHER_NONE;
            		var _options_vertex, _options_fragment;
            		var material = new ShaderMaterial({
            				uniqueName: 'SplatMaterial',
            				vertexGLSL: (_options_vertex = options.vertex) != null ? _options_vertex : shaderChunks.gsplatVS,
            				fragmentGLSL: (_options_fragment = options.fragment) != null ? _options_fragment : shaderChunks.gsplatPS,
            				attributes: {
            						vertex_position: SEMANTIC_POSITION,
            						vertex_id_attrib: SEMANTIC_ATTR13
            				}
            		});
            		material.setDefine("DITHER_" + ditherEnum.toUpperCase(), '');
            		material.cull = CULLFACE_NONE;
            		material.blendType = dither ? BLEND_NONE : BLEND_PREMULTIPLIED;
            		material.depthWrite = dither;
            		material.update();
            		return material;
            };
            
            var getSHData = (gsplatData, numCoeffs)=>{
            		var result = [];
            		for(var i = 0; i < numCoeffs; ++i){
            				result.push(gsplatData.getProp("f_rest_" + i));
            		}
            		return result;
            };
            class GSplat {
            		destroy() {
            				var _this_colorTexture, _this_transformATexture, _this_transformBTexture, _this_sh1to3Texture, _this_sh4to7Texture, _this_sh8to11Texture, _this_sh12to15Texture;
            				(_this_colorTexture = this.colorTexture) == null ? void 0 : _this_colorTexture.destroy();
            				(_this_transformATexture = this.transformATexture) == null ? void 0 : _this_transformATexture.destroy();
            				(_this_transformBTexture = this.transformBTexture) == null ? void 0 : _this_transformBTexture.destroy();
            				(_this_sh1to3Texture = this.sh1to3Texture) == null ? void 0 : _this_sh1to3Texture.destroy();
            				(_this_sh4to7Texture = this.sh4to7Texture) == null ? void 0 : _this_sh4to7Texture.destroy();
            				(_this_sh8to11Texture = this.sh8to11Texture) == null ? void 0 : _this_sh8to11Texture.destroy();
            				(_this_sh12to15Texture = this.sh12to15Texture) == null ? void 0 : _this_sh12to15Texture.destroy();
            		}
            		createMaterial(options) {
            				var result = createGSplatMaterial(options);
            				result.setParameter('splatColor', this.colorTexture);
            				result.setParameter('transformA', this.transformATexture);
            				result.setParameter('transformB', this.transformBTexture);
            				result.setParameter('numSplats', this.numSplatsVisible);
            				result.setDefine('SH_BANDS', this.shBands);
            				if (this.sh1to3Texture) result.setParameter('splatSH_1to3', this.sh1to3Texture);
            				if (this.sh4to7Texture) result.setParameter('splatSH_4to7', this.sh4to7Texture);
            				if (this.sh8to11Texture) result.setParameter('splatSH_8to11', this.sh8to11Texture);
            				if (this.sh12to15Texture) result.setParameter('splatSH_12to15', this.sh12to15Texture);
            				return result;
            		}
            		evalTextureSize(count) {
            				var width = Math.ceil(Math.sqrt(count));
            				var height = Math.ceil(count / width);
            				return new Vec2(width, height);
            		}
            		createTexture(name, format, size) {
            				return new Texture(this.device, {
            						name: name,
            						width: size.x,
            						height: size.y,
            						format: format,
            						cubemap: false,
            						mipmaps: false,
            						minFilter: FILTER_NEAREST,
            						magFilter: FILTER_NEAREST,
            						addressU: ADDRESS_CLAMP_TO_EDGE,
            						addressV: ADDRESS_CLAMP_TO_EDGE
            				});
            		}
            		updateColorData(gsplatData) {
            				var texture = this.colorTexture;
            				if (!texture) {
            						return;
            				}
            				var float2Half = FloatPacking.float2Half;
            				var data = texture.lock();
            				var cr = gsplatData.getProp('f_dc_0');
            				var cg = gsplatData.getProp('f_dc_1');
            				var cb = gsplatData.getProp('f_dc_2');
            				var ca = gsplatData.getProp('opacity');
            				var SH_C0 = 0.28209479177387814;
            				for(var i = 0; i < this.numSplats; ++i){
            						var r = cr[i] * SH_C0 + 0.5;
            						var g = cg[i] * SH_C0 + 0.5;
            						var b = cb[i] * SH_C0 + 0.5;
            						var a = 1 / (1 + Math.exp(-ca[i]));
            						data[i * 4 + 0] = float2Half(r);
            						data[i * 4 + 1] = float2Half(g);
            						data[i * 4 + 2] = float2Half(b);
            						data[i * 4 + 3] = float2Half(a);
            				}
            				texture.unlock();
            		}
            		updateTransformData(gsplatData) {
            				var float2Half = FloatPacking.float2Half;
            				if (!this.transformATexture) {
            						return;
            				}
            				var dataA = this.transformATexture.lock();
            				var dataAFloat32 = new Float32Array(dataA.buffer);
            				var dataB = this.transformBTexture.lock();
            				var p = new Vec3();
            				var r = new Quat();
            				var s = new Vec3();
            				var iter = gsplatData.createIter(p, r, s);
            				for(var i = 0; i < this.numSplats; i++){
            						iter.read(i);
            						r.normalize();
            						if (r.w < 0) {
            								r.mulScalar(-1);
            						}
            						dataAFloat32[i * 4 + 0] = p.x;
            						dataAFloat32[i * 4 + 1] = p.y;
            						dataAFloat32[i * 4 + 2] = p.z;
            						dataA[i * 4 + 3] = float2Half(r.x) | float2Half(r.y) << 16;
            						dataB[i * 4 + 0] = float2Half(s.x);
            						dataB[i * 4 + 1] = float2Half(s.y);
            						dataB[i * 4 + 2] = float2Half(s.z);
            						dataB[i * 4 + 3] = float2Half(r.z);
            				}
            				this.transformATexture.unlock();
            				this.transformBTexture.unlock();
            		}
            		updateSHData(gsplatData) {
            				var _this_sh4to7Texture, _this_sh8to11Texture, _this_sh12to15Texture, _this_sh4to7Texture1, _this_sh8to11Texture1, _this_sh12to15Texture1;
            				var sh1to3Data = this.sh1to3Texture.lock();
            				var sh4to7Data = (_this_sh4to7Texture = this.sh4to7Texture) == null ? void 0 : _this_sh4to7Texture.lock();
            				var sh8to11Data = (_this_sh8to11Texture = this.sh8to11Texture) == null ? void 0 : _this_sh8to11Texture.lock();
            				var sh12to15Data = (_this_sh12to15Texture = this.sh12to15Texture) == null ? void 0 : _this_sh12to15Texture.lock();
            				var numCoeffs = {
            						1: 3,
            						2: 8,
            						3: 15
            				}[this.shBands];
            				var src = getSHData(gsplatData, numCoeffs * 3);
            				var t11 = (1 << 11) - 1;
            				var t10 = (1 << 10) - 1;
            				var float32 = new Float32Array(1);
            				var uint32 = new Uint32Array(float32.buffer);
            				var c = new Array(numCoeffs * 3).fill(0);
            				for(var i = 0; i < gsplatData.numSplats; ++i){
            						for(var j = 0; j < numCoeffs; ++j){
            								c[j * 3] = src[j][i];
            								c[j * 3 + 1] = src[j + numCoeffs][i];
            								c[j * 3 + 2] = src[j + numCoeffs * 2][i];
            						}
            						var max = c[0];
            						for(var j1 = 1; j1 < numCoeffs * 3; ++j1){
            								max = Math.max(max, Math.abs(c[j1]));
            						}
            						if (max === 0) {
            								continue;
            						}
            						for(var j2 = 0; j2 < numCoeffs; ++j2){
            								c[j2 * 3 + 0] = Math.max(0, Math.min(t11, Math.floor((c[j2 * 3 + 0] / max * 0.5 + 0.5) * t11 + 0.5)));
            								c[j2 * 3 + 1] = Math.max(0, Math.min(t10, Math.floor((c[j2 * 3 + 1] / max * 0.5 + 0.5) * t10 + 0.5)));
            								c[j2 * 3 + 2] = Math.max(0, Math.min(t11, Math.floor((c[j2 * 3 + 2] / max * 0.5 + 0.5) * t11 + 0.5)));
            						}
            						float32[0] = max;
            						sh1to3Data[i * 4 + 0] = uint32[0];
            						sh1to3Data[i * 4 + 1] = c[0] << 21 | c[1] << 11 | c[2];
            						sh1to3Data[i * 4 + 2] = c[3] << 21 | c[4] << 11 | c[5];
            						sh1to3Data[i * 4 + 3] = c[6] << 21 | c[7] << 11 | c[8];
            						if (this.shBands > 1) {
            								sh4to7Data[i * 4 + 0] = c[9] << 21 | c[10] << 11 | c[11];
            								sh4to7Data[i * 4 + 1] = c[12] << 21 | c[13] << 11 | c[14];
            								sh4to7Data[i * 4 + 2] = c[15] << 21 | c[16] << 11 | c[17];
            								sh4to7Data[i * 4 + 3] = c[18] << 21 | c[19] << 11 | c[20];
            								if (this.shBands > 2) {
            										sh8to11Data[i * 4 + 0] = c[21] << 21 | c[22] << 11 | c[23];
            										sh8to11Data[i * 4 + 1] = c[24] << 21 | c[25] << 11 | c[26];
            										sh8to11Data[i * 4 + 2] = c[27] << 21 | c[28] << 11 | c[29];
            										sh8to11Data[i * 4 + 3] = c[30] << 21 | c[31] << 11 | c[32];
            										sh12to15Data[i * 4 + 0] = c[33] << 21 | c[34] << 11 | c[35];
            										sh12to15Data[i * 4 + 1] = c[36] << 21 | c[37] << 11 | c[38];
            										sh12to15Data[i * 4 + 2] = c[39] << 21 | c[40] << 11 | c[41];
            										sh12to15Data[i * 4 + 3] = c[42] << 21 | c[43] << 11 | c[44];
            								} else {
            										sh8to11Data[i] = c[21] << 21 | c[22] << 11 | c[23];
            								}
            						}
            				}
            				this.sh1to3Texture.unlock();
            				(_this_sh4to7Texture1 = this.sh4to7Texture) == null ? void 0 : _this_sh4to7Texture1.unlock();
            				(_this_sh8to11Texture1 = this.sh8to11Texture) == null ? void 0 : _this_sh8to11Texture1.unlock();
            				(_this_sh12to15Texture1 = this.sh12to15Texture) == null ? void 0 : _this_sh12to15Texture1.unlock();
            		}
            		constructor(device, gsplatData){
            				var numSplats = gsplatData.numSplats;
            				this.device = device;
            				this.numSplats = numSplats;
            				this.numSplatsVisible = numSplats;
            				this.centers = new Float32Array(gsplatData.numSplats * 3);
            				gsplatData.getCenters(this.centers);
            				this.aabb = new BoundingBox();
            				gsplatData.calcAabb(this.aabb);
            				var size = this.evalTextureSize(numSplats);
            				this.colorTexture = this.createTexture('splatColor', PIXELFORMAT_RGBA16F, size);
            				this.transformATexture = this.createTexture('transformA', PIXELFORMAT_RGBA32U, size);
            				this.transformBTexture = this.createTexture('transformB', PIXELFORMAT_RGBA16F, size);
            				this.updateColorData(gsplatData);
            				this.updateTransformData(gsplatData);
            				this.shBands = gsplatData.shBands;
            				if (this.shBands > 0) {
            						this.sh1to3Texture = this.createTexture('splatSH_1to3', PIXELFORMAT_RGBA32U, size);
            						if (this.shBands > 1) {
            								this.sh4to7Texture = this.createTexture('splatSH_4to7', PIXELFORMAT_RGBA32U, size);
            								if (this.shBands > 2) {
            										this.sh8to11Texture = this.createTexture('splatSH_8to11', PIXELFORMAT_RGBA32U, size);
            										this.sh12to15Texture = this.createTexture('splatSH_12to15', PIXELFORMAT_RGBA32U, size);
            								} else {
            										this.sh8to11Texture = this.createTexture('splatSH_8to11', PIXELFORMAT_R32U, size);
            								}
            						}
            						this.updateSHData(gsplatData);
            				}
            		}
            }
            
            function SortWorker() {
            		var order;
            		var centers;
            		var chunks;
            		var mapping;
            		var cameraPosition;
            		var cameraDirection;
            		var forceUpdate = false;
            		var lastCameraPosition = {
            				x: 0,
            				y: 0,
            				z: 0
            		};
            		var lastCameraDirection = {
            				x: 0,
            				y: 0,
            				z: 0
            		};
            		var boundMin = {
            				x: 0,
            				y: 0,
            				z: 0
            		};
            		var boundMax = {
            				x: 0,
            				y: 0,
            				z: 0
            		};
            		var distances;
            		var countBuffer;
            		var numBins = 32;
            		var binCount = new Array(numBins).fill(0);
            		var binBase = new Array(numBins).fill(0);
            		var binDivider = new Array(numBins).fill(0);
            		var binarySearch = (m, n, compare_fn)=>{
            				while(m <= n){
            						var k = n + m >> 1;
            						var cmp = compare_fn(k);
            						if (cmp > 0) {
            								m = k + 1;
            						} else if (cmp < 0) {
            								n = k - 1;
            						} else {
            								return k;
            						}
            				}
            				return ~m;
            		};
            		var update = ()=>{
            				if (!order || !centers || centers.length === 0 || !cameraPosition || !cameraDirection) return;
            				var px = cameraPosition.x;
            				var py = cameraPosition.y;
            				var pz = cameraPosition.z;
            				var dx = cameraDirection.x;
            				var dy = cameraDirection.y;
            				var dz = cameraDirection.z;
            				var epsilon = 0.001;
            				if (!forceUpdate && Math.abs(px - lastCameraPosition.x) < epsilon && Math.abs(py - lastCameraPosition.y) < epsilon && Math.abs(pz - lastCameraPosition.z) < epsilon && Math.abs(dx - lastCameraDirection.x) < epsilon && Math.abs(dy - lastCameraDirection.y) < epsilon && Math.abs(dz - lastCameraDirection.z) < epsilon) {
            						return;
            				}
            				forceUpdate = false;
            				lastCameraPosition.x = px;
            				lastCameraPosition.y = py;
            				lastCameraPosition.z = pz;
            				lastCameraDirection.x = dx;
            				lastCameraDirection.y = dy;
            				lastCameraDirection.z = dz;
            				var minDist;
            				var maxDist;
            				for(var i = 0; i < 8; ++i){
            						var x = i & 1 ? boundMin.x : boundMax.x;
            						var y = i & 2 ? boundMin.y : boundMax.y;
            						var z = i & 4 ? boundMin.z : boundMax.z;
            						var d = x * dx + y * dy + z * dz;
            						if (i === 0) {
            								minDist = maxDist = d;
            						} else {
            								minDist = Math.min(minDist, d);
            								maxDist = Math.max(maxDist, d);
            						}
            				}
            				var numVertices = centers.length / 3;
            				var compareBits = Math.max(10, Math.min(20, Math.round(Math.log2(numVertices / 4))));
            				var bucketCount = 2 ** compareBits + 1;
            				if ((distances == null ? void 0 : distances.length) !== numVertices) {
            						distances = new Uint32Array(numVertices);
            				}
            				if (!countBuffer || countBuffer.length !== bucketCount) {
            						countBuffer = new Uint32Array(bucketCount);
            				} else {
            						countBuffer.fill(0);
            				}
            				var range = maxDist - minDist;
            				if (range < 1e-6) {
            						for(var i1 = 0; i1 < numVertices; ++i1){
            								distances[i1] = 0;
            								countBuffer[0]++;
            						}
            				} else {
            						var numChunks = chunks.length / 4;
            						binCount.fill(0);
            						for(var i2 = 0; i2 < numChunks; ++i2){
            								var x1 = chunks[i2 * 4 + 0];
            								var y1 = chunks[i2 * 4 + 1];
            								var z1 = chunks[i2 * 4 + 2];
            								var r = chunks[i2 * 4 + 3];
            								var d1 = x1 * dx + y1 * dy + z1 * dz - minDist;
            								var binMin = Math.max(0, Math.floor((d1 - r) * numBins / range));
            								var binMax = Math.min(numBins, Math.ceil((d1 + r) * numBins / range));
            								for(var j = binMin; j < binMax; ++j){
            										binCount[j]++;
            								}
            						}
            						var binTotal = binCount.reduce((a, b)=>a + b, 0);
            						for(var i3 = 0; i3 < numBins; ++i3){
            								binDivider[i3] = binCount[i3] / binTotal * bucketCount >>> 0;
            						}
            						for(var i4 = 0; i4 < numBins; ++i4){
            								binBase[i4] = i4 === 0 ? 0 : binBase[i4 - 1] + binDivider[i4 - 1];
            						}
            						var binRange = range / numBins;
            						var ii = 0;
            						for(var i5 = 0; i5 < numVertices; ++i5){
            								var x2 = centers[ii++];
            								var y2 = centers[ii++];
            								var z2 = centers[ii++];
            								var d2 = (x2 * dx + y2 * dy + z2 * dz - minDist) / binRange;
            								var bin = d2 >>> 0;
            								var sortKey = binBase[bin] + binDivider[bin] * (d2 - bin) >>> 0;
            								distances[i5] = sortKey;
            								countBuffer[sortKey]++;
            						}
            				}
            				for(var i6 = 1; i6 < bucketCount; i6++){
            						countBuffer[i6] += countBuffer[i6 - 1];
            				}
            				for(var i7 = 0; i7 < numVertices; i7++){
            						var distance = distances[i7];
            						var destIndex = --countBuffer[distance];
            						order[destIndex] = i7;
            				}
            				var cameraDist = px * dx + py * dy + pz * dz;
            				var dist = (i)=>{
            						var o = order[i] * 3;
            						return centers[o++] * dx + centers[o++] * dy + centers[o] * dz - cameraDist;
            				};
            				var findZero = ()=>{
            						var result = binarySearch(0, numVertices - 1, (i)=>-dist(i));
            						return Math.min(numVertices, Math.abs(result));
            				};
            				var count = dist(numVertices - 1) >= 0 ? findZero() : numVertices;
            				if (mapping) {
            						for(var i8 = 0; i8 < numVertices; ++i8){
            								order[i8] = mapping[order[i8]];
            						}
            				}
            				self.postMessage({
            						order: order.buffer,
            						count
            				}, [
            						order.buffer
            				]);
            				order = null;
            		};
            		self.onmessage = (message)=>{
            				if (message.data.order) {
            						order = new Uint32Array(message.data.order);
            				}
            				if (message.data.centers) {
            						centers = new Float32Array(message.data.centers);
            						forceUpdate = true;
            						if (message.data.chunks) {
            								var chunksSrc = new Float32Array(message.data.chunks);
            								chunks = new Float32Array(message.data.chunks, 0, chunksSrc.length * 4 / 6);
            								boundMin.x = chunksSrc[0];
            								boundMin.y = chunksSrc[1];
            								boundMin.z = chunksSrc[2];
            								boundMax.x = chunksSrc[3];
            								boundMax.y = chunksSrc[4];
            								boundMax.z = chunksSrc[5];
            								for(var i = 0; i < chunksSrc.length / 6; ++i){
            										var mx = chunksSrc[i * 6 + 0];
            										var my = chunksSrc[i * 6 + 1];
            										var mz = chunksSrc[i * 6 + 2];
            										var Mx = chunksSrc[i * 6 + 3];
            										var My = chunksSrc[i * 6 + 4];
            										var Mz = chunksSrc[i * 6 + 5];
            										chunks[i * 4 + 0] = (mx + Mx) * 0.5;
            										chunks[i * 4 + 1] = (my + My) * 0.5;
            										chunks[i * 4 + 2] = (mz + Mz) * 0.5;
            										chunks[i * 4 + 3] = Math.sqrt((Mx - mx) ** 2 + (My - my) ** 2 + (Mz - mz) ** 2) * 0.5;
            										if (mx < boundMin.x) boundMin.x = mx;
            										if (my < boundMin.y) boundMin.y = my;
            										if (mz < boundMin.z) boundMin.z = mz;
            										if (Mx > boundMax.x) boundMax.x = Mx;
            										if (My > boundMax.y) boundMax.y = My;
            										if (Mz > boundMax.z) boundMax.z = Mz;
            								}
            						} else {
            								var numVertices = centers.length / 3;
            								var numChunks = Math.ceil(numVertices / 256);
            								chunks = new Float32Array(numChunks * 4);
            								boundMin.x = boundMin.y = boundMin.z = Infinity;
            								boundMax.x = boundMax.y = boundMax.z = -Infinity;
            								var mx1, my1, mz1, Mx1, My1, Mz1;
            								for(var c = 0; c < numChunks; ++c){
            										mx1 = my1 = mz1 = Infinity;
            										Mx1 = My1 = Mz1 = -Infinity;
            										var start = c * 256;
            										var end = Math.min(numVertices, (c + 1) * 256);
            										for(var i1 = start; i1 < end; ++i1){
            												var x = centers[i1 * 3 + 0];
            												var y = centers[i1 * 3 + 1];
            												var z = centers[i1 * 3 + 2];
            												var validX = Number.isFinite(x);
            												var validY = Number.isFinite(y);
            												var validZ = Number.isFinite(z);
            												if (!validX) centers[i1 * 3 + 0] = 0;
            												if (!validY) centers[i1 * 3 + 1] = 0;
            												if (!validZ) centers[i1 * 3 + 2] = 0;
            												if (!validX || !validY || !validZ) {
            														continue;
            												}
            												if (x < mx1) mx1 = x;
            												else if (x > Mx1) Mx1 = x;
            												if (y < my1) my1 = y;
            												else if (y > My1) My1 = y;
            												if (z < mz1) mz1 = z;
            												else if (z > Mz1) Mz1 = z;
            												if (x < boundMin.x) boundMin.x = x;
            												else if (x > boundMax.x) boundMax.x = x;
            												if (y < boundMin.y) boundMin.y = y;
            												else if (y > boundMax.y) boundMax.y = y;
            												if (z < boundMin.z) boundMin.z = z;
            												else if (z > boundMax.z) boundMax.z = z;
            										}
            										chunks[c * 4 + 0] = (mx1 + Mx1) * 0.5;
            										chunks[c * 4 + 1] = (my1 + My1) * 0.5;
            										chunks[c * 4 + 2] = (mz1 + Mz1) * 0.5;
            										chunks[c * 4 + 3] = Math.sqrt((Mx1 - mx1) ** 2 + (My1 - my1) ** 2 + (Mz1 - mz1) ** 2) * 0.5;
            								}
            						}
            				}
            				if (message.data.hasOwnProperty('mapping')) {
            						mapping = message.data.mapping ? new Uint32Array(message.data.mapping) : null;
            						forceUpdate = true;
            				}
            				if (message.data.cameraPosition) cameraPosition = message.data.cameraPosition;
            				if (message.data.cameraDirection) cameraDirection = message.data.cameraDirection;
            				update();
            		};
            }
            class GSplatSorter extends EventHandler {
            		destroy() {
            				this.worker.terminate();
            				this.worker = null;
            		}
            		init(orderTexture, centers, chunks) {
            				this.orderTexture = orderTexture;
            				this.centers = centers.slice();
            				var orderBuffer = this.orderTexture.lock({
            						mode: TEXTURELOCK_READ
            				}).slice();
            				this.orderTexture.unlock();
            				for(var i = 0; i < orderBuffer.length; ++i){
            						orderBuffer[i] = i;
            				}
            				var obj = {
            						order: orderBuffer.buffer,
            						centers: centers.buffer,
            						chunks: chunks == null ? void 0 : chunks.buffer
            				};
            				var transfer = [
            						orderBuffer.buffer,
            						centers.buffer
            				].concat(chunks ? [
            						chunks.buffer
            				] : []);
            				this.worker.postMessage(obj, transfer);
            		}
            		setMapping(mapping) {
            				if (mapping) {
            						var centers = new Float32Array(mapping.length * 3);
            						for(var i = 0; i < mapping.length; ++i){
            								var src = mapping[i] * 3;
            								var dst = i * 3;
            								centers[dst + 0] = this.centers[src + 0];
            								centers[dst + 1] = this.centers[src + 1];
            								centers[dst + 2] = this.centers[src + 2];
            						}
            						this.worker.postMessage({
            								centers: centers.buffer,
            								mapping: mapping.buffer
            						}, [
            								centers.buffer,
            								mapping.buffer
            						]);
            				} else {
            						var centers1 = this.centers.slice();
            						this.worker.postMessage({
            								centers: centers1.buffer,
            								mapping: null
            						}, [
            								centers1.buffer
            						]);
            				}
            		}
            		setCamera(pos, dir) {
            				this.worker.postMessage({
            						cameraPosition: {
            								x: pos.x,
            								y: pos.y,
            								z: pos.z
            						},
            						cameraDirection: {
            								x: dir.x,
            								y: dir.y,
            								z: dir.z
            						}
            				});
            		}
            		constructor(){
            				super();
            				this.worker = new Worker(URL.createObjectURL(new Blob([
            						"(" + SortWorker.toString() + ")()"
            				], {
            						type: "application/javascript"
            				})));
            				this.worker.onmessage = (message)=>{
            						var newOrder = message.data.order;
            						var oldOrder = this.orderTexture._levels[0].buffer;
            						this.worker.postMessage({
            								order: oldOrder
            						}, [
            								oldOrder
            						]);
            						this.orderTexture._levels[0] = new Uint32Array(newOrder);
            						this.orderTexture.upload();
            						this.fire('updated', message.data.count);
            				};
            		}
            }
            
            var mat = new Mat4();
            var cameraPosition = new Vec3();
            var cameraDirection = new Vec3();
            var viewport = [
            		0,
            		0
            ];
            class GSplatInstance {
            		destroy() {
            				var _this_material, _this_meshInstance, _this_sorter;
            				(_this_material = this.material) == null ? void 0 : _this_material.destroy();
            				(_this_meshInstance = this.meshInstance) == null ? void 0 : _this_meshInstance.destroy();
            				(_this_sorter = this.sorter) == null ? void 0 : _this_sorter.destroy();
            		}
            		clone() {
            				return new GSplatInstance(this.splat, this.options);
            		}
            		createMaterial(options) {
            				this.material = this.splat.createMaterial(options);
            				this.material.setParameter('splatOrder', this.orderTexture);
            				this.material.setParameter('alphaClip', 0.3);
            				if (this.meshInstance) {
            						this.meshInstance.material = this.material;
            				}
            		}
            		updateViewport(cameraNode) {
            				var _camera_camera;
            				var camera = cameraNode == null ? void 0 : cameraNode.camera;
            				var renderTarget = camera == null ? void 0 : camera.renderTarget;
            				var { width, height } = renderTarget != null ? renderTarget : this.splat.device;
            				viewport[0] = width;
            				viewport[1] = height;
            				var xr = camera == null ? void 0 : (_camera_camera = camera.camera) == null ? void 0 : _camera_camera.xr;
            				if ((xr == null ? void 0 : xr.active) && xr.views.list.length === 2) {
            						viewport[0] *= 0.5;
            				}
            				this.material.setParameter('viewport', viewport);
            		}
            		sort(cameraNode) {
            				if (this.sorter) {
            						var cameraMat = cameraNode.getWorldTransform();
            						cameraMat.getTranslation(cameraPosition);
            						cameraMat.getZ(cameraDirection);
            						var modelMat = this.meshInstance.node.getWorldTransform();
            						var invModelMat = mat.invert(modelMat);
            						invModelMat.transformPoint(cameraPosition, cameraPosition);
            						invModelMat.transformVector(cameraDirection, cameraDirection);
            						if (!cameraPosition.equalsApprox(this.lastCameraPosition) || !cameraDirection.equalsApprox(this.lastCameraDirection)) {
            								this.lastCameraPosition.copy(cameraPosition);
            								this.lastCameraDirection.copy(cameraDirection);
            								this.sorter.setCamera(cameraPosition, cameraDirection);
            						}
            				}
            				this.updateViewport(cameraNode);
            		}
            		update() {
            				if (this.cameras.length > 0) {
            						var camera = this.cameras[0];
            						this.sort(camera._node);
            						this.cameras.length = 0;
            				}
            		}
            		constructor(splat, options){
            				var _splat_chunks;
            				this.options = {};
            				this.sorter = null;
            				this.lastCameraPosition = new Vec3();
            				this.lastCameraDirection = new Vec3();
            				this.cameras = [];
            				this.splat = splat;
            				options = Object.assign(this.options, options);
            				var device = splat.device;
            				this.orderTexture = this.splat.createTexture('splatOrder', PIXELFORMAT_R32U, this.splat.evalTextureSize(this.splat.numSplats));
            				this.createMaterial(options);
            				var splatInstanceSize = 128;
            				var numSplats = Math.ceil(splat.numSplats / splatInstanceSize) * splatInstanceSize;
            				var numSplatInstances = numSplats / splatInstanceSize;
            				var indexData = new Uint32Array(numSplatInstances);
            				for(var i = 0; i < numSplatInstances; ++i){
            						indexData[i] = i * splatInstanceSize;
            				}
            				var vertexFormat = new VertexFormat(device, [
            						{
            								semantic: SEMANTIC_ATTR13,
            								components: 1,
            								type: TYPE_UINT32,
            								asInt: true
            						}
            				]);
            				var indicesVB = new VertexBuffer(device, vertexFormat, numSplatInstances, {
            						usage: BUFFER_STATIC,
            						data: indexData.buffer
            				});
            				var meshPositions = new Float32Array(12 * splatInstanceSize);
            				var meshIndices = new Uint32Array(6 * splatInstanceSize);
            				for(var i1 = 0; i1 < splatInstanceSize; ++i1){
            						meshPositions.set([
            								-1,
            								-1,
            								i1,
            								1,
            								-1,
            								i1,
            								1,
            								1,
            								i1,
            								-1,
            								1,
            								i1
            						], i1 * 12);
            						var b = i1 * 4;
            						meshIndices.set([
            								0 + b,
            								1 + b,
            								2 + b,
            								0 + b,
            								2 + b,
            								3 + b
            						], i1 * 6);
            				}
            				var mesh = new Mesh(device);
            				mesh.setPositions(meshPositions, 3);
            				mesh.setIndices(meshIndices);
            				mesh.update();
            				this.mesh = mesh;
            				this.mesh.aabb.copy(splat.aabb);
            				this.meshInstance = new MeshInstance(this.mesh, this.material);
            				this.meshInstance.setInstancing(indicesVB, true);
            				this.meshInstance.gsplatInstance = this;
            				this.meshInstance.instancingCount = 0;
            				var centers = splat.centers.slice();
            				var chunks = (_splat_chunks = splat.chunks) == null ? void 0 : _splat_chunks.slice();
            				if (!options.dither || options.dither === DITHER_NONE) {
            						this.sorter = new GSplatSorter();
            						this.sorter.init(this.orderTexture, centers, chunks);
            						this.sorter.on('updated', (count)=>{
            								this.meshInstance.instancingCount = Math.ceil(count / splatInstanceSize);
            								this.material.setParameter('numSplats', count);
            						});
            				}
            		}
            }
            
            var FILLMODE_FILL_WINDOW = 'FILL_WINDOW';
            var FILLMODE_KEEP_ASPECT = 'KEEP_ASPECT';
            var RESOLUTION_AUTO = 'AUTO';
            var RESOLUTION_FIXED = 'FIXED';
            
            var currentApplication;
            function getApplication() {
            		return currentApplication;
            }
            function setApplication(app) {
            		currentApplication = app;
            }
            
            class FrameGraph {
            		addRenderPass(renderPass) {
            				renderPass.frameUpdate();
            				var beforePasses = renderPass.beforePasses;
            				for(var i = 0; i < beforePasses.length; i++){
            						var pass = beforePasses[i];
            						if (pass.enabled) {
            								this.addRenderPass(pass);
            						}
            				}
            				if (renderPass.enabled) {
            						this.renderPasses.push(renderPass);
            				}
            				var afterPasses = renderPass.afterPasses;
            				for(var i1 = 0; i1 < afterPasses.length; i1++){
            						var pass1 = afterPasses[i1];
            						if (pass1.enabled) {
            								this.addRenderPass(pass1);
            						}
            				}
            		}
            		reset() {
            				this.renderPasses.length = 0;
            		}
            		compile() {
            				var renderTargetMap = this.renderTargetMap;
            				var renderPasses = this.renderPasses;
            				for(var i = 0; i < renderPasses.length; i++){
            						var renderPass = renderPasses[i];
            						var renderTarget = renderPass.renderTarget;
            						if (renderTarget !== undefined) {
            								var prevPass = renderTargetMap.get(renderTarget);
            								if (prevPass) {
            										var count = renderPass.colorArrayOps.length;
            										for(var j = 0; j < count; j++){
            												var colorOps = renderPass.colorArrayOps[j];
            												if (!colorOps.clear) {
            														prevPass.colorArrayOps[j].store = true;
            												}
            										}
            										if (!renderPass.depthStencilOps.clearDepth) {
            												prevPass.depthStencilOps.storeDepth = true;
            										}
            										if (!renderPass.depthStencilOps.clearStencil) {
            												prevPass.depthStencilOps.storeStencil = true;
            										}
            								}
            								renderTargetMap.set(renderTarget, renderPass);
            						}
            				}
            				for(var i1 = 0; i1 < renderPasses.length - 1; i1++){
            						var firstPass = renderPasses[i1];
            						var firstRT = firstPass.renderTarget;
            						var secondPass = renderPasses[i1 + 1];
            						var secondRT = secondPass.renderTarget;
            						if (firstRT !== secondRT || firstRT === undefined) {
            								continue;
            						}
            						if (secondPass.depthStencilOps.clearDepth || secondPass.depthStencilOps.clearStencil || secondPass.colorArrayOps.some((colorOps)=>colorOps.clear)) {
            								continue;
            						}
            						if (firstPass.afterPasses.length > 0) {
            								continue;
            						}
            						if (secondPass.beforePasses.length > 0) {
            								continue;
            						}
            						firstPass._skipEnd = true;
            						secondPass._skipStart = true;
            				}
            				var lastCubeTexture = null;
            				var lastCubeRenderPass = null;
            				for(var i2 = 0; i2 < renderPasses.length; i2++){
            						var renderPass1 = renderPasses[i2];
            						var renderTarget1 = renderPass1.renderTarget;
            						var thisTexture = renderTarget1 == null ? void 0 : renderTarget1.colorBuffer;
            						if (thisTexture == null ? void 0 : thisTexture.cubemap) {
            								if (lastCubeTexture === thisTexture) {
            										var count1 = lastCubeRenderPass.colorArrayOps.length;
            										for(var j1 = 0; j1 < count1; j1++){
            												lastCubeRenderPass.colorArrayOps[j1].mipmaps = false;
            										}
            								}
            								lastCubeTexture = renderTarget1.colorBuffer;
            								lastCubeRenderPass = renderPass1;
            						} else if (renderPass1.requiresCubemaps) {
            								lastCubeTexture = null;
            								lastCubeRenderPass = null;
            						}
            				}
            				renderTargetMap.clear();
            		}
            		render(device) {
            				this.compile();
            				var renderPasses = this.renderPasses;
            				for(var i = 0; i < renderPasses.length; i++){
            						renderPasses[i].render();
            				}
            		}
            		constructor(){
            				this.renderPasses = [];
            				this.renderTargetMap = new Map();
            		}
            }
            
            class AreaLightCacheEntry {
            		destroy() {
            				var _this_texture0, _this_texture1;
            				(_this_texture0 = this.texture0) == null ? void 0 : _this_texture0.destroy();
            				(_this_texture1 = this.texture1) == null ? void 0 : _this_texture1.destroy();
            		}
            		constructor(texture0, texture1){
            				this.texture0 = texture0;
            				this.texture1 = texture1;
            		}
            }
            var deviceCache = new DeviceCache();
            class AreaLightLuts {
            		static createTexture(device, format, size, postfix) {
            				if (postfix === void 0) postfix = '';
            				var tex = new Texture(device, {
            						name: "AreaLightLUT" + postfix,
            						width: size,
            						height: size,
            						format: format,
            						addressU: ADDRESS_CLAMP_TO_EDGE,
            						addressV: ADDRESS_CLAMP_TO_EDGE,
            						type: TEXTURETYPE_DEFAULT,
            						magFilter: FILTER_LINEAR,
            						minFilter: FILTER_NEAREST,
            						anisotropy: 1,
            						mipmaps: false
            				});
            				return tex;
            		}
            		static applyTextures(device, texture1, texture2) {
            				deviceCache.remove(device);
            				deviceCache.get(device, ()=>{
            						return new AreaLightCacheEntry(texture1, texture1 === texture2 ? null : texture2);
            				});
            				device.scope.resolve('areaLightsLutTex1').setValue(texture1);
            				device.scope.resolve('areaLightsLutTex2').setValue(texture2);
            		}
            		static createPlaceholder(device) {
            				var texture = AreaLightLuts.createTexture(device, PIXELFORMAT_RGBA16F, 2, 'placeholder');
            				var pixels = texture.lock();
            				pixels.fill(0);
            				texture.unlock();
            				AreaLightLuts.applyTextures(device, texture, texture);
            		}
            		static set(device, ltcMat1, ltcMat2) {
            				function buildTexture(device, data, format) {
            						var texture = AreaLightLuts.createTexture(device, format, 64);
            						texture.lock().set(data);
            						texture.unlock();
            						return texture;
            				}
            				function convertToHalfFloat(data) {
            						var count = data.length;
            						var ret = new Uint16Array(count);
            						var float2Half = FloatPacking.float2Half;
            						for(var i = 0; i < count; i++){
            								ret[i] = float2Half(data[i]);
            						}
            						return ret;
            				}
            				var srcData1 = ltcMat1;
            				var srcData2 = ltcMat2;
            				var data1 = convertToHalfFloat(srcData1);
            				var data2 = convertToHalfFloat(srcData2);
            				var tex1 = buildTexture(device, data1, PIXELFORMAT_RGBA16F);
            				var tex2 = buildTexture(device, data2, PIXELFORMAT_RGBA16F);
            				AreaLightLuts.applyTextures(device, tex1, tex2);
            		}
            }
            
            var DEFAULT_LOCALE = 'en-US';
            var DEFAULT_LOCALE_FALLBACKS = {
            		'en': 'en-US',
            		'es': 'en-ES',
            		'zh': 'zh-CN',
            		'zh-HK': 'zh-TW',
            		'zh-TW': 'zh-HK',
            		'zh-MO': 'zh-HK',
            		'fr': 'fr-FR',
            		'de': 'de-DE',
            		'it': 'it-IT',
            		'ru': 'ru-RU',
            		'ja': 'ja-JP'
            };
            
            var PLURALS = {};
            function definePluralFn(locales, fn) {
            		for(var i = 0, len = locales.length; i < len; i++){
            				PLURALS[locales[i]] = fn;
            		}
            }
            function getLang(locale) {
            		var idx = locale.indexOf('-');
            		if (idx !== -1) {
            				return locale.substring(0, idx);
            		}
            		return locale;
            }
            function replaceLang(locale, desiredLang) {
            		var idx = locale.indexOf('-');
            		if (idx !== -1) {
            				return desiredLang + locale.substring(idx);
            		}
            		return desiredLang;
            }
            function findAvailableLocale(desiredLocale, availableLocales) {
            		if (availableLocales[desiredLocale]) {
            				return desiredLocale;
            		}
            		var fallback = DEFAULT_LOCALE_FALLBACKS[desiredLocale];
            		if (fallback && availableLocales[fallback]) {
            				return fallback;
            		}
            		var lang = getLang(desiredLocale);
            		fallback = DEFAULT_LOCALE_FALLBACKS[lang];
            		if (availableLocales[fallback]) {
            				return fallback;
            		}
            		if (availableLocales[lang]) {
            				return lang;
            		}
            		return DEFAULT_LOCALE;
            }
            definePluralFn([
            		'ja',
            		'ko',
            		'th',
            		'vi',
            		'zh',
            		'id'
            ], (n)=>{
            		return 0;
            });
            definePluralFn([
            		'fa',
            		'hi'
            ], (n)=>{
            		if (n >= 0 && n <= 1) {
            				return 0;
            		}
            		return 1;
            });
            definePluralFn([
            		'fr',
            		'pt'
            ], (n)=>{
            		if (n >= 0 && n < 2) {
            				return 0;
            		}
            		return 1;
            });
            definePluralFn([
            		'da'
            ], (n)=>{
            		if (n === 1 || !Number.isInteger(n) && n >= 0 && n <= 1) {
            				return 0;
            		}
            		return 1;
            });
            definePluralFn([
            		'de',
            		'en',
            		'it',
            		'el',
            		'es',
            		'tr',
            		'fi',
            		'sv',
            		'nb',
            		'no',
            		'ur'
            ], (n)=>{
            		if (n === 1) {
            				return 0;
            		}
            		return 1;
            });
            definePluralFn([
            		'ru',
            		'uk'
            ], (n)=>{
            		if (Number.isInteger(n)) {
            				var mod10 = n % 10;
            				var mod100 = n % 100;
            				if (mod10 === 1 && mod100 !== 11) {
            						return 0;
            				} else if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
            						return 1;
            				} else if (mod10 === 0 || mod10 >= 5 && mod10 <= 9 || mod100 >= 11 && mod100 <= 14) {
            						return 2;
            				}
            		}
            		return 3;
            });
            definePluralFn([
            		'pl'
            ], (n)=>{
            		if (Number.isInteger(n)) {
            				if (n === 1) {
            						return 0;
            				}
            				var mod10 = n % 10;
            				var mod100 = n % 100;
            				if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {
            						return 1;
            				} else if (mod10 >= 0 && mod10 <= 1 || mod10 >= 5 && mod10 <= 9 || mod100 >= 12 && mod100 <= 14) {
            						return 2;
            				}
            		}
            		return 3;
            });
            definePluralFn([
            		'ar'
            ], (n)=>{
            		if (n === 0) {
            				return 0;
            		} else if (n === 1) {
            				return 1;
            		} else if (n === 2) {
            				return 2;
            		}
            		if (Number.isInteger(n)) {
            				var mod100 = n % 100;
            				if (mod100 >= 3 && mod100 <= 10) {
            						return 3;
            				} else if (mod100 >= 11 && mod100 <= 99) {
            						return 4;
            				}
            		}
            		return 5;
            });
            var DEFAULT_PLURAL_FN = PLURALS[getLang(DEFAULT_LOCALE)];
            function getPluralFn(lang) {
            		return PLURALS[lang] || DEFAULT_PLURAL_FN;
            }
            
            var ABSOLUTE_URL = new RegExp('^' + '\\s*' + '(?:' + '(?:' + '[a-z]+[a-z0-9\\-+.]*' + ':' + ')?' + '//' + '|' + 'data:' + '|blob:' + ')', 'i');
            
            class AssetFile {
            		equals(other) {
            				return this.url === other.url && this.filename === other.filename && this.hash === other.hash && this.size === other.size && this.opt === other.opt && this.contents === other.contents;
            		}
            		constructor(url = '', filename = '', hash = null, size = null, opt = null, contents = null){
            				this.url = url;
            				this.filename = filename;
            				this.hash = hash;
            				this.size = size;
            				this.opt = opt;
            				this.contents = contents;
            		}
            }
            
            var assetIdCounter = -1;
            var VARIANT_SUPPORT = {
            		pvr: 'extCompressedTexturePVRTC',
            		dxt: 'extCompressedTextureS3TC',
            		etc2: 'extCompressedTextureETC',
            		etc1: 'extCompressedTextureETC1',
            		basis: 'canvas'
            };
            var VARIANT_DEFAULT_PRIORITY = [
            		'pvr',
            		'dxt',
            		'etc2',
            		'etc1',
            		'basis'
            ];
            class Asset extends EventHandler {
            		set name(value) {
            				if (this._name === value) {
            						return;
            				}
            				var old = this._name;
            				this._name = value;
            				this.fire('name', this, this._name, old);
            		}
            		get name() {
            				return this._name;
            		}
            		set file(value) {
            				if (value && value.variants && [
            						'texture',
            						'textureatlas',
            						'bundle'
            				].indexOf(this.type) !== -1) {
            						var _this_registry__loader, _this_registry;
            						var app = ((_this_registry = this.registry) == null ? void 0 : (_this_registry__loader = _this_registry._loader) == null ? void 0 : _this_registry__loader._app) || getApplication();
            						var device = app == null ? void 0 : app.graphicsDevice;
            						if (device) {
            								var _this, _loop = function(i, len) {
            										var variant = VARIANT_DEFAULT_PRIORITY[i];
            										if (value.variants[variant] && device[VARIANT_SUPPORT[variant]]) {
            												value = value.variants[variant];
            												return "break";
            										}
            										if (app.enableBundles) {
            												var bundles = app.bundles.listBundlesForAsset(_this);
            												if (bundles && bundles.find((b)=>{
            														var _b_file;
            														return b == null ? void 0 : (_b_file = b.file) == null ? void 0 : _b_file.variants[variant];
            												})) {
            														return "break";
            												}
            										}
            								};
            								for(var i = 0, len = VARIANT_DEFAULT_PRIORITY.length; i < len; i++){
            										var _ret = (_this = this, _loop(i, len));
            										if (_ret === "break") break;
            								}
            						}
            				}
            				var oldFile = this._file;
            				var newFile = value ? new AssetFile(value.url, value.filename, value.hash, value.size, value.opt, value.contents) : null;
            				if (!!newFile !== !!oldFile || newFile && !newFile.equals(oldFile)) {
            						this._file = newFile;
            						this.fire('change', this, 'file', newFile, oldFile);
            						this.reload();
            				}
            		}
            		get file() {
            				return this._file;
            		}
            		set data(value) {
            				var old = this._data;
            				this._data = value;
            				if (value !== old) {
            						this.fire('change', this, 'data', value, old);
            						if (this.loaded) {
            								this.registry._loader.patch(this, this.registry);
            						}
            				}
            		}
            		get data() {
            				return this._data;
            		}
            		set resource(value) {
            				var _old = this._resources[0];
            				this._resources[0] = value;
            				this.fire('change', this, 'resource', value, _old);
            		}
            		get resource() {
            				return this._resources[0];
            		}
            		set resources(value) {
            				var _old = this._resources;
            				this._resources = value;
            				this.fire('change', this, 'resources', value, _old);
            		}
            		get resources() {
            				return this._resources;
            		}
            		set preload(value) {
            				value = !!value;
            				if (this._preload === value) {
            						return;
            				}
            				this._preload = value;
            				if (this._preload && !this.loaded && !this.loading && this.registry) {
            						this.registry.load(this);
            				}
            		}
            		get preload() {
            				return this._preload;
            		}
            		set loadFaces(value) {
            				value = !!value;
            				if (!this.hasOwnProperty('_loadFaces') || value !== this._loadFaces) {
            						this._loadFaces = value;
            						if (this.loaded) {
            								this.registry._loader.patch(this, this.registry);
            						}
            				}
            		}
            		get loadFaces() {
            				return this._loadFaces;
            		}
            		getFileUrl() {
            				var file = this.file;
            				if (!file || !file.url) {
            						return null;
            				}
            				var url = file.url;
            				if (this.registry && this.registry.prefix && !ABSOLUTE_URL.test(url)) {
            						url = this.registry.prefix + url;
            				}
            				if (this.type !== "script" && file.hash) {
            						var separator = url.indexOf('?') !== -1 ? '&' : '?';
            						url += separator + "t=" + file.hash;
            				}
            				return url;
            		}
            		getAbsoluteUrl(relativePath) {
            				if (relativePath.startsWith('blob:') || relativePath.startsWith('data:')) {
            						return relativePath;
            				}
            				var base = path.getDirectory(this.file.url);
            				return path.join(base, relativePath);
            		}
            		getLocalizedAssetId(locale) {
            				locale = findAvailableLocale(locale, this._i18n);
            				return this._i18n[locale] || null;
            		}
            		addLocalizedAssetId(locale, assetId) {
            				this._i18n[locale] = assetId;
            				this.fire('add:localized', locale, assetId);
            		}
            		removeLocalizedAssetId(locale) {
            				var assetId = this._i18n[locale];
            				if (assetId) {
            						delete this._i18n[locale];
            						this.fire('remove:localized', locale, assetId);
            				}
            		}
            		ready(callback, scope) {
            				scope = scope || this;
            				if (this.loaded) {
            						callback.call(scope, this);
            				} else {
            						this.once('load', (asset)=>{
            								callback.call(scope, asset);
            						});
            				}
            		}
            		reload() {
            				if (this.loaded) {
            						this.loaded = false;
            						this.registry.load(this);
            				}
            		}
            		unload() {
            				if (!this.loaded && this._resources.length === 0) {
            						return;
            				}
            				this.fire('unload', this);
            				this.registry.fire("unload:" + this.id, this);
            				var old = this._resources;
            				if (this.urlObject) {
            						URL.revokeObjectURL(this.urlObject);
            						this.urlObject = null;
            				}
            				this.resources = [];
            				this.loaded = false;
            				if (this.file) {
            						this.registry._loader.clearCache(this.getFileUrl(), this.type);
            				}
            				for(var i = 0; i < old.length; ++i){
            						var resource = old[i];
            						if (resource && resource.destroy) {
            								resource.destroy();
            						}
            				}
            		}
            		static fetchArrayBuffer(loadUrl, callback, asset, maxRetries) {
            				if (maxRetries === void 0) maxRetries = 0;
            				var _asset_file;
            				if (asset == null ? void 0 : (_asset_file = asset.file) == null ? void 0 : _asset_file.contents) {
            						setTimeout(()=>{
            								callback(null, asset.file.contents);
            						});
            				} else {
            						http.get(loadUrl, {
            								cache: true,
            								responseType: 'arraybuffer',
            								retry: maxRetries > 0,
            								maxRetries: maxRetries
            						}, callback);
            				}
            		}
            		constructor(name, type, file, data = {}, options = {}){
            				super(), this._file = null, this._i18n = {}, this._preload = false, this._resources = [], this.id = assetIdCounter--, this.loaded = false, this.loading = false, this.options = {}, this.registry = null, this.tags = new Tags(this), this.urlObject = null;
            				this._name = name || '';
            				this.type = type;
            				this._data = data || {};
            				this.options = options || {};
            				if (file) this.file = file;
            		}
            }
            Asset.EVENT_LOAD = 'load';
            Asset.EVENT_UNLOAD = 'unload';
            Asset.EVENT_REMOVE = 'remove';
            Asset.EVENT_ERROR = 'error';
            Asset.EVENT_CHANGE = 'change';
            Asset.EVENT_PROGRESS = 'progress';
            Asset.EVENT_ADDLOCALIZED = 'add:localized';
            Asset.EVENT_REMOVELOCALIZED = 'remove:localized';
            
            class TagsCache {
            		addItem(item) {
            				var tags = item.tags._list;
            				for (var tag of tags){
            						this.add(tag, item);
            				}
            		}
            		removeItem(item) {
            				var tags = item.tags._list;
            				for (var tag of tags){
            						this.remove(tag, item);
            				}
            		}
            		add(tag, item) {
            				if (this._index[tag] && this._index[tag].list.indexOf(item) !== -1) {
            						return;
            				}
            				if (!this._index[tag]) {
            						this._index[tag] = {
            								list: []
            						};
            						if (this._key) {
            								this._index[tag].keys = {};
            						}
            				}
            				this._index[tag].list.push(item);
            				if (this._key) {
            						this._index[tag].keys[item[this._key]] = item;
            				}
            		}
            		remove(tag, item) {
            				if (!this._index[tag]) {
            						return;
            				}
            				if (this._key) {
            						if (!this._index[tag].keys[item[this._key]]) {
            								return;
            						}
            				}
            				var ind = this._index[tag].list.indexOf(item);
            				if (ind === -1) {
            						return;
            				}
            				this._index[tag].list.splice(ind, 1);
            				if (this._key) {
            						delete this._index[tag].keys[item[this._key]];
            				}
            				if (this._index[tag].list.length === 0) {
            						delete this._index[tag];
            				}
            		}
            		find(args) {
            				var index = {};
            				var items = [];
            				var item, tag, tags, tagsRest, missingIndex;
            				var sort = (a, b)=>{
            						return this._index[a].list.length - this._index[b].list.length;
            				};
            				for(var i = 0; i < args.length; i++){
            						tag = args[i];
            						if (tag instanceof Array) {
            								if (tag.length === 0) {
            										continue;
            								}
            								if (tag.length === 1) {
            										tag = tag[0];
            								} else {
            										missingIndex = false;
            										for(var t = 0; t < tag.length; t++){
            												if (!this._index[tag[t]]) {
            														missingIndex = true;
            														break;
            												}
            										}
            										if (missingIndex) {
            												continue;
            										}
            										tags = tag.slice(0).sort(sort);
            										tagsRest = tags.slice(1);
            										if (tagsRest.length === 1) {
            												tagsRest = tagsRest[0];
            										}
            										for(var n = 0; n < this._index[tags[0]].list.length; n++){
            												item = this._index[tags[0]].list[n];
            												if ((this._key ? !index[item[this._key]] : items.indexOf(item) === -1) && item.tags.has(tagsRest)) {
            														if (this._key) {
            																index[item[this._key]] = true;
            														}
            														items.push(item);
            												}
            										}
            										continue;
            								}
            						}
            						if (tag && typeof tag === 'string' && this._index[tag]) {
            								for(var n1 = 0; n1 < this._index[tag].list.length; n1++){
            										item = this._index[tag].list[n1];
            										if (this._key) {
            												if (!index[item[this._key]]) {
            														index[item[this._key]] = true;
            														items.push(item);
            												}
            										} else if (items.indexOf(item) === -1) {
            												items.push(item);
            										}
            								}
            						}
            				}
            				return items;
            		}
            		constructor(key = null){
            				this._index = {};
            				this._key = key;
            		}
            }
            
            class AssetRegistry extends EventHandler {
            		list(filters) {
            				if (filters === void 0) filters = {};
            				var assets = Array.from(this._assets);
            				if (filters.preload !== undefined) {
            						return assets.filter((asset)=>asset.preload === filters.preload);
            				}
            				return assets;
            		}
            		add(asset) {
            				var _asset_file, _asset_file1;
            				if (this._assets.has(asset)) return;
            				this._assets.add(asset);
            				this._idToAsset.set(asset.id, asset);
            				if ((_asset_file = asset.file) == null ? void 0 : _asset_file.url) {
            						this._urlToAsset.set(asset.file.url, asset);
            				}
            				if (!this._nameToAsset.has(asset.name)) {
            						this._nameToAsset.set(asset.name, new Set());
            				}
            				this._nameToAsset.get(asset.name).add(asset);
            				asset.on('name', this._onNameChange, this);
            				asset.registry = this;
            				this._tags.addItem(asset);
            				asset.tags.on('add', this._onTagAdd, this);
            				asset.tags.on('remove', this._onTagRemove, this);
            				this.fire('add', asset);
            				this.fire("add:" + asset.id, asset);
            				if ((_asset_file1 = asset.file) == null ? void 0 : _asset_file1.url) {
            						this.fire("add:url:" + asset.file.url, asset);
            				}
            				if (asset.preload) {
            						this.load(asset);
            				}
            		}
            		remove(asset) {
            				var _asset_file, _asset_file1;
            				if (!this._assets.has(asset)) return false;
            				this._assets.delete(asset);
            				this._idToAsset.delete(asset.id);
            				if ((_asset_file = asset.file) == null ? void 0 : _asset_file.url) {
            						this._urlToAsset.delete(asset.file.url);
            				}
            				asset.off('name', this._onNameChange, this);
            				if (this._nameToAsset.has(asset.name)) {
            						var items = this._nameToAsset.get(asset.name);
            						items.delete(asset);
            						if (items.size === 0) {
            								this._nameToAsset.delete(asset.name);
            						}
            				}
            				this._tags.removeItem(asset);
            				asset.tags.off('add', this._onTagAdd, this);
            				asset.tags.off('remove', this._onTagRemove, this);
            				asset.fire('remove', asset);
            				this.fire('remove', asset);
            				this.fire("remove:" + asset.id, asset);
            				if ((_asset_file1 = asset.file) == null ? void 0 : _asset_file1.url) {
            						this.fire("remove:url:" + asset.file.url, asset);
            				}
            				return true;
            		}
            		get(id) {
            				return this._idToAsset.get(Number(id));
            		}
            		getByUrl(url) {
            				return this._urlToAsset.get(url);
            		}
            		load(asset, options) {
            				if ((asset.loading || asset.loaded) && !(options == null ? void 0 : options.force)) {
            						return;
            				}
            				var file = asset.file;
            				var _fireLoad = ()=>{
            						this.fire('load', asset);
            						this.fire("load:" + asset.id, asset);
            						if (file && file.url) {
            								this.fire("load:url:" + file.url, asset);
            						}
            						asset.fire('load', asset);
            				};
            				var _opened = (resource)=>{
            						if (resource instanceof Array) {
            								asset.resources = resource;
            						} else {
            								asset.resource = resource;
            						}
            						this._loader.patch(asset, this);
            						if (asset.type === 'bundle') {
            								var assetIds = asset.data.assets;
            								for(var i = 0; i < assetIds.length; i++){
            										var assetInBundle = this._idToAsset.get(assetIds[i]);
            										if (assetInBundle && !assetInBundle.loaded) {
            												this.load(assetInBundle, {
            														force: true
            												});
            										}
            								}
            								if (asset.resource.loaded) {
            										_fireLoad();
            								} else {
            										this.fire('load:start', asset);
            										this.fire("load:start:" + asset.id, asset);
            										if (file && file.url) {
            												this.fire("load:start:url:" + file.url, asset);
            										}
            										asset.fire('load:start', asset);
            										asset.resource.on('load', _fireLoad);
            								}
            						} else {
            								_fireLoad();
            						}
            				};
            				var _loaded = (err, resource, extra)=>{
            						asset.loaded = true;
            						asset.loading = false;
            						if (err) {
            								this.fire('error', err, asset);
            								this.fire("error:" + asset.id, err, asset);
            								asset.fire('error', err, asset);
            						} else {
            								if (asset.type === "script") {
            										var handler = this._loader.getHandler("script");
            										if (handler._cache[asset.id] && handler._cache[asset.id].parentNode === document.head) {
            												document.head.removeChild(handler._cache[asset.id]);
            										}
            										handler._cache[asset.id] = extra;
            								}
            								_opened(resource);
            						}
            				};
            				if (file || asset.type === 'cubemap') {
            						this.fire('load:start', asset);
            						this.fire("load:" + asset.id + ":start", asset);
            						asset.loading = true;
            						var fileUrl = asset.getFileUrl();
            						if (asset.type === 'bundle') {
            								var assetIds = asset.data.assets;
            								for(var i = 0; i < assetIds.length; i++){
            										var assetInBundle = this._idToAsset.get(assetIds[i]);
            										if (!assetInBundle) {
            												continue;
            										}
            										if (assetInBundle.loaded || assetInBundle.resource || assetInBundle.loading) {
            												continue;
            										}
            										assetInBundle.loading = true;
            								}
            						}
            						this._loader.load(fileUrl, asset.type, _loaded, asset, options);
            				} else {
            						var resource = this._loader.open(asset.type, asset.data);
            						asset.loaded = true;
            						_opened(resource);
            				}
            		}
            		loadFromUrl(url, type, callback) {
            				this.loadFromUrlAndFilename(url, null, type, callback);
            		}
            		loadFromUrlAndFilename(url, filename, type, callback) {
            				var name = path.getBasename(filename || url);
            				var file = {
            						filename: filename || name,
            						url: url
            				};
            				var asset = this.getByUrl(url);
            				if (!asset) {
            						asset = new Asset(name, type, file);
            						this.add(asset);
            				} else if (asset.loaded) {
            						callback(asset.loadFromUrlError || null, asset);
            						return;
            				}
            				var startLoad = (asset)=>{
            						asset.once('load', (loadedAsset)=>{
            								if (type === 'material') {
            										this._loadTextures(loadedAsset, (err, textures)=>{
            												callback(err, loadedAsset);
            										});
            								} else {
            										callback(null, loadedAsset);
            								}
            						});
            						asset.once('error', (err)=>{
            								if (err) {
            										this.loadFromUrlError = err;
            								}
            								callback(err, asset);
            						});
            						this.load(asset);
            				};
            				if (asset.resource) {
            						callback(null, asset);
            				} else if (type === 'model') {
            						this._loadModel(asset, startLoad);
            				} else {
            						startLoad(asset);
            				}
            		}
            		_loadModel(modelAsset, continuation) {
            				var url = modelAsset.getFileUrl();
            				var ext = path.getExtension(url);
            				if (ext === '.json' || ext === '.glb') {
            						var dir = path.getDirectory(url);
            						var basename = path.getBasename(url);
            						var mappingUrl = path.join(dir, basename.replace(ext, '.mapping.json'));
            						this._loader.load(mappingUrl, 'json', (err, data)=>{
            								if (err) {
            										modelAsset.data = {
            												mapping: []
            										};
            										continuation(modelAsset);
            								} else {
            										this._loadMaterials(modelAsset, data, (e, materials)=>{
            												modelAsset.data = data;
            												continuation(modelAsset);
            										});
            								}
            						});
            				} else {
            						continuation(modelAsset);
            				}
            		}
            		_loadMaterials(modelAsset, mapping, callback) {
            				var materials = [];
            				var count = 0;
            				var onMaterialLoaded = (err, materialAsset)=>{
            						this._loadTextures(materialAsset, (err, textures)=>{
            								materials.push(materialAsset);
            								if (materials.length === count) {
            										callback(null, materials);
            								}
            						});
            				};
            				for(var i = 0; i < mapping.mapping.length; i++){
            						var path = mapping.mapping[i].path;
            						if (path) {
            								count++;
            								var url = modelAsset.getAbsoluteUrl(path);
            								this.loadFromUrl(url, 'material', onMaterialLoaded);
            						}
            				}
            				if (count === 0) {
            						callback(null, materials);
            				}
            		}
            		_loadTextures(materialAsset, callback) {
            				var textures = [];
            				var count = 0;
            				var data = materialAsset.data;
            				if (data.mappingFormat !== 'path') {
            						callback(null, textures);
            						return;
            				}
            				var onTextureLoaded = (err, texture)=>{
            						if (err) console.error(err);
            						textures.push(texture);
            						if (textures.length === count) {
            								callback(null, textures);
            						}
            				};
            				var texParams = standardMaterialTextureParameters;
            				for(var i = 0; i < texParams.length; i++){
            						var path = data[texParams[i]];
            						if (path && typeof path === 'string') {
            								count++;
            								var url = materialAsset.getAbsoluteUrl(path);
            								this.loadFromUrl(url, 'texture', onTextureLoaded);
            						}
            				}
            				if (count === 0) {
            						callback(null, textures);
            				}
            		}
            		_onTagAdd(tag, asset) {
            				this._tags.add(tag, asset);
            		}
            		_onTagRemove(tag, asset) {
            				this._tags.remove(tag, asset);
            		}
            		_onNameChange(asset, name, nameOld) {
            				if (this._nameToAsset.has(nameOld)) {
            						var items = this._nameToAsset.get(nameOld);
            						items.delete(asset);
            						if (items.size === 0) {
            								this._nameToAsset.delete(nameOld);
            						}
            				}
            				if (!this._nameToAsset.has(asset.name)) {
            						this._nameToAsset.set(asset.name, new Set());
            				}
            				this._nameToAsset.get(asset.name).add(asset);
            		}
            		findByTag() {
            				for(var _len = arguments.length, query = new Array(_len), _key = 0; _key < _len; _key++){
            						query[_key] = arguments[_key];
            				}
            				return this._tags.find(query);
            		}
            		filter(callback) {
            				return Array.from(this._assets).filter((asset)=>callback(asset));
            		}
            		find(name, type) {
            				var items = this._nameToAsset.get(name);
            				if (!items) return null;
            				for (var asset of items){
            						if (!type || asset.type === type) {
            								return asset;
            						}
            				}
            				return null;
            		}
            		findAll(name, type) {
            				var items = this._nameToAsset.get(name);
            				if (!items) return [];
            				var results = Array.from(items);
            				if (!type) return results;
            				return results.filter((asset)=>asset.type === type);
            		}
            		constructor(loader){
            				super(), this._assets = new Set(), this._idToAsset = new Map(), this._urlToAsset = new Map(), this._nameToAsset = new Map(), this._tags = new TagsCache('_id'), this.prefix = null, this.bundles = null;
            				this._loader = loader;
            		}
            }
            AssetRegistry.EVENT_LOAD = 'load';
            AssetRegistry.EVENT_ADD = 'add';
            AssetRegistry.EVENT_REMOVE = 'remove';
            AssetRegistry.EVENT_ERROR = 'error';
            
            class BundleRegistry {
            		_onAssetAdd(asset) {
            				if (asset.type === 'bundle') {
            						this._idToBundle.set(asset.id, asset);
            						this._assets.on("load:start:" + asset.id, this._onBundleLoadStart, this);
            						this._assets.on("load:" + asset.id, this._onBundleLoad, this);
            						this._assets.on("error:" + asset.id, this._onBundleError, this);
            						var assetIds = asset.data.assets;
            						for(var i = 0; i < assetIds.length; i++){
            								this._indexAssetInBundle(assetIds[i], asset);
            						}
            				} else {
            						if (this._assetToBundles.has(asset.id)) {
            								this._indexAssetFileUrls(asset);
            						}
            				}
            		}
            		_unbindAssetEvents(id) {
            				this._assets.off("load:start:" + id, this._onBundleLoadStart, this);
            				this._assets.off("load:" + id, this._onBundleLoad, this);
            				this._assets.off("error:" + id, this._onBundleError, this);
            		}
            		_indexAssetInBundle(id, bundle) {
            				var bundles = this._assetToBundles.get(id);
            				if (!bundles) {
            						bundles = new Set();
            						this._assetToBundles.set(id, bundles);
            				}
            				bundles.add(bundle);
            				var asset = this._assets.get(id);
            				if (asset) this._indexAssetFileUrls(asset);
            		}
            		_indexAssetFileUrls(asset) {
            				var urls = this._getAssetFileUrls(asset);
            				if (!urls) return;
            				for(var i = 0; i < urls.length; i++){
            						var bundles = this._assetToBundles.get(asset.id);
            						if (!bundles) continue;
            						this._urlsToBundles.set(urls[i], bundles);
            				}
            		}
            		_getAssetFileUrls(asset) {
            				var url = asset.getFileUrl();
            				if (!url) return null;
            				url = url.split('?')[0];
            				var urls = [
            						url
            				];
            				if (asset.type === 'font') {
            						var numFiles = asset.data.info.maps.length;
            						for(var i = 1; i < numFiles; i++){
            								urls.push(url.replace('.png', "" + i + ".png"));
            						}
            				}
            				return urls;
            		}
            		_onAssetRemove(asset) {
            				if (asset.type === 'bundle') {
            						this._idToBundle.delete(asset.id);
            						this._unbindAssetEvents(asset.id);
            						var assetIds = asset.data.assets;
            						for(var i = 0; i < assetIds.length; i++){
            								var bundles = this._assetToBundles.get(assetIds[i]);
            								if (!bundles) continue;
            								bundles.delete(asset);
            								if (bundles.size === 0) {
            										this._assetToBundles.delete(assetIds[i]);
            										for (var [url, otherBundles] of this._urlsToBundles){
            												if (otherBundles !== bundles) {
            														continue;
            												}
            												this._urlsToBundles.delete(url);
            										}
            								}
            						}
            						this._onBundleError("Bundle " + asset.id + " was removed");
            				} else {
            						var bundles1 = this._assetToBundles.get(asset.id);
            						if (!bundles1) return;
            						this._assetToBundles.delete(asset.id);
            						var urls = this._getAssetFileUrls(asset);
            						if (!urls) return;
            						for(var i1 = 0; i1 < urls.length; i1++){
            								this._urlsToBundles.delete(urls[i1]);
            						}
            				}
            		}
            		_onBundleLoadStart(asset) {
            				asset.resource.on('add', (url, data)=>{
            						var callbacks = this._fileRequests.get(url);
            						if (!callbacks) return;
            						for(var i = 0; i < callbacks.length; i++){
            								callbacks[i](null, data);
            						}
            						this._fileRequests.delete(url);
            				});
            		}
            		_onBundleLoad(asset) {
            				if (!asset.resource) {
            						this._onBundleError("Bundle " + asset.id + " failed to load");
            						return;
            				}
            				if (!this._fileRequests) {
            						return;
            				}
            				for (var [url, requests] of this._fileRequests){
            						var bundles = this._urlsToBundles.get(url);
            						if (!bundles || !bundles.has(asset)) continue;
            						var decodedUrl = decodeURIComponent(url);
            						var err = void 0, data = void 0;
            						if (asset.resource.has(decodedUrl)) {
            								data = asset.resource.get(decodedUrl);
            						} else if (asset.resource.loaded) {
            								err = "Bundle " + asset.id + " does not contain URL " + url;
            						} else {
            								continue;
            						}
            						for(var i = 0; i < requests.length; i++){
            								requests[i](err, err || data);
            						}
            						this._fileRequests.delete(url);
            				}
            		}
            		_onBundleError(err) {
            				for (var [url, requests] of this._fileRequests){
            						var bundle = this._findLoadedOrLoadingBundleForUrl(url);
            						if (!bundle) {
            								for(var i = 0; i < requests.length; i++){
            										requests[i](err);
            								}
            								this._fileRequests.delete(url);
            						}
            				}
            		}
            		_findLoadedOrLoadingBundleForUrl(url) {
            				var bundles = this._urlsToBundles.get(url);
            				if (!bundles) return null;
            				var candidate = null;
            				for (var bundle of bundles){
            						if (bundle.loaded && bundle.resource) {
            								return bundle;
            						} else if (bundle.loading) {
            								candidate = bundle;
            						}
            				}
            				return candidate;
            		}
            		listBundlesForAsset(asset) {
            				var bundles = this._assetToBundles.get(asset.id);
            				if (bundles) return Array.from(bundles);
            				return null;
            		}
            		list() {
            				return Array.from(this._idToBundle.values());
            		}
            		hasUrl(url) {
            				return this._urlsToBundles.has(url);
            		}
            		urlIsLoadedOrLoading(url) {
            				return !!this._findLoadedOrLoadingBundleForUrl(url);
            		}
            		loadUrl(url, callback) {
            				var bundle = this._findLoadedOrLoadingBundleForUrl(url);
            				if (!bundle) {
            						callback("URL " + url + " not found in any bundles");
            						return;
            				}
            				if (bundle.loaded) {
            						var decodedUrl = decodeURIComponent(url);
            						if (bundle.resource.has(decodedUrl)) {
            								callback(null, bundle.resource.get(decodedUrl));
            								return;
            						} else if (bundle.resource.loaded) {
            								callback("Bundle " + bundle.id + " does not contain URL " + url);
            								return;
            						}
            				}
            				var callbacks = this._fileRequests.get(url);
            				if (!callbacks) {
            						callbacks = [];
            						this._fileRequests.set(url, callbacks);
            				}
            				callbacks.push(callback);
            		}
            		destroy() {
            				this._assets.off('add', this._onAssetAdd, this);
            				this._assets.off('remove', this._onAssetRemove, this);
            				for (var id of this._idToBundle.keys()){
            						this._unbindAssetEvents(id);
            				}
            				this._assets = null;
            				this._idToBundle.clear();
            				this._idToBundle = null;
            				this._assetToBundles.clear();
            				this._assetToBundles = null;
            				this._urlsToBundles.clear();
            				this._urlsToBundles = null;
            				this._fileRequests.clear();
            				this._fileRequests = null;
            		}
            		constructor(assets){
            				this._idToBundle = new Map();
            				this._assetToBundles = new Map();
            				this._urlsToBundles = new Map();
            				this._fileRequests = new Map();
            				this._assets = assets;
            				this._assets.bundles = this;
            				this._assets.on('add', this._onAssetAdd, this);
            				this._assets.on('remove', this._onAssetRemove, this);
            		}
            }
            
            class ComponentSystemRegistry extends EventHandler {
            		add(system) {
            				var id = system.id;
            				if (this[id]) {
            						throw new Error("ComponentSystem name '" + id + "' already registered or not allowed");
            				}
            				this[id] = system;
            				this.list.push(system);
            		}
            		remove(system) {
            				var id = system.id;
            				if (!this[id]) {
            						throw new Error("No ComponentSystem named '" + id + "' registered");
            				}
            				delete this[id];
            				var index = this.list.indexOf(this[id]);
            				if (index !== -1) {
            						this.list.splice(index, 1);
            				}
            		}
            		destroy() {
            				this.off();
            				for(var i = 0; i < this.list.length; i++){
            						this.list[i].destroy();
            				}
            		}
            		constructor(){
            				super();
            				this.list = [];
            		}
            }
            
            class Bundle extends EventHandler {
            		addFile(url, data) {
            				if (this._index.has(url)) {
            						return;
            				}
            				this._index.set(url, data);
            				this.fire('add', url, data);
            		}
            		has(url) {
            				return this._index.has(url);
            		}
            		get(url) {
            				return this._index.get(url) || null;
            		}
            		destroy() {
            				this._index.clear();
            		}
            		set loaded(value) {
            				if (!value || this._loaded) {
            						return;
            				}
            				this._loaded = true;
            				this.fire('load');
            		}
            		get loaded() {
            				return this._loaded;
            		}
            		constructor(...args){
            				super(...args), this._index = new Map(), this._loaded = false;
            		}
            }
            Bundle.EVENT_ADD = 'add';
            Bundle.EVENT_LOAD = 'load';
            
            class Untar extends EventHandler {
            		pump(done, value) {
            				if (done) {
            						this.fire('done');
            						return null;
            				}
            				this.bytesReceived += value.byteLength;
            				var data = new Uint8Array(this.data.length + value.length);
            				data.set(this.data);
            				data.set(value, this.data.length);
            				this.data = data;
            				while(this.readFile());
            				return this.reader.read().then((res)=>{
            						this.pump(res.done, res.value);
            				}).catch((err)=>{
            						this.fire('error', err);
            				});
            		}
            		readFile() {
            				if (!this.headerRead && this.bytesReceived > this.bytesRead + this.headerSize) {
            						this.headerRead = true;
            						var view = new DataView(this.data.buffer, this.bytesRead, this.headerSize);
            						var _this_decoder;
            						(_this_decoder = this.decoder) != null ? _this_decoder : this.decoder = new TextDecoder('windows-1252');
            						var headers = this.decoder.decode(view);
            						this.fileName = headers.substring(0, 100).replace(/\0/g, '');
            						this.fileSize = parseInt(headers.substring(124, 136), 8);
            						this.fileType = headers.substring(156, 157);
            						this.ustarFormat = headers.substring(257, 263);
            						if (this.ustarFormat.indexOf('ustar') !== -1) {
            								var prefix = headers.substring(345, 500).replace(/\0/g, '');
            								if (prefix.length > 0) {
            										this.fileName = prefix.trim() + this.fileName.trim();
            								}
            						}
            						this.bytesRead += 512;
            				}
            				if (this.headerRead) {
            						if (this.bytesReceived < this.bytesRead + this.fileSize) {
            								return false;
            						}
            						if (this.fileType === '' || this.fileType === '0') {
            								var dataView = new DataView(this.data.buffer, this.bytesRead, this.fileSize);
            								var file = {
            										name: this.prefix + this.fileName,
            										size: this.fileSize,
            										data: dataView
            								};
            								this.fire('file', file);
            						}
            						this.bytesRead += this.fileSize;
            						this.headerRead = false;
            						var bytesRemained = this.bytesRead % this.paddingSize;
            						if (bytesRemained !== 0) {
            								this.bytesRead += this.paddingSize - bytesRemained;
            						}
            						return true;
            				}
            				return false;
            		}
            		constructor(fetchPromise, assetsPrefix = ''){
            				super(), this.headerSize = 512, this.paddingSize = 512, this.bytesRead = 0, this.bytesReceived = 0, this.headerRead = false, this.reader = null, this.data = new Uint8Array(0), this.decoder = null, this.prefix = '', this.fileName = '', this.fileSize = 0, this.fileType = '', this.ustarFormat = '';
            				this.prefix = assetsPrefix || '';
            				this.reader = fetchPromise.body.getReader();
            				this.reader.read().then((res)=>{
            						this.pump(res.done, res.value);
            				}).catch((err)=>{
            						this.fire('error', err);
            				});
            		}
            }
            
            class ResourceHandler {
            		set maxRetries(value) {
            				this._maxRetries = value;
            		}
            		get maxRetries() {
            				return this._maxRetries;
            		}
            		load(url, callback, asset) {}
            		open(url, data, asset) {
            				return data;
            		}
            		patch(asset, assets) {}
            		constructor(app, handlerType){
            				this.handlerType = '';
            				this._maxRetries = 0;
            				this._app = app;
            				this.handlerType = handlerType;
            		}
            }
            
            class BundleHandler extends ResourceHandler {
            		_fetchRetries(url, options, retries) {
            				if (retries === void 0) retries = 0;
            				return new Promise((resolve, reject)=>{
            						var tryFetch = ()=>{
            								fetch(url, options).then(resolve).catch((err)=>{
            										retries++;
            										if (retries < this.maxRetries) {
            												tryFetch();
            										} else {
            												reject(err);
            										}
            								});
            						};
            						tryFetch();
            				});
            		}
            		load(url, callback) {
            				if (typeof url === 'string') {
            						url = {
            								load: url,
            								original: url
            						};
            				}
            				this._fetchRetries(url.load, {
            						mode: 'cors',
            						credentials: 'include'
            				}, this.maxRetries).then((res)=>{
            						var bundle = new Bundle();
            						callback(null, bundle);
            						var untar = new Untar(res, this._assets.prefix);
            						untar.on('file', (file)=>{
            								bundle.addFile(file.name, file.data);
            						});
            						untar.on('done', ()=>{
            								bundle.loaded = true;
            						});
            						untar.on('error', (err)=>{
            								callback(err);
            						});
            				}).catch((err)=>{
            						callback(err);
            				});
            		}
            		open(url, bundle) {
            				return bundle;
            		}
            		constructor(app){
            				super(app, 'bundle');
            				this._assets = app.assets;
            		}
            }
            
            class ResourceLoader {
            		addHandler(type, handler) {
            				this._handlers[type] = handler;
            				handler._loader = this;
            		}
            		removeHandler(type) {
            				delete this._handlers[type];
            		}
            		getHandler(type) {
            				return this._handlers[type];
            		}
            		static makeKey(url, type) {
            				return url + "-" + type;
            		}
            		load(url, type, callback, asset, options) {
            				var handler = this._handlers[type];
            				if (!handler) {
            						var err = "No resource handler for asset type: '" + type + "' when loading [" + url + "]";
            						callback(err);
            						return;
            				}
            				if (!url) {
            						this._loadNull(handler, callback, asset);
            						return;
            				}
            				var key = ResourceLoader.makeKey(url, type);
            				if (this._cache[key] !== undefined) {
            						callback(null, this._cache[key]);
            				} else if (this._requests[key]) {
            						this._requests[key].push(callback);
            				} else {
            						this._requests[key] = [
            								callback
            						];
            						var self = this;
            						var handleLoad = function handleLoad(err, urlObj) {
            								if (err) {
            										self._onFailure(key, err);
            										return;
            								}
            								if (urlObj.load instanceof DataView) {
            										if (handler.openBinary) {
            												if (!self._requests[key]) {
            														return;
            												}
            												try {
            														var data = handler.openBinary(urlObj.load);
            														self._onSuccess(key, data);
            												} catch (err) {
            														self._onFailure(key, err);
            												}
            												return;
            										}
            										urlObj.load = URL.createObjectURL(new Blob([
            												urlObj.load
            										]));
            										if (asset) {
            												if (asset.urlObject) {
            														URL.revokeObjectURL(asset.urlObject);
            												}
            												asset.urlObject = urlObj.load;
            										}
            								}
            								handler.load(urlObj, (err, data, extra)=>{
            										if (!self._requests[key]) {
            												return;
            										}
            										if (err) {
            												self._onFailure(key, err);
            												return;
            										}
            										try {
            												self._onSuccess(key, handler.open(urlObj.original, data, asset), extra);
            										} catch (e) {
            												self._onFailure(key, e);
            										}
            								}, asset);
            						};
            						var normalizedUrl = url.split('?')[0];
            						if (this._app.enableBundles && this._app.bundles.hasUrl(normalizedUrl) && !(options && options.bundlesIgnore)) {
            								if (!this._app.bundles.urlIsLoadedOrLoading(normalizedUrl)) {
            										var _this__app_assets;
            										var bundles = this._app.bundles.listBundlesForAsset(asset);
            										var bundle;
            										if (options && options.bundlesFilter) {
            												bundle = options.bundlesFilter(bundles);
            										}
            										if (!bundle) {
            												bundles == null ? void 0 : bundles.sort((a, b)=>{
            														return a.file.size - b.file.size;
            												});
            												bundle = bundles == null ? void 0 : bundles[0];
            										}
            										if (bundle) (_this__app_assets = this._app.assets) == null ? void 0 : _this__app_assets.load(bundle);
            								}
            								this._app.bundles.loadUrl(normalizedUrl, (err, fileUrlFromBundle)=>{
            										handleLoad(err, {
            												load: fileUrlFromBundle,
            												original: normalizedUrl
            										});
            								});
            						} else {
            								handleLoad(null, {
            										load: url,
            										original: asset && asset.file.filename || url
            								});
            						}
            				}
            		}
            		_loadNull(handler, callback, asset) {
            				var onLoad = function onLoad(err, data, extra) {
            						if (err) {
            								callback(err);
            						} else {
            								try {
            										callback(null, handler.open(null, data, asset), extra);
            								} catch (e) {
            										callback(e);
            								}
            						}
            				};
            				handler.load(null, onLoad, asset);
            		}
            		_onSuccess(key, result, extra) {
            				if (result !== null) {
            						this._cache[key] = result;
            				} else {
            						delete this._cache[key];
            				}
            				for(var i = 0; i < this._requests[key].length; i++){
            						this._requests[key][i](null, result, extra);
            				}
            				delete this._requests[key];
            		}
            		_onFailure(key, err) {
            				console.error(err);
            				if (this._requests[key]) {
            						for(var i = 0; i < this._requests[key].length; i++){
            								this._requests[key][i](err);
            						}
            						delete this._requests[key];
            				}
            		}
            		open(type, data) {
            				var handler = this._handlers[type];
            				if (!handler) {
            						console.warn("No resource handler found for: " + type);
            						return data;
            				}
            				return handler.open(null, data);
            		}
            		patch(asset, assets) {
            				var handler = this._handlers[asset.type];
            				if (!handler) {
            						console.warn("No resource handler found for: " + asset.type);
            						return;
            				}
            				if (handler.patch) {
            						handler.patch(asset, assets);
            				}
            		}
            		clearCache(url, type) {
            				var key = ResourceLoader.makeKey(url, type);
            				delete this._cache[key];
            		}
            		getFromCache(url, type) {
            				var key = ResourceLoader.makeKey(url, type);
            				if (this._cache[key]) {
            						return this._cache[key];
            				}
            				return undefined;
            		}
            		enableRetry(maxRetries) {
            				if (maxRetries === void 0) maxRetries = 5;
            				maxRetries = Math.max(0, maxRetries) || 0;
            				for(var key in this._handlers){
            						this._handlers[key].maxRetries = maxRetries;
            				}
            		}
            		disableRetry() {
            				for(var key in this._handlers){
            						this._handlers[key].maxRetries = 0;
            				}
            		}
            		destroy() {
            				this._handlers = {};
            				this._requests = {};
            				this._cache = {};
            		}
            		constructor(app){
            				this._handlers = {};
            				this._requests = {};
            				this._cache = {};
            				this._app = app;
            		}
            }
            
            class I18nParser {
            		_validate(data) {
            				if (!data.header) {
            						throw new Error('pc.I18n#addData: Missing "header" field');
            				}
            				if (!data.header.version) {
            						throw new Error('pc.I18n#addData: Missing "header.version" field');
            				}
            				if (data.header.version !== 1) {
            						throw new Error('pc.I18n#addData: Invalid "header.version" field');
            				}
            				if (!data.data) {
            						throw new Error('pc.I18n#addData: Missing "data" field');
            				} else if (!Array.isArray(data.data)) {
            						throw new Error('pc.I18n#addData: "data" field must be an array');
            				}
            				for(var i = 0, len = data.data.length; i < len; i++){
            						var entry = data.data[i];
            						if (!entry.info) {
            								throw new Error('pc.I18n#addData: missing "data[' + i + '].info" field');
            						}
            						if (!entry.info.locale) {
            								throw new Error('pc.I18n#addData: missing "data[' + i + '].info.locale" field');
            						}
            						if (typeof entry.info.locale !== 'string') {
            								throw new Error('pc.I18n#addData: "data[' + i + '].info.locale" must be a string');
            						}
            						if (!entry.messages) {
            								throw new Error('pc.I18n#addData: missing "data[' + i + '].messages" field');
            						}
            				}
            		}
            		parse(data) {
            				return data.data;
            		}
            }
            
            class I18n extends EventHandler {
            		set assets(value) {
            				var index = {};
            				for(var i = 0, len = value.length; i < len; i++){
            						var id = value[i] instanceof Asset ? value[i].id : value[i];
            						index[id] = true;
            				}
            				var i1 = this._assets.length;
            				while(i1--){
            						var id1 = this._assets[i1];
            						if (!index[id1]) {
            								this._app.assets.off("add:" + id1, this._onAssetAdd, this);
            								var asset = this._app.assets.get(id1);
            								if (asset) {
            										this._onAssetRemove(asset);
            								}
            								this._assets.splice(i1, 1);
            						}
            				}
            				for(var id2 in index){
            						var idNum = parseInt(id2, 10);
            						if (this._assets.indexOf(idNum) !== -1) continue;
            						this._assets.push(idNum);
            						var asset1 = this._app.assets.get(idNum);
            						if (!asset1) {
            								this._app.assets.once("add:" + idNum, this._onAssetAdd, this);
            						} else {
            								this._onAssetAdd(asset1);
            						}
            				}
            		}
            		get assets() {
            				return this._assets;
            		}
            		set locale(value) {
            				if (this._locale === value) {
            						return;
            				}
            				var lang = getLang(value);
            				if (lang === 'in') {
            						lang = 'id';
            						value = replaceLang(value, lang);
            						if (this._locale === value) {
            								return;
            						}
            				}
            				var old = this._locale;
            				this._locale = value;
            				this._lang = lang;
            				this._pluralFn = getPluralFn(this._lang);
            				this.fire('set:locale', value, old);
            		}
            		get locale() {
            				return this._locale;
            		}
            		static findAvailableLocale(desiredLocale, availableLocales) {
            				return findAvailableLocale(desiredLocale, availableLocales);
            		}
            		findAvailableLocale(desiredLocale) {
            				if (this._translations[desiredLocale]) {
            						return desiredLocale;
            				}
            				var lang = getLang(desiredLocale);
            				return this._findFallbackLocale(desiredLocale, lang);
            		}
            		getText(key, locale) {
            				var result = key;
            				var lang;
            				if (!locale) {
            						locale = this._locale;
            						lang = this._lang;
            				}
            				var translations = this._translations[locale];
            				if (!translations) {
            						if (!lang) {
            								lang = getLang(locale);
            						}
            						locale = this._findFallbackLocale(locale, lang);
            						translations = this._translations[locale];
            				}
            				if (translations && translations.hasOwnProperty(key)) {
            						result = translations[key];
            						if (Array.isArray(result)) {
            								result = result[0];
            						}
            						if (result === null || result === undefined) {
            								result = key;
            						}
            				}
            				return result;
            		}
            		getPluralText(key, n, locale) {
            				var result = key;
            				var lang;
            				var pluralFn;
            				if (!locale) {
            						locale = this._locale;
            						lang = this._lang;
            						pluralFn = this._pluralFn;
            				} else {
            						lang = getLang(locale);
            						pluralFn = getPluralFn(lang);
            				}
            				var translations = this._translations[locale];
            				if (!translations) {
            						locale = this._findFallbackLocale(locale, lang);
            						lang = getLang(locale);
            						pluralFn = getPluralFn(lang);
            						translations = this._translations[locale];
            				}
            				if (translations && translations[key] && pluralFn) {
            						var index = pluralFn(n);
            						result = translations[key][index];
            						if (result === null || result === undefined) {
            								result = key;
            						}
            				}
            				return result;
            		}
            		addData(data) {
            				var parsed;
            				try {
            						parsed = this._parser.parse(data);
            				} catch (err) {
            						console.error(err);
            						return;
            				}
            				for(var i = 0, len = parsed.length; i < len; i++){
            						var entry = parsed[i];
            						var locale = entry.info.locale;
            						var messages = entry.messages;
            						if (!this._translations[locale]) {
            								this._translations[locale] = {};
            								var lang = getLang(locale);
            								if (!this._availableLangs[lang]) {
            										this._availableLangs[lang] = locale;
            								}
            						}
            						Object.assign(this._translations[locale], messages);
            						this.fire('data:add', locale, messages);
            				}
            		}
            		removeData(data) {
            				var parsed;
            				try {
            						parsed = this._parser.parse(data);
            				} catch (err) {
            						console.error(err);
            						return;
            				}
            				for(var i = 0, len = parsed.length; i < len; i++){
            						var entry = parsed[i];
            						var locale = entry.info.locale;
            						var translations = this._translations[locale];
            						if (!translations) continue;
            						var messages = entry.messages;
            						for(var key in messages){
            								delete translations[key];
            						}
            						if (Object.keys(translations).length === 0) {
            								delete this._translations[locale];
            								delete this._availableLangs[getLang(locale)];
            						}
            						this.fire('data:remove', locale, messages);
            				}
            		}
            		destroy() {
            				this._translations = null;
            				this._availableLangs = null;
            				this._assets = null;
            				this._parser = null;
            				this.off();
            		}
            		_findFallbackLocale(locale, lang) {
            				var result = DEFAULT_LOCALE_FALLBACKS[locale];
            				if (result && this._translations[result]) {
            						return result;
            				}
            				result = DEFAULT_LOCALE_FALLBACKS[lang];
            				if (result && this._translations[result]) {
            						return result;
            				}
            				result = this._availableLangs[lang];
            				if (result && this._translations[result]) {
            						return result;
            				}
            				return DEFAULT_LOCALE;
            		}
            		_onAssetAdd(asset) {
            				asset.on('load', this._onAssetLoad, this);
            				asset.on('change', this._onAssetChange, this);
            				asset.on('remove', this._onAssetRemove, this);
            				asset.on('unload', this._onAssetUnload, this);
            				if (asset.resource) {
            						this._onAssetLoad(asset);
            				}
            		}
            		_onAssetLoad(asset) {
            				this.addData(asset.resource);
            		}
            		_onAssetChange(asset) {
            				if (asset.resource) {
            						this.addData(asset.resource);
            				}
            		}
            		_onAssetRemove(asset) {
            				asset.off('load', this._onAssetLoad, this);
            				asset.off('change', this._onAssetChange, this);
            				asset.off('remove', this._onAssetRemove, this);
            				asset.off('unload', this._onAssetUnload, this);
            				if (asset.resource) {
            						this.removeData(asset.resource);
            				}
            				this._app.assets.once("add:" + asset.id, this._onAssetAdd, this);
            		}
            		_onAssetUnload(asset) {
            				if (asset.resource) {
            						this.removeData(asset.resource);
            				}
            		}
            		constructor(app){
            				super();
            				this.locale = DEFAULT_LOCALE;
            				this._translations = {};
            				this._availableLangs = {};
            				this._app = app;
            				this._assets = [];
            				this._parser = new I18nParser();
            		}
            }
            
            class ScriptRegistry extends EventHandler {
            		destroy() {
            				this.app = null;
            				this.off();
            		}
            		addSchema(id, schema) {
            				if (!schema) return;
            				this._scriptSchemas.set(id, schema);
            		}
            		getSchema(id) {
            				return this._scriptSchemas.get(id);
            		}
            		add(script) {
            				var scriptName = script.__name;
            				if (this._scripts.hasOwnProperty(scriptName)) {
            						setTimeout(()=>{
            								if (script.prototype.swap) {
            										var old = this._scripts[scriptName];
            										var ind = this._list.indexOf(old);
            										this._list[ind] = script;
            										this._scripts[scriptName] = script;
            										this.fire('swap', scriptName, script);
            										this.fire("swap:" + scriptName, script);
            								} else {
            										console.warn("script registry already has '" + scriptName + "' script, define 'swap' method for new script type to enable code hot swapping");
            								}
            						});
            						return false;
            				}
            				this._scripts[scriptName] = script;
            				this._list.push(script);
            				this.fire('add', scriptName, script);
            				this.fire("add:" + scriptName, script);
            				setTimeout(()=>{
            						if (!this._scripts.hasOwnProperty(scriptName)) {
            								return;
            						}
            						if (!this.app || !this.app.systems || !this.app.systems.script) {
            								return;
            						}
            						var components = this.app.systems.script._components;
            						var attributes;
            						var scriptInstances = [];
            						var scriptInstancesInitialized = [];
            						for(components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++){
            								var component = components.items[components.loopIndex];
            								if (component._scriptsIndex[scriptName] && component._scriptsIndex[scriptName].awaiting) {
            										if (component._scriptsData && component._scriptsData[scriptName]) {
            												attributes = component._scriptsData[scriptName].attributes;
            										}
            										var scriptInstance = component.create(scriptName, {
            												preloading: true,
            												ind: component._scriptsIndex[scriptName].ind,
            												attributes: attributes
            										});
            										if (scriptInstance) {
            												scriptInstances.push(scriptInstance);
            										}
            										for (var _$script of component.scripts){
            												component.initializeAttributes(_$script);
            										}
            								}
            						}
            						for(var i = 0; i < scriptInstances.length; i++){
            								if (scriptInstances[i].enabled) {
            										scriptInstances[i]._initialized = true;
            										scriptInstancesInitialized.push(scriptInstances[i]);
            										if (scriptInstances[i].initialize) {
            												scriptInstances[i].initialize();
            										}
            								}
            						}
            						for(var i1 = 0; i1 < scriptInstancesInitialized.length; i1++){
            								if (!scriptInstancesInitialized[i1].enabled || scriptInstancesInitialized[i1]._postInitialized) {
            										continue;
            								}
            								scriptInstancesInitialized[i1]._postInitialized = true;
            								if (scriptInstancesInitialized[i1].postInitialize) {
            										scriptInstancesInitialized[i1].postInitialize();
            								}
            						}
            				});
            				return true;
            		}
            		remove(nameOrType) {
            				var scriptType = nameOrType;
            				var scriptName = nameOrType;
            				if (typeof scriptName !== 'string') {
            						scriptName = scriptType.__name;
            				} else {
            						scriptType = this.get(scriptName);
            				}
            				if (this.get(scriptName) !== scriptType) {
            						return false;
            				}
            				delete this._scripts[scriptName];
            				var ind = this._list.indexOf(scriptType);
            				this._list.splice(ind, 1);
            				this.fire('remove', scriptName, scriptType);
            				this.fire("remove:" + scriptName, scriptType);
            				return true;
            		}
            		get(name) {
            				return this._scripts[name] || null;
            		}
            		has(nameOrType) {
            				if (typeof nameOrType === 'string') {
            						return this._scripts.hasOwnProperty(nameOrType);
            				}
            				if (!nameOrType) return false;
            				var scriptName = nameOrType.__name;
            				return this._scripts[scriptName] === nameOrType;
            		}
            		list() {
            				return this._list;
            		}
            		constructor(app){
            				super(), this._scripts = {}, this._list = [], this._scriptSchemas = new Map();
            				this.app = app;
            		}
            }
            
            var cmpStaticOrder = (a, b)=>a.constructor.order - b.constructor.order;
            var sortStaticOrder = (arr)=>arr.sort(cmpStaticOrder);
            var _enableList = [];
            var tmpPool = [];
            var getTempArray = ()=>{
            		var _tmpPool_pop;
            		return (_tmpPool_pop = tmpPool.pop()) != null ? _tmpPool_pop : [];
            };
            var releaseTempArray = (a)=>{
            		a.length = 0;
            		tmpPool.push(a);
            };
            class Entity extends GraphNode {
            		addComponent(type, data) {
            				var system = this._app.systems[type];
            				if (!system) {
            						return null;
            				}
            				if (this.c[type]) {
            						return null;
            				}
            				return system.addComponent(this, data);
            		}
            		removeComponent(type) {
            				var system = this._app.systems[type];
            				if (!system) {
            						return;
            				}
            				if (!this.c[type]) {
            						return;
            				}
            				system.removeComponent(this);
            		}
            		findComponent(type) {
            				var entity = this.findOne((entity)=>{
            						var _entity_c;
            						return (_entity_c = entity.c) == null ? void 0 : _entity_c[type];
            				});
            				return entity && entity.c[type];
            		}
            		findComponents(type) {
            				return this.find((entity)=>{
            						var _entity_c;
            						return (_entity_c = entity.c) == null ? void 0 : _entity_c[type];
            				}).map((entity)=>entity.c[type]);
            		}
            		findScript(nameOrType) {
            				var entity = this.findOne((node)=>{
            						var _node_c_script, _node_c;
            						return (_node_c = node.c) == null ? void 0 : (_node_c_script = _node_c.script) == null ? void 0 : _node_c_script.has(nameOrType);
            				});
            				return entity == null ? void 0 : entity.c.script.get(nameOrType);
            		}
            		findScripts(nameOrType) {
            				var entities = this.find((node)=>{
            						var _node_c_script, _node_c;
            						return (_node_c = node.c) == null ? void 0 : (_node_c_script = _node_c.script) == null ? void 0 : _node_c_script.has(nameOrType);
            				});
            				return entities.map((entity)=>entity.c.script.get(nameOrType));
            		}
            		getGuid() {
            				if (!this._guid) {
            						this.setGuid(guid.create());
            				}
            				return this._guid;
            		}
            		setGuid(guid) {
            				var index = this._app._entityIndex;
            				if (this._guid) {
            						delete index[this._guid];
            				}
            				this._guid = guid;
            				index[this._guid] = this;
            		}
            		_notifyHierarchyStateChanged(node, enabled) {
            				var enableFirst = false;
            				if (node === this && _enableList.length === 0) {
            						enableFirst = true;
            				}
            				node._beingEnabled = true;
            				node._onHierarchyStateChanged(enabled);
            				if (node._onHierarchyStatePostChanged) {
            						_enableList.push(node);
            				}
            				var c = node._children;
            				for(var i = 0, len = c.length; i < len; i++){
            						if (c[i]._enabled) {
            								this._notifyHierarchyStateChanged(c[i], enabled);
            						}
            				}
            				node._beingEnabled = false;
            				if (enableFirst) {
            						for(var i1 = 0; i1 < _enableList.length; i1++){
            								_enableList[i1]._onHierarchyStatePostChanged();
            						}
            						_enableList.length = 0;
            				}
            		}
            		_onHierarchyStateChanged(enabled) {
            				super._onHierarchyStateChanged(enabled);
            				var components = this._getSortedComponents();
            				for(var i = 0; i < components.length; i++){
            						var component = components[i];
            						if (component.enabled) {
            								if (enabled) {
            										component.onEnable();
            								} else {
            										component.onDisable();
            								}
            						}
            				}
            				releaseTempArray(components);
            		}
            		_onHierarchyStatePostChanged() {
            				var components = this._getSortedComponents();
            				for(var i = 0; i < components.length; i++){
            						components[i].onPostStateChange();
            				}
            				releaseTempArray(components);
            		}
            		findByGuid(guid) {
            				if (this._guid === guid) return this;
            				var e = this._app._entityIndex[guid];
            				if (e && (e === this || e.isDescendantOf(this))) {
            						return e;
            				}
            				return null;
            		}
            		destroy() {
            				this._destroying = true;
            				for(var name in this.c){
            						this.c[name].enabled = false;
            				}
            				for(var name1 in this.c){
            						this.c[name1].system.removeComponent(this);
            				}
            				super.destroy();
            				if (this._guid) {
            						delete this._app._entityIndex[this._guid];
            				}
            				this._destroying = false;
            		}
            		clone() {
            				var duplicatedIdsMap = {};
            				var clone = this._cloneRecursively(duplicatedIdsMap);
            				duplicatedIdsMap[this.getGuid()] = clone;
            				resolveDuplicatedEntityReferenceProperties(this, this, clone, duplicatedIdsMap);
            				return clone;
            		}
            		_getSortedComponents() {
            				var components = this.c;
            				var sortedArray = getTempArray();
            				var needSort = 0;
            				for(var type in components){
            						if (components.hasOwnProperty(type)) {
            								var component = components[type];
            								needSort |= component.constructor.order !== 0;
            								sortedArray.push(component);
            						}
            				}
            				if (needSort && sortedArray.length > 1) {
            						sortStaticOrder(sortedArray);
            				}
            				return sortedArray;
            		}
            		_cloneRecursively(duplicatedIdsMap) {
            				var clone = new this.constructor(undefined, this._app);
            				super._cloneInternal(clone);
            				for(var type in this.c){
            						var component = this.c[type];
            						component.system.cloneComponent(this, clone);
            				}
            				for(var i = 0; i < this._children.length; i++){
            						var oldChild = this._children[i];
            						if (oldChild instanceof Entity) {
            								var newChild = oldChild._cloneRecursively(duplicatedIdsMap);
            								clone.addChild(newChild);
            								duplicatedIdsMap[oldChild.getGuid()] = newChild;
            						}
            				}
            				return clone;
            		}
            		constructor(name, app = getApplication()){
            				super(name), this.c = {}, this._destroying = false, this._guid = null, this._template = false;
            				this._app = app;
            		}
            }
            Entity.EVENT_DESTROY = 'destroy';
            function resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, oldEntity, newEntity, duplicatedIdsMap) {
            		if (oldEntity instanceof Entity) {
            				var components = oldEntity.c;
            				for(var componentName in components){
            						var component = components[componentName];
            						var entityProperties = component.system.getPropertiesOfType('entity');
            						for(var i = 0, len = entityProperties.length; i < len; i++){
            								var propertyDescriptor = entityProperties[i];
            								var propertyName = propertyDescriptor.name;
            								var oldEntityReferenceId = component[propertyName];
            								var entityIsWithinOldSubtree = !!oldSubtreeRoot.findByGuid(oldEntityReferenceId);
            								if (entityIsWithinOldSubtree) {
            										var newEntityReferenceId = duplicatedIdsMap[oldEntityReferenceId].getGuid();
            										if (newEntityReferenceId) {
            												newEntity.c[componentName][propertyName] = newEntityReferenceId;
            										}
            								}
            						}
            				}
            				if (components.script) {
            						newEntity.script.resolveDuplicatedEntityReferenceProperties(components.script, duplicatedIdsMap);
            				}
            				if (components.render) {
            						newEntity.render.resolveDuplicatedEntityReferenceProperties(components.render, duplicatedIdsMap);
            				}
            				if (components.button) {
            						newEntity.button.resolveDuplicatedEntityReferenceProperties(components.button, duplicatedIdsMap);
            				}
            				if (components.scrollview) {
            						newEntity.scrollview.resolveDuplicatedEntityReferenceProperties(components.scrollview, duplicatedIdsMap);
            				}
            				if (components.scrollbar) {
            						newEntity.scrollbar.resolveDuplicatedEntityReferenceProperties(components.scrollbar, duplicatedIdsMap);
            				}
            				if (components.anim) {
            						newEntity.anim.resolveDuplicatedEntityReferenceProperties(components.anim, duplicatedIdsMap);
            				}
            				var _old = oldEntity.children.filter((e)=>e instanceof Entity);
            				var _new = newEntity.children.filter((e)=>e instanceof Entity);
            				for(var i1 = 0, len1 = _old.length; i1 < len1; i1++){
            						resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, _old[i1], _new[i1], duplicatedIdsMap);
            				}
            		}
            }
            
            class SceneRegistryItem {
            		get loaded() {
            				return !!this.data;
            		}
            		get loading() {
            				return this._loading;
            		}
            		constructor(name, url){
            				this.data = null;
            				this._loading = false;
            				this._onLoadedCallbacks = [];
            				this.name = name;
            				this.url = url;
            		}
            }
            
            class SceneRegistry {
            		destroy() {
            				this._app = null;
            		}
            		list() {
            				return this._list;
            		}
            		add(name, url) {
            				if (this._index.hasOwnProperty(name)) {
            						return false;
            				}
            				var item = new SceneRegistryItem(name, url);
            				var i = this._list.push(item);
            				this._index[item.name] = i - 1;
            				this._urlIndex[item.url] = i - 1;
            				return true;
            		}
            		find(name) {
            				if (this._index.hasOwnProperty(name)) {
            						return this._list[this._index[name]];
            				}
            				return null;
            		}
            		findByUrl(url) {
            				if (this._urlIndex.hasOwnProperty(url)) {
            						return this._list[this._urlIndex[url]];
            				}
            				return null;
            		}
            		remove(name) {
            				if (this._index.hasOwnProperty(name)) {
            						var idx = this._index[name];
            						var item = this._list[idx];
            						delete this._urlIndex[item.url];
            						delete this._index[name];
            						this._list.splice(idx, 1);
            						for(var i = 0; i < this._list.length; i++){
            								item = this._list[i];
            								this._index[item.name] = i;
            								this._urlIndex[item.url] = i;
            						}
            				}
            		}
            		_loadSceneData(sceneItem, storeInCache, callback) {
            				var app = this._app;
            				var url = sceneItem;
            				if (typeof sceneItem === 'string') {
            						sceneItem = this.findByUrl(url) || this.find(url) || new SceneRegistryItem('Untitled', url);
            				}
            				url = sceneItem.url;
            				if (!url) {
            						callback('Cannot find scene to load');
            						return;
            				}
            				if (sceneItem.loaded) {
            						callback(null, sceneItem);
            						return;
            				}
            				if (app.assets && app.assets.prefix && !ABSOLUTE_URL.test(url)) {
            						url = path.join(app.assets.prefix, url);
            				}
            				sceneItem._onLoadedCallbacks.push(callback);
            				if (!sceneItem._loading) {
            						var handler = app.loader.getHandler('hierarchy');
            						handler.load(url, (err, data)=>{
            								sceneItem.data = data;
            								sceneItem._loading = false;
            								for(var i = 0; i < sceneItem._onLoadedCallbacks.length; i++){
            										sceneItem._onLoadedCallbacks[i](err, sceneItem);
            								}
            								if (!storeInCache) {
            										sceneItem.data = null;
            								}
            								sceneItem._onLoadedCallbacks.length = 0;
            						});
            				}
            				sceneItem._loading = true;
            		}
            		loadSceneData(sceneItem, callback) {
            				this._loadSceneData(sceneItem, true, callback);
            		}
            		unloadSceneData(sceneItem) {
            				if (typeof sceneItem === 'string') {
            						sceneItem = this.findByUrl(sceneItem);
            				}
            				if (sceneItem) {
            						sceneItem.data = null;
            				}
            		}
            		_loadSceneHierarchy(sceneItem, onBeforeAddHierarchy, callback) {
            				this._loadSceneData(sceneItem, false, (err, sceneItem)=>{
            						if (err) {
            								if (callback) {
            										callback(err);
            								}
            								return;
            						}
            						if (onBeforeAddHierarchy) {
            								onBeforeAddHierarchy(sceneItem);
            						}
            						var app = this._app;
            						var _loaded = ()=>{
            								var handler = app.loader.getHandler('hierarchy');
            								app.systems.script.preloading = true;
            								var entity = handler.open(sceneItem.url, sceneItem.data);
            								app.systems.script.preloading = false;
            								app.loader.clearCache(sceneItem.url, 'hierarchy');
            								app.root.addChild(entity);
            								app.systems.fire('initialize', entity);
            								app.systems.fire('postInitialize', entity);
            								app.systems.fire('postPostInitialize', entity);
            								if (callback) callback(null, entity);
            						};
            						app._preloadScripts(sceneItem.data, _loaded);
            				});
            		}
            		loadSceneHierarchy(sceneItem, callback) {
            				this._loadSceneHierarchy(sceneItem, null, callback);
            		}
            		loadSceneSettings(sceneItem, callback) {
            				this._loadSceneData(sceneItem, false, (err, sceneItem)=>{
            						if (!err) {
            								this._app.applySceneSettings(sceneItem.data.settings);
            								if (callback) {
            										callback(null);
            								}
            						} else {
            								if (callback) {
            										callback(err);
            								}
            						}
            				});
            		}
            		changeScene(sceneItem, callback) {
            				var app = this._app;
            				var onBeforeAddHierarchy = (sceneItem)=>{
            						var { children } = app.root;
            						while(children.length){
            								children[0].destroy();
            						}
            						app.applySceneSettings(sceneItem.data.settings);
            				};
            				this._loadSceneHierarchy(sceneItem, onBeforeAddHierarchy, callback);
            		}
            		loadScene(url, callback) {
            				var app = this._app;
            				var handler = app.loader.getHandler('scene');
            				if (app.assets && app.assets.prefix && !ABSOLUTE_URL.test(url)) {
            						url = path.join(app.assets.prefix, url);
            				}
            				handler.load(url, (err, data)=>{
            						if (!err) {
            								var _loaded = ()=>{
            										app.systems.script.preloading = true;
            										var scene = handler.open(url, data);
            										var sceneItem = this.findByUrl(url);
            										if (sceneItem && !sceneItem.loaded) {
            												sceneItem.data = data;
            										}
            										app.systems.script.preloading = false;
            										app.loader.clearCache(url, 'scene');
            										app.loader.patch({
            												resource: scene,
            												type: 'scene'
            										}, app.assets);
            										app.root.addChild(scene.root);
            										if (app.systems.rigidbody && typeof Ammo !== 'undefined') {
            												app.systems.rigidbody.gravity.set(scene._gravity.x, scene._gravity.y, scene._gravity.z);
            										}
            										if (callback) {
            												callback(null, scene);
            										}
            								};
            								app._preloadScripts(data, _loaded);
            						} else {
            								if (callback) {
            										callback(err);
            								}
            						}
            				});
            		}
            		constructor(app){
            				this._list = [];
            				this._index = {};
            				this._urlIndex = {};
            				this._app = app;
            		}
            }
            
            class ApplicationStats {
            		get scene() {
            				return getApplication().scene._stats;
            		}
            		get lightmapper() {
            				var _getApplication_lightmapper;
            				return (_getApplication_lightmapper = getApplication().lightmapper) == null ? void 0 : _getApplication_lightmapper.stats;
            		}
            		get batcher() {
            				var batcher = getApplication()._batcher;
            				return batcher ? batcher._stats : null;
            		}
            		constructor(device){
            				this.frame = {
            						fps: 0,
            						ms: 0,
            						dt: 0,
            						updateStart: 0,
            						updateTime: 0,
            						renderStart: 0,
            						renderTime: 0,
            						physicsStart: 0,
            						physicsTime: 0,
            						cullTime: 0,
            						sortTime: 0,
            						skinTime: 0,
            						morphTime: 0,
            						instancingTime: 0,
            						triangles: 0,
            						otherPrimitives: 0,
            						shaders: 0,
            						materials: 0,
            						cameras: 0,
            						shadowMapUpdates: 0,
            						shadowMapTime: 0,
            						depthMapTime: 0,
            						forwardTime: 0,
            						lightClustersTime: 0,
            						lightClusters: 0,
            						_timeToCountFrames: 0,
            						_fpsAccum: 0
            				};
            				this.drawCalls = {
            						forward: 0,
            						depth: 0,
            						shadow: 0,
            						immediate: 0,
            						misc: 0,
            						total: 0,
            						skinned: 0,
            						instanced: 0,
            						removedByInstancing: 0
            				};
            				this.misc = {
            						renderTargetCreationTime: 0
            				};
            				this.particles = {
            						updatesPerFrame: 0,
            						_updatesPerFrame: 0,
            						frameTime: 0,
            						_frameTime: 0
            				};
            				this.shaders = device._shaderStats;
            				this.vram = device._vram;
            				Object.defineProperty(this.vram, 'totalUsed', {
            						get: function get() {
            								return this.tex + this.vb + this.ib;
            						}
            				});
            				Object.defineProperty(this.vram, 'geom', {
            						get: function get() {
            								return this.vb + this.ib;
            						}
            				});
            		}
            }
            
            class AppBase extends EventHandler {
            		init(appOptions) {
            				var { assetPrefix, batchManager, componentSystems, elementInput, gamepads, graphicsDevice, keyboard, lightmapper, mouse, resourceHandlers, scriptsOrder, scriptPrefix, soundManager, touch, xr } = appOptions;
            				this.graphicsDevice = graphicsDevice;
            				this._initDefaultMaterial();
            				this._initProgramLibrary();
            				this.stats = new ApplicationStats(graphicsDevice);
            				this._soundManager = soundManager;
            				this.scene = new Scene(graphicsDevice);
            				this._registerSceneImmediate(this.scene);
            				this.assets = new AssetRegistry(this.loader);
            				if (assetPrefix) this.assets.prefix = assetPrefix;
            				this.bundles = new BundleRegistry(this.assets);
            				this.scriptsOrder = scriptsOrder || [];
            				this.defaultLayerWorld = new Layer({
            						name: 'World',
            						id: LAYERID_WORLD
            				});
            				this.defaultLayerDepth = new Layer({
            						name: 'Depth',
            						id: LAYERID_DEPTH,
            						enabled: false,
            						opaqueSortMode: SORTMODE_NONE
            				});
            				this.defaultLayerSkybox = new Layer({
            						name: 'Skybox',
            						id: LAYERID_SKYBOX,
            						opaqueSortMode: SORTMODE_NONE
            				});
            				this.defaultLayerUi = new Layer({
            						name: 'UI',
            						id: LAYERID_UI,
            						transparentSortMode: SORTMODE_MANUAL
            				});
            				this.defaultLayerImmediate = new Layer({
            						name: 'Immediate',
            						id: LAYERID_IMMEDIATE,
            						opaqueSortMode: SORTMODE_NONE
            				});
            				var defaultLayerComposition = new LayerComposition('default');
            				defaultLayerComposition.pushOpaque(this.defaultLayerWorld);
            				defaultLayerComposition.pushOpaque(this.defaultLayerDepth);
            				defaultLayerComposition.pushOpaque(this.defaultLayerSkybox);
            				defaultLayerComposition.pushTransparent(this.defaultLayerWorld);
            				defaultLayerComposition.pushOpaque(this.defaultLayerImmediate);
            				defaultLayerComposition.pushTransparent(this.defaultLayerImmediate);
            				defaultLayerComposition.pushTransparent(this.defaultLayerUi);
            				this.scene.layers = defaultLayerComposition;
            				AreaLightLuts.createPlaceholder(graphicsDevice);
            				this.renderer = new ForwardRenderer(graphicsDevice);
            				this.renderer.scene = this.scene;
            				if (lightmapper) {
            						this.lightmapper = new lightmapper(graphicsDevice, this.root, this.scene, this.renderer, this.assets);
            						this.once('prerender', this._firstBake, this);
            				}
            				if (batchManager) {
            						this._batcher = new batchManager(graphicsDevice, this.root, this.scene);
            						this.once('prerender', this._firstBatch, this);
            				}
            				this.keyboard = keyboard || null;
            				this.mouse = mouse || null;
            				this.touch = touch || null;
            				this.gamepads = gamepads || null;
            				if (elementInput) {
            						this.elementInput = elementInput;
            						this.elementInput.app = this;
            				}
            				this.xr = xr ? new xr(this) : null;
            				if (this.elementInput) this.elementInput.attachSelectEvents();
            				this._scriptPrefix = scriptPrefix || '';
            				if (this.enableBundles) {
            						this.loader.addHandler('bundle', new BundleHandler(this));
            				}
            				resourceHandlers.forEach((resourceHandler)=>{
            						var handler = new resourceHandler(this);
            						this.loader.addHandler(handler.handlerType, handler);
            				});
            				componentSystems.forEach((componentSystem)=>{
            						this.systems.add(new componentSystem(this));
            				});
            				this._visibilityChangeHandler = this.onVisibilityChange.bind(this);
            				if (typeof document !== 'undefined') {
            						if (document.hidden !== undefined) {
            								this._hiddenAttr = 'hidden';
            								document.addEventListener('visibilitychange', this._visibilityChangeHandler, false);
            						} else if (document.mozHidden !== undefined) {
            								this._hiddenAttr = 'mozHidden';
            								document.addEventListener('mozvisibilitychange', this._visibilityChangeHandler, false);
            						} else if (document.msHidden !== undefined) {
            								this._hiddenAttr = 'msHidden';
            								document.addEventListener('msvisibilitychange', this._visibilityChangeHandler, false);
            						} else if (document.webkitHidden !== undefined) {
            								this._hiddenAttr = 'webkitHidden';
            								document.addEventListener('webkitvisibilitychange', this._visibilityChangeHandler, false);
            						}
            				}
            				this.tick = makeTick(this);
            		}
            		static getApplication(id) {
            				return id ? AppBase._applications[id] : getApplication();
            		}
            		_initDefaultMaterial() {
            				var material = new StandardMaterial();
            				material.name = 'Default Material';
            				setDefaultMaterial(this.graphicsDevice, material);
            		}
            		_initProgramLibrary() {
            				var library = new ProgramLibrary(this.graphicsDevice, new StandardMaterial());
            				setProgramLibrary(this.graphicsDevice, library);
            		}
            		get soundManager() {
            				return this._soundManager;
            		}
            		get batcher() {
            				return this._batcher;
            		}
            		get fillMode() {
            				return this._fillMode;
            		}
            		get resolutionMode() {
            				return this._resolutionMode;
            		}
            		configure(url, callback) {
            				http.get(url, (err, response)=>{
            						if (err) {
            								callback(err);
            								return;
            						}
            						var props = response.application_properties;
            						var scenes = response.scenes;
            						var assets = response.assets;
            						this._parseApplicationProperties(props, (err)=>{
            								this._parseScenes(scenes);
            								this._parseAssets(assets);
            								if (!err) {
            										callback(null);
            								} else {
            										callback(err);
            								}
            						});
            				});
            		}
            		preload(callback) {
            				this.fire('preload:start');
            				var assets = this.assets.list({
            						preload: true
            				});
            				if (assets.length === 0) {
            						this.fire('preload:end');
            						callback();
            						return;
            				}
            				var loadedCount = 0;
            				var onAssetLoadOrError = ()=>{
            						loadedCount++;
            						this.fire('preload:progress', loadedCount / assets.length);
            						if (loadedCount === assets.length) {
            								this.fire('preload:end');
            								callback();
            						}
            				};
            				assets.forEach((asset)=>{
            						if (!asset.loaded) {
            								asset.once('load', onAssetLoadOrError);
            								asset.once('error', onAssetLoadOrError);
            								this.assets.load(asset);
            						} else {
            								onAssetLoadOrError();
            						}
            				});
            		}
            		_preloadScripts(sceneData, callback) {
            				callback();
            		}
            		_parseApplicationProperties(props, callback) {
            				if (typeof props.maxAssetRetries === 'number' && props.maxAssetRetries > 0) {
            						this.loader.enableRetry(props.maxAssetRetries);
            				}
            				if (!props.useDevicePixelRatio) {
            						props.useDevicePixelRatio = props.use_device_pixel_ratio;
            				}
            				if (!props.resolutionMode) {
            						props.resolutionMode = props.resolution_mode;
            				}
            				if (!props.fillMode) {
            						props.fillMode = props.fill_mode;
            				}
            				this._width = props.width;
            				this._height = props.height;
            				if (props.useDevicePixelRatio) {
            						this.graphicsDevice.maxPixelRatio = window.devicePixelRatio;
            				}
            				this.setCanvasResolution(props.resolutionMode, this._width, this._height);
            				this.setCanvasFillMode(props.fillMode, this._width, this._height);
            				if (props.layers && props.layerOrder) {
            						var composition = new LayerComposition('application');
            						var layers = {};
            						for(var key in props.layers){
            								var data = props.layers[key];
            								data.id = parseInt(key, 10);
            								data.enabled = data.id !== LAYERID_DEPTH;
            								layers[key] = new Layer(data);
            						}
            						for(var i = 0, len = props.layerOrder.length; i < len; i++){
            								var sublayer = props.layerOrder[i];
            								var layer = layers[sublayer.layer];
            								if (!layer) continue;
            								if (sublayer.transparent) {
            										composition.pushTransparent(layer);
            								} else {
            										composition.pushOpaque(layer);
            								}
            								composition.subLayerEnabled[i] = sublayer.enabled;
            						}
            						this.scene.layers = composition;
            				}
            				if (props.batchGroups) {
            						var batcher = this.batcher;
            						if (batcher) {
            								for(var i1 = 0, len1 = props.batchGroups.length; i1 < len1; i1++){
            										var grp = props.batchGroups[i1];
            										batcher.addGroup(grp.name, grp.dynamic, grp.maxAabbSize, grp.id, grp.layers);
            								}
            						}
            				}
            				if (props.i18nAssets) {
            						this.i18n.assets = props.i18nAssets;
            				}
            				this._loadLibraries(props.libraries, callback);
            		}
            		_loadLibraries(urls, callback) {
            				var len = urls.length;
            				var count = len;
            				var regex = /^https?:\/\//;
            				if (len) {
            						var onLoad = (err, script)=>{
            								count--;
            								if (err) {
            										callback(err);
            								} else if (count === 0) {
            										this.onLibrariesLoaded();
            										callback(null);
            								}
            						};
            						for(var i = 0; i < len; ++i){
            								var url = urls[i];
            								if (!regex.test(url.toLowerCase()) && this._scriptPrefix) {
            										url = path.join(this._scriptPrefix, url);
            								}
            								this.loader.load(url, "script", onLoad);
            						}
            				} else {
            						this.onLibrariesLoaded();
            						callback(null);
            				}
            		}
            		_parseScenes(scenes) {
            				if (!scenes) return;
            				for(var i = 0; i < scenes.length; i++){
            						this.scenes.add(scenes[i].name, scenes[i].url);
            				}
            		}
            		_parseAssets(assets) {
            				var list = [];
            				var scriptsIndex = {};
            				var bundlesIndex = {};
            				for(var i = 0; i < this.scriptsOrder.length; i++){
            						var id = this.scriptsOrder[i];
            						if (!assets[id]) {
            								continue;
            						}
            						scriptsIndex[id] = true;
            						list.push(assets[id]);
            				}
            				if (this.enableBundles) {
            						for(var id1 in assets){
            								if (assets[id1].type === 'bundle') {
            										bundlesIndex[id1] = true;
            										list.push(assets[id1]);
            								}
            						}
            				}
            				for(var id2 in assets){
            						if (scriptsIndex[id2] || bundlesIndex[id2]) {
            								continue;
            						}
            						list.push(assets[id2]);
            				}
            				for(var i1 = 0; i1 < list.length; i1++){
            						var data = list[i1];
            						var asset = new Asset(data.name, data.type, data.file, data.data);
            						asset.id = parseInt(data.id, 10);
            						asset.preload = data.preload ? data.preload : false;
            						asset.loaded = data.type === "script" && data.data && data.data.loadingType > 0;
            						asset.tags.add(data.tags);
            						if (data.i18n) {
            								for(var locale in data.i18n){
            										asset.addLocalizedAssetId(locale, data.i18n[locale]);
            								}
            						}
            						this.assets.add(asset);
            				}
            		}
            		start() {
            				this.frame = 0;
            				this.fire('start', {
            						timestamp: now(),
            						target: this
            				});
            				if (!this._librariesLoaded) {
            						this.onLibrariesLoaded();
            				}
            				this.systems.fire('initialize', this.root);
            				this.fire('initialize');
            				this.systems.fire('postInitialize', this.root);
            				this.systems.fire('postPostInitialize', this.root);
            				this.fire('postinitialize');
            				this.tick();
            		}
            		inputUpdate(dt) {
            				if (this.controller) {
            						this.controller.update(dt);
            				}
            				if (this.mouse) {
            						this.mouse.update();
            				}
            				if (this.keyboard) {
            						this.keyboard.update();
            				}
            				if (this.gamepads) {
            						this.gamepads.update();
            				}
            		}
            		update(dt) {
            				this.frame++;
            				this.graphicsDevice.updateClientRect();
            				this.systems.fire(this._inTools ? 'toolsUpdate' : 'update', dt);
            				this.systems.fire('animationUpdate', dt);
            				this.systems.fire('postUpdate', dt);
            				this.fire('update', dt);
            				this.inputUpdate(dt);
            		}
            		frameStart() {
            				this.graphicsDevice.frameStart();
            		}
            		frameEnd() {
            				this.graphicsDevice.frameEnd();
            		}
            		render() {
            				this.fire('prerender');
            				this.root.syncHierarchy();
            				if (this._batcher) {
            						this._batcher.updateAll();
            				}
            				this.renderComposition(this.scene.layers);
            				this.fire('postrender');
            		}
            		renderComposition(layerComposition) {
            				this.renderer.update(layerComposition);
            				this.renderer.buildFrameGraph(this.frameGraph, layerComposition);
            				this.frameGraph.render(this.graphicsDevice);
            		}
            		_fillFrameStatsBasic(now, dt, ms) {
            				var stats = this.stats.frame;
            				stats.dt = dt;
            				stats.ms = ms;
            				if (now > stats._timeToCountFrames) {
            						stats.fps = stats._fpsAccum;
            						stats._fpsAccum = 0;
            						stats._timeToCountFrames = now + 1000;
            				} else {
            						stats._fpsAccum++;
            				}
            				this.stats.drawCalls.total = this.graphicsDevice._drawCallsPerFrame;
            				this.graphicsDevice._drawCallsPerFrame = 0;
            		}
            		_fillFrameStats() {
            				var stats = this.stats.frame;
            				stats.cameras = this.renderer._camerasRendered;
            				stats.materials = this.renderer._materialSwitches;
            				stats.shaders = this.graphicsDevice._shaderSwitchesPerFrame;
            				stats.shadowMapUpdates = this.renderer._shadowMapUpdates;
            				stats.shadowMapTime = this.renderer._shadowMapTime;
            				stats.depthMapTime = this.renderer._depthMapTime;
            				stats.forwardTime = this.renderer._forwardTime;
            				var prims = this.graphicsDevice._primsPerFrame;
            				stats.triangles = prims[PRIMITIVE_TRIANGLES] / 3 + Math.max(prims[PRIMITIVE_TRISTRIP] - 2, 0) + Math.max(prims[PRIMITIVE_TRIFAN] - 2, 0);
            				stats.cullTime = this.renderer._cullTime;
            				stats.sortTime = this.renderer._sortTime;
            				stats.skinTime = this.renderer._skinTime;
            				stats.morphTime = this.renderer._morphTime;
            				stats.lightClusters = this.renderer._lightClusters;
            				stats.lightClustersTime = this.renderer._lightClustersTime;
            				stats.otherPrimitives = 0;
            				for(var i = 0; i < prims.length; i++){
            						if (i < PRIMITIVE_TRIANGLES) {
            								stats.otherPrimitives += prims[i];
            						}
            						prims[i] = 0;
            				}
            				this.renderer._camerasRendered = 0;
            				this.renderer._materialSwitches = 0;
            				this.renderer._shadowMapUpdates = 0;
            				this.graphicsDevice._shaderSwitchesPerFrame = 0;
            				this.renderer._cullTime = 0;
            				this.renderer._layerCompositionUpdateTime = 0;
            				this.renderer._lightClustersTime = 0;
            				this.renderer._sortTime = 0;
            				this.renderer._skinTime = 0;
            				this.renderer._morphTime = 0;
            				this.renderer._shadowMapTime = 0;
            				this.renderer._depthMapTime = 0;
            				this.renderer._forwardTime = 0;
            				stats = this.stats.drawCalls;
            				stats.forward = this.renderer._forwardDrawCalls;
            				stats.culled = this.renderer._numDrawCallsCulled;
            				stats.depth = 0;
            				stats.shadow = this.renderer._shadowDrawCalls;
            				stats.skinned = this.renderer._skinDrawCalls;
            				stats.immediate = 0;
            				stats.instanced = 0;
            				stats.removedByInstancing = 0;
            				stats.misc = stats.total - (stats.forward + stats.shadow);
            				this.renderer._depthDrawCalls = 0;
            				this.renderer._shadowDrawCalls = 0;
            				this.renderer._forwardDrawCalls = 0;
            				this.renderer._numDrawCallsCulled = 0;
            				this.renderer._skinDrawCalls = 0;
            				this.renderer._immediateRendered = 0;
            				this.renderer._instancedDrawCalls = 0;
            				this.stats.misc.renderTargetCreationTime = this.graphicsDevice.renderTargetCreationTime;
            				stats = this.stats.particles;
            				stats.updatesPerFrame = stats._updatesPerFrame;
            				stats.frameTime = stats._frameTime;
            				stats._updatesPerFrame = 0;
            				stats._frameTime = 0;
            		}
            		setCanvasFillMode(mode, width, height) {
            				this._fillMode = mode;
            				this.resizeCanvas(width, height);
            		}
            		setCanvasResolution(mode, width, height) {
            				this._resolutionMode = mode;
            				if (mode === RESOLUTION_AUTO && width === undefined) {
            						width = this.graphicsDevice.canvas.clientWidth;
            						height = this.graphicsDevice.canvas.clientHeight;
            				}
            				this.graphicsDevice.resizeCanvas(width, height);
            		}
            		isHidden() {
            				return document[this._hiddenAttr];
            		}
            		onVisibilityChange() {
            				if (this.isHidden()) {
            						if (this._soundManager) {
            								this._soundManager.suspend();
            						}
            				} else {
            						if (this._soundManager) {
            								this._soundManager.resume();
            						}
            				}
            		}
            		resizeCanvas(width, height) {
            				if (!this._allowResize) return undefined;
            				if (this.xr && this.xr.session) {
            						return undefined;
            				}
            				var windowWidth = window.innerWidth;
            				var windowHeight = window.innerHeight;
            				if (this._fillMode === FILLMODE_KEEP_ASPECT) {
            						var r = this.graphicsDevice.canvas.width / this.graphicsDevice.canvas.height;
            						var winR = windowWidth / windowHeight;
            						if (r > winR) {
            								width = windowWidth;
            								height = width / r;
            						} else {
            								height = windowHeight;
            								width = height * r;
            						}
            				} else if (this._fillMode === FILLMODE_FILL_WINDOW) {
            						width = windowWidth;
            						height = windowHeight;
            				}
            				this.graphicsDevice.canvas.style.width = "" + width + "px";
            				this.graphicsDevice.canvas.style.height = "" + height + "px";
            				this.updateCanvasSize();
            				return {
            						width: width,
            						height: height
            				};
            		}
            		updateCanvasSize() {
            				var _this_xr;
            				if (!this._allowResize || ((_this_xr = this.xr) == null ? void 0 : _this_xr.active)) {
            						return;
            				}
            				if (this._resolutionMode === RESOLUTION_AUTO) {
            						var canvas = this.graphicsDevice.canvas;
            						this.graphicsDevice.resizeCanvas(canvas.clientWidth, canvas.clientHeight);
            				}
            		}
            		onLibrariesLoaded() {
            				this._librariesLoaded = true;
            				if (this.systems.rigidbody) {
            						this.systems.rigidbody.onLibraryLoaded();
            				}
            		}
            		applySceneSettings(settings) {
            				var asset;
            				if (this.systems.rigidbody && typeof Ammo !== 'undefined') {
            						var [x, y, z] = settings.physics.gravity;
            						this.systems.rigidbody.gravity.set(x, y, z);
            				}
            				this.scene.applySettings(settings);
            				if (settings.render.hasOwnProperty('skybox')) {
            						if (settings.render.skybox) {
            								asset = this.assets.get(settings.render.skybox);
            								if (asset) {
            										this.setSkybox(asset);
            								} else {
            										this.assets.once("add:" + settings.render.skybox, this.setSkybox, this);
            								}
            						} else {
            								this.setSkybox(null);
            						}
            				}
            		}
            		setAreaLightLuts(ltcMat1, ltcMat2) {
            				if (ltcMat1 && ltcMat2) {
            						AreaLightLuts.set(this.graphicsDevice, ltcMat1, ltcMat2);
            				}
            		}
            		setSkybox(asset) {
            				if (asset !== this._skyboxAsset) {
            						var onSkyboxRemoved = ()=>{
            								this.setSkybox(null);
            						};
            						var onSkyboxChanged = ()=>{
            								this.scene.setSkybox(this._skyboxAsset ? this._skyboxAsset.resources : null);
            						};
            						if (this._skyboxAsset) {
            								this.assets.off("load:" + this._skyboxAsset.id, onSkyboxChanged, this);
            								this.assets.off("remove:" + this._skyboxAsset.id, onSkyboxRemoved, this);
            								this._skyboxAsset.off('change', onSkyboxChanged, this);
            						}
            						this._skyboxAsset = asset;
            						if (this._skyboxAsset) {
            								this.assets.on("load:" + this._skyboxAsset.id, onSkyboxChanged, this);
            								this.assets.once("remove:" + this._skyboxAsset.id, onSkyboxRemoved, this);
            								this._skyboxAsset.on('change', onSkyboxChanged, this);
            								if (this.scene.skyboxMip === 0 && !this._skyboxAsset.loadFaces) {
            										this._skyboxAsset.loadFaces = true;
            								}
            								this.assets.load(this._skyboxAsset);
            						}
            						onSkyboxChanged();
            				}
            		}
            		_firstBake() {
            				var _this_lightmapper;
            				(_this_lightmapper = this.lightmapper) == null ? void 0 : _this_lightmapper.bake(null, this.scene.lightmapMode);
            		}
            		_firstBatch() {
            				var _this_batcher;
            				(_this_batcher = this.batcher) == null ? void 0 : _this_batcher.generate();
            		}
            		_processTimestamp(timestamp) {
            				return timestamp;
            		}
            		drawLine(start, end, color, depthTest, layer) {
            				this.scene.drawLine(start, end, color, depthTest, layer);
            		}
            		drawLines(positions, colors, depthTest, layer) {
            				if (depthTest === void 0) depthTest = true;
            				if (layer === void 0) layer = this.scene.defaultDrawLayer;
            				this.scene.drawLines(positions, colors, depthTest, layer);
            		}
            		drawLineArrays(positions, colors, depthTest, layer) {
            				if (depthTest === void 0) depthTest = true;
            				if (layer === void 0) layer = this.scene.defaultDrawLayer;
            				this.scene.drawLineArrays(positions, colors, depthTest, layer);
            		}
            		drawWireSphere(center, radius, color, segments, depthTest, layer) {
            				if (color === void 0) color = Color.WHITE;
            				if (segments === void 0) segments = 20;
            				if (depthTest === void 0) depthTest = true;
            				if (layer === void 0) layer = this.scene.defaultDrawLayer;
            				this.scene.immediate.drawWireSphere(center, radius, color, segments, depthTest, layer);
            		}
            		drawWireAlignedBox(minPoint, maxPoint, color, depthTest, layer, mat) {
            				if (color === void 0) color = Color.WHITE;
            				if (depthTest === void 0) depthTest = true;
            				if (layer === void 0) layer = this.scene.defaultDrawLayer;
            				this.scene.immediate.drawWireAlignedBox(minPoint, maxPoint, color, depthTest, layer, mat);
            		}
            		drawMeshInstance(meshInstance, layer) {
            				if (layer === void 0) layer = this.scene.defaultDrawLayer;
            				this.scene.immediate.drawMesh(null, null, null, meshInstance, layer);
            		}
            		drawMesh(mesh, material, matrix, layer) {
            				if (layer === void 0) layer = this.scene.defaultDrawLayer;
            				this.scene.immediate.drawMesh(material, matrix, mesh, null, layer);
            		}
            		drawQuad(matrix, material, layer) {
            				if (layer === void 0) layer = this.scene.defaultDrawLayer;
            				this.scene.immediate.drawMesh(material, matrix, this.scene.immediate.getQuadMesh(), null, layer);
            		}
            		drawTexture(x, y, width, height, texture, material, layer, filterable) {
            				if (layer === void 0) layer = this.scene.defaultDrawLayer;
            				if (filterable === void 0) filterable = true;
            				if (filterable === false && !this.graphicsDevice.isWebGPU) {
            						return;
            				}
            				var matrix = new Mat4();
            				matrix.setTRS(new Vec3(x, y, 0.0), Quat.IDENTITY, new Vec3(width, -height, 0.0));
            				if (!material) {
            						material = new ShaderMaterial();
            						material.cull = CULLFACE_NONE;
            						material.setParameter('colorMap', texture);
            						material.shaderDesc = filterable ? this.scene.immediate.getTextureShaderDesc(texture.encoding) : this.scene.immediate.getUnfilterableTextureShaderDesc();
            						material.update();
            				}
            				this.drawQuad(matrix, material, layer);
            		}
            		drawDepthTexture(x, y, width, height, layer) {
            				if (layer === void 0) layer = this.scene.defaultDrawLayer;
            				var material = new ShaderMaterial();
            				material.cull = CULLFACE_NONE;
            				material.shaderDesc = this.scene.immediate.getDepthTextureShaderDesc();
            				material.update();
            				this.drawTexture(x, y, width, height, null, material, layer);
            		}
            		destroy() {
            				var _this_lightmapper, _this_xr, _this_xr1, _this__soundManager;
            				if (this._inFrameUpdate) {
            						this._destroyRequested = true;
            						return;
            				}
            				var canvasId = this.graphicsDevice.canvas.id;
            				this.fire('destroy', this);
            				this.off('librariesloaded');
            				if (typeof document !== 'undefined') {
            						document.removeEventListener('visibilitychange', this._visibilityChangeHandler, false);
            						document.removeEventListener('mozvisibilitychange', this._visibilityChangeHandler, false);
            						document.removeEventListener('msvisibilitychange', this._visibilityChangeHandler, false);
            						document.removeEventListener('webkitvisibilitychange', this._visibilityChangeHandler, false);
            				}
            				this._visibilityChangeHandler = null;
            				this.root.destroy();
            				this.root = null;
            				if (this.mouse) {
            						this.mouse.off();
            						this.mouse.detach();
            						this.mouse = null;
            				}
            				if (this.keyboard) {
            						this.keyboard.off();
            						this.keyboard.detach();
            						this.keyboard = null;
            				}
            				if (this.touch) {
            						this.touch.off();
            						this.touch.detach();
            						this.touch = null;
            				}
            				if (this.elementInput) {
            						this.elementInput.detach();
            						this.elementInput = null;
            				}
            				if (this.gamepads) {
            						this.gamepads.destroy();
            						this.gamepads = null;
            				}
            				if (this.controller) {
            						this.controller = null;
            				}
            				this.systems.destroy();
            				if (this.scene.layers) {
            						this.scene.layers.destroy();
            				}
            				var assets = this.assets.list();
            				for(var i = 0; i < assets.length; i++){
            						assets[i].unload();
            						assets[i].off();
            				}
            				this.assets.off();
            				this.bundles.destroy();
            				this.bundles = null;
            				this.i18n.destroy();
            				this.i18n = null;
            				var scriptHandler = this.loader.getHandler("script");
            				scriptHandler == null ? void 0 : scriptHandler.clearCache();
            				this.loader.destroy();
            				this.loader = null;
            				this.scene.destroy();
            				this.scene = null;
            				this.systems = null;
            				this.context = null;
            				this.scripts.destroy();
            				this.scripts = null;
            				this.scenes.destroy();
            				this.scenes = null;
            				(_this_lightmapper = this.lightmapper) == null ? void 0 : _this_lightmapper.destroy();
            				this.lightmapper = null;
            				if (this._batcher) {
            						this._batcher.destroy();
            						this._batcher = null;
            				}
            				this._entityIndex = {};
            				this.defaultLayerDepth.onDisable = null;
            				this.defaultLayerDepth.onEnable = null;
            				this.defaultLayerDepth = null;
            				this.defaultLayerWorld = null;
            				(_this_xr = this.xr) == null ? void 0 : _this_xr.end();
            				(_this_xr1 = this.xr) == null ? void 0 : _this_xr1.destroy();
            				this.renderer.destroy();
            				this.renderer = null;
            				this.graphicsDevice.destroy();
            				this.graphicsDevice = null;
            				this.tick = null;
            				this.off();
            				(_this__soundManager = this._soundManager) == null ? void 0 : _this__soundManager.destroy();
            				this._soundManager = null;
            				AppBase._applications[canvasId] = null;
            				if (getApplication() === this) {
            						setApplication(null);
            				}
            				AppBase.cancelTick(this);
            		}
            		static cancelTick(app) {
            				if (app.frameRequestId) {
            						window.cancelAnimationFrame(app.frameRequestId);
            						app.frameRequestId = undefined;
            				}
            		}
            		getEntityFromIndex(guid) {
            				return this._entityIndex[guid];
            		}
            		_registerSceneImmediate(scene) {
            				this.on('postrender', scene.immediate.onPostRender, scene.immediate);
            		}
            		constructor(canvas){
            				super(), this._batcher = null, this._destroyRequested = false, this._inFrameUpdate = false, this._librariesLoaded = false, this._fillMode = FILLMODE_KEEP_ASPECT, this._resolutionMode = RESOLUTION_FIXED, this._allowResize = true, this._skyboxAsset = null, this._entityIndex = {}, this._inTools = false, this._scriptPrefix = '', this._time = 0, this.enableBundles = typeof TextDecoder !== 'undefined', this.timeScale = 1, this.maxDeltaTime = 0.1, this.frame = 0, this.frameGraph = new FrameGraph(), this.scriptsOrder = [], this.autoRender = true, this.renderNextFrame = false, this.lightmapper = null, this.loader = new ResourceLoader(this), this.scenes = new SceneRegistry(this), this.scripts = new ScriptRegistry(this), this.systems = new ComponentSystemRegistry(), this.i18n = new I18n(this), this.keyboard = null, this.mouse = null, this.touch = null, this.gamepads = null, this.elementInput = null, this.xr = null;
            				AppBase._applications[canvas.id] = this;
            				setApplication(this);
            				this.root = new Entity();
            				this.root._enabledInHierarchy = true;
            		}
            }
            AppBase._applications = {};
            var _frameEndData = {};
            var makeTick = function makeTick(_app) {
            		var application = _app;
            		return function(timestamp, frame) {
            				var _application_xr;
            				if (!application.graphicsDevice) {
            						return;
            				}
            				if (application.frameRequestId) {
            						var _application_xr_session, _application_xr1;
            						(_application_xr1 = application.xr) == null ? void 0 : (_application_xr_session = _application_xr1.session) == null ? void 0 : _application_xr_session.cancelAnimationFrame(application.frameRequestId);
            						cancelAnimationFrame(application.frameRequestId);
            						application.frameRequestId = null;
            				}
            				application._inFrameUpdate = true;
            				setApplication(application);
            				var currentTime = application._processTimestamp(timestamp) || now();
            				var ms = currentTime - (application._time || currentTime);
            				var dt = ms / 1000.0;
            				dt = math.clamp(dt, 0, application.maxDeltaTime);
            				dt *= application.timeScale;
            				application._time = currentTime;
            				if ((_application_xr = application.xr) == null ? void 0 : _application_xr.session) {
            						application.frameRequestId = application.xr.session.requestAnimationFrame(application.tick);
            				} else {
            						application.frameRequestId = platform.browser || platform.worker ? requestAnimationFrame(application.tick) : null;
            				}
            				if (application.graphicsDevice.contextLost) {
            						return;
            				}
            				application._fillFrameStatsBasic(currentTime, dt, ms);
            				application.fire('frameupdate', ms);
            				var shouldRenderFrame = true;
            				if (frame) {
            						var _application_xr2;
            						shouldRenderFrame = (_application_xr2 = application.xr) == null ? void 0 : _application_xr2.update(frame);
            						application.graphicsDevice.defaultFramebuffer = frame.session.renderState.baseLayer.framebuffer;
            				} else {
            						application.graphicsDevice.defaultFramebuffer = null;
            				}
            				if (shouldRenderFrame) {
            						application.update(dt);
            						application.fire('framerender');
            						if (application.autoRender || application.renderNextFrame) {
            								application.updateCanvasSize();
            								application.frameStart();
            								application.render();
            								application.frameEnd();
            								application.renderNextFrame = false;
            						}
            						_frameEndData.timestamp = now();
            						_frameEndData.target = application;
            						application.fire('frameend', _frameEndData);
            				}
            				application._inFrameUpdate = false;
            				if (application._destroyRequested) {
            						application.destroy();
            				}
            		};
            };
            
            class AppOptions {
            		constructor(){
            				this.componentSystems = [];
            				this.resourceHandlers = [];
            		}
            }
            
            var tempSphere = new BoundingSphere();
            class BakeLight {
            		store() {
            				this.mask = this.light.mask;
            				this.shadowUpdateMode = this.light.shadowUpdateMode;
            				this.enabled = this.light.enabled;
            				this.intensity = this.light.intensity;
            				this.rotation = this.light._node.getLocalRotation().clone();
            				this.numCascades = this.light.numCascades;
            				this.castShadows = this.light._castShadows;
            		}
            		restore() {
            				var light = this.light;
            				light.mask = this.mask;
            				light.shadowUpdateMode = this.shadowUpdateMode;
            				light.enabled = this.enabled;
            				light.intensity = this.intensity;
            				light._node.setLocalRotation(this.rotation);
            				light.numCascades = this.numCascades;
            				light._castShadows = this.castShadows;
            		}
            		startBake() {
            				this.light.enabled = true;
            				this.light._destroyShadowMap();
            				this.light.beginFrame();
            		}
            		endBake(shadowMapCache) {
            				var light = this.light;
            				light.enabled = false;
            				if (light.shadowMap) {
            						if (light.shadowMap.cached) {
            								shadowMapCache.add(light, light.shadowMap);
            						}
            						light.shadowMap = null;
            				}
            		}
            		constructor(scene, light, lightingParams){
            				this.scene = scene;
            				this.light = light;
            				this.store();
            				light.numCascades = 1;
            				if (this.scene.clusteredLightingEnabled && !lightingParams.shadowsEnabled) {
            						light.castShadows = false;
            				}
            				if (light.type !== LIGHTTYPE_DIRECTIONAL) {
            						light._node.getWorldTransform();
            						light.getBoundingSphere(tempSphere);
            						this.lightBounds = new BoundingBox();
            						this.lightBounds.center.copy(tempSphere.center);
            						this.lightBounds.halfExtents.set(tempSphere.radius, tempSphere.radius, tempSphere.radius);
            				}
            		}
            }
            
            var _tempPoint$1 = new Vec2();
            class BakeLightSimple extends BakeLight {
            		get numVirtualLights() {
            				if (this.light.type === LIGHTTYPE_DIRECTIONAL) {
            						return this.light.bakeNumSamples;
            				}
            				return 1;
            		}
            		prepareVirtualLight(index, numVirtualLights) {
            				var light = this.light;
            				light._node.setLocalRotation(this.rotation);
            				if (index > 0) {
            						var directionalSpreadAngle = light.bakeArea;
            						random.circlePointDeterministic(_tempPoint$1, index, numVirtualLights);
            						_tempPoint$1.mulScalar(directionalSpreadAngle * 0.5);
            						light._node.rotateLocal(_tempPoint$1.x, 0, _tempPoint$1.y);
            				}
            				light._node.getWorldTransform();
            				var gamma = 2.2;
            				var linearIntensity = Math.pow(this.intensity, gamma);
            				light.intensity = Math.pow(linearIntensity / numVirtualLights, 1 / gamma);
            		}
            		constructor(lightmapper, light){
            				super(lightmapper.scene, light, lightmapper.lightingParams);
            		}
            }
            
            var _tempPoint = new Vec3();
            class BakeLightAmbient extends BakeLight {
            		get numVirtualLights() {
            				return this.light.bakeNumSamples;
            		}
            		prepareVirtualLight(index, numVirtualLights) {
            				random.spherePointDeterministic(_tempPoint, index, numVirtualLights, 0, this.scene.ambientBakeSpherePart);
            				this.light._node.lookAt(_tempPoint.mulScalar(-1));
            				this.light._node.rotateLocal(90, 0, 0);
            				var gamma = 2.2;
            				var fullIntensity = 2 * Math.PI * this.scene.ambientBakeSpherePart;
            				var linearIntensity = Math.pow(fullIntensity, gamma);
            				this.light.intensity = Math.pow(linearIntensity / numVirtualLights, 1 / gamma);
            		}
            		constructor(lightmapper){
            				var scene = lightmapper.scene;
            				var lightEntity = new Entity('AmbientLight');
            				lightEntity.addComponent('light', {
            						type: 'directional',
            						affectDynamic: true,
            						affectLightmapped: false,
            						bake: true,
            						bakeNumSamples: scene.ambientBakeNumSamples,
            						castShadows: true,
            						normalOffsetBias: 0.05,
            						shadowBias: 0.2,
            						shadowDistance: 1,
            						shadowResolution: 2048,
            						shadowType: SHADOW_PCF3_32F,
            						color: Color.WHITE,
            						intensity: 1,
            						bakeDir: false
            				});
            				super(scene, lightEntity.light.light, lightmapper.lightingParams);
            		}
            }
            
            class BakeMeshNode {
            		store() {
            				this.castShadows = this.component.castShadows;
            		}
            		restore() {
            				this.component.castShadows = this.castShadows;
            		}
            		constructor(node, meshInstances = null){
            				this.node = node;
            				this.component = node.render || node.model;
            				meshInstances = meshInstances || this.component.meshInstances;
            				this.store();
            				this.meshInstances = meshInstances;
            				this.bounds = null;
            				this.renderTargets = [];
            		}
            }
            
            var DENOISE_FILTER_SIZE = 15;
            class LightmapFilters {
            		setSourceTexture(texture) {
            				this.constantTexSource.setValue(texture);
            		}
            		prepare(textureWidth, textureHeight) {
            				this.pixelOffset[0] = 1 / textureWidth;
            				this.pixelOffset[1] = 1 / textureHeight;
            				this.constantPixelOffset.setValue(this.pixelOffset);
            		}
            		prepareDenoise(filterRange, filterSmoothness, bakeHDR) {
            				var index = bakeHDR ? 0 : 1;
            				if (!this.shaderDenoise[index]) {
            						var name = "lmBilateralDeNoise-" + (bakeHDR ? 'hdr' : 'rgbm');
            						var define = bakeHDR ? '#define HDR\n' : '';
            						this.shaderDenoise[index] = createShaderFromCode(this.device, shaderChunks.fullscreenQuadVS, define + shaderChunksLightmapper.bilateralDeNoisePS, name);
            						this.sigmas = new Float32Array(2);
            						this.constantSigmas = this.device.scope.resolve('sigmas');
            						this.constantKernel = this.device.scope.resolve('kernel[0]');
            						this.bZnorm = this.device.scope.resolve('bZnorm');
            				}
            				this.sigmas[0] = filterRange;
            				this.sigmas[1] = filterSmoothness;
            				this.constantSigmas.setValue(this.sigmas);
            				this.evaluateDenoiseUniforms(filterRange, filterSmoothness);
            		}
            		getDenoise(bakeHDR) {
            				var index = bakeHDR ? 0 : 1;
            				return this.shaderDenoise[index];
            		}
            		getDilate(device, bakeHDR) {
            				var index = bakeHDR ? 0 : 1;
            				if (!this.shaderDilate[index]) {
            						var name = "lmDilate-" + (bakeHDR ? 'hdr' : 'rgbm');
            						var define = bakeHDR ? '#define HDR\n' : '';
            						this.shaderDilate[index] = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, define + shaderChunksLightmapper.dilatePS, name);
            				}
            				return this.shaderDilate[index];
            		}
            		evaluateDenoiseUniforms(filterRange, filterSmoothness) {
            				function normpdf(x, sigma) {
            						return 0.39894 * Math.exp(-0.5 * x * x / (sigma * sigma)) / sigma;
            				}
            				this.kernel = this.kernel || new Float32Array(DENOISE_FILTER_SIZE);
            				var kernel = this.kernel;
            				var kSize = Math.floor((DENOISE_FILTER_SIZE - 1) / 2);
            				for(var j = 0; j <= kSize; ++j){
            						var value = normpdf(j, filterRange);
            						kernel[kSize + j] = value;
            						kernel[kSize - j] = value;
            				}
            				this.constantKernel.setValue(this.kernel);
            				var bZnorm = 1 / normpdf(0.0, filterSmoothness);
            				this.bZnorm.setValue(bZnorm);
            		}
            		constructor(device){
            				this.device = device;
            				this.shaderDilate = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunksLightmapper.dilatePS, 'lmDilate');
            				this.constantTexSource = device.scope.resolve('source');
            				this.constantPixelOffset = device.scope.resolve('pixelOffset');
            				this.pixelOffset = new Float32Array(2);
            				this.shaderDenoise = [];
            				this.sigmas = null;
            				this.constantSigmas = null;
            				this.kernel = null;
            		}
            }
            
            class RenderPassLightmapper extends RenderPass {
            		destroy() {
            				this.viewBindGroups.forEach((bg)=>{
            						bg.defaultUniformBuffer.destroy();
            						bg.destroy();
            				});
            				this.viewBindGroups.length = 0;
            		}
            		execute() {
            				this.device;
            				var { renderer, camera, receivers, renderTarget, worldClusters, lightArray } = this;
            				renderer.renderForwardLayer(camera, renderTarget, null, undefined, SHADER_FORWARD, this.viewBindGroups, {
            						meshInstances: receivers,
            						splitLights: lightArray,
            						lightClusters: worldClusters
            				});
            		}
            		constructor(device, renderer, camera, worldClusters, receivers, lightArray){
            				super(device), this.viewBindGroups = [];
            				this.renderer = renderer;
            				this.camera = camera;
            				this.worldClusters = worldClusters;
            				this.receivers = receivers;
            				this.lightArray = lightArray;
            		}
            }
            
            var MAX_LIGHTMAP_SIZE = 2048;
            var PASS_COLOR = 0;
            var PASS_DIR = 1;
            var tempVec$1 = new Vec3();
            class Lightmapper {
            		destroy() {
            				var _this_camera;
            				LightmapCache.decRef(this.blackTex);
            				this.blackTex = null;
            				LightmapCache.destroy();
            				this.device = null;
            				this.root = null;
            				this.scene = null;
            				this.renderer = null;
            				this.assets = null;
            				(_this_camera = this.camera) == null ? void 0 : _this_camera.destroy();
            				this.camera = null;
            		}
            		initBake(device) {
            				this.bakeHDR = this.scene.lightmapPixelFormat !== PIXELFORMAT_RGBA8;
            				if (!this._initCalled) {
            						this._initCalled = true;
            						this.lightmapFilters = new LightmapFilters(device);
            						this.constantBakeDir = device.scope.resolve('bakeDir');
            						this.materials = [];
            						this.blackTex = new Texture(this.device, {
            								width: 4,
            								height: 4,
            								format: PIXELFORMAT_RGBA8,
            								type: TEXTURETYPE_RGBM,
            								name: 'lightmapBlack'
            						});
            						LightmapCache.incRef(this.blackTex);
            						var camera = new Camera();
            						camera.clearColor.set(0, 0, 0, 0);
            						camera.clearColorBuffer = true;
            						camera.clearDepthBuffer = false;
            						camera.clearStencilBuffer = false;
            						camera.frustumCulling = false;
            						camera.projection = PROJECTION_ORTHOGRAPHIC;
            						camera.aspectRatio = 1;
            						camera.node = new GraphNode();
            						this.camera = camera;
            						this.camera.shaderParams.gammaCorrection = GAMMA_NONE;
            						this.camera.shaderParams.toneMapping = TONEMAP_LINEAR;
            				}
            				if (this.scene.clusteredLightingEnabled) {
            						var lightingParams = new LightingParams(device.supportsAreaLights, device.maxTextureSize, ()=>{});
            						this.lightingParams = lightingParams;
            						var srcParams = this.scene.lighting;
            						lightingParams.shadowsEnabled = srcParams.shadowsEnabled;
            						lightingParams.shadowAtlasResolution = srcParams.shadowAtlasResolution;
            						lightingParams.cookiesEnabled = srcParams.cookiesEnabled;
            						lightingParams.cookieAtlasResolution = srcParams.cookieAtlasResolution;
            						lightingParams.areaLightsEnabled = srcParams.areaLightsEnabled;
            						lightingParams.cells = new Vec3(3, 3, 3);
            						lightingParams.maxLightsPerCell = 4;
            						this.worldClusters = new WorldClusters(device);
            						this.worldClusters.name = 'ClusterLightmapper';
            				}
            		}
            		finishBake(bakeNodes) {
            				this.materials = [];
            				function destroyRT(rt) {
            						LightmapCache.decRef(rt.colorBuffer);
            						rt.destroy();
            				}
            				this.renderTargets.forEach((rt)=>{
            						destroyRT(rt);
            				});
            				this.renderTargets.clear();
            				bakeNodes.forEach((node)=>{
            						node.renderTargets.forEach((rt)=>{
            								destroyRT(rt);
            						});
            						node.renderTargets.length = 0;
            				});
            				this.ambientAOMaterial = null;
            				if (this.worldClusters) {
            						this.worldClusters.destroy();
            						this.worldClusters = null;
            				}
            		}
            		createMaterialForPass(device, scene, pass, addAmbient) {
            				var material = new StandardMaterial();
            				material.name = "lmMaterial-pass:" + pass + "-ambient:" + addAmbient;
            				material.chunks.APIVersion = CHUNKAPI_1_65;
            				material.setDefine('UV1LAYOUT', '');
            				if (pass === PASS_COLOR) {
            						var bakeLmEndChunk = shaderChunksLightmapper.bakeLmEndPS;
            						if (addAmbient) {
            								bakeLmEndChunk = "\n                    dDiffuseLight = ((dDiffuseLight - 0.5) * max(" + scene.ambientBakeOcclusionContrast.toFixed(1) + " + 1.0, 0.0)) + 0.5;\n                    dDiffuseLight += vec3(" + scene.ambientBakeOcclusionBrightness.toFixed(1) + ");\n                    dDiffuseLight = saturate(dDiffuseLight);\n                    dDiffuseLight *= dAmbientLight;\n                    " + bakeLmEndChunk + "\n                ";
            						} else {
            								material.ambient = new Color(0, 0, 0);
            						}
            						material.chunks.basePS = shaderChunks.basePS + (this.bakeHDR ? '' : '\n#define LIGHTMAP_RGBM\n');
            						material.chunks.endPS = bakeLmEndChunk;
            						material.lightMap = this.blackTex;
            				} else {
            						material.chunks.basePS = "\n                #define STD_LIGHTMAP_DIR\n                " + shaderChunks.basePS + "\n                uniform float bakeDir;\n            ";
            						material.chunks.endPS = shaderChunksLightmapper.bakeDirLmEndPS;
            				}
            				material.chunks.outputAlphaPS = '\n';
            				material.cull = CULLFACE_NONE;
            				material.forceUv1 = true;
            				material.update();
            				return material;
            		}
            		createMaterials(device, scene, passCount) {
            				for(var pass = 0; pass < passCount; pass++){
            						if (!this.passMaterials[pass]) {
            								this.passMaterials[pass] = this.createMaterialForPass(device, scene, pass, false);
            						}
            				}
            				if (!this.ambientAOMaterial) {
            						this.ambientAOMaterial = this.createMaterialForPass(device, scene, 0, true);
            						this.ambientAOMaterial.onUpdateShader = function(options) {
            								options.litOptions.lightMapWithoutAmbient = true;
            								options.litOptions.separateAmbient = true;
            								return options;
            						};
            				}
            		}
            		createTexture(size, name) {
            				return new Texture(this.device, {
            						width: size,
            						height: size,
            						format: this.scene.lightmapPixelFormat,
            						mipmaps: false,
            						type: this.bakeHDR ? TEXTURETYPE_DEFAULT : TEXTURETYPE_RGBM,
            						minFilter: FILTER_NEAREST,
            						magFilter: FILTER_NEAREST,
            						addressU: ADDRESS_CLAMP_TO_EDGE,
            						addressV: ADDRESS_CLAMP_TO_EDGE,
            						name: name
            				});
            		}
            		collectModels(node, bakeNodes, allNodes) {
            				var _node_model, _node_model1, _node_render;
            				if (!node.enabled) return;
            				var meshInstances;
            				if (((_node_model = node.model) == null ? void 0 : _node_model.model) && ((_node_model1 = node.model) == null ? void 0 : _node_model1.enabled)) {
            						if (allNodes) allNodes.push(new BakeMeshNode(node));
            						if (node.model.lightmapped) {
            								if (bakeNodes) {
            										meshInstances = node.model.model.meshInstances;
            								}
            						}
            				}
            				if ((_node_render = node.render) == null ? void 0 : _node_render.enabled) {
            						if (allNodes) allNodes.push(new BakeMeshNode(node));
            						if (node.render.lightmapped) {
            								if (bakeNodes) {
            										meshInstances = node.render.meshInstances;
            								}
            						}
            				}
            				if (meshInstances) {
            						var hasUv1 = true;
            						for(var i = 0; i < meshInstances.length; i++){
            								if (!meshInstances[i].mesh.vertexBuffer.format.hasUv1) {
            										hasUv1 = false;
            										break;
            								}
            						}
            						if (hasUv1) {
            								var notInstancedMeshInstances = [];
            								for(var i1 = 0; i1 < meshInstances.length; i1++){
            										var mesh = meshInstances[i1].mesh;
            										if (this._tempSet.has(mesh)) {
            												bakeNodes.push(new BakeMeshNode(node, [
            														meshInstances[i1]
            												]));
            										} else {
            												notInstancedMeshInstances.push(meshInstances[i1]);
            										}
            										this._tempSet.add(mesh);
            								}
            								this._tempSet.clear();
            								if (notInstancedMeshInstances.length > 0) {
            										bakeNodes.push(new BakeMeshNode(node, notInstancedMeshInstances));
            								}
            						}
            				}
            				for(var i2 = 0; i2 < node._children.length; i2++){
            						this.collectModels(node._children[i2], bakeNodes, allNodes);
            				}
            		}
            		prepareShadowCasters(nodes) {
            				var casters = [];
            				for(var n = 0; n < nodes.length; n++){
            						var component = nodes[n].component;
            						component.castShadows = component.castShadowsLightmap;
            						if (component.castShadowsLightmap) {
            								var meshes = nodes[n].meshInstances;
            								for(var i = 0; i < meshes.length; i++){
            										meshes[i].visibleThisFrame = true;
            										casters.push(meshes[i]);
            								}
            						}
            				}
            				return casters;
            		}
            		updateTransforms(nodes) {
            				for(var i = 0; i < nodes.length; i++){
            						var meshInstances = nodes[i].meshInstances;
            						for(var j = 0; j < meshInstances.length; j++){
            								meshInstances[j].node.getWorldTransform();
            						}
            				}
            		}
            		calculateLightmapSize(node) {
            				var data;
            				var sizeMult = this.scene.lightmapSizeMultiplier || 16;
            				var scale = tempVec$1;
            				var srcArea, lightmapSizeMultiplier;
            				if (node.model) {
            						lightmapSizeMultiplier = node.model.lightmapSizeMultiplier;
            						if (node.model.asset) {
            								data = this.assets.get(node.model.asset).data;
            								if (data.area) {
            										srcArea = data.area;
            								}
            						} else if (node.model._area) {
            								data = node.model;
            								if (data._area) {
            										srcArea = data._area;
            								}
            						}
            				} else if (node.render) {
            						lightmapSizeMultiplier = node.render.lightmapSizeMultiplier;
            						if (node.render.type !== 'asset') {
            								if (node.render._area) {
            										data = node.render;
            										if (data._area) {
            												srcArea = data._area;
            										}
            								}
            						}
            				}
            				var area = {
            						x: 1,
            						y: 1,
            						z: 1,
            						uv: 1
            				};
            				if (srcArea) {
            						area.x = srcArea.x;
            						area.y = srcArea.y;
            						area.z = srcArea.z;
            						area.uv = srcArea.uv;
            				}
            				var areaMult = lightmapSizeMultiplier || 1;
            				area.x *= areaMult;
            				area.y *= areaMult;
            				area.z *= areaMult;
            				var component = node.render || node.model;
            				var bounds = this.computeNodeBounds(component.meshInstances);
            				scale.copy(bounds.halfExtents);
            				var totalArea = area.x * scale.y * scale.z + area.y * scale.x * scale.z + area.z * scale.x * scale.y;
            				totalArea /= area.uv;
            				totalArea = Math.sqrt(totalArea);
            				var lightmapSize = Math.min(math.nextPowerOfTwo(totalArea * sizeMult), this.scene.lightmapMaxResolution || MAX_LIGHTMAP_SIZE);
            				return lightmapSize;
            		}
            		setLightmapping(nodes, value, passCount, shaderDefs) {
            				for(var i = 0; i < nodes.length; i++){
            						var node = nodes[i];
            						var meshInstances = node.meshInstances;
            						for(var j = 0; j < meshInstances.length; j++){
            								var meshInstance = meshInstances[j];
            								meshInstance.setLightmapped(value);
            								if (value) {
            										if (shaderDefs) {
            												meshInstance._shaderDefs |= shaderDefs;
            										}
            										meshInstance.mask = MASK_AFFECT_LIGHTMAPPED;
            										for(var pass = 0; pass < passCount; pass++){
            												var tex = node.renderTargets[pass].colorBuffer;
            												tex.minFilter = FILTER_LINEAR;
            												tex.magFilter = FILTER_LINEAR;
            												meshInstance.setRealtimeLightmap(MeshInstance.lightmapParamNames[pass], tex);
            										}
            								}
            						}
            				}
            		}
            		bake(nodes, mode) {
            				if (mode === void 0) mode = BAKE_COLORDIR;
            				var device = this.device;
            				var startTime = now();
            				this.scene._updateSkyMesh();
            				this.stats.renderPasses = 0;
            				this.stats.shadowMapTime = 0;
            				this.stats.forwardTime = 0;
            				var startShaders = device._shaderStats.linked;
            				var startFboTime = device._renderTargetCreationTime;
            				var startCompileTime = device._shaderStats.compileTime;
            				var bakeNodes = [];
            				var allNodes = [];
            				if (nodes) {
            						for(var i = 0; i < nodes.length; i++){
            								this.collectModels(nodes[i], bakeNodes, null);
            						}
            						this.collectModels(this.root, null, allNodes);
            				} else {
            						this.collectModels(this.root, bakeNodes, allNodes);
            				}
            				if (bakeNodes.length > 0) {
            						this.renderer.shadowRenderer.frameUpdate();
            						var passCount = mode === BAKE_COLORDIR ? 2 : 1;
            						this.setLightmapping(bakeNodes, false, passCount);
            						this.initBake(device);
            						this.bakeInternal(passCount, bakeNodes, allNodes);
            						var shaderDefs = SHADERDEF_LM;
            						if (mode === BAKE_COLORDIR) {
            								shaderDefs |= SHADERDEF_DIRLM;
            						}
            						if (this.scene.ambientBake) {
            								shaderDefs |= SHADERDEF_LMAMBIENT;
            						}
            						this.setLightmapping(bakeNodes, true, passCount, shaderDefs);
            						this.finishBake(bakeNodes);
            				}
            				var nowTime = now();
            				this.stats.totalRenderTime = nowTime - startTime;
            				this.stats.shadersLinked = device._shaderStats.linked - startShaders;
            				this.stats.compileTime = device._shaderStats.compileTime - startCompileTime;
            				this.stats.fboTime = device._renderTargetCreationTime - startFboTime;
            				this.stats.lightmapCount = bakeNodes.length;
            		}
            		allocateTextures(bakeNodes, passCount) {
            				for(var i = 0; i < bakeNodes.length; i++){
            						var bakeNode = bakeNodes[i];
            						var size = this.calculateLightmapSize(bakeNode.node);
            						for(var pass = 0; pass < passCount; pass++){
            								var tex = this.createTexture(size, "lightmapper_lightmap_" + i);
            								LightmapCache.incRef(tex);
            								bakeNode.renderTargets[pass] = new RenderTarget({
            										colorBuffer: tex,
            										depth: false
            								});
            						}
            						if (!this.renderTargets.has(size)) {
            								var tex1 = this.createTexture(size, "lightmapper_temp_lightmap_" + size);
            								LightmapCache.incRef(tex1);
            								this.renderTargets.set(size, new RenderTarget({
            										colorBuffer: tex1,
            										depth: false
            								}));
            						}
            				}
            		}
            		prepareLightsToBake(allLights, bakeLights) {
            				if (this.scene.ambientBake) {
            						var ambientLight = new BakeLightAmbient(this);
            						bakeLights.push(ambientLight);
            				}
            				var sceneLights = this.renderer.lights;
            				for(var i = 0; i < sceneLights.length; i++){
            						var light = sceneLights[i];
            						var bakeLight = new BakeLightSimple(this, light);
            						allLights.push(bakeLight);
            						if (light.enabled && (light.mask & MASK_BAKE) !== 0) {
            								light.mask = MASK_BAKE | MASK_AFFECT_LIGHTMAPPED | MASK_AFFECT_DYNAMIC;
            								light.shadowUpdateMode = light.type === LIGHTTYPE_DIRECTIONAL ? SHADOWUPDATE_REALTIME : SHADOWUPDATE_THISFRAME;
            								bakeLights.push(bakeLight);
            						}
            				}
            				bakeLights.sort();
            		}
            		restoreLights(allLights) {
            				for(var i = 0; i < allLights.length; i++){
            						allLights[i].restore();
            				}
            		}
            		setupScene() {
            				this.ambientLight.copy(this.scene.ambientLight);
            				if (!this.scene.ambientBake) {
            						this.scene.ambientLight.set(0, 0, 0);
            				}
            				this.renderer.setSceneConstants();
            		}
            		restoreScene() {
            				this.scene.ambientLight.copy(this.ambientLight);
            		}
            		computeNodeBounds(meshInstances) {
            				var bounds = new BoundingBox();
            				if (meshInstances.length > 0) {
            						bounds.copy(meshInstances[0].aabb);
            						for(var m = 1; m < meshInstances.length; m++){
            								bounds.add(meshInstances[m].aabb);
            						}
            				}
            				return bounds;
            		}
            		computeNodesBounds(nodes) {
            				for(var i = 0; i < nodes.length; i++){
            						var meshInstances = nodes[i].meshInstances;
            						nodes[i].bounds = this.computeNodeBounds(meshInstances);
            				}
            		}
            		computeBounds(meshInstances) {
            				var bounds = new BoundingBox();
            				for(var i = 0; i < meshInstances.length; i++){
            						bounds.copy(meshInstances[0].aabb);
            						for(var m = 1; m < meshInstances.length; m++){
            								bounds.add(meshInstances[m].aabb);
            						}
            				}
            				return bounds;
            		}
            		backupMaterials(meshInstances) {
            				for(var i = 0; i < meshInstances.length; i++){
            						this.materials[i] = meshInstances[i].material;
            				}
            		}
            		restoreMaterials(meshInstances) {
            				for(var i = 0; i < meshInstances.length; i++){
            						meshInstances[i].material = this.materials[i];
            				}
            		}
            		lightCameraPrepare(device, bakeLight) {
            				var light = bakeLight.light;
            				var shadowCam;
            				if (light.type === LIGHTTYPE_SPOT) {
            						var lightRenderData = light.getRenderData(null, 0);
            						shadowCam = lightRenderData.shadowCamera;
            						shadowCam._node.setPosition(light._node.getPosition());
            						shadowCam._node.setRotation(light._node.getRotation());
            						shadowCam._node.rotateLocal(-90, 0, 0);
            						shadowCam.projection = PROJECTION_PERSPECTIVE;
            						shadowCam.nearClip = light.attenuationEnd / 1000;
            						shadowCam.farClip = light.attenuationEnd;
            						shadowCam.aspectRatio = 1;
            						shadowCam.fov = light._outerConeAngle * 2;
            						this.renderer.updateCameraFrustum(shadowCam);
            				}
            				return shadowCam;
            		}
            		lightCameraPrepareAndCull(bakeLight, bakeNode, shadowCam, casterBounds) {
            				var light = bakeLight.light;
            				var lightAffectsNode = true;
            				if (light.type === LIGHTTYPE_DIRECTIONAL) {
            						tempVec$1.copy(casterBounds.center);
            						tempVec$1.y += casterBounds.halfExtents.y;
            						this.camera.node.setPosition(tempVec$1);
            						this.camera.node.setEulerAngles(-90, 0, 0);
            						this.camera.nearClip = 0;
            						this.camera.farClip = casterBounds.halfExtents.y * 2;
            						var frustumSize = Math.max(casterBounds.halfExtents.x, casterBounds.halfExtents.z);
            						this.camera.orthoHeight = frustumSize;
            				} else {
            						if (!bakeLight.lightBounds.intersects(bakeNode.bounds)) {
            								lightAffectsNode = false;
            						}
            				}
            				if (light.type === LIGHTTYPE_SPOT) {
            						var nodeVisible = false;
            						var meshInstances = bakeNode.meshInstances;
            						for(var i = 0; i < meshInstances.length; i++){
            								if (meshInstances[i]._isVisible(shadowCam)) {
            										nodeVisible = true;
            										break;
            								}
            						}
            						if (!nodeVisible) {
            								lightAffectsNode = false;
            						}
            				}
            				return lightAffectsNode;
            		}
            		setupLightArray(lightArray, light) {
            				lightArray[LIGHTTYPE_DIRECTIONAL].length = 0;
            				lightArray[LIGHTTYPE_OMNI].length = 0;
            				lightArray[LIGHTTYPE_SPOT].length = 0;
            				lightArray[light.type][0] = light;
            				light.visibleThisFrame = true;
            		}
            		renderShadowMap(comp, shadowMapRendered, casters, bakeLight) {
            				var light = bakeLight.light;
            				var isClustered = this.scene.clusteredLightingEnabled;
            				var castShadow = light.castShadows && (!isClustered || this.scene.lighting.shadowsEnabled);
            				if (!shadowMapRendered && castShadow) {
            						if (!light.shadowMap && !isClustered) {
            								light.shadowMap = this.shadowMapCache.get(this.device, light);
            						}
            						if (light.type === LIGHTTYPE_DIRECTIONAL) {
            								this.renderer._shadowRendererDirectional.cull(light, comp, this.camera, casters);
            								var shadowPass = this.renderer._shadowRendererDirectional.getLightRenderPass(light, this.camera);
            								shadowPass == null ? void 0 : shadowPass.render();
            						} else {
            								if (this.device.isWebGPU) {
            										return true;
            								}
            								this.renderer._shadowRendererLocal.cull(light, comp, casters);
            								var insideRenderPass = false;
            								this.renderer.shadowRenderer.render(light, this.camera, insideRenderPass);
            						}
            				}
            				return true;
            		}
            		postprocessTextures(device, bakeNodes, passCount) {
            				var numDilates2x = 1;
            				var dilateShader = this.lightmapFilters.getDilate(device, this.bakeHDR);
            				var denoiseShader;
            				var filterLightmap = this.scene.lightmapFilterEnabled;
            				if (filterLightmap) {
            						this.lightmapFilters.prepareDenoise(this.scene.lightmapFilterRange, this.scene.lightmapFilterSmoothness, this.bakeHDR);
            						denoiseShader = this.lightmapFilters.getDenoise(this.bakeHDR);
            				}
            				device.setBlendState(BlendState.NOBLEND);
            				device.setDepthState(DepthState.NODEPTH);
            				device.setStencilState(null, null);
            				for(var node = 0; node < bakeNodes.length; node++){
            						var bakeNode = bakeNodes[node];
            						for(var pass = 0; pass < passCount; pass++){
            								var nodeRT = bakeNode.renderTargets[pass];
            								var lightmap = nodeRT.colorBuffer;
            								var tempRT = this.renderTargets.get(lightmap.width);
            								var tempTex = tempRT.colorBuffer;
            								this.lightmapFilters.prepare(lightmap.width, lightmap.height);
            								for(var i = 0; i < numDilates2x; i++){
            										this.lightmapFilters.setSourceTexture(lightmap);
            										var bilateralFilterEnabled = filterLightmap && pass === 0 && i === 0;
            										drawQuadWithShader(device, tempRT, bilateralFilterEnabled ? denoiseShader : dilateShader);
            										this.lightmapFilters.setSourceTexture(tempTex);
            										drawQuadWithShader(device, nodeRT, dilateShader);
            								}
            						}
            				}
            		}
            		bakeInternal(passCount, bakeNodes, allNodes) {
            				var scene = this.scene;
            				var comp = scene.layers;
            				var device = this.device;
            				var clusteredLightingEnabled = scene.clusteredLightingEnabled;
            				this.createMaterials(device, scene, passCount);
            				this.setupScene();
            				comp._update();
            				this.computeNodesBounds(bakeNodes);
            				this.allocateTextures(bakeNodes, passCount);
            				this.renderer.collectLights(comp);
            				var allLights = [], bakeLights = [];
            				this.prepareLightsToBake(allLights, bakeLights);
            				this.updateTransforms(allNodes);
            				var casters = this.prepareShadowCasters(allNodes);
            				this.renderer.updateCpuSkinMatrices(casters);
            				this.renderer.gpuUpdate(casters);
            				var casterBounds = this.computeBounds(casters);
            				var i, j, rcv, m;
            				for(i = 0; i < bakeNodes.length; i++){
            						var bakeNode = bakeNodes[i];
            						rcv = bakeNode.meshInstances;
            						for(j = 0; j < rcv.length; j++){
            								m = rcv[j];
            								m.setLightmapped(false);
            								m.mask = MASK_BAKE;
            								m.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], this.blackTex);
            								m.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], this.blackTex);
            						}
            				}
            				for(j = 0; j < bakeLights.length; j++){
            						bakeLights[j].light.enabled = false;
            				}
            				var lightArray = [
            						[],
            						[],
            						[]
            				];
            				var pass, node;
            				var shadersUpdatedOn1stPass = false;
            				for(i = 0; i < bakeLights.length; i++){
            						var bakeLight = bakeLights[i];
            						var isAmbientLight = bakeLight instanceof BakeLightAmbient;
            						var isDirectional = bakeLight.light.type === LIGHTTYPE_DIRECTIONAL;
            						var numVirtualLights = bakeLight.numVirtualLights;
            						if (passCount > 1 && numVirtualLights > 1 && bakeLight.light.bakeDir) {
            								numVirtualLights = 1;
            						}
            						for(var virtualLightIndex = 0; virtualLightIndex < numVirtualLights; virtualLightIndex++){
            								if (numVirtualLights > 1) {
            										bakeLight.prepareVirtualLight(virtualLightIndex, numVirtualLights);
            								}
            								bakeLight.startBake();
            								var shadowMapRendered = false;
            								var shadowCam = this.lightCameraPrepare(device, bakeLight);
            								for(node = 0; node < bakeNodes.length; node++){
            										var bakeNode1 = bakeNodes[node];
            										rcv = bakeNode1.meshInstances;
            										var lightAffectsNode = this.lightCameraPrepareAndCull(bakeLight, bakeNode1, shadowCam, casterBounds);
            										if (!lightAffectsNode) {
            												continue;
            										}
            										this.setupLightArray(lightArray, bakeLight.light);
            										var clusterLights = isDirectional ? [] : [
            												bakeLight.light
            										];
            										if (clusteredLightingEnabled) {
            												this.renderer.lightTextureAtlas.update(clusterLights, this.lightingParams);
            										}
            										shadowMapRendered = this.renderShadowMap(comp, shadowMapRendered, casters, bakeLight);
            										if (clusteredLightingEnabled) {
            												this.worldClusters.update(clusterLights, this.lightingParams);
            										}
            										this.backupMaterials(rcv);
            										for(pass = 0; pass < passCount; pass++){
            												if (pass > 0 && virtualLightIndex > 0) {
            														break;
            												}
            												if (isAmbientLight && pass > 0) {
            														break;
            												}
            												var nodeRT = bakeNode1.renderTargets[pass];
            												var lightmapSize = bakeNode1.renderTargets[pass].colorBuffer.width;
            												var tempRT = this.renderTargets.get(lightmapSize);
            												var tempTex = tempRT.colorBuffer;
            												if (pass === 0) {
            														shadersUpdatedOn1stPass = scene.updateShaders;
            												} else if (shadersUpdatedOn1stPass) {
            														scene.updateShaders = true;
            												}
            												var passMaterial = this.passMaterials[pass];
            												if (isAmbientLight) {
            														var lastVirtualLightForPass = virtualLightIndex + 1 === numVirtualLights;
            														if (lastVirtualLightForPass && pass === 0) {
            																passMaterial = this.ambientAOMaterial;
            														}
            												}
            												for(j = 0; j < rcv.length; j++){
            														rcv[j].material = passMaterial;
            												}
            												this.renderer.updateShaders(rcv);
            												if (pass === PASS_DIR) {
            														this.constantBakeDir.setValue(bakeLight.light.bakeDir ? 1 : 0);
            												}
            												if (device.isWebGPU) {
            														var renderPass = new RenderPassLightmapper(device, this.renderer, this.camera, clusteredLightingEnabled ? this.worldClusters : null, rcv, lightArray);
            														renderPass.init(tempRT);
            														renderPass.render();
            														renderPass.destroy();
            												} else {
            														this.renderer.setCamera(this.camera, tempRT, true);
            														if (clusteredLightingEnabled) {
            																this.worldClusters.activate();
            														}
            														this.renderer._forwardTime = 0;
            														this.renderer._shadowMapTime = 0;
            														this.renderer.renderForward(this.camera, tempRT, rcv, lightArray, SHADER_FORWARD);
            														device.updateEnd();
            												}
            												bakeNode1.renderTargets[pass] = tempRT;
            												this.renderTargets.set(lightmapSize, nodeRT);
            												for(j = 0; j < rcv.length; j++){
            														m = rcv[j];
            														m.setRealtimeLightmap(MeshInstance.lightmapParamNames[pass], tempTex);
            														m._shaderDefs |= SHADERDEF_LM;
            												}
            										}
            										this.restoreMaterials(rcv);
            								}
            								bakeLight.endBake(this.shadowMapCache);
            						}
            				}
            				this.postprocessTextures(device, bakeNodes, passCount);
            				for(node = 0; node < allNodes.length; node++){
            						allNodes[node].restore();
            				}
            				this.restoreLights(allLights);
            				this.restoreScene();
            				if (!clusteredLightingEnabled) {
            						this.shadowMapCache.clear();
            				}
            		}
            		constructor(device, root, scene, renderer, assets){
            				this.device = device;
            				this.root = root;
            				this.scene = scene;
            				this.renderer = renderer;
            				this.assets = assets;
            				this.shadowMapCache = renderer.shadowMapCache;
            				this._tempSet = new Set();
            				this._initCalled = false;
            				this.passMaterials = [];
            				this.ambientAOMaterial = null;
            				this.fog = '';
            				this.ambientLight = new Color();
            				this.renderTargets = new Map();
            				this.stats = {
            						renderPasses: 0,
            						lightmapCount: 0,
            						totalRenderTime: 0,
            						forwardTime: 0,
            						fboTime: 0,
            						shadowMapTime: 0,
            						compileTime: 0,
            						shadersLinked: 0
            				};
            		}
            }
            
            class Component extends EventHandler {
            		static _buildAccessors(obj, schema) {
            				schema.forEach((descriptor)=>{
            						var name = typeof descriptor === 'object' ? descriptor.name : descriptor;
            						Object.defineProperty(obj, name, {
            								get: function get() {
            										return this.data[name];
            								},
            								set: function set(value) {
            										var data = this.data;
            										var oldValue = data[name];
            										data[name] = value;
            										this.fire('set', name, oldValue, value);
            								},
            								configurable: true
            						});
            				});
            				obj._accessorsBuilt = true;
            		}
            		buildAccessors(schema) {
            				Component._buildAccessors(this, schema);
            		}
            		onSetEnabled(name, oldValue, newValue) {
            				if (oldValue !== newValue) {
            						if (this.entity.enabled) {
            								if (newValue) {
            										this.onEnable();
            								} else {
            										this.onDisable();
            								}
            						}
            				}
            		}
            		onEnable() {}
            		onDisable() {}
            		onPostStateChange() {}
            		get data() {
            				var record = this.system.store[this.entity.getGuid()];
            				return record ? record.data : null;
            		}
            		set enabled(arg) {}
            		get enabled() {
            				return true;
            		}
            		constructor(system, entity){
            				super();
            				this.system = system;
            				this.entity = entity;
            				if (this.system.schema && !this._accessorsBuilt) {
            						this.buildAccessors(this.system.schema);
            				}
            				this.on('set', function(name, oldValue, newValue) {
            						this.fire("set_" + name, name, oldValue, newValue);
            				});
            				this.on('set_enabled', this.onSetEnabled, this);
            		}
            }
            Component.order = 0;
            
            class ComponentSystem extends EventHandler {
            		addComponent(entity, data) {
            				if (data === void 0) data = {};
            				var component = new this.ComponentType(this, entity);
            				var componentData = new this.DataType();
            				this.store[entity.getGuid()] = {
            						entity: entity,
            						data: componentData
            				};
            				entity[this.id] = component;
            				entity.c[this.id] = component;
            				this.initializeComponentData(component, data, []);
            				this.fire('add', entity, component);
            				return component;
            		}
            		removeComponent(entity) {
            				var id = this.id;
            				var record = this.store[entity.getGuid()];
            				var component = entity.c[id];
            				component.fire('beforeremove');
            				this.fire('beforeremove', entity, component);
            				delete this.store[entity.getGuid()];
            				entity[id] = undefined;
            				delete entity.c[id];
            				this.fire('remove', entity, record.data);
            		}
            		cloneComponent(entity, clone) {
            				var src = this.store[entity.getGuid()];
            				return this.addComponent(clone, src.data);
            		}
            		initializeComponentData(component, data, properties) {
            				if (data === void 0) data = {};
            				for(var i = 0, len = properties.length; i < len; i++){
            						var descriptor = properties[i];
            						var name = void 0, type = void 0;
            						if (typeof descriptor === 'object') {
            								name = descriptor.name;
            								type = descriptor.type;
            						} else {
            								name = descriptor;
            								type = undefined;
            						}
            						var value = data[name];
            						if (value !== undefined) {
            								if (type !== undefined) {
            										value = convertValue(value, type);
            								}
            								component[name] = value;
            						} else {
            								component[name] = component.data[name];
            						}
            				}
            				if (component.enabled && component.entity.enabled) {
            						component.onEnable();
            				}
            		}
            		getPropertiesOfType(type) {
            				var matchingProperties = [];
            				var schema = this.schema || [];
            				schema.forEach((descriptor)=>{
            						if (descriptor && typeof descriptor === 'object' && descriptor.type === type) {
            								matchingProperties.push(descriptor);
            						}
            				});
            				return matchingProperties;
            		}
            		destroy() {
            				this.off();
            		}
            		constructor(app){
            				super();
            				this.app = app;
            				this.store = {};
            				this.schema = [];
            		}
            }
            function convertValue(value, type) {
            		if (!value) {
            				return value;
            		}
            		switch(type){
            				case 'rgb':
            						if (value instanceof Color) {
            								return value.clone();
            						}
            						return new Color(value[0], value[1], value[2]);
            				case 'rgba':
            						if (value instanceof Color) {
            								return value.clone();
            						}
            						return new Color(value[0], value[1], value[2], value[3]);
            				case 'vec2':
            						if (value instanceof Vec2) {
            								return value.clone();
            						}
            						return new Vec2(value[0], value[1]);
            				case 'vec3':
            						if (value instanceof Vec3) {
            								return value.clone();
            						}
            						return new Vec3(value[0], value[1], value[2]);
            				case 'vec4':
            						if (value instanceof Vec4) {
            								return value.clone();
            						}
            						return new Vec4(value[0], value[1], value[2], value[3]);
            				case 'boolean':
            				case 'number':
            				case 'string':
            						return value;
            				case 'entity':
            						return value;
            				default:
            						throw new Error("Could not convert unhandled type: " + type);
            		}
            }
            
            var INTERPOLATION_STEP = 0;
            var INTERPOLATION_LINEAR = 1;
            var INTERPOLATION_CUBIC = 2;
            
            class AnimCache {
            		update(time, input) {
            				if (time < this._left || time >= this._right) {
            						var len = input.length;
            						if (!len) {
            								this._left = -Infinity;
            								this._right = Infinity;
            								this._len = 0;
            								this._recip = 0;
            								this._p0 = this._p1 = 0;
            						} else {
            								if (time < input[0]) {
            										this._left = -Infinity;
            										this._right = input[0];
            										this._len = 0;
            										this._recip = 0;
            										this._p0 = this._p1 = 0;
            								} else if (time >= input[len - 1]) {
            										this._left = input[len - 1];
            										this._right = Infinity;
            										this._len = 0;
            										this._recip = 0;
            										this._p0 = this._p1 = len - 1;
            								} else {
            										var index = this._findKey(time, input);
            										this._left = input[index];
            										this._right = input[index + 1];
            										this._len = this._right - this._left;
            										var diff = 1.0 / this._len;
            										this._recip = isFinite(diff) ? diff : 0;
            										this._p0 = index;
            										this._p1 = index + 1;
            								}
            						}
            				}
            				this._t = this._recip === 0 ? 0 : (time - this._left) * this._recip;
            				this._hermite.valid = false;
            		}
            		_findKey(time, input) {
            				var index = 0;
            				while(time >= input[index + 1]){
            						index++;
            				}
            				return index;
            		}
            		eval(result, interpolation, output) {
            				var data = output._data;
            				var comp = output._components;
            				var idx0 = this._p0 * comp;
            				if (interpolation === INTERPOLATION_STEP) {
            						for(var i = 0; i < comp; ++i){
            								result[i] = data[idx0 + i];
            						}
            				} else {
            						var t = this._t;
            						var idx1 = this._p1 * comp;
            						switch(interpolation){
            								case INTERPOLATION_LINEAR:
            										for(var i1 = 0; i1 < comp; ++i1){
            												result[i1] = math.lerp(data[idx0 + i1], data[idx1 + i1], t);
            										}
            										break;
            								case INTERPOLATION_CUBIC:
            										{
            												var hermite = this._hermite;
            												if (!hermite.valid) {
            														var t2 = t * t;
            														var twot = t + t;
            														var omt = 1 - t;
            														var omt2 = omt * omt;
            														hermite.valid = true;
            														hermite.p0 = (1 + twot) * omt2;
            														hermite.m0 = t * omt2;
            														hermite.p1 = t2 * (3 - twot);
            														hermite.m1 = t2 * (t - 1);
            												}
            												var p0 = (this._p0 * 3 + 1) * comp;
            												var m0 = (this._p0 * 3 + 2) * comp;
            												var p1 = (this._p1 * 3 + 1) * comp;
            												var m1 = (this._p1 * 3 + 0) * comp;
            												for(var i2 = 0; i2 < comp; ++i2){
            														result[i2] = hermite.p0 * data[p0 + i2] + hermite.m0 * data[m0 + i2] * this._len + hermite.p1 * data[p1 + i2] + hermite.m1 * data[m1 + i2] * this._len;
            												}
            												break;
            										}
            						}
            				}
            		}
            		constructor(){
            				this._left = Infinity;
            				this._right = -Infinity;
            				this._len = 0;
            				this._recip = 0;
            				this._p0 = 0;
            				this._p1 = 0;
            				this._t = 0;
            				this._hermite = {
            						valid: false,
            						p0: 0,
            						m0: 0,
            						p1: 0,
            						m1: 0
            				};
            		}
            }
            
            class AnimSnapshot {
            		constructor(animTrack){
            				this._name = "" + animTrack.name + "Snapshot";
            				this._time = -1;
            				this._cache = [];
            				this._results = [];
            				for(var i = 0; i < animTrack._inputs.length; ++i){
            						this._cache[i] = new AnimCache();
            				}
            				var curves = animTrack._curves;
            				var outputs = animTrack._outputs;
            				for(var i1 = 0; i1 < curves.length; ++i1){
            						var curve = curves[i1];
            						var output = outputs[curve._output];
            						var storage = [];
            						for(var j = 0; j < output._components; ++j){
            								storage[j] = 0;
            						}
            						this._results[i1] = storage;
            				}
            		}
            }
            
            function _extends$b() {
            		_extends$b = Object.assign || function(target) {
            				for(var i = 1; i < arguments.length; i++){
            						var source = arguments[i];
            						for(var key in source){
            								if (Object.prototype.hasOwnProperty.call(source, key)) {
            										target[key] = source[key];
            								}
            						}
            				}
            				return target;
            		};
            		return _extends$b.apply(this, arguments);
            }
            class AnimClip {
            		set name(name) {
            				this._name = name;
            		}
            		get name() {
            				return this._name;
            		}
            		set track(track) {
            				this._track = track;
            				this._snapshot = new AnimSnapshot(track);
            		}
            		get track() {
            				return this._track;
            		}
            		get snapshot() {
            				return this._snapshot;
            		}
            		set time(time) {
            				this._time = time;
            				this.alignCursorToCurrentTime();
            		}
            		get time() {
            				return this._time;
            		}
            		set speed(speed) {
            				var signChanged = Math.sign(speed) !== Math.sign(this._speed);
            				this._speed = speed;
            				if (signChanged) {
            						this.alignCursorToCurrentTime();
            				}
            		}
            		get speed() {
            				return this._speed;
            		}
            		set loop(loop) {
            				this._loop = loop;
            		}
            		get loop() {
            				return this._loop;
            		}
            		set blendWeight(blendWeight) {
            				this._blendWeight = blendWeight;
            		}
            		get blendWeight() {
            				return this._blendWeight;
            		}
            		set blendOrder(blendOrder) {
            				this._blendOrder = blendOrder;
            		}
            		get blendOrder() {
            				return this._blendOrder;
            		}
            		set eventCursor(value) {
            				this._eventCursor = value;
            		}
            		get eventCursor() {
            				return this._eventCursor;
            		}
            		get eventCursorEnd() {
            				return this.isReverse ? 0 : this._track.events.length - 1;
            		}
            		get nextEvent() {
            				return this._track.events[this._eventCursor];
            		}
            		get isReverse() {
            				return this._speed < 0;
            		}
            		nextEventAheadOfTime(time) {
            				if (!this.nextEvent) return false;
            				return this.isReverse ? this.nextEvent.time <= time : this.nextEvent.time >= time;
            		}
            		nextEventBehindTime(time) {
            				if (!this.nextEvent) return false;
            				if (time === this.track.duration) {
            						return this.isReverse ? this.nextEvent.time >= time : this.nextEvent.time <= time;
            				}
            				return this.isReverse ? this.nextEvent.time > time : this.nextEvent.time < time;
            		}
            		resetEventCursor() {
            				this._eventCursor = this.isReverse ? this._track.events.length - 1 : 0;
            		}
            		moveEventCursor() {
            				this._eventCursor += this.isReverse ? -1 : 1;
            				if (this._eventCursor >= this.track.events.length) {
            						this._eventCursor = 0;
            				} else if (this._eventCursor < 0) {
            						this._eventCursor = this.track.events.length - 1;
            				}
            		}
            		clipFrameTime(frameEndTime) {
            				var eventFrame = AnimClip.eventFrame;
            				eventFrame.start = 0;
            				eventFrame.end = frameEndTime;
            				eventFrame.residual = 0;
            				if (this.isReverse) {
            						if (frameEndTime < 0) {
            								eventFrame.start = this.track.duration;
            								eventFrame.end = 0;
            								eventFrame.residual = frameEndTime + this.track.duration;
            						}
            				} else {
            						if (frameEndTime > this.track.duration) {
            								eventFrame.start = 0;
            								eventFrame.end = this.track.duration;
            								eventFrame.residual = frameEndTime - this.track.duration;
            						}
            				}
            		}
            		alignCursorToCurrentTime() {
            				this.resetEventCursor();
            				while(this.nextEventBehindTime(this._time) && this._eventCursor !== this.eventCursorEnd){
            						this.moveEventCursor();
            				}
            		}
            		fireNextEvent() {
            				this._eventHandler.fire(this.nextEvent.name, _extends$b({
            						track: this.track
            				}, this.nextEvent));
            				this.moveEventCursor();
            		}
            		fireNextEventInFrame(frameStartTime, frameEndTime) {
            				if (this.nextEventAheadOfTime(frameStartTime) && this.nextEventBehindTime(frameEndTime)) {
            						this.fireNextEvent();
            						return true;
            				}
            				return false;
            		}
            		activeEventsForFrame(frameStartTime, frameEndTime) {
            				var eventFrame = AnimClip.eventFrame;
            				this.clipFrameTime(frameEndTime);
            				var initialCursor = this.eventCursor;
            				while(this.fireNextEventInFrame(frameStartTime, eventFrame.end)){
            						if (initialCursor === this.eventCursor) {
            								break;
            						}
            				}
            				if (this.loop && Math.abs(eventFrame.residual) > 0) {
            						this.activeEventsForFrame(eventFrame.start, eventFrame.residual);
            				}
            		}
            		progressForTime(time) {
            				return time * this._speed / this._track.duration;
            		}
            		_update(deltaTime) {
            				if (this._playing) {
            						var time = this._time;
            						var duration = this._track.duration;
            						var speed = this._speed;
            						var loop = this._loop;
            						if (this._track.events.length > 0 && duration > 0) {
            								this.activeEventsForFrame(time, time + speed * deltaTime);
            						}
            						time += speed * deltaTime;
            						if (speed >= 0) {
            								if (time > duration) {
            										if (loop) {
            												time = time % duration || 0;
            										} else {
            												time = this._track.duration;
            												this.pause();
            										}
            								}
            						} else {
            								if (time < 0) {
            										if (loop) {
            												time = duration + (time % duration || 0);
            										} else {
            												time = 0;
            												this.pause();
            										}
            								}
            						}
            						this._time = time;
            				}
            				if (this._time !== this._snapshot._time) {
            						this._track.eval(this._time, this._snapshot);
            				}
            		}
            		play() {
            				this._playing = true;
            				this._time = 0;
            		}
            		stop() {
            				this._playing = false;
            				this._time = 0;
            		}
            		pause() {
            				this._playing = false;
            		}
            		resume() {
            				this._playing = true;
            		}
            		reset() {
            				this._time = 0;
            		}
            		constructor(track, time, speed, playing, loop, eventHandler){
            				this._name = track.name;
            				this._track = track;
            				this._snapshot = new AnimSnapshot(track);
            				this._playing = playing;
            				this._time = time;
            				this._speed = speed;
            				this._loop = loop;
            				this._blendWeight = 1.0;
            				this._blendOrder = 0.0;
            				this._eventHandler = eventHandler;
            				this.alignCursorToCurrentTime();
            		}
            }
            AnimClip.eventFrame = {
            		start: 0,
            		end: 0,
            		residual: 0
            };
            
            var ANIM_INTERRUPTION_NONE = 'NONE';
            var ANIM_INTERRUPTION_PREV = 'PREV_STATE';
            var ANIM_INTERRUPTION_NEXT = 'NEXT_STATE';
            var ANIM_INTERRUPTION_PREV_NEXT = 'PREV_STATE_NEXT_STATE';
            var ANIM_INTERRUPTION_NEXT_PREV = 'NEXT_STATE_PREV_STATE';
            var ANIM_GREATER_THAN = 'GREATER_THAN';
            var ANIM_LESS_THAN = 'LESS_THAN';
            var ANIM_GREATER_THAN_EQUAL_TO = 'GREATER_THAN_EQUAL_TO';
            var ANIM_LESS_THAN_EQUAL_TO = 'LESS_THAN_EQUAL_TO';
            var ANIM_EQUAL_TO = 'EQUAL_TO';
            var ANIM_NOT_EQUAL_TO = 'NOT_EQUAL_TO';
            var ANIM_PARAMETER_INTEGER = 'INTEGER';
            var ANIM_PARAMETER_FLOAT = 'FLOAT';
            var ANIM_PARAMETER_BOOLEAN = 'BOOLEAN';
            var ANIM_PARAMETER_TRIGGER = 'TRIGGER';
            var ANIM_BLEND_1D = '1D';
            var ANIM_BLEND_2D_DIRECTIONAL = '2D_DIRECTIONAL';
            var ANIM_BLEND_2D_CARTESIAN = '2D_CARTESIAN';
            var ANIM_BLEND_DIRECT = 'DIRECT';
            var ANIM_STATE_START = 'START';
            var ANIM_STATE_END = 'END';
            var ANIM_STATE_ANY = 'ANY';
            var ANIM_CONTROL_STATES = [
            		ANIM_STATE_START,
            		ANIM_STATE_END,
            		ANIM_STATE_ANY
            ];
            var ANIM_LAYER_OVERWRITE = 'OVERWRITE';
            var ANIM_LAYER_ADDITIVE = 'ADDITIVE';
            
            class AnimBlend {
            		static dot(a, b) {
            				var len = a.length;
            				var result = 0;
            				for(var i = 0; i < len; ++i){
            						result += a[i] * b[i];
            				}
            				return result;
            		}
            		static normalize(a) {
            				var l = AnimBlend.dot(a, a);
            				if (l > 0) {
            						l = 1.0 / Math.sqrt(l);
            						var len = a.length;
            						for(var i = 0; i < len; ++i){
            								a[i] *= l;
            						}
            				}
            		}
            		static set(a, b, type) {
            				var len = a.length;
            				if (type === 'quaternion') {
            						var l = AnimBlend.dot(b, b);
            						if (l > 0) {
            								l = 1.0 / Math.sqrt(l);
            						}
            						for(var i = 0; i < len; ++i){
            								a[i] = b[i] * l;
            						}
            				} else {
            						for(var i1 = 0; i1 < len; ++i1){
            								a[i1] = b[i1];
            						}
            				}
            		}
            		static blendVec(a, b, t, additive) {
            				var it = additive ? 1.0 : 1.0 - t;
            				var len = a.length;
            				for(var i = 0; i < len; ++i){
            						a[i] = a[i] * it + b[i] * t;
            				}
            		}
            		static blendQuat(a, b, t, additive) {
            				var len = a.length;
            				var it = additive ? 1.0 : 1.0 - t;
            				if (AnimBlend.dot(a, b) < 0) {
            						t = -t;
            				}
            				for(var i = 0; i < len; ++i){
            						a[i] = a[i] * it + b[i] * t;
            				}
            				if (!additive) {
            						AnimBlend.normalize(a);
            				}
            		}
            		static blend(a, b, t, type, additive) {
            				if (type === 'quaternion') {
            						AnimBlend.blendQuat(a, b, t, additive);
            				} else {
            						AnimBlend.blendVec(a, b, t, additive);
            				}
            		}
            		static stableSort(a, lessFunc) {
            				var len = a.length;
            				for(var i = 0; i < len - 1; ++i){
            						for(var j = i + 1; j < len; ++j){
            								if (lessFunc(a[j], a[i])) {
            										var tmp = a[i];
            										a[i] = a[j];
            										a[j] = tmp;
            								}
            						}
            				}
            		}
            }
            
            class AnimTargetValue {
            		get _normalizeWeights() {
            				return this._component.normalizeWeights;
            		}
            		getWeight(index) {
            				if (this.dirty) this.updateWeights();
            				if (this._normalizeWeights && this.totalWeight === 0 || !this.mask[index]) {
            						return 0;
            				} else if (this._normalizeWeights) {
            						return this.weights[index] / this.totalWeight;
            				}
            				return math.clamp(this.weights[index], 0, 1);
            		}
            		_layerBlendType(index) {
            				return this._component.layers[index].blendType;
            		}
            		setMask(index, value) {
            				this.mask[index] = value;
            				if (this._normalizeWeights) {
            						if (this._component.layers[index].blendType === ANIM_LAYER_OVERWRITE) {
            								this.mask = this.mask.fill(0, 0, index);
            						}
            						this.dirty = true;
            				}
            		}
            		updateWeights() {
            				this.totalWeight = 0;
            				for(var i = 0; i < this.weights.length; i++){
            						this.weights[i] = this._component.layers[i].weight;
            						this.totalWeight += this.mask[i] * this.weights[i];
            				}
            				this.dirty = false;
            		}
            		updateValue(index, value) {
            				if (this.counter === 0) {
            						AnimBlend.set(this.value, AnimTargetValue.IDENTITY_QUAT_ARR, this.valueType);
            						if (!this._normalizeWeights) {
            								AnimBlend.blend(this.value, this.baseValue, 1, this.valueType);
            						}
            				}
            				if (!this.mask[index] || this.getWeight(index) === 0) return;
            				if (this._layerBlendType(index) === ANIM_LAYER_ADDITIVE && !this._normalizeWeights) {
            						if (this.valueType === AnimTargetValue.TYPE_QUAT) {
            								var v = AnimTargetValue.q1.set(this.value[0], this.value[1], this.value[2], this.value[3]);
            								var aV1 = AnimTargetValue.q2.set(this.baseValue[0], this.baseValue[1], this.baseValue[2], this.baseValue[3]);
            								var aV2 = AnimTargetValue.q3.set(value[0], value[1], value[2], value[3]);
            								var aV = aV1.invert().mul(aV2);
            								aV.slerp(Quat.IDENTITY, aV, this.getWeight(index));
            								v.mul(aV);
            								AnimTargetValue.quatArr[0] = v.x;
            								AnimTargetValue.quatArr[1] = v.y;
            								AnimTargetValue.quatArr[2] = v.z;
            								AnimTargetValue.quatArr[3] = v.w;
            								AnimBlend.set(this.value, AnimTargetValue.quatArr, this.valueType);
            						} else {
            								AnimTargetValue.vecArr[0] = value[0] - this.baseValue[0];
            								AnimTargetValue.vecArr[1] = value[1] - this.baseValue[1];
            								AnimTargetValue.vecArr[2] = value[2] - this.baseValue[2];
            								AnimBlend.blend(this.value, AnimTargetValue.vecArr, this.getWeight(index), this.valueType, true);
            						}
            				} else {
            						AnimBlend.blend(this.value, value, this.getWeight(index), this.valueType);
            				}
            				if (this.setter) this.setter(this.value);
            		}
            		unbind() {
            				if (this.setter) {
            						this.setter(this.baseValue);
            				}
            		}
            		constructor(component, type){
            				this._component = component;
            				this.mask = new Int8Array(component.layers.length);
            				this.weights = new Float32Array(component.layers.length);
            				this.totalWeight = 0;
            				this.counter = 0;
            				this.layerCounter = 0;
            				this.valueType = type;
            				this.dirty = true;
            				this.value = type === AnimTargetValue.TYPE_QUAT ? [
            						0,
            						0,
            						0,
            						1
            				] : [
            						0,
            						0,
            						0
            				];
            				this.baseValue = null;
            				this.setter = null;
            		}
            }
            AnimTargetValue.TYPE_QUAT = 'quaternion';
            AnimTargetValue.TYPE_VEC3 = 'vector3';
            AnimTargetValue.q1 = new Quat();
            AnimTargetValue.q2 = new Quat();
            AnimTargetValue.q3 = new Quat();
            AnimTargetValue.quatArr = [
            		0,
            		0,
            		0,
            		1
            ];
            AnimTargetValue.vecArr = [
            		0,
            		0,
            		0
            ];
            AnimTargetValue.IDENTITY_QUAT_ARR = [
            		0,
            		0,
            		0,
            		1
            ];
            
            class AnimEvaluator {
            		get clips() {
            				return this._clips;
            		}
            		addClip(clip) {
            				var targets = this._targets;
            				var binder = this._binder;
            				var curves = clip.track.curves;
            				var snapshot = clip.snapshot;
            				var inputs = [];
            				var outputs = [];
            				for(var i = 0; i < curves.length; ++i){
            						var curve = curves[i];
            						var paths = curve.paths;
            						for(var j = 0; j < paths.length; ++j){
            								var path = paths[j];
            								var resolved = binder.resolve(path);
            								var target = targets[resolved && resolved.targetPath || null];
            								if (!target && resolved) {
            										target = {
            												target: resolved,
            												value: [],
            												curves: 0,
            												blendCounter: 0
            										};
            										for(var k = 0; k < target.target.components; ++k){
            												target.value.push(0);
            										}
            										targets[resolved.targetPath] = target;
            										if (binder.animComponent) {
            												if (!binder.animComponent.targets[resolved.targetPath]) {
            														var type = void 0;
            														if (resolved.targetPath.substring(resolved.targetPath.length - 13) === 'localRotation') {
            																type = AnimTargetValue.TYPE_QUAT;
            														} else {
            																type = AnimTargetValue.TYPE_VEC3;
            														}
            														binder.animComponent.targets[resolved.targetPath] = new AnimTargetValue(binder.animComponent, type);
            												}
            												binder.animComponent.targets[resolved.targetPath].layerCounter++;
            												binder.animComponent.targets[resolved.targetPath].setMask(binder.layerIndex, 1);
            										}
            								}
            								if (target) {
            										target.curves++;
            										inputs.push(snapshot._results[i]);
            										outputs.push(target);
            								}
            						}
            				}
            				this._clips.push(clip);
            				this._inputs.push(inputs);
            				this._outputs.push(outputs);
            		}
            		removeClip(index) {
            				var targets = this._targets;
            				var binder = this._binder;
            				var clips = this._clips;
            				var clip = clips[index];
            				var curves = clip.track.curves;
            				for(var i = 0; i < curves.length; ++i){
            						var curve = curves[i];
            						var paths = curve.paths;
            						for(var j = 0; j < paths.length; ++j){
            								var path = paths[j];
            								var target = this._binder.resolve(path);
            								if (target) {
            										target.curves--;
            										if (target.curves === 0) {
            												binder.unresolve(path);
            												delete targets[target.targetPath];
            												if (binder.animComponent) {
            														binder.animComponent.targets[target.targetPath].layerCounter--;
            												}
            										}
            								}
            						}
            				}
            				clips.splice(index, 1);
            				this._inputs.splice(index, 1);
            				this._outputs.splice(index, 1);
            		}
            		removeClips() {
            				while(this._clips.length > 0){
            						this.removeClip(0);
            				}
            		}
            		updateClipTrack(name, animTrack) {
            				this._clips.forEach((clip)=>{
            						if (clip.name.includes(name)) {
            								clip.track = animTrack;
            						}
            				});
            				this.rebind();
            		}
            		findClip(name) {
            				var clips = this._clips;
            				for(var i = 0; i < clips.length; ++i){
            						var clip = clips[i];
            						if (clip.name === name) {
            								return clip;
            						}
            				}
            				return null;
            		}
            		rebind() {
            				this._binder.rebind();
            				this._targets = {};
            				var clips = [
            						...this.clips
            				];
            				this.removeClips();
            				clips.forEach((clip)=>{
            						this.addClip(clip);
            				});
            		}
            		assignMask(mask) {
            				return this._binder.assignMask(mask);
            		}
            		update(deltaTime, outputAnimation) {
            				if (outputAnimation === void 0) outputAnimation = true;
            				var clips = this._clips;
            				var order = clips.map((c, i)=>{
            						return i;
            				});
            				AnimBlend.stableSort(order, (a, b)=>{
            						return clips[a].blendOrder < clips[b].blendOrder;
            				});
            				for(var i = 0; i < order.length; ++i){
            						var index = order[i];
            						var clip = clips[index];
            						var inputs = this._inputs[index];
            						var outputs = this._outputs[index];
            						var blendWeight = clip.blendWeight;
            						if (blendWeight > 0.0) {
            								clip._update(deltaTime);
            						}
            						if (!outputAnimation) break;
            						var input = void 0;
            						var output = void 0;
            						var value = void 0;
            						if (blendWeight >= 1.0) {
            								for(var j = 0; j < inputs.length; ++j){
            										input = inputs[j];
            										output = outputs[j];
            										value = output.value;
            										AnimBlend.set(value, input, output.target.type);
            										output.blendCounter++;
            								}
            						} else if (blendWeight > 0.0) {
            								for(var j1 = 0; j1 < inputs.length; ++j1){
            										input = inputs[j1];
            										output = outputs[j1];
            										value = output.value;
            										if (output.blendCounter === 0) {
            												AnimBlend.set(value, input, output.target.type);
            										} else {
            												AnimBlend.blend(value, input, blendWeight, output.target.type);
            										}
            										output.blendCounter++;
            								}
            						}
            				}
            				var targets = this._targets;
            				var binder = this._binder;
            				for(var path in targets){
            						if (targets.hasOwnProperty(path)) {
            								var target = targets[path];
            								if (binder.animComponent && target.target.isTransform) {
            										var animTarget = binder.animComponent.targets[path];
            										if (animTarget.counter === animTarget.layerCounter) {
            												animTarget.counter = 0;
            										}
            										if (!animTarget.path) {
            												animTarget.path = path;
            												animTarget.baseValue = target.target.get();
            												animTarget.setter = target.target.set;
            										}
            										animTarget.updateValue(binder.layerIndex, target.value);
            										animTarget.counter++;
            								} else {
            										target.target.set(target.value);
            								}
            								target.blendCounter = 0;
            						}
            				}
            				this._binder.update(deltaTime);
            		}
            		constructor(binder){
            				this._binder = binder;
            				this._clips = [];
            				this._inputs = [];
            				this._outputs = [];
            				this._targets = {};
            		}
            }
            
            class AnimEvents {
            		get events() {
            				return this._events;
            		}
            		constructor(events){
            				this._events = [
            						...events
            				];
            				this._events.sort((a, b)=>a.time - b.time);
            		}
            }
            
            class AnimTrack {
            		get name() {
            				return this._name;
            		}
            		get duration() {
            				return this._duration;
            		}
            		get inputs() {
            				return this._inputs;
            		}
            		get outputs() {
            				return this._outputs;
            		}
            		get curves() {
            				return this._curves;
            		}
            		set events(animEvents) {
            				this._animEvents = animEvents;
            		}
            		get events() {
            				return this._animEvents.events;
            		}
            		eval(time, snapshot) {
            				snapshot._time = time;
            				var inputs = this._inputs;
            				var outputs = this._outputs;
            				var curves = this._curves;
            				var cache = snapshot._cache;
            				var results = snapshot._results;
            				for(var i = 0; i < inputs.length; ++i){
            						cache[i].update(time, inputs[i]._data);
            				}
            				for(var i1 = 0; i1 < curves.length; ++i1){
            						var curve = curves[i1];
            						var output = outputs[curve._output];
            						var result = results[i1];
            						cache[curve._input].eval(result, curve._interpolation, output);
            				}
            		}
            		constructor(name, duration, inputs, outputs, curves, animEvents = new AnimEvents([])){
            				this._name = name;
            				this._duration = duration;
            				this._inputs = inputs;
            				this._outputs = outputs;
            				this._curves = curves;
            				this._animEvents = animEvents;
            		}
            }
            AnimTrack.EMPTY = Object.freeze(new AnimTrack('empty', Number.MAX_VALUE, [], [], []));
            
            class AnimBinder {
            		static joinPath(pathSegments, character) {
            				character = character || '.';
            				var escape = function escape(string) {
            						return string.replace(/\\/g, '\\\\').replace(new RegExp("\\" + character, 'g'), "\\" + character);
            				};
            				return pathSegments.map(escape).join(character);
            		}
            		static splitPath(path, character) {
            				character = character || '.';
            				var result = [];
            				var curr = '';
            				var i = 0;
            				while(i < path.length){
            						var c = path[i++];
            						if (c === '\\' && i < path.length) {
            								c = path[i++];
            								if (c === '\\' || c === character) {
            										curr += c;
            								} else {
            										curr += "\\" + c;
            								}
            						} else if (c === character) {
            								result.push(curr);
            								curr = '';
            						} else {
            								curr += c;
            						}
            				}
            				if (curr.length > 0) {
            						result.push(curr);
            				}
            				return result;
            		}
            		static encode(entityPath, component, propertyPath) {
            				return (Array.isArray(entityPath) ? entityPath.join('/') : entityPath) + "/" + component + "/" + (Array.isArray(propertyPath) ? propertyPath.join('/') : propertyPath);
            		}
            		resolve(path) {
            				return null;
            		}
            		unresolve(path) {}
            		update(deltaTime) {}
            }
            
            class AnimTarget {
            		get set() {
            				return this._set;
            		}
            		get get() {
            				return this._get;
            		}
            		get type() {
            				return this._type;
            		}
            		get components() {
            				return this._components;
            		}
            		get targetPath() {
            				return this._targetPath;
            		}
            		get isTransform() {
            				return this._isTransform;
            		}
            		constructor(func, type, components, targetPath){
            				if (func.set) {
            						this._set = func.set;
            						this._get = func.get;
            				} else {
            						this._set = func;
            				}
            				this._type = type;
            				this._components = components;
            				this._targetPath = targetPath;
            				this._isTransform = this._targetPath.substring(this._targetPath.length - 13) === 'localRotation' || this._targetPath.substring(this._targetPath.length - 13) === 'localPosition' || this._targetPath.substring(this._targetPath.length - 10) === 'localScale';
            		}
            }
            
            class DefaultAnimBinder {
            		_isPathActive(path) {
            				if (!this._mask) return true;
            				var rootNodeNames = [
            						path.entityPath[0],
            						this.graph.name
            				];
            				for(var j = 0; j < rootNodeNames.length; ++j){
            						var currEntityPath = rootNodeNames[j];
            						if (this._isPathInMask(currEntityPath, path.entityPath.length === 1)) return true;
            						for(var i = 1; i < path.entityPath.length; i++){
            								currEntityPath += "/" + path.entityPath[i];
            								if (this._isPathInMask(currEntityPath, i === path.entityPath.length - 1)) return true;
            						}
            				}
            				return false;
            		}
            		findNode(path) {
            				if (!this._isPathActive(path)) {
            						return null;
            				}
            				var node;
            				if (this.graph) {
            						node = this.graph.findByPath(path.entityPath);
            						if (!node) {
            								node = this.graph.findByPath(path.entityPath.slice(1));
            						}
            				}
            				if (!node) {
            						node = this.nodes[path.entityPath[path.entityPath.length - 1] || ''];
            				}
            				return node;
            		}
            		static createAnimTarget(func, type, valueCount, node, propertyPath, componentType) {
            				var targetPath = AnimBinder.encode(node.path, componentType ? componentType : 'entity', propertyPath);
            				return new AnimTarget(func, type, valueCount, targetPath);
            		}
            		resolve(path) {
            				var encodedPath = AnimBinder.encode(path.entityPath, path.component, path.propertyPath);
            				var target = this.targetCache[encodedPath];
            				if (target) return target;
            				var node = this.findNode(path);
            				if (!node) {
            						return null;
            				}
            				var handler = this.handlers[path.propertyPath];
            				if (!handler) {
            						return null;
            				}
            				target = handler(node);
            				if (!target) {
            						return null;
            				}
            				this.targetCache[encodedPath] = target;
            				if (!this.nodeCounts[node.path]) {
            						this.activeNodes.push(node);
            						this.nodeCounts[node.path] = 1;
            				} else {
            						this.nodeCounts[node.path]++;
            				}
            				return target;
            		}
            		unresolve(path) {
            				if (path.component !== 'graph') {
            						return;
            				}
            				var node = this.nodes[path.entityPath[path.entityPath.length - 1] || ''];
            				this.nodeCounts[node.path]--;
            				if (this.nodeCounts[node.path] === 0) {
            						var activeNodes = this.activeNodes;
            						var i = activeNodes.indexOf(node.node);
            						var len = activeNodes.length;
            						if (i < len - 1) {
            								activeNodes[i] = activeNodes[len - 1];
            						}
            						activeNodes.pop();
            				}
            		}
            		update(deltaTime) {
            				var activeNodes = this.activeNodes;
            				for(var i = 0; i < activeNodes.length; ++i){
            						activeNodes[i]._dirtifyLocal();
            				}
            		}
            		assignMask(mask) {
            				if (mask !== this._mask) {
            						this._mask = mask;
            						return true;
            				}
            				return false;
            		}
            		constructor(graph){
            				this._isPathInMask = (path, checkMaskValue)=>{
            						var maskItem = this._mask[path];
            						if (!maskItem) return false;
            						else if (maskItem.children || checkMaskValue && maskItem.value !== false) return true;
            						return false;
            				};
            				this.graph = graph;
            				if (!graph) return;
            				this._mask = null;
            				var nodes = {};
            				var flatten = function flatten1(node) {
            						nodes[node.name] = node;
            						for(var i = 0; i < node.children.length; ++i){
            								flatten(node.children[i]);
            						}
            				};
            				flatten(graph);
            				this.nodes = nodes;
            				this.targetCache = {};
            				var findMeshInstances = function findMeshInstances(node) {
            						var object = node;
            						while(object && !(object instanceof Entity)){
            								object = object.parent;
            						}
            						var meshInstances;
            						if (object) {
            								if (object.render) {
            										meshInstances = object.render.meshInstances;
            								} else if (object.model) {
            										meshInstances = object.model.meshInstances;
            								}
            						}
            						return meshInstances;
            				};
            				this.nodeCounts = {};
            				this.activeNodes = [];
            				this.handlers = {
            						'localPosition': function(node) {
            								var object = node.localPosition;
            								var func = function func(value) {
            										object.set(...value);
            								};
            								return DefaultAnimBinder.createAnimTarget(func, 'vector', 3, node, 'localPosition');
            						},
            						'localRotation': function(node) {
            								var object = node.localRotation;
            								var func = function func(value) {
            										object.set(...value);
            								};
            								return DefaultAnimBinder.createAnimTarget(func, 'quaternion', 4, node, 'localRotation');
            						},
            						'localScale': function(node) {
            								var object = node.localScale;
            								var func = function func(value) {
            										object.set(...value);
            								};
            								return DefaultAnimBinder.createAnimTarget(func, 'vector', 3, node, 'localScale');
            						},
            						'weight': function(node, weightName) {
            								if (weightName.indexOf('name.') === 0) {
            										weightName = weightName.replace('name.', '');
            								} else {
            										weightName = Number(weightName);
            								}
            								var meshInstances = findMeshInstances(node);
            								var setters;
            								if (meshInstances) {
            										var _loop = function(i) {
            												if (meshInstances[i].node.name === node.name && meshInstances[i].morphInstance) {
            														var morphInstance = meshInstances[i].morphInstance;
            														var func = (value)=>{
            																morphInstance.setWeight(weightName, value[0]);
            														};
            														if (!setters) setters = [];
            														setters.push(func);
            												}
            										};
            										for(var i = 0; i < meshInstances.length; ++i)_loop(i);
            								}
            								if (setters) {
            										var callSetters = (value)=>{
            												for(var i = 0; i < setters.length; ++i){
            														setters[i](value);
            												}
            										};
            										return DefaultAnimBinder.createAnimTarget(callSetters, 'number', 1, node, "weight." + weightName);
            								}
            								return null;
            						},
            						'materialTexture': (node, textureName)=>{
            								var meshInstances = findMeshInstances(node);
            								if (meshInstances) {
            										var meshInstance;
            										for(var i = 0; i < meshInstances.length; ++i){
            												if (meshInstances[i].node.name === node.name) {
            														meshInstance = meshInstances[i];
            														break;
            												}
            										}
            										if (meshInstance) {
            												var func = (value)=>{
            														var textureAsset = this.animComponent.system.app.assets.get(value[0]);
            														if (textureAsset && textureAsset.resource && textureAsset.type === 'texture') {
            																meshInstance.material[textureName] = textureAsset.resource;
            																meshInstance.material.update();
            														}
            												};
            												return DefaultAnimBinder.createAnimTarget(func, 'vector', 1, node, 'materialTexture', 'material');
            										}
            								}
            								return null;
            						}
            				};
            		}
            }
            
            class AnimationComponent extends Component {
            		set animations(value) {
            				this._animations = value;
            				this.onSetAnimations();
            		}
            		get animations() {
            				return this._animations;
            		}
            		set assets(value) {
            				var assets = this._assets;
            				if (assets && assets.length) {
            						for(var i = 0; i < assets.length; i++){
            								if (assets[i]) {
            										var asset = this.system.app.assets.get(assets[i]);
            										if (asset) {
            												asset.off('change', this.onAssetChanged, this);
            												asset.off('remove', this.onAssetRemoved, this);
            												var animName = this.animationsIndex[asset.id];
            												if (this.currAnim === animName) {
            														this._stopCurrentAnimation();
            												}
            												delete this.animations[animName];
            												delete this.animationsIndex[asset.id];
            										}
            								}
            						}
            				}
            				this._assets = value;
            				var assetIds = value.map((value)=>{
            						return value instanceof Asset ? value.id : value;
            				});
            				this.loadAnimationAssets(assetIds);
            		}
            		get assets() {
            				return this._assets;
            		}
            		set currentTime(currentTime) {
            				if (this.skeleton) {
            						this.skeleton.currentTime = currentTime;
            						this.skeleton.addTime(0);
            						this.skeleton.updateGraph();
            				}
            				if (this.animEvaluator) {
            						var clips = this.animEvaluator.clips;
            						for(var i = 0; i < clips.length; ++i){
            								clips[i].time = currentTime;
            						}
            				}
            		}
            		get currentTime() {
            				if (this.skeleton) {
            						return this.skeleton._time;
            				}
            				if (this.animEvaluator) {
            						var clips = this.animEvaluator.clips;
            						if (clips.length > 0) {
            								return clips[clips.length - 1].time;
            						}
            				}
            				return 0;
            		}
            		get duration() {
            				if (this.currAnim) {
            						return this.animations[this.currAnim].duration;
            				}
            				return 0;
            		}
            		set loop(value) {
            				this._loop = value;
            				if (this.skeleton) {
            						this.skeleton.looping = value;
            				}
            				if (this.animEvaluator) {
            						for(var i = 0; i < this.animEvaluator.clips.length; ++i){
            								this.animEvaluator.clips[i].loop = value;
            						}
            				}
            		}
            		get loop() {
            				return this._loop;
            		}
            		play(name, blendTime) {
            				if (blendTime === void 0) blendTime = 0;
            				if (!this.enabled || !this.entity.enabled) {
            						return;
            				}
            				if (!this.animations[name]) {
            						return;
            				}
            				this.prevAnim = this.currAnim;
            				this.currAnim = name;
            				if (this.model) {
            						if (!this.skeleton && !this.animEvaluator) {
            								this._createAnimationController();
            						}
            						var prevAnim = this.animations[this.prevAnim];
            						var currAnim = this.animations[this.currAnim];
            						this.blending = blendTime > 0 && !!this.prevAnim;
            						if (this.blending) {
            								this.blend = 0;
            								this.blendSpeed = 1 / blendTime;
            						}
            						if (this.skeleton) {
            								if (this.blending) {
            										this.fromSkel.animation = prevAnim;
            										this.fromSkel.addTime(this.skeleton._time);
            										this.toSkel.animation = currAnim;
            								} else {
            										this.skeleton.animation = currAnim;
            								}
            						}
            						if (this.animEvaluator) {
            								var animEvaluator = this.animEvaluator;
            								if (this.blending) {
            										while(animEvaluator.clips.length > 1){
            												animEvaluator.removeClip(0);
            										}
            								} else {
            										this.animEvaluator.removeClips();
            								}
            								var clip = new AnimClip(this.animations[this.currAnim], 0, 1.0, true, this.loop);
            								clip.name = this.currAnim;
            								clip.blendWeight = this.blending ? 0 : 1;
            								clip.reset();
            								this.animEvaluator.addClip(clip);
            						}
            				}
            				this.playing = true;
            		}
            		getAnimation(name) {
            				return this.animations[name];
            		}
            		setModel(model) {
            				if (model !== this.model) {
            						this._resetAnimationController();
            						this.model = model;
            						if (this.animations && this.currAnim && this.animations[this.currAnim]) {
            								this.play(this.currAnim);
            						}
            				}
            		}
            		onSetAnimations() {
            				var modelComponent = this.entity.model;
            				if (modelComponent) {
            						var m = modelComponent.model;
            						if (m && m !== this.model) {
            								this.setModel(m);
            						}
            				}
            				if (!this.currAnim && this.activate && this.enabled && this.entity.enabled) {
            						var animationNames = Object.keys(this._animations);
            						if (animationNames.length > 0) {
            								this.play(animationNames[0]);
            						}
            				}
            		}
            		_resetAnimationController() {
            				this.skeleton = null;
            				this.fromSkel = null;
            				this.toSkel = null;
            				this.animEvaluator = null;
            		}
            		_createAnimationController() {
            				var model = this.model;
            				var animations = this.animations;
            				var hasJson = false;
            				var hasGlb = false;
            				for(var animation in animations){
            						if (animations.hasOwnProperty(animation)) {
            								var anim = animations[animation];
            								if (anim.constructor === AnimTrack) {
            										hasGlb = true;
            								} else {
            										hasJson = true;
            								}
            						}
            				}
            				var graph = model.getGraph();
            				if (hasJson) {
            						this.fromSkel = new Skeleton(graph);
            						this.toSkel = new Skeleton(graph);
            						this.skeleton = new Skeleton(graph);
            						this.skeleton.looping = this.loop;
            						this.skeleton.setGraph(graph);
            				} else if (hasGlb) {
            						this.animEvaluator = new AnimEvaluator(new DefaultAnimBinder(this.entity));
            				}
            		}
            		loadAnimationAssets(ids) {
            				if (!ids || !ids.length) {
            						return;
            				}
            				var assets = this.system.app.assets;
            				var onAssetReady = (asset)=>{
            						if (asset.resources.length > 1) {
            								for(var i = 0; i < asset.resources.length; i++){
            										this.animations[asset.resources[i].name] = asset.resources[i];
            										this.animationsIndex[asset.id] = asset.resources[i].name;
            								}
            						} else {
            								this.animations[asset.name] = asset.resource;
            								this.animationsIndex[asset.id] = asset.name;
            						}
            						this.animations = this.animations;
            				};
            				var onAssetAdd = (asset)=>{
            						asset.off('change', this.onAssetChanged, this);
            						asset.on('change', this.onAssetChanged, this);
            						asset.off('remove', this.onAssetRemoved, this);
            						asset.on('remove', this.onAssetRemoved, this);
            						if (asset.resource) {
            								onAssetReady(asset);
            						} else {
            								asset.once('load', onAssetReady, this);
            								if (this.enabled && this.entity.enabled) {
            										assets.load(asset);
            								}
            						}
            				};
            				for(var i = 0, l = ids.length; i < l; i++){
            						var asset = assets.get(ids[i]);
            						if (asset) {
            								onAssetAdd(asset);
            						} else {
            								assets.on("add:" + ids[i], onAssetAdd);
            						}
            				}
            		}
            		onAssetChanged(asset, attribute, newValue, oldValue) {
            				if (attribute === 'resource' || attribute === 'resources') {
            						if (attribute === 'resources' && newValue && newValue.length === 0) {
            								newValue = null;
            						}
            						if (newValue) {
            								var restarted = false;
            								if (newValue.length > 1) {
            										if (oldValue && oldValue.length > 1) {
            												for(var i = 0; i < oldValue.length; i++){
            														delete this.animations[oldValue[i].name];
            												}
            										} else {
            												delete this.animations[asset.name];
            										}
            										restarted = false;
            										for(var i1 = 0; i1 < newValue.length; i1++){
            												this.animations[newValue[i1].name] = newValue[i1];
            												if (!restarted && this.currAnim === newValue[i1].name) {
            														if (this.playing && this.enabled && this.entity.enabled) {
            																restarted = true;
            																this.play(newValue[i1].name);
            														}
            												}
            										}
            										if (!restarted) {
            												this._stopCurrentAnimation();
            												this.onSetAnimations();
            										}
            								} else {
            										if (oldValue && oldValue.length > 1) {
            												for(var i2 = 0; i2 < oldValue.length; i2++){
            														delete this.animations[oldValue[i2].name];
            												}
            										}
            										this.animations[asset.name] = newValue[0] || newValue;
            										restarted = false;
            										if (this.currAnim === asset.name) {
            												if (this.playing && this.enabled && this.entity.enabled) {
            														restarted = true;
            														this.play(asset.name);
            												}
            										}
            										if (!restarted) {
            												this._stopCurrentAnimation();
            												this.onSetAnimations();
            										}
            								}
            								this.animationsIndex[asset.id] = asset.name;
            						} else {
            								if (oldValue.length > 1) {
            										for(var i3 = 0; i3 < oldValue.length; i3++){
            												delete this.animations[oldValue[i3].name];
            												if (this.currAnim === oldValue[i3].name) {
            														this._stopCurrentAnimation();
            												}
            										}
            								} else {
            										delete this.animations[asset.name];
            										if (this.currAnim === asset.name) {
            												this._stopCurrentAnimation();
            										}
            								}
            								delete this.animationsIndex[asset.id];
            						}
            				}
            		}
            		onAssetRemoved(asset) {
            				asset.off('remove', this.onAssetRemoved, this);
            				if (this.animations) {
            						if (asset.resources.length > 1) {
            								for(var i = 0; i < asset.resources.length; i++){
            										delete this.animations[asset.resources[i].name];
            										if (this.currAnim === asset.resources[i].name) {
            												this._stopCurrentAnimation();
            										}
            								}
            						} else {
            								delete this.animations[asset.name];
            								if (this.currAnim === asset.name) {
            										this._stopCurrentAnimation();
            								}
            						}
            						delete this.animationsIndex[asset.id];
            				}
            		}
            		_stopCurrentAnimation() {
            				this.currAnim = null;
            				this.playing = false;
            				if (this.skeleton) {
            						this.skeleton.currentTime = 0;
            						this.skeleton.animation = null;
            				}
            				if (this.animEvaluator) {
            						for(var i = 0; i < this.animEvaluator.clips.length; ++i){
            								this.animEvaluator.clips[i].stop();
            						}
            						this.animEvaluator.update(0);
            						this.animEvaluator.removeClips();
            				}
            		}
            		onEnable() {
            				super.onEnable();
            				var assets = this.assets;
            				var registry = this.system.app.assets;
            				if (assets) {
            						for(var i = 0, len = assets.length; i < len; i++){
            								var asset = assets[i];
            								if (!(asset instanceof Asset)) {
            										asset = registry.get(asset);
            								}
            								if (asset && !asset.resource) {
            										registry.load(asset);
            								}
            						}
            				}
            				if (this.activate && !this.currAnim) {
            						var animationNames = Object.keys(this.animations);
            						if (animationNames.length > 0) {
            								this.play(animationNames[0]);
            						}
            				}
            		}
            		onBeforeRemove() {
            				for(var i = 0; i < this.assets.length; i++){
            						var asset = this.assets[i];
            						if (typeof asset === 'number') {
            								asset = this.system.app.assets.get(asset);
            						}
            						if (!asset) continue;
            						asset.off('change', this.onAssetChanged, this);
            						asset.off('remove', this.onAssetRemoved, this);
            				}
            				this.skeleton = null;
            				this.fromSkel = null;
            				this.toSkel = null;
            				this.animEvaluator = null;
            		}
            		update(dt) {
            				if (this.blending) {
            						this.blend += dt * this.blendSpeed;
            						if (this.blend >= 1) {
            								this.blend = 1;
            						}
            				}
            				if (this.playing) {
            						var skeleton = this.skeleton;
            						if (skeleton !== null && this.model !== null) {
            								if (this.blending) {
            										skeleton.blend(this.fromSkel, this.toSkel, this.blend);
            								} else {
            										var delta = dt * this.speed;
            										skeleton.addTime(delta);
            										if (this.speed > 0 && skeleton._time === skeleton.animation.duration && !this.loop) {
            												this.playing = false;
            										} else if (this.speed < 0 && skeleton._time === 0 && !this.loop) {
            												this.playing = false;
            										}
            								}
            								if (this.blending && this.blend === 1) {
            										skeleton.animation = this.toSkel.animation;
            								}
            								skeleton.updateGraph();
            						}
            				}
            				var animEvaluator = this.animEvaluator;
            				if (animEvaluator) {
            						for(var i = 0; i < animEvaluator.clips.length; ++i){
            								var clip = animEvaluator.clips[i];
            								clip.speed = this.speed;
            								if (!this.playing) {
            										clip.pause();
            								} else {
            										clip.resume();
            								}
            						}
            						if (this.blending && animEvaluator.clips.length > 1) {
            								animEvaluator.clips[1].blendWeight = this.blend;
            						}
            						animEvaluator.update(dt);
            				}
            				if (this.blending && this.blend === 1) {
            						this.blending = false;
            				}
            		}
            		constructor(...args){
            				super(...args), this._animations = {}, this._assets = [], this._loop = true, this.animEvaluator = null, this.model = null, this.skeleton = null, this.fromSkel = null, this.toSkel = null, this.animationsIndex = {}, this.prevAnim = null, this.currAnim = null, this.blend = 0, this.blending = false, this.blendSpeed = 0, this.activate = true, this.speed = 1;
            		}
            }
            
            class AnimationComponentData {
            		constructor(){
            				this.enabled = true;
            		}
            }
            
            var _schema$k = [
            		'enabled'
            ];
            class AnimationComponentSystem extends ComponentSystem {
            		initializeComponentData(component, data, properties) {
            				properties = [
            						'activate',
            						'enabled',
            						'loop',
            						'speed',
            						'assets'
            				];
            				for (var property of properties){
            						if (data.hasOwnProperty(property)) {
            								component[property] = data[property];
            						}
            				}
            				super.initializeComponentData(component, data, _schema$k);
            		}
            		cloneComponent(entity, clone) {
            				this.addComponent(clone, {});
            				clone.animation.assets = entity.animation.assets.slice();
            				clone.animation.speed = entity.animation.speed;
            				clone.animation.loop = entity.animation.loop;
            				clone.animation.activate = entity.animation.activate;
            				clone.animation.enabled = entity.animation.enabled;
            				var clonedAnimations = {};
            				var animations = entity.animation.animations;
            				for(var key in animations){
            						if (animations.hasOwnProperty(key)) {
            								clonedAnimations[key] = animations[key];
            						}
            				}
            				clone.animation.animations = clonedAnimations;
            				var clonedAnimationsIndex = {};
            				var animationsIndex = entity.animation.animationsIndex;
            				for(var key1 in animationsIndex){
            						if (animationsIndex.hasOwnProperty(key1)) {
            								clonedAnimationsIndex[key1] = animationsIndex[key1];
            						}
            				}
            				clone.animation.animationsIndex = clonedAnimationsIndex;
            				return clone.animation;
            		}
            		onBeforeRemove(entity, component) {
            				component.onBeforeRemove();
            		}
            		onUpdate(dt) {
            				var components = this.store;
            				for(var id in components){
            						if (components.hasOwnProperty(id)) {
            								var component = components[id];
            								if (component.data.enabled && component.entity.enabled) {
            										component.entity.animation.update(dt);
            								}
            						}
            				}
            		}
            		destroy() {
            				super.destroy();
            				this.app.systems.off('update', this.onUpdate, this);
            		}
            		constructor(app){
            				super(app);
            				this.id = 'animation';
            				this.ComponentType = AnimationComponent;
            				this.DataType = AnimationComponentData;
            				this.schema = _schema$k;
            				this.on('beforeremove', this.onBeforeRemove, this);
            				this.app.systems.on('update', this.onUpdate, this);
            		}
            }
            Component._buildAccessors(AnimationComponent.prototype, _schema$k);
            
            class AnimNode {
            		get parent() {
            				return this._parent;
            		}
            		get name() {
            				return this._name;
            		}
            		get path() {
            				return this._parent ? this._parent.path + "." + this._name : this._name;
            		}
            		get point() {
            				return this._point;
            		}
            		get pointLength() {
            				return this._pointLength;
            		}
            		set weight(value) {
            				this._weight = value;
            		}
            		get weight() {
            				return this._parent ? this._parent.weight * this._weight : this._weight;
            		}
            		get normalizedWeight() {
            				var totalWeight = this._state.totalWeight;
            				if (totalWeight === 0.0) return 0.0;
            				return this.weight / totalWeight;
            		}
            		get speed() {
            				return this._weightedSpeed * this._speed;
            		}
            		get absoluteSpeed() {
            				return Math.abs(this._speed);
            		}
            		set weightedSpeed(weightedSpeed) {
            				this._weightedSpeed = weightedSpeed;
            		}
            		get weightedSpeed() {
            				return this._weightedSpeed;
            		}
            		set animTrack(value) {
            				this._animTrack = value;
            		}
            		get animTrack() {
            				return this._animTrack;
            		}
            		constructor(state, parent, name, point, speed = 1){
            				this._state = state;
            				this._parent = parent;
            				this._name = name;
            				if (Array.isArray(point)) {
            						this._point = new Vec2(point[0], point[1]);
            						this._pointLength = this._point.length();
            				} else {
            						this._point = point;
            						this._pointLength = point;
            				}
            				this._speed = speed;
            				this._weightedSpeed = 1.0;
            				this._weight = 1.0;
            				this._animTrack = null;
            		}
            }
            
            class AnimBlendTree extends AnimNode {
            		get weight() {
            				this.calculateWeights();
            				return this._parent ? this._parent.weight * this._weight : this._weight;
            		}
            		get syncAnimations() {
            				return this._syncAnimations;
            		}
            		getChild(name) {
            				for(var i = 0; i < this._children.length; i++){
            						if (this._children[i].name === name) return this._children[i];
            				}
            				return null;
            		}
            		updateParameterValues() {
            				var paramsEqual = true;
            				for(var i = 0; i < this._parameterValues.length; i++){
            						var updatedParameter = this._findParameter(this._parameters[i]).value;
            						if (this._parameterValues[i] !== updatedParameter) {
            								this._parameterValues[i] = updatedParameter;
            								paramsEqual = false;
            						}
            				}
            				return paramsEqual;
            		}
            		getNodeWeightedDuration(i) {
            				return this._children[i].animTrack.duration / this._children[i].speedMultiplier * this._children[i].weight;
            		}
            		getNodeCount() {
            				var count = 0;
            				for(var i = 0; i < this._children.length; i++){
            						var child = this._children[i];
            						if (child.constructor === AnimBlendTree) {
            								count += this._children[i].getNodeCount();
            						} else {
            								count++;
            						}
            				}
            				return count;
            		}
            		constructor(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter){
            				super(state, parent, name, point);
            				this._parameters = parameters;
            				this._parameterValues = new Array(parameters.length);
            				this._children = [];
            				this._findParameter = findParameter;
            				this._syncAnimations = syncAnimations !== false;
            				this._pointCache = {};
            				for(var i = 0; i < children.length; i++){
            						var child = children[i];
            						if (child.children) {
            								this._children.push(createTree(child.type, state, this, child.name, 1.0, child.parameter ? [
            										child.parameter
            								] : child.parameters, child.children, child.syncAnimations, createTree, findParameter));
            						} else {
            								this._children.push(new AnimNode(state, this, child.name, child.point, child.speed));
            						}
            				}
            		}
            }
            
            class AnimBlendTree1D extends AnimBlendTree {
            		calculateWeights() {
            				if (this.updateParameterValues()) return;
            				var weightedDurationSum = 0.0;
            				this._children[0].weight = 0.0;
            				for(var i = 0; i < this._children.length; i++){
            						var c1 = this._children[i];
            						if (i !== this._children.length - 1) {
            								var c2 = this._children[i + 1];
            								if (c1.point === c2.point) {
            										c1.weight = 0.5;
            										c2.weight = 0.5;
            								} else if (math.between(this._parameterValues[0], c1.point, c2.point, true)) {
            										var child2Distance = Math.abs(c1.point - c2.point);
            										var parameterDistance = Math.abs(c1.point - this._parameterValues[0]);
            										var weight = (child2Distance - parameterDistance) / child2Distance;
            										c1.weight = weight;
            										c2.weight = 1.0 - weight;
            								} else {
            										c2.weight = 0.0;
            								}
            						}
            						if (this._syncAnimations) {
            								weightedDurationSum += c1.animTrack.duration / c1.absoluteSpeed * c1.weight;
            						}
            				}
            				if (this._syncAnimations) {
            						for(var i1 = 0; i1 < this._children.length; i1++){
            								var child = this._children[i1];
            								child.weightedSpeed = child.animTrack.duration / child.absoluteSpeed / weightedDurationSum;
            						}
            				}
            		}
            		constructor(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter){
            				children.sort((a, b)=>a.point - b.point);
            				super(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
            		}
            }
            
            class AnimBlendTreeCartesian2D extends AnimBlendTree {
            		pointDistanceCache(i, j) {
            				var pointKey = "" + i + j;
            				if (!this._pointCache[pointKey]) {
            						this._pointCache[pointKey] = this._children[j].point.clone().sub(this._children[i].point);
            				}
            				return this._pointCache[pointKey];
            		}
            		calculateWeights() {
            				if (this.updateParameterValues()) return;
            				var weightSum, weightedDurationSum;
            				AnimBlendTreeCartesian2D._p.set(...this._parameterValues);
            				weightSum = 0.0;
            				weightedDurationSum = 0.0;
            				for(var i = 0; i < this._children.length; i++){
            						var child = this._children[i];
            						var pi = child.point;
            						AnimBlendTreeCartesian2D._pip.set(AnimBlendTreeCartesian2D._p.x, AnimBlendTreeCartesian2D._p.y).sub(pi);
            						var minj = Number.MAX_VALUE;
            						for(var j = 0; j < this._children.length; j++){
            								if (i === j) continue;
            								var pipj = this.pointDistanceCache(i, j);
            								var result = math.clamp(1.0 - AnimBlendTreeCartesian2D._pip.dot(pipj) / pipj.lengthSq(), 0.0, 1.0);
            								if (result < minj) minj = result;
            						}
            						child.weight = minj;
            						weightSum += minj;
            						if (this._syncAnimations) {
            								weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;
            						}
            				}
            				for(var i1 = 0; i1 < this._children.length; i1++){
            						var child1 = this._children[i1];
            						child1.weight = child1._weight / weightSum;
            						if (this._syncAnimations) {
            								child1.weightedSpeed = child1.animTrack.duration / child1.absoluteSpeed / weightedDurationSum;
            						}
            				}
            		}
            }
            AnimBlendTreeCartesian2D._p = new Vec2();
            AnimBlendTreeCartesian2D._pip = new Vec2();
            
            class AnimBlendTreeDirectional2D extends AnimBlendTree {
            		pointCache(i, j) {
            				var pointKey = "" + i + j;
            				if (!this._pointCache[pointKey]) {
            						this._pointCache[pointKey] = new Vec2((this._children[j].pointLength - this._children[i].pointLength) / ((this._children[j].pointLength + this._children[i].pointLength) / 2), Vec2.angleRad(this._children[i].point, this._children[j].point) * 2.0);
            				}
            				return this._pointCache[pointKey];
            		}
            		calculateWeights() {
            				if (this.updateParameterValues()) return;
            				var weightSum, weightedDurationSum;
            				AnimBlendTreeDirectional2D._p.set(...this._parameterValues);
            				var pLength = AnimBlendTreeDirectional2D._p.length();
            				weightSum = 0.0;
            				weightedDurationSum = 0.0;
            				for(var i = 0; i < this._children.length; i++){
            						var child = this._children[i];
            						var pi = child.point;
            						var piLength = child.pointLength;
            						var minj = Number.MAX_VALUE;
            						for(var j = 0; j < this._children.length; j++){
            								if (i === j) continue;
            								var pipj = this.pointCache(i, j);
            								var pjLength = this._children[j].pointLength;
            								AnimBlendTreeDirectional2D._pip.set((pLength - piLength) / ((pjLength + piLength) / 2), Vec2.angleRad(pi, AnimBlendTreeDirectional2D._p) * 2.0);
            								var result = math.clamp(1.0 - Math.abs(AnimBlendTreeDirectional2D._pip.dot(pipj) / pipj.lengthSq()), 0.0, 1.0);
            								if (result < minj) minj = result;
            						}
            						child.weight = minj;
            						weightSum += minj;
            						if (this._syncAnimations) {
            								weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;
            						}
            				}
            				for(var i1 = 0; i1 < this._children.length; i1++){
            						var child1 = this._children[i1];
            						child1.weight = child1._weight / weightSum;
            						if (this._syncAnimations) {
            								var weightedChildDuration = child1.animTrack.duration / weightedDurationSum * weightSum;
            								child1.weightedSpeed = child1.absoluteSpeed * weightedChildDuration;
            						}
            				}
            		}
            }
            AnimBlendTreeDirectional2D._p = new Vec2();
            AnimBlendTreeDirectional2D._pip = new Vec2();
            
            class AnimBlendTreeDirect extends AnimBlendTree {
            		calculateWeights() {
            				if (this.updateParameterValues()) return;
            				var weightSum = 0.0;
            				var weightedDurationSum = 0.0;
            				for(var i = 0; i < this._children.length; i++){
            						weightSum += Math.max(this._parameterValues[i], 0.0);
            						if (this._syncAnimations) {
            								var child = this._children[i];
            								weightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;
            						}
            				}
            				for(var i1 = 0; i1 < this._children.length; i1++){
            						var child1 = this._children[i1];
            						var weight = Math.max(this._parameterValues[i1], 0.0);
            						if (weightSum) {
            								child1.weight = weight / weightSum;
            								if (this._syncAnimations) {
            										child1.weightedSpeed = child1.animTrack.duration / child1.absoluteSpeed / weightedDurationSum;
            								}
            						} else {
            								child1.weight = 0.0;
            								if (this._syncAnimations) {
            										child1.weightedSpeed = 0;
            								}
            						}
            				}
            		}
            }
            
            class AnimState {
            		_createTree(type, state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {
            				switch(type){
            						case ANIM_BLEND_1D:
            								return new AnimBlendTree1D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
            						case ANIM_BLEND_2D_CARTESIAN:
            								return new AnimBlendTreeCartesian2D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
            						case ANIM_BLEND_2D_DIRECTIONAL:
            								return new AnimBlendTreeDirectional2D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
            						case ANIM_BLEND_DIRECT:
            								return new AnimBlendTreeDirect(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);
            				}
            				return undefined;
            		}
            		_getNodeFromPath(path) {
            				var currNode = this._blendTree;
            				for(var i = 1; i < path.length; i++){
            						currNode = currNode.getChild(path[i]);
            				}
            				return currNode;
            		}
            		addAnimation(path, animTrack) {
            				var pathString = path.join('.');
            				var indexOfAnimation = this._animationList.findIndex((animation)=>{
            						return animation.path === pathString;
            				});
            				if (indexOfAnimation >= 0) {
            						this._animationList[indexOfAnimation].animTrack = animTrack;
            				} else {
            						var node = this._getNodeFromPath(path);
            						node.animTrack = animTrack;
            						this._animationList.push(node);
            				}
            				this._updateHasAnimations();
            		}
            		_updateHasAnimations() {
            				this._hasAnimations = this._animationList.length > 0 && this._animationList.every((animation)=>animation.animTrack && animation.animTrack !== AnimTrack.EMPTY);
            		}
            		get name() {
            				return this._name;
            		}
            		set animations(value) {
            				this._animationList = value;
            				this._updateHasAnimations();
            		}
            		get animations() {
            				return this._animationList;
            		}
            		get hasAnimations() {
            				return this._hasAnimations;
            		}
            		set speed(value) {
            				this._speed = value;
            		}
            		get speed() {
            				return this._speed;
            		}
            		set loop(value) {
            				this._loop = value;
            		}
            		get loop() {
            				return this._loop;
            		}
            		get nodeCount() {
            				if (!this._blendTree || this._blendTree.constructor === AnimNode) return 1;
            				return this._blendTree.getNodeCount();
            		}
            		get playable() {
            				return ANIM_CONTROL_STATES.indexOf(this.name) !== -1 || this.animations.length === this.nodeCount;
            		}
            		get looping() {
            				if (this.animations.length > 0) {
            						var trackClipName = this.name + "." + this.animations[0].animTrack.name;
            						var trackClip = this._controller.animEvaluator.findClip(trackClipName);
            						if (trackClip) {
            								return trackClip.loop;
            						}
            				}
            				return false;
            		}
            		get totalWeight() {
            				var sum = 0;
            				for(var i = 0; i < this.animations.length; i++){
            						sum += this.animations[i].weight;
            				}
            				return sum;
            		}
            		get timelineDuration() {
            				var duration = 0;
            				for(var i = 0; i < this.animations.length; i++){
            						var animation = this.animations[i];
            						if (animation.animTrack.duration > duration) {
            								duration = animation.animTrack.duration;
            						}
            				}
            				return duration;
            		}
            		constructor(controller, name, speed = 1, loop = true, blendTree){
            				this._animations = {};
            				this._animationList = [];
            				this._controller = controller;
            				this._name = name;
            				this._speed = speed;
            				this._loop = loop;
            				this._hasAnimations = false;
            				if (blendTree) {
            						this._blendTree = this._createTree(blendTree.type, this, null, name, 1.0, blendTree.parameter ? [
            								blendTree.parameter
            						] : blendTree.parameters, blendTree.children, blendTree.syncAnimations, this._createTree, this._controller.findParameter);
            				} else {
            						this._blendTree = new AnimNode(this, null, name, 1.0, speed);
            				}
            		}
            }
            
            class AnimTransition {
            		get from() {
            				return this._from;
            		}
            		set to(value) {
            				this._to = value;
            		}
            		get to() {
            				return this._to;
            		}
            		get time() {
            				return this._time;
            		}
            		get priority() {
            				return this._priority;
            		}
            		get conditions() {
            				return this._conditions;
            		}
            		get exitTime() {
            				return this._exitTime;
            		}
            		get transitionOffset() {
            				return this._transitionOffset;
            		}
            		get interruptionSource() {
            				return this._interruptionSource;
            		}
            		get hasExitTime() {
            				return !!this.exitTime;
            		}
            		constructor({ from, to, time = 0, priority = 0, conditions = [], exitTime = null, transitionOffset = null, interruptionSource = ANIM_INTERRUPTION_NONE }){
            				this._from = from;
            				this._to = to;
            				this._time = time;
            				this._priority = priority;
            				this._conditions = conditions;
            				this._exitTime = exitTime;
            				this._transitionOffset = transitionOffset;
            				this._interruptionSource = interruptionSource;
            		}
            }
            
            function _extends$a() {
            		_extends$a = Object.assign || function(target) {
            				for(var i = 1; i < arguments.length; i++){
            						var source = arguments[i];
            						for(var key in source){
            								if (Object.prototype.hasOwnProperty.call(source, key)) {
            										target[key] = source[key];
            								}
            						}
            				}
            				return target;
            		};
            		return _extends$a.apply(this, arguments);
            }
            class AnimController {
            		get animEvaluator() {
            				return this._animEvaluator;
            		}
            		set activeState(stateName) {
            				this._activeStateName = stateName;
            		}
            		get activeState() {
            				return this._findState(this._activeStateName);
            		}
            		get activeStateName() {
            				return this._activeStateName;
            		}
            		get activeStateAnimations() {
            				return this.activeState.animations;
            		}
            		set previousState(stateName) {
            				this._previousStateName = stateName;
            		}
            		get previousState() {
            				return this._findState(this._previousStateName);
            		}
            		get previousStateName() {
            				return this._previousStateName;
            		}
            		get playable() {
            				var playable = true;
            				for(var i = 0; i < this._stateNames.length; i++){
            						if (!this._states[this._stateNames[i]].playable) {
            								playable = false;
            						}
            				}
            				return playable;
            		}
            		set playing(value) {
            				this._playing = value;
            		}
            		get playing() {
            				return this._playing;
            		}
            		get activeStateProgress() {
            				return this._getActiveStateProgressForTime(this._timeInState);
            		}
            		get activeStateDuration() {
            				if (this._activeStateDurationDirty) {
            						var maxDuration = 0.0;
            						for(var i = 0; i < this.activeStateAnimations.length; i++){
            								var activeClip = this._animEvaluator.findClip(this.activeStateAnimations[i].name);
            								if (activeClip) {
            										maxDuration = Math.max(maxDuration, activeClip.track.duration);
            								}
            						}
            						this._activeStateDuration = maxDuration;
            						this._activeStateDurationDirty = false;
            				}
            				return this._activeStateDuration;
            		}
            		set activeStateCurrentTime(time) {
            				this._timeInStateBefore = time;
            				this._timeInState = time;
            				for(var i = 0; i < this.activeStateAnimations.length; i++){
            						var clip = this.animEvaluator.findClip(this.activeStateAnimations[i].name);
            						if (clip) {
            								clip.time = time;
            						}
            				}
            		}
            		get activeStateCurrentTime() {
            				return this._timeInState;
            		}
            		get transitioning() {
            				return this._isTransitioning;
            		}
            		get transitionProgress() {
            				return this._currTransitionTime / this._totalTransitionTime;
            		}
            		get states() {
            				return this._stateNames;
            		}
            		assignMask(mask) {
            				return this._animEvaluator.assignMask(mask);
            		}
            		_findState(stateName) {
            				return this._states[stateName];
            		}
            		_getActiveStateProgressForTime(time) {
            				if (this.activeStateName === ANIM_STATE_START || this.activeStateName === ANIM_STATE_END || this.activeStateName === ANIM_STATE_ANY) {
            						return 1.0;
            				}
            				var activeClip = this._animEvaluator.findClip(this.activeStateAnimations[0].name);
            				if (activeClip) {
            						return activeClip.progressForTime(time);
            				}
            				return null;
            		}
            		_findTransitionsFromState(stateName) {
            				var transitions = this._findTransitionsFromStateCache[stateName];
            				if (!transitions) {
            						transitions = this._transitions.filter((transition)=>{
            								return transition.from === stateName;
            						});
            						sortPriority(transitions);
            						this._findTransitionsFromStateCache[stateName] = transitions;
            				}
            				return transitions;
            		}
            		_findTransitionsBetweenStates(sourceStateName, destinationStateName) {
            				var transitions = this._findTransitionsBetweenStatesCache[sourceStateName + "->" + destinationStateName];
            				if (!transitions) {
            						transitions = this._transitions.filter((transition)=>{
            								return transition.from === sourceStateName && transition.to === destinationStateName;
            						});
            						sortPriority(transitions);
            						this._findTransitionsBetweenStatesCache[sourceStateName + "->" + destinationStateName] = transitions;
            				}
            				return transitions;
            		}
            		_transitionHasConditionsMet(transition) {
            				var conditions = transition.conditions;
            				for(var i = 0; i < conditions.length; i++){
            						var condition = conditions[i];
            						var parameter = this._findParameter(condition.parameterName);
            						switch(condition.predicate){
            								case ANIM_GREATER_THAN:
            										if (!(parameter.value > condition.value)) return false;
            										break;
            								case ANIM_LESS_THAN:
            										if (!(parameter.value < condition.value)) return false;
            										break;
            								case ANIM_GREATER_THAN_EQUAL_TO:
            										if (!(parameter.value >= condition.value)) return false;
            										break;
            								case ANIM_LESS_THAN_EQUAL_TO:
            										if (!(parameter.value <= condition.value)) return false;
            										break;
            								case ANIM_EQUAL_TO:
            										if (!(parameter.value === condition.value)) return false;
            										break;
            								case ANIM_NOT_EQUAL_TO:
            										if (!(parameter.value !== condition.value)) return false;
            										break;
            						}
            				}
            				return true;
            		}
            		_findTransition(from, to) {
            				var transitions = [];
            				if (from && to) {
            						transitions = transitions.concat(this._findTransitionsBetweenStates(from, to));
            				} else {
            						if (!this._isTransitioning) {
            								transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
            								transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
            						} else {
            								switch(this._transitionInterruptionSource){
            										case ANIM_INTERRUPTION_PREV:
            												transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
            												transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
            												break;
            										case ANIM_INTERRUPTION_NEXT:
            												transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
            												transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
            												break;
            										case ANIM_INTERRUPTION_PREV_NEXT:
            												transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
            												transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
            												transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
            												break;
            										case ANIM_INTERRUPTION_NEXT_PREV:
            												transitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));
            												transitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));
            												transitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));
            												break;
            								}
            						}
            				}
            				transitions = transitions.filter((transition)=>{
            						if (transition.to === this.activeStateName) {
            								return false;
            						}
            						if (transition.hasExitTime) {
            								var progressBefore = this._getActiveStateProgressForTime(this._timeInStateBefore);
            								var progress = this._getActiveStateProgressForTime(this._timeInState);
            								if (transition.exitTime < 1.0 && this.activeState.loop) {
            										progressBefore -= Math.floor(progressBefore);
            										progress -= Math.floor(progress);
            								}
            								if (progress === progressBefore) {
            										if (progress !== transition.exitTime) {
            												return null;
            										}
            								} else if (!(transition.exitTime > progressBefore && transition.exitTime <= progress)) {
            										return null;
            								}
            						}
            						return this._transitionHasConditionsMet(transition);
            				});
            				if (transitions.length > 0) {
            						var transition = transitions[0];
            						if (transition.to === ANIM_STATE_END) {
            								var startTransition = this._findTransitionsFromState(ANIM_STATE_START)[0];
            								transition.to = startTransition.to;
            						}
            						return transition;
            				}
            				return null;
            		}
            		updateStateFromTransition(transition) {
            				var state;
            				var animation;
            				var clip;
            				this.previousState = transition.from ? this.activeStateName : null;
            				this.activeState = transition.to;
            				this._activeStateDurationDirty = true;
            				for(var i = 0; i < transition.conditions.length; i++){
            						var condition = transition.conditions[i];
            						var parameter = this._findParameter(condition.parameterName);
            						if (parameter.type === ANIM_PARAMETER_TRIGGER) {
            								this._consumeTrigger(condition.parameterName);
            						}
            				}
            				if (this.previousState) {
            						if (!this._isTransitioning) {
            								this._transitionPreviousStates = [];
            						}
            						this._transitionPreviousStates.push({
            								name: this._previousStateName,
            								weight: 1
            						});
            						var interpolatedTime = Math.min(this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1, 1.0);
            						for(var i1 = 0; i1 < this._transitionPreviousStates.length; i1++){
            								if (!this._isTransitioning) {
            										this._transitionPreviousStates[i1].weight = 1.0;
            								} else if (i1 !== this._transitionPreviousStates.length - 1) {
            										this._transitionPreviousStates[i1].weight *= 1.0 - interpolatedTime;
            								} else {
            										this._transitionPreviousStates[i1].weight = interpolatedTime;
            								}
            								state = this._findState(this._transitionPreviousStates[i1].name);
            								for(var j = 0; j < state.animations.length; j++){
            										animation = state.animations[j];
            										clip = this._animEvaluator.findClip(animation.name + ".previous." + i1);
            										if (!clip) {
            												clip = this._animEvaluator.findClip(animation.name);
            												clip.name = animation.name + ".previous." + i1;
            										}
            										if (i1 !== this._transitionPreviousStates.length - 1) {
            												clip.pause();
            										}
            								}
            						}
            				}
            				this._isTransitioning = true;
            				this._totalTransitionTime = transition.time;
            				this._currTransitionTime = 0;
            				this._transitionInterruptionSource = transition.interruptionSource;
            				var activeState = this.activeState;
            				var hasTransitionOffset = transition.transitionOffset && transition.transitionOffset > 0.0 && transition.transitionOffset < 1.0;
            				var timeInState = 0;
            				var timeInStateBefore = 0;
            				if (hasTransitionOffset) {
            						var offsetTime = activeState.timelineDuration * transition.transitionOffset;
            						timeInState = offsetTime;
            						timeInStateBefore = offsetTime;
            				}
            				this._timeInState = timeInState;
            				this._timeInStateBefore = timeInStateBefore;
            				for(var i2 = 0; i2 < activeState.animations.length; i2++){
            						clip = this._animEvaluator.findClip(activeState.animations[i2].name);
            						if (!clip) {
            								var speed = Number.isFinite(activeState.animations[i2].speed) ? activeState.animations[i2].speed : activeState.speed;
            								clip = new AnimClip(activeState.animations[i2].animTrack, this._timeInState, speed, true, activeState.loop, this._eventHandler);
            								clip.name = activeState.animations[i2].name;
            								this._animEvaluator.addClip(clip);
            						} else {
            								clip.reset();
            						}
            						if (transition.time > 0) {
            								clip.blendWeight = 0.0;
            						} else {
            								clip.blendWeight = activeState.animations[i2].normalizedWeight;
            						}
            						clip.play();
            						if (hasTransitionOffset) {
            								clip.time = activeState.timelineDuration * transition.transitionOffset;
            						} else {
            								var startTime = activeState.speed >= 0 ? 0 : this.activeStateDuration;
            								clip.time = startTime;
            						}
            				}
            		}
            		_transitionToState(newStateName) {
            				if (!this._findState(newStateName)) {
            						return;
            				}
            				var transition = this._findTransition(this._activeStateName, newStateName);
            				if (!transition) {
            						this._animEvaluator.removeClips();
            						transition = new AnimTransition({
            								from: null,
            								to: newStateName
            						});
            				}
            				this.updateStateFromTransition(transition);
            		}
            		assignAnimation(pathString, animTrack, speed, loop) {
            				var path = pathString.split('.');
            				var state = this._findState(path[0]);
            				if (!state) {
            						state = new AnimState(this, path[0], speed);
            						this._states[path[0]] = state;
            						this._stateNames.push(path[0]);
            				}
            				state.addAnimation(path, animTrack);
            				this._animEvaluator.updateClipTrack(state.name, animTrack);
            				if (speed !== undefined) {
            						state.speed = speed;
            				}
            				if (loop !== undefined) {
            						state.loop = loop;
            				}
            				if (!this._playing && this._activate && this.playable) {
            						this.play();
            				}
            				this._activeStateDurationDirty = true;
            		}
            		removeNodeAnimations(nodeName) {
            				if (ANIM_CONTROL_STATES.indexOf(nodeName) !== -1) {
            						return false;
            				}
            				var state = this._findState(nodeName);
            				if (!state) {
            						return false;
            				}
            				state.animations = [];
            				return true;
            		}
            		play(stateName) {
            				if (stateName) {
            						this._transitionToState(stateName);
            				}
            				this._playing = true;
            		}
            		pause() {
            				this._playing = false;
            		}
            		reset() {
            				this._previousStateName = null;
            				this._activeStateName = ANIM_STATE_START;
            				this._playing = false;
            				this._currTransitionTime = 1.0;
            				this._totalTransitionTime = 1.0;
            				this._isTransitioning = false;
            				this._timeInState = 0;
            				this._timeInStateBefore = 0;
            				this._animEvaluator.removeClips();
            		}
            		rebind() {
            				this._animEvaluator.rebind();
            		}
            		update(dt) {
            				if (!this._playing) {
            						return;
            				}
            				var state;
            				var animation;
            				var clip;
            				if (this.activeState.loop || this._timeInState < this.activeStateDuration) {
            						this._timeInStateBefore = this._timeInState;
            						this._timeInState += dt * this.activeState.speed;
            						if (!this.activeState.loop && this._timeInState > this.activeStateDuration) {
            								this._timeInState = this.activeStateDuration;
            								dt = this.activeStateDuration - this._timeInStateBefore;
            						}
            				}
            				var transition = this._findTransition(this._activeStateName);
            				if (transition) {
            						this.updateStateFromTransition(transition);
            				}
            				if (this._isTransitioning) {
            						this._currTransitionTime += dt;
            						if (this._currTransitionTime <= this._totalTransitionTime) {
            								var interpolatedTime = this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1;
            								for(var i = 0; i < this._transitionPreviousStates.length; i++){
            										state = this._findState(this._transitionPreviousStates[i].name);
            										var stateWeight = this._transitionPreviousStates[i].weight;
            										for(var j = 0; j < state.animations.length; j++){
            												animation = state.animations[j];
            												clip = this._animEvaluator.findClip(animation.name + ".previous." + i);
            												if (clip) {
            														clip.blendWeight = (1.0 - interpolatedTime) * animation.normalizedWeight * stateWeight;
            												}
            										}
            								}
            								state = this.activeState;
            								for(var i1 = 0; i1 < state.animations.length; i1++){
            										animation = state.animations[i1];
            										this._animEvaluator.findClip(animation.name).blendWeight = interpolatedTime * animation.normalizedWeight;
            								}
            						} else {
            								this._isTransitioning = false;
            								var activeClips = this.activeStateAnimations.length;
            								var totalClips = this._animEvaluator.clips.length;
            								for(var i2 = 0; i2 < totalClips - activeClips; i2++){
            										this._animEvaluator.removeClip(0);
            								}
            								this._transitionPreviousStates = [];
            								state = this.activeState;
            								for(var i3 = 0; i3 < state.animations.length; i3++){
            										animation = state.animations[i3];
            										clip = this._animEvaluator.findClip(animation.name);
            										if (clip) {
            												clip.blendWeight = animation.normalizedWeight;
            										}
            								}
            						}
            				} else {
            						if (this.activeState._blendTree.constructor !== AnimNode) {
            								state = this.activeState;
            								for(var i4 = 0; i4 < state.animations.length; i4++){
            										animation = state.animations[i4];
            										clip = this._animEvaluator.findClip(animation.name);
            										if (clip) {
            												clip.blendWeight = animation.normalizedWeight;
            												if (animation.parent.syncAnimations) {
            														clip.speed = animation.speed;
            												}
            										}
            								}
            						}
            				}
            				this._animEvaluator.update(dt, this.activeState.hasAnimations);
            		}
            		constructor(animEvaluator, states, transitions, activate, eventHandler, findParameter, consumeTrigger){
            				this._states = {};
            				this._stateNames = [];
            				this._findTransitionsFromStateCache = {};
            				this._findTransitionsBetweenStatesCache = {};
            				this._previousStateName = null;
            				this._activeStateName = ANIM_STATE_START;
            				this._activeStateDuration = 0;
            				this._activeStateDurationDirty = true;
            				this._playing = false;
            				this._currTransitionTime = 1;
            				this._totalTransitionTime = 1;
            				this._isTransitioning = false;
            				this._transitionInterruptionSource = ANIM_INTERRUPTION_NONE;
            				this._transitionPreviousStates = [];
            				this._timeInState = 0;
            				this._timeInStateBefore = 0;
            				this.findParameter = (name)=>{
            						return this._findParameter(name);
            				};
            				this._animEvaluator = animEvaluator;
            				this._eventHandler = eventHandler;
            				this._findParameter = findParameter;
            				this._consumeTrigger = consumeTrigger;
            				for(var i = 0; i < states.length; i++){
            						this._states[states[i].name] = new AnimState(this, states[i].name, states[i].speed, states[i].loop, states[i].blendTree);
            						this._stateNames.push(states[i].name);
            				}
            				this._transitions = transitions.map((transition)=>{
            						return new AnimTransition(_extends$a({}, transition));
            				});
            				this._activate = activate;
            		}
            }
            
            var v2 = new Vec2();
            var v3 = new Vec3();
            var v4 = new Vec4();
            var c = new Color();
            var q$3 = new Quat();
            class AnimComponentBinder extends DefaultAnimBinder {
            		static _packFloat(values) {
            				return values[0];
            		}
            		static _packBoolean(values) {
            				return !!values[0];
            		}
            		static _packVec2(values) {
            				v2.x = values[0];
            				v2.y = values[1];
            				return v2;
            		}
            		static _packVec3(values) {
            				v3.x = values[0];
            				v3.y = values[1];
            				v3.z = values[2];
            				return v3;
            		}
            		static _packVec4(values) {
            				v4.x = values[0];
            				v4.y = values[1];
            				v4.z = values[2];
            				v4.w = values[3];
            				return v4;
            		}
            		static _packColor(values) {
            				c.r = values[0];
            				c.g = values[1];
            				c.b = values[2];
            				c.a = values[3];
            				return c;
            		}
            		static _packQuat(values) {
            				q$3.x = values[0];
            				q$3.y = values[1];
            				q$3.z = values[2];
            				q$3.w = values[3];
            				return q$3;
            		}
            		resolve(path) {
            				var encodedPath = AnimBinder.encode(path.entityPath, path.component, path.propertyPath);
            				var target = this.targetCache[encodedPath];
            				if (target) return target;
            				var entity;
            				var propertyComponent;
            				var targetPath;
            				switch(path.component){
            						case 'entity':
            								entity = this._getEntityFromHierarchy(path.entityPath);
            								targetPath = AnimBinder.encode(entity.path, 'entity', path.propertyPath);
            								propertyComponent = entity;
            								break;
            						case 'graph':
            								propertyComponent = this.findNode(path);
            								if (!propertyComponent) return null;
            								targetPath = AnimBinder.encode(propertyComponent.path, 'graph', path.propertyPath);
            								break;
            						default:
            								entity = this._getEntityFromHierarchy(path.entityPath);
            								propertyComponent = entity.findComponent(path.component);
            								if (!propertyComponent) {
            										return null;
            								}
            								targetPath = AnimBinder.encode(entity.path, path.component, path.propertyPath);
            								break;
            				}
            				target = this._createAnimTargetForProperty(propertyComponent, path.propertyPath, targetPath);
            				this.targetCache[encodedPath] = target;
            				return target;
            		}
            		update(deltaTime) {
            				var activeNodes = this.activeNodes;
            				if (activeNodes) {
            						for(var i = 0; i < activeNodes.length; i++){
            								activeNodes[i]._dirtifyLocal();
            						}
            				}
            		}
            		_getEntityFromHierarchy(entityHierarchy) {
            				if (!this.animComponent.entity.name === entityHierarchy[0]) {
            						return null;
            				}
            				var currEntity = this.animComponent.entity;
            				if (entityHierarchy.length === 1) {
            						return currEntity;
            				}
            				return currEntity._parent.findByPath(entityHierarchy);
            		}
            		_resolvePath(object, path, resolveLeaf) {
            				var steps = path.length - (resolveLeaf ? 0 : 1);
            				for(var i = 0; i < steps; i++){
            						object = object[path[i]];
            				}
            				return object;
            		}
            		_setter(object, path, packFunc) {
            				var obj = this._resolvePath(object, path);
            				var key = path[path.length - 1];
            				var setterFuncName = "set" + key.substring(0, 1).toUpperCase() + key.substring(1);
            				if (obj[setterFuncName]) {
            						var getterFunc = obj["get" + key.substring(0, 1).toUpperCase() + key.substring(1)].bind(obj);
            						var baseValues = getterFunc();
            						baseValues = [
            								baseValues.x,
            								baseValues.y,
            								baseValues.z,
            								baseValues.w
            						];
            						var setterFunc = obj[setterFuncName].bind(obj);
            						return {
            								set: (values)=>{
            										setterFunc(packFunc(values));
            								},
            								get: ()=>baseValues
            						};
            				}
            				var prop = obj[key];
            				if (typeof prop === 'object' && prop.hasOwnProperty('copy')) {
            						return function(values) {
            								prop.copy(packFunc(values));
            						};
            				}
            				if ([
            						Vec2,
            						Vec3,
            						Vec4,
            						Color,
            						Quat
            				].indexOf(obj.constructor) !== -1 && path.length > 1) {
            						var parent = path.length > 2 ? this._resolvePath(object, path.slice(0, -1)) : object;
            						var objKey = path[path.length - 2];
            						return function(values) {
            								obj[key] = packFunc(values);
            								parent[objKey] = obj;
            						};
            				}
            				return function(values) {
            						obj[key] = packFunc(values);
            				};
            		}
            		_createAnimTargetForProperty(propertyComponent, propertyHierarchy, targetPath) {
            				if (this.handlers && propertyHierarchy[0].startsWith('weight.')) {
            						return this.handlers.weight(propertyComponent, propertyHierarchy[0].replace('weight.', ''));
            				} else if (this.handlers && propertyHierarchy[0] === 'material' && propertyHierarchy.length === 2) {
            						var materialPropertyName = propertyHierarchy[1];
            						if (materialPropertyName.endsWith('Map')) {
            								return this.handlers.materialTexture(propertyComponent, materialPropertyName);
            						}
            				}
            				var property = this._resolvePath(propertyComponent, propertyHierarchy, true);
            				if (typeof property === 'undefined') {
            						return null;
            				}
            				var setter;
            				var animDataType;
            				var animDataComponents;
            				if (typeof property === 'number') {
            						setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packFloat);
            						animDataType = 'vector';
            						animDataComponents = 1;
            				} else if (typeof property === 'boolean') {
            						setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packBoolean);
            						animDataType = 'vector';
            						animDataComponents = 1;
            				} else if (typeof property === 'object') {
            						switch(property.constructor){
            								case Vec2:
            										setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec2);
            										animDataType = 'vector';
            										animDataComponents = 2;
            										break;
            								case Vec3:
            										setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec3);
            										animDataType = 'vector';
            										animDataComponents = 3;
            										break;
            								case Vec4:
            										setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec4);
            										animDataType = 'vector';
            										animDataComponents = 4;
            										break;
            								case Color:
            										setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packColor);
            										animDataType = 'vector';
            										animDataComponents = 4;
            										break;
            								case Quat:
            										setter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packQuat);
            										animDataType = 'quaternion';
            										animDataComponents = 4;
            										break;
            								default:
            										return null;
            						}
            				}
            				if (propertyHierarchy.indexOf('material') !== -1) {
            						return new AnimTarget((values)=>{
            								setter(values);
            								propertyComponent.material.update();
            						}, animDataType, animDataComponents, targetPath);
            				}
            				return new AnimTarget(setter, animDataType, animDataComponents, targetPath);
            		}
            		rebind() {
            				this.targetCache = {};
            				if (this.animComponent.rootBone) {
            						this.graph = this.animComponent.rootBone;
            				} else {
            						this.graph = this.animComponent.entity;
            				}
            				var nodes = {};
            				var flatten = function flatten1(node) {
            						nodes[node.name] = node;
            						for(var i = 0; i < node.children.length; ++i){
            								flatten(node.children[i]);
            						}
            				};
            				flatten(this.graph);
            				this.nodes = nodes;
            		}
            		constructor(animComponent, graph, layerName, mask, layerIndex){
            				super(graph);
            				this.animComponent = animComponent;
            				this._mask = mask;
            				this.layerName = layerName;
            				this.layerIndex = layerIndex;
            		}
            }
            
            class AnimComponentLayer {
            		get name() {
            				return this._name;
            		}
            		set playing(value) {
            				this._controller.playing = value;
            		}
            		get playing() {
            				return this._controller.playing;
            		}
            		get playable() {
            				return this._controller.playable;
            		}
            		get activeState() {
            				return this._controller.activeStateName;
            		}
            		get previousState() {
            				return this._controller.previousStateName;
            		}
            		get activeStateProgress() {
            				return this._controller.activeStateProgress;
            		}
            		get activeStateDuration() {
            				return this._controller.activeStateDuration;
            		}
            		set activeStateCurrentTime(time) {
            				var controller = this._controller;
            				var layerPlaying = controller.playing;
            				controller.playing = true;
            				controller.activeStateCurrentTime = time;
            				if (!layerPlaying) {
            						controller.update(0);
            				}
            				controller.playing = layerPlaying;
            		}
            		get activeStateCurrentTime() {
            				return this._controller.activeStateCurrentTime;
            		}
            		get transitioning() {
            				return this._controller.transitioning;
            		}
            		get transitionProgress() {
            				if (this.transitioning) {
            						return this._controller.transitionProgress;
            				}
            				return null;
            		}
            		get states() {
            				return this._controller.states;
            		}
            		set weight(value) {
            				this._weight = value;
            				this._component.dirtifyTargets();
            		}
            		get weight() {
            				return this._weight;
            		}
            		set blendType(value) {
            				if (value !== this._blendType) {
            						this._blendType = value;
            						if (this._controller.normalizeWeights) {
            								this._component.rebind();
            						}
            				}
            		}
            		get blendType() {
            				return this._blendType;
            		}
            		set mask(value) {
            				if (this._controller.assignMask(value)) {
            						this._component.rebind();
            				}
            				this._mask = value;
            		}
            		get mask() {
            				return this._mask;
            		}
            		play(name) {
            				this._controller.play(name);
            		}
            		pause() {
            				this._controller.pause();
            		}
            		reset() {
            				this._controller.reset();
            		}
            		rebind() {
            				this._controller.rebind();
            		}
            		update(dt) {
            				if (this._blendTime) {
            						if (this._blendTimeElapsed < this._blendTime) {
            								this.weight = math.lerp(this._startingWeight, this._targetWeight, this._blendTimeElapsed / this._blendTime);
            								this._blendTimeElapsed += dt;
            						} else {
            								this.weight = this._targetWeight;
            								this._blendTime = 0;
            								this._blendTimeElapsed = 0;
            								this._startingWeight = 0;
            								this._targetWeight = 0;
            						}
            				}
            				this._controller.update(dt);
            		}
            		blendToWeight(weight, time) {
            				this._startingWeight = this.weight;
            				this._targetWeight = weight;
            				this._blendTime = Math.max(0, time);
            				this._blendTimeElapsed = 0;
            		}
            		assignAnimation(nodePath, animTrack, speed, loop) {
            				if (!(animTrack instanceof AnimTrack)) {
            						return;
            				}
            				this._controller.assignAnimation(nodePath, animTrack, speed, loop);
            				if (this._controller._transitions.length === 0) {
            						this._controller._transitions.push(new AnimTransition({
            								from: 'START',
            								to: nodePath
            						}));
            				}
            				if (this._component.activate && this._component.playable) {
            						this._component.playing = true;
            				}
            		}
            		removeNodeAnimations(nodeName) {
            				if (this._controller.removeNodeAnimations(nodeName)) {
            						this._component.playing = false;
            				}
            		}
            		getAnimationAsset(stateName) {
            				return this._component.animationAssets[this.name + ":" + stateName];
            		}
            		transition(to, time, transitionOffset) {
            				if (time === void 0) time = 0;
            				if (transitionOffset === void 0) transitionOffset = null;
            				this._controller.updateStateFromTransition(new AnimTransition({
            						from: this._controller.activeStateName,
            						to,
            						time,
            						transitionOffset
            				}));
            		}
            		constructor(name, controller, component, weight = 1, blendType = ANIM_LAYER_OVERWRITE){
            				this._mask = null;
            				this._blendTime = 0;
            				this._blendTimeElapsed = 0;
            				this._startingWeight = 0;
            				this._targetWeight = 0;
            				this._name = name;
            				this._controller = controller;
            				this._component = component;
            				this._weight = weight;
            				this._blendType = blendType;
            		}
            }
            
            class AnimStateGraph {
            		get parameters() {
            				return Object.assign({}, this._parameters);
            		}
            		get layers() {
            				return this._layers;
            		}
            		constructor(data){
            				this._layers = [];
            				this._parameters = {};
            				if (!Array.isArray(data.layers)) {
            						for(var layerId in data.layers){
            								var dataLayer = data.layers[layerId];
            								var layer = {
            										name: dataLayer.name,
            										blendType: dataLayer.blendType,
            										weight: dataLayer.weight,
            										states: [],
            										transitions: []
            								};
            								for(var i = 0; i < dataLayer.states.length; i++){
            										layer.states.push(data.states[dataLayer.states[i]]);
            								}
            								for(var i1 = 0; i1 < dataLayer.transitions.length; i1++){
            										var dataLayerTransition = data.transitions[dataLayer.transitions[i1]];
            										if (dataLayerTransition.conditions && !Array.isArray(dataLayerTransition.conditions)) {
            												var conditionKeys = Object.keys(dataLayerTransition.conditions);
            												var conditions = [];
            												for(var j = 0; j < conditionKeys.length; j++){
            														var condition = dataLayerTransition.conditions[conditionKeys[j]];
            														if (condition.parameterName) {
            																conditions.push(condition);
            														}
            												}
            												dataLayerTransition.conditions = conditions;
            										}
            										if (Number.isInteger(dataLayerTransition.from)) {
            												dataLayerTransition.from = data.states[dataLayerTransition.from].name;
            										}
            										if (Number.isInteger(dataLayerTransition.to)) {
            												dataLayerTransition.to = data.states[dataLayerTransition.to].name;
            										}
            										layer.transitions.push(dataLayerTransition);
            								}
            								this._layers.push(layer);
            						}
            				} else {
            						this._layers = data.layers;
            				}
            				for(var paramId in data.parameters){
            						var param = data.parameters[paramId];
            						this._parameters[param.name] = {
            								type: param.type,
            								value: param.value
            						};
            				}
            		}
            }
            
            function _extends$9() {
            		_extends$9 = Object.assign || function(target) {
            				for(var i = 1; i < arguments.length; i++){
            						var source = arguments[i];
            						for(var key in source){
            								if (Object.prototype.hasOwnProperty.call(source, key)) {
            										target[key] = source[key];
            								}
            						}
            				}
            				return target;
            		};
            		return _extends$9.apply(this, arguments);
            }
            class AnimComponent extends Component {
            		set stateGraphAsset(value) {
            				if (value === null) {
            						this.removeStateGraph();
            						return;
            				}
            				if (this._stateGraphAsset) {
            						var stateGraphAsset = this.system.app.assets.get(this._stateGraphAsset);
            						stateGraphAsset.off('change', this._onStateGraphAssetChangeEvent, this);
            				}
            				var _id;
            				var _asset;
            				if (value instanceof Asset) {
            						_id = value.id;
            						_asset = this.system.app.assets.get(_id);
            						if (!_asset) {
            								this.system.app.assets.add(value);
            								_asset = this.system.app.assets.get(_id);
            						}
            				} else {
            						_id = value;
            						_asset = this.system.app.assets.get(_id);
            				}
            				if (!_asset || this._stateGraphAsset === _id) {
            						return;
            				}
            				if (_asset.resource) {
            						this._stateGraph = _asset.resource;
            						this.loadStateGraph(this._stateGraph);
            						_asset.on('change', this._onStateGraphAssetChangeEvent, this);
            				} else {
            						_asset.once('load', (asset)=>{
            								this._stateGraph = asset.resource;
            								this.loadStateGraph(this._stateGraph);
            						});
            						_asset.on('change', this._onStateGraphAssetChangeEvent, this);
            						this.system.app.assets.load(_asset);
            				}
            				this._stateGraphAsset = _id;
            		}
            		get stateGraphAsset() {
            				return this._stateGraphAsset;
            		}
            		set normalizeWeights(value) {
            				this._normalizeWeights = value;
            				this.unbind();
            		}
            		get normalizeWeights() {
            				return this._normalizeWeights;
            		}
            		set animationAssets(value) {
            				this._animationAssets = value;
            				this.loadAnimationAssets();
            		}
            		get animationAssets() {
            				return this._animationAssets;
            		}
            		set speed(value) {
            				this._speed = value;
            		}
            		get speed() {
            				return this._speed;
            		}
            		set activate(value) {
            				this._activate = value;
            		}
            		get activate() {
            				return this._activate;
            		}
            		set playing(value) {
            				this._playing = value;
            		}
            		get playing() {
            				return this._playing;
            		}
            		set rootBone(value) {
            				if (typeof value === 'string') {
            						var entity = this.entity.root.findByGuid(value);
            						this._rootBone = entity;
            				} else if (value instanceof Entity) {
            						this._rootBone = value;
            				} else {
            						this._rootBone = null;
            				}
            				this.rebind();
            		}
            		get rootBone() {
            				return this._rootBone;
            		}
            		set stateGraph(value) {
            				this._stateGraph = value;
            		}
            		get stateGraph() {
            				return this._stateGraph;
            		}
            		get layers() {
            				return this._layers;
            		}
            		set layerIndices(value) {
            				this._layerIndices = value;
            		}
            		get layerIndices() {
            				return this._layerIndices;
            		}
            		set parameters(value) {
            				this._parameters = value;
            		}
            		get parameters() {
            				return this._parameters;
            		}
            		set targets(value) {
            				this._targets = value;
            		}
            		get targets() {
            				return this._targets;
            		}
            		get playable() {
            				for(var i = 0; i < this._layers.length; i++){
            						if (!this._layers[i].playable) {
            								return false;
            						}
            				}
            				return true;
            		}
            		get baseLayer() {
            				if (this._layers.length > 0) {
            						return this._layers[0];
            				}
            				return null;
            		}
            		_onStateGraphAssetChangeEvent(asset) {
            				var prevAnimationAssets = this.animationAssets;
            				var prevMasks = this.layers.map((layer)=>layer.mask);
            				this.removeStateGraph();
            				this._stateGraph = new AnimStateGraph(asset._data);
            				this.loadStateGraph(this._stateGraph);
            				this.animationAssets = prevAnimationAssets;
            				this.loadAnimationAssets();
            				this.layers.forEach((layer, i)=>{
            						layer.mask = prevMasks[i];
            				});
            				this.rebind();
            		}
            		dirtifyTargets() {
            				var targets = Object.values(this._targets);
            				for(var i = 0; i < targets.length; i++){
            						targets[i].dirty = true;
            				}
            		}
            		_addLayer(param) {
            				var { name, states, transitions, weight, mask, blendType } = param;
            				var graph;
            				if (this.rootBone) {
            						graph = this.rootBone;
            				} else {
            						graph = this.entity;
            				}
            				var layerIndex = this._layers.length;
            				var animBinder = new AnimComponentBinder(this, graph, name, mask, layerIndex);
            				var animEvaluator = new AnimEvaluator(animBinder);
            				var controller = new AnimController(animEvaluator, states, transitions, this._activate, this, this.findParameter, this.consumeTrigger);
            				this._layers.push(new AnimComponentLayer(name, controller, this, weight, blendType));
            				this._layerIndices[name] = layerIndex;
            				return this._layers[layerIndex];
            		}
            		addLayer(name, weight, mask, blendType) {
            				var layer = this.findAnimationLayer(name);
            				if (layer) return layer;
            				var states = [
            						{
            								'name': 'START',
            								'speed': 1
            						}
            				];
            				var transitions = [];
            				return this._addLayer({
            						name,
            						states,
            						transitions,
            						weight,
            						mask,
            						blendType
            				});
            		}
            		_assignParameters(stateGraph) {
            				this._parameters = {};
            				var paramKeys = Object.keys(stateGraph.parameters);
            				for(var i = 0; i < paramKeys.length; i++){
            						var paramKey = paramKeys[i];
            						this._parameters[paramKey] = {
            								type: stateGraph.parameters[paramKey].type,
            								value: stateGraph.parameters[paramKey].value
            						};
            				}
            		}
            		loadStateGraph(stateGraph) {
            				this._stateGraph = stateGraph;
            				this._assignParameters(stateGraph);
            				this._layers = [];
            				var containsBlendTree = false;
            				for(var i = 0; i < stateGraph.layers.length; i++){
            						var layer = stateGraph.layers[i];
            						this._addLayer(_extends$9({}, layer));
            						if (layer.states.some((state)=>state.blendTree)) {
            								containsBlendTree = true;
            						}
            				}
            				if (!containsBlendTree) {
            						this.setupAnimationAssets();
            				}
            		}
            		setupAnimationAssets() {
            				for(var i = 0; i < this._layers.length; i++){
            						var layer = this._layers[i];
            						var layerName = layer.name;
            						for(var j = 0; j < layer.states.length; j++){
            								var stateName = layer.states[j];
            								if (ANIM_CONTROL_STATES.indexOf(stateName) === -1) {
            										var stateKey = layerName + ":" + stateName;
            										if (!this._animationAssets[stateKey]) {
            												this._animationAssets[stateKey] = {
            														asset: null
            												};
            										}
            								}
            						}
            				}
            				this.loadAnimationAssets();
            		}
            		loadAnimationAssets() {
            				for(var i = 0; i < this._layers.length; i++){
            						var layer = this._layers[i];
            						for(var j = 0; j < layer.states.length; j++){
            								var stateName = layer.states[j];
            								if (ANIM_CONTROL_STATES.indexOf(stateName) !== -1) continue;
            								var animationAsset = this._animationAssets[layer.name + ":" + stateName];
            								if (!animationAsset || !animationAsset.asset) {
            										this.findAnimationLayer(layer.name).assignAnimation(stateName, AnimTrack.EMPTY);
            										continue;
            								}
            								var assetId = animationAsset.asset;
            								var asset = this.system.app.assets.get(assetId);
            								if (asset) {
            										if (asset.resource) {
            												this.onAnimationAssetLoaded(layer.name, stateName, asset);
            										} else {
            												asset.once('load', (function(layerName, stateName) {
            														return (function(asset) {
            																this.onAnimationAssetLoaded(layerName, stateName, asset);
            														}).bind(this);
            												}).bind(this)(layer.name, stateName));
            												this.system.app.assets.load(asset);
            										}
            								}
            						}
            				}
            		}
            		onAnimationAssetLoaded(layerName, stateName, asset) {
            				this.findAnimationLayer(layerName).assignAnimation(stateName, asset.resource);
            		}
            		removeStateGraph() {
            				this._stateGraph = null;
            				this._stateGraphAsset = null;
            				this._animationAssets = {};
            				this._layers = [];
            				this._layerIndices = {};
            				this._parameters = {};
            				this._playing = false;
            				this.unbind();
            				this._targets = {};
            		}
            		reset() {
            				this._assignParameters(this._stateGraph);
            				for(var i = 0; i < this._layers.length; i++){
            						var layerPlaying = this._layers[i].playing;
            						this._layers[i].reset();
            						this._layers[i].playing = layerPlaying;
            				}
            		}
            		unbind() {
            				if (!this._normalizeWeights) {
            						Object.keys(this._targets).forEach((targetKey)=>{
            								this._targets[targetKey].unbind();
            						});
            				}
            		}
            		rebind() {
            				this._targets = {};
            				for(var i = 0; i < this._layers.length; i++){
            						this._layers[i].rebind();
            				}
            		}
            		findAnimationLayer(name) {
            				var layerIndex = this._layerIndices[name];
            				return this._layers[layerIndex] || null;
            		}
            		addAnimationState(nodeName, animTrack, speed, loop, layerName) {
            				if (speed === void 0) speed = 1;
            				if (loop === void 0) loop = true;
            				if (layerName === void 0) layerName = 'Base';
            				if (!this._stateGraph) {
            						this.loadStateGraph(new AnimStateGraph({
            								'layers': [
            										{
            												'name': layerName,
            												'states': [
            														{
            																'name': 'START',
            																'speed': 1
            														},
            														{
            																'name': nodeName,
            																'speed': speed,
            																'loop': loop,
            																'defaultState': true
            														}
            												],
            												'transitions': [
            														{
            																'from': 'START',
            																'to': nodeName
            														}
            												]
            										}
            								],
            								'parameters': {}
            						}));
            				}
            				var layer = this.findAnimationLayer(layerName);
            				if (layer) {
            						layer.assignAnimation(nodeName, animTrack, speed, loop);
            				} else {
            						var _this_addLayer;
            						(_this_addLayer = this.addLayer(layerName)) == null ? void 0 : _this_addLayer.assignAnimation(nodeName, animTrack, speed, loop);
            				}
            		}
            		assignAnimation(nodePath, animTrack, layerName, speed, loop) {
            				if (speed === void 0) speed = 1;
            				if (loop === void 0) loop = true;
            				if (!this._stateGraph && nodePath.indexOf('.') === -1) {
            						this.loadStateGraph(new AnimStateGraph({
            								'layers': [
            										{
            												'name': 'Base',
            												'states': [
            														{
            																'name': 'START',
            																'speed': 1
            														},
            														{
            																'name': nodePath,
            																'speed': speed,
            																'loop': loop,
            																'defaultState': true
            														}
            												],
            												'transitions': [
            														{
            																'from': 'START',
            																'to': nodePath
            														}
            												]
            										}
            								],
            								'parameters': {}
            						}));
            						this.baseLayer.assignAnimation(nodePath, animTrack);
            						return;
            				}
            				var layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;
            				if (!layer) {
            						return;
            				}
            				layer.assignAnimation(nodePath, animTrack, speed, loop);
            		}
            		removeNodeAnimations(nodeName, layerName) {
            				var layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;
            				if (!layer) {
            						return;
            				}
            				layer.removeNodeAnimations(nodeName);
            		}
            		getParameterValue(name, type) {
            				var param = this._parameters[name];
            				if (param && param.type === type) {
            						return param.value;
            				}
            				return undefined;
            		}
            		setParameterValue(name, type, value) {
            				var param = this._parameters[name];
            				if (param && param.type === type) {
            						param.value = value;
            						return;
            				}
            		}
            		getFloat(name) {
            				return this.getParameterValue(name, ANIM_PARAMETER_FLOAT);
            		}
            		setFloat(name, value) {
            				this.setParameterValue(name, ANIM_PARAMETER_FLOAT, value);
            		}
            		getInteger(name) {
            				return this.getParameterValue(name, ANIM_PARAMETER_INTEGER);
            		}
            		setInteger(name, value) {
            				if (typeof value === 'number' && value % 1 === 0) {
            						this.setParameterValue(name, ANIM_PARAMETER_INTEGER, value);
            				}
            		}
            		getBoolean(name) {
            				return this.getParameterValue(name, ANIM_PARAMETER_BOOLEAN);
            		}
            		setBoolean(name, value) {
            				this.setParameterValue(name, ANIM_PARAMETER_BOOLEAN, !!value);
            		}
            		getTrigger(name) {
            				return this.getParameterValue(name, ANIM_PARAMETER_TRIGGER);
            		}
            		setTrigger(name, singleFrame) {
            				if (singleFrame === void 0) singleFrame = false;
            				this.setParameterValue(name, ANIM_PARAMETER_TRIGGER, true);
            				if (singleFrame) {
            						this._consumedTriggers.add(name);
            				}
            		}
            		resetTrigger(name) {
            				this.setParameterValue(name, ANIM_PARAMETER_TRIGGER, false);
            		}
            		onBeforeRemove() {
            				if (Number.isFinite(this._stateGraphAsset)) {
            						var stateGraphAsset = this.system.app.assets.get(this._stateGraphAsset);
            						stateGraphAsset.off('change', this._onStateGraphAssetChangeEvent, this);
            				}
            		}
            		update(dt) {
            				for(var i = 0; i < this.layers.length; i++){
            						this.layers[i].update(dt * this.speed);
            				}
            				this._consumedTriggers.forEach((trigger)=>{
            						this.parameters[trigger].value = false;
            				});
            				this._consumedTriggers.clear();
            		}
            		resolveDuplicatedEntityReferenceProperties(oldAnim, duplicatedIdsMap) {
            				if (oldAnim.rootBone && duplicatedIdsMap[oldAnim.rootBone.getGuid()]) {
            						this.rootBone = duplicatedIdsMap[oldAnim.rootBone.getGuid()];
            				} else {
            						this.rebind();
            				}
            		}
            		constructor(...args){
            				super(...args), this._stateGraphAsset = null, this._animationAssets = {}, this._speed = 1, this._activate = true, this._playing = false, this._rootBone = null, this._stateGraph = null, this._layers = [], this._layerIndices = {}, this._parameters = {}, this._targets = {}, this._consumedTriggers = new Set(), this._normalizeWeights = false, this.findParameter = (name)=>{
            						return this._parameters[name];
            				}, this.consumeTrigger = (name)=>{
            						this._consumedTriggers.add(name);
            				};
            		}
            }
            
            class AnimComponentData {
            		constructor(){
            				this.enabled = true;
            		}
            }
            
            var _schema$j = [
            		'enabled'
            ];
            class AnimComponentSystem extends ComponentSystem {
            		initializeComponentData(component, data, properties) {
            				super.initializeComponentData(component, data, _schema$j);
            				var complexProperties = [
            						'animationAssets',
            						'stateGraph',
            						'layers',
            						'masks'
            				];
            				Object.keys(data).forEach((key)=>{
            						if (complexProperties.includes(key)) return;
            						component[key] = data[key];
            				});
            				if (data.stateGraph) {
            						component.stateGraph = data.stateGraph;
            						component.loadStateGraph(component.stateGraph);
            				}
            				if (data.layers) {
            						data.layers.forEach((layer, i)=>{
            								layer._controller.states.forEach((stateKey)=>{
            										layer._controller._states[stateKey]._animationList.forEach((node)=>{
            												if (!node.animTrack || node.animTrack === AnimTrack.EMPTY) {
            														var animationAsset = this.app.assets.get(layer._component._animationAssets[layer.name + ":" + node.name].asset);
            														if (animationAsset && !animationAsset.loaded) {
            																animationAsset.once('load', ()=>{
            																		component.layers[i].assignAnimation(node.name, animationAsset.resource);
            																});
            														}
            												} else {
            														component.layers[i].assignAnimation(node.name, node.animTrack);
            												}
            										});
            								});
            						});
            				}
            				if (data.animationAssets) {
            						component.animationAssets = Object.assign(component.animationAssets, data.animationAssets);
            				}
            				if (data.masks) {
            						Object.keys(data.masks).forEach((key)=>{
            								if (component.layers[key]) {
            										var maskData = data.masks[key].mask;
            										var mask = {};
            										Object.keys(maskData).forEach((maskKey)=>{
            												mask[decodeURI(maskKey)] = maskData[maskKey];
            										});
            										component.layers[key].mask = mask;
            								}
            						});
            				}
            		}
            		onAnimationUpdate(dt) {
            				var components = this.store;
            				for(var id in components){
            						if (components.hasOwnProperty(id)) {
            								var component = components[id].entity.anim;
            								var componentData = component.data;
            								if (componentData.enabled && component.entity.enabled && component.playing) {
            										component.update(dt);
            								}
            						}
            				}
            		}
            		cloneComponent(entity, clone) {
            				var masks;
            				if (!entity.anim.rootBone || entity.anim.rootBone === entity) {
            						masks = {};
            						entity.anim.layers.forEach((layer, i)=>{
            								if (layer.mask) {
            										var mask = {};
            										Object.keys(layer.mask).forEach((path)=>{
            												var pathArr = path.split('/');
            												pathArr.shift();
            												var clonePath = [
            														clone.name,
            														...pathArr
            												].join('/');
            												mask[clonePath] = layer.mask[path];
            										});
            										masks[i] = {
            												mask
            										};
            								}
            						});
            				}
            				var data = {
            						enabled: entity.anim.enabled,
            						stateGraphAsset: entity.anim.stateGraphAsset,
            						animationAssets: entity.anim.animationAssets,
            						speed: entity.anim.speed,
            						activate: entity.anim.activate,
            						playing: entity.anim.playing,
            						rootBone: entity.anim.rootBone,
            						stateGraph: entity.anim.stateGraph,
            						layers: entity.anim.layers,
            						layerIndices: entity.anim.layerIndices,
            						parameters: entity.anim.parameters,
            						normalizeWeights: entity.anim.normalizeWeights,
            						masks
            				};
            				return this.addComponent(clone, data);
            		}
            		onBeforeRemove(entity, component) {
            				component.onBeforeRemove();
            		}
            		destroy() {
            				super.destroy();
            				this.app.systems.off('animationUpdate', this.onAnimationUpdate, this);
            		}
            		constructor(app){
            				super(app);
            				this.id = 'anim';
            				this.ComponentType = AnimComponent;
            				this.DataType = AnimComponentData;
            				this.schema = _schema$j;
            				this.on('beforeremove', this.onBeforeRemove, this);
            				this.app.systems.on('animationUpdate', this.onAnimationUpdate, this);
            		}
            }
            Component._buildAccessors(AnimComponent.prototype, _schema$j);
            
            class AudioListenerComponent extends Component {
            		setCurrentListener() {
            				if (this.enabled && this.entity.audiolistener && this.entity.enabled) {
            						this.system.current = this.entity;
            						var position = this.system.current.getPosition();
            						this.system.manager.listener.setPosition(position);
            				}
            		}
            		onEnable() {
            				this.setCurrentListener();
            		}
            		onDisable() {
            				if (this.system.current === this.entity) {
            						this.system.current = null;
            				}
            		}
            }
            
            class AudioListenerComponentData {
            		constructor(){
            				this.enabled = true;
            		}
            }
            
            var _schema$i = [
            		'enabled'
            ];
            class AudioListenerComponentSystem extends ComponentSystem {
            		initializeComponentData(component, data, properties) {
            				properties = [
            						'enabled'
            				];
            				super.initializeComponentData(component, data, properties);
            		}
            		onUpdate(dt) {
            				if (this.current) {
            						var position = this.current.getPosition();
            						this.manager.listener.setPosition(position);
            						var wtm = this.current.getWorldTransform();
            						this.manager.listener.setOrientation(wtm);
            				}
            		}
            		destroy() {
            				super.destroy();
            				this.app.systems.off('update', this.onUpdate, this);
            		}
            		constructor(app){
            				super(app);
            				this.id = 'audiolistener';
            				this.ComponentType = AudioListenerComponent;
            				this.DataType = AudioListenerComponentData;
            				this.schema = _schema$i;
            				this.manager = app.soundManager;
            				this.current = null;
            				this.app.systems.on('update', this.onUpdate, this);
            		}
            }
            Component._buildAccessors(AudioListenerComponent.prototype, _schema$i);
            
            var BUTTON_TRANSITION_MODE_TINT = 0;
            var BUTTON_TRANSITION_MODE_SPRITE_CHANGE = 1;
            
            var ELEMENTTYPE_GROUP = 'group';
            var ELEMENTTYPE_IMAGE = 'image';
            var ELEMENTTYPE_TEXT = 'text';
            var FITMODE_STRETCH = 'stretch';
            var FITMODE_CONTAIN = 'contain';
            var FITMODE_COVER = 'cover';
            
            var VisualState = {
            		DEFAULT: 'DEFAULT',
            		HOVER: 'HOVER',
            		PRESSED: 'PRESSED',
            		INACTIVE: 'INACTIVE'
            };
            var STATES_TO_TINT_NAMES = {};
            STATES_TO_TINT_NAMES[VisualState.DEFAULT] = '_defaultTint';
            STATES_TO_TINT_NAMES[VisualState.HOVER] = 'hoverTint';
            STATES_TO_TINT_NAMES[VisualState.PRESSED] = 'pressedTint';
            STATES_TO_TINT_NAMES[VisualState.INACTIVE] = 'inactiveTint';
            var STATES_TO_SPRITE_ASSET_NAMES = {};
            STATES_TO_SPRITE_ASSET_NAMES[VisualState.DEFAULT] = '_defaultSpriteAsset';
            STATES_TO_SPRITE_ASSET_NAMES[VisualState.HOVER] = 'hoverSpriteAsset';
            STATES_TO_SPRITE_ASSET_NAMES[VisualState.PRESSED] = 'pressedSpriteAsset';
            STATES_TO_SPRITE_ASSET_NAMES[VisualState.INACTIVE] = 'inactiveSpriteAsset';
            var STATES_TO_SPRITE_FRAME_NAMES = {};
            STATES_TO_SPRITE_FRAME_NAMES[VisualState.DEFAULT] = '_defaultSpriteFrame';
            STATES_TO_SPRITE_FRAME_NAMES[VisualState.HOVER] = 'hoverSpriteFrame';
            STATES_TO_SPRITE_FRAME_NAMES[VisualState.PRESSED] = 'pressedSpriteFrame';
            STATES_TO_SPRITE_FRAME_NAMES[VisualState.INACTIVE] = 'inactiveSpriteFrame';
            class ButtonComponent extends Component {
            		get data() {
            				var record = this.system.store[this.entity.getGuid()];
            				return record ? record.data : null;
            		}
            		set enabled(arg) {
            				this._setValue('enabled', arg);
            		}
            		get enabled() {
            				return this.data.enabled;
            		}
            		set active(arg) {
            				this._setValue('active', arg);
            		}
            		get active() {
            				return this.data.active;
            		}
            		set imageEntity(arg) {
            				if (this._imageEntity !== arg) {
            						var isString = typeof arg === 'string';
            						if (this._imageEntity && isString && this._imageEntity.getGuid() === arg) {
            								return;
            						}
            						if (this._imageEntity) {
            								this._imageEntityUnsubscribe();
            						}
            						if (arg instanceof GraphNode) {
            								this._imageEntity = arg;
            						} else if (isString) {
            								this._imageEntity = this.system.app.getEntityFromIndex(arg) || null;
            						} else {
            								this._imageEntity = null;
            						}
            						if (this._imageEntity) {
            								this._imageEntitySubscribe();
            						}
            						if (this._imageEntity) {
            								this.data.imageEntity = this._imageEntity.getGuid();
            						} else if (isString && arg) {
            								this.data.imageEntity = arg;
            						}
            				}
            		}
            		get imageEntity() {
            				return this._imageEntity;
            		}
            		set hitPadding(arg) {
            				this._setValue('hitPadding', arg);
            		}
            		get hitPadding() {
            				return this.data.hitPadding;
            		}
            		set transitionMode(arg) {
            				this._setValue('transitionMode', arg);
            		}
            		get transitionMode() {
            				return this.data.transitionMode;
            		}
            		set hoverTint(arg) {
            				this._setValue('hoverTint', arg);
            		}
            		get hoverTint() {
            				return this.data.hoverTint;
            		}
            		set pressedTint(arg) {
            				this._setValue('pressedTint', arg);
            		}
            		get pressedTint() {
            				return this.data.pressedTint;
            		}
            		set inactiveTint(arg) {
            				this._setValue('inactiveTint', arg);
            		}
            		get inactiveTint() {
            				return this.data.inactiveTint;
            		}
            		set fadeDuration(arg) {
            				this._setValue('fadeDuration', arg);
            		}
            		get fadeDuration() {
            				return this.data.fadeDuration;
            		}
            		set hoverSpriteAsset(arg) {
            				this._setValue('hoverSpriteAsset', arg);
            		}
            		get hoverSpriteAsset() {
            				return this.data.hoverSpriteAsset;
            		}
            		set hoverSpriteFrame(arg) {
            				this._setValue('hoverSpriteFrame', arg);
            		}
            		get hoverSpriteFrame() {
            				return this.data.hoverSpriteFrame;
            		}
            		set pressedSpriteAsset(arg) {
            				this._setValue('pressedSpriteAsset', arg);
            		}
            		get pressedSpriteAsset() {
            				return this.data.pressedSpriteAsset;
            		}
            		set pressedSpriteFrame(arg) {
            				this._setValue('pressedSpriteFrame', arg);
            		}
            		get pressedSpriteFrame() {
            				return this.data.pressedSpriteFrame;
            		}
            		set inactiveSpriteAsset(arg) {
            				this._setValue('inactiveSpriteAsset', arg);
            		}
            		get inactiveSpriteAsset() {
            				return this.data.inactiveSpriteAsset;
            		}
            		set inactiveSpriteFrame(arg) {
            				this._setValue('inactiveSpriteFrame', arg);
            		}
            		get inactiveSpriteFrame() {
            				return this.data.inactiveSpriteFrame;
            		}
            		_setValue(name, value) {
            				var data = this.data;
            				var oldValue = data[name];
            				data[name] = value;
            				this.fire('set', name, oldValue, value);
            		}
            		_toggleLifecycleListeners(onOrOff, system) {
            				this[onOrOff]('set_active', this._onSetActive, this);
            				this[onOrOff]('set_transitionMode', this._onSetTransitionMode, this);
            				this[onOrOff]('set_hoverTint', this._onSetTransitionValue, this);
            				this[onOrOff]('set_pressedTint', this._onSetTransitionValue, this);
            				this[onOrOff]('set_inactiveTint', this._onSetTransitionValue, this);
            				this[onOrOff]('set_hoverSpriteAsset', this._onSetTransitionValue, this);
            				this[onOrOff]('set_hoverSpriteFrame', this._onSetTransitionValue, this);
            				this[onOrOff]('set_pressedSpriteAsset', this._onSetTransitionValue, this);
            				this[onOrOff]('set_pressedSpriteFrame', this._onSetTransitionValue, this);
            				this[onOrOff]('set_inactiveSpriteAsset', this._onSetTransitionValue, this);
            				this[onOrOff]('set_inactiveSpriteFrame', this._onSetTransitionValue, this);
            				if (onOrOff === 'on') {
            						this._evtElementAdd = this.entity.on('element:add', this._onElementComponentAdd, this);
            				} else {
            						var _this__evtElementAdd;
            						(_this__evtElementAdd = this._evtElementAdd) == null ? void 0 : _this__evtElementAdd.off();
            						this._evtElementAdd = null;
            				}
            		}
            		_onSetActive(name, oldValue, newValue) {
            				if (oldValue !== newValue) {
            						this._updateVisualState();
            				}
            		}
            		_onSetTransitionMode(name, oldValue, newValue) {
            				if (oldValue !== newValue) {
            						this._cancelTween();
            						this._resetToDefaultVisualState(oldValue);
            						this._forceReapplyVisualState();
            				}
            		}
            		_onSetTransitionValue(name, oldValue, newValue) {
            				if (oldValue !== newValue) {
            						this._forceReapplyVisualState();
            				}
            		}
            		_imageEntitySubscribe() {
            				this._evtImageEntityElementAdd = this._imageEntity.on('element:add', this._onImageElementGain, this);
            				if (this._imageEntity.element) {
            						this._onImageElementGain();
            				}
            		}
            		_imageEntityUnsubscribe() {
            				var _this__evtImageEntityElementAdd, _this__imageEntity;
            				(_this__evtImageEntityElementAdd = this._evtImageEntityElementAdd) == null ? void 0 : _this__evtImageEntityElementAdd.off();
            				this._evtImageEntityElementAdd = null;
            				if ((_this__imageEntity = this._imageEntity) == null ? void 0 : _this__imageEntity.element) {
            						this._onImageElementLose();
            				}
            		}
            		_imageEntityElementSubscribe() {
            				var element = this._imageEntity.element;
            				this._evtImageEntityElementRemove = element.once('beforeremove', this._onImageElementLose, this);
            				this._evtImageEntityElementColor = element.on('set:color', this._onSetColor, this);
            				this._evtImageEntityElementOpacity = element.on('set:opacity', this._onSetOpacity, this);
            				this._evtImageEntityElementSpriteAsset = element.on('set:spriteAsset', this._onSetSpriteAsset, this);
            				this._evtImageEntityElementSpriteFrame = element.on('set:spriteFrame', this._onSetSpriteFrame, this);
            		}
            		_imageEntityElementUnsubscribe() {
            				var _this__evtImageEntityElementRemove, _this__evtImageEntityElementColor, _this__evtImageEntityElementOpacity, _this__evtImageEntityElementSpriteAsset, _this__evtImageEntityElementSpriteFrame;
            				(_this__evtImageEntityElementRemove = this._evtImageEntityElementRemove) == null ? void 0 : _this__evtImageEntityElementRemove.off();
            				this._evtImageEntityElementRemove = null;
            				(_this__evtImageEntityElementColor = this._evtImageEntityElementColor) == null ? void 0 : _this__evtImageEntityElementColor.off();
            				this._evtImageEntityElementColor = null;
            				(_this__evtImageEntityElementOpacity = this._evtImageEntityElementOpacity) == null ? void 0 : _this__evtImageEntityElementOpacity.off();
            				this._evtImageEntityElementOpacity = null;
            				(_this__evtImageEntityElementSpriteAsset = this._evtImageEntityElementSpriteAsset) == null ? void 0 : _this__evtImageEntityElementSpriteAsset.off();
            				this._evtImageEntityElementSpriteAsset = null;
            				(_this__evtImageEntityElementSpriteFrame = this._evtImageEntityElementSpriteFrame) == null ? void 0 : _this__evtImageEntityElementSpriteFrame.off();
            				this._evtImageEntityElementSpriteFrame = null;
            		}
            		_onElementComponentRemove() {
            				this._toggleHitElementListeners('off');
            		}
            		_onElementComponentAdd() {
            				this._toggleHitElementListeners('on');
            		}
            		_onImageElementLose() {
            				this._imageEntityElementUnsubscribe();
            				this._cancelTween();
            				this._resetToDefaultVisualState(this.transitionMode);
            		}
            		_onImageElementGain() {
            				this._imageEntityElementSubscribe();
            				this._storeDefaultVisualState();
            				this._forceReapplyVisualState();
            		}
            		_toggleHitElementListeners(onOrOff) {
            				if (this.entity.element) {
            						var isAdding = onOrOff === 'on';
            						if (isAdding && this._hasHitElementListeners) {
            								return;
            						}
            						this.entity.element[onOrOff]('beforeremove', this._onElementComponentRemove, this);
            						this.entity.element[onOrOff]('mouseenter', this._onMouseEnter, this);
            						this.entity.element[onOrOff]('mouseleave', this._onMouseLeave, this);
            						this.entity.element[onOrOff]('mousedown', this._onMouseDown, this);
            						this.entity.element[onOrOff]('mouseup', this._onMouseUp, this);
            						this.entity.element[onOrOff]('touchstart', this._onTouchStart, this);
            						this.entity.element[onOrOff]('touchend', this._onTouchEnd, this);
            						this.entity.element[onOrOff]('touchleave', this._onTouchLeave, this);
            						this.entity.element[onOrOff]('touchcancel', this._onTouchCancel, this);
            						this.entity.element[onOrOff]('selectstart', this._onSelectStart, this);
            						this.entity.element[onOrOff]('selectend', this._onSelectEnd, this);
            						this.entity.element[onOrOff]('selectenter', this._onSelectEnter, this);
            						this.entity.element[onOrOff]('selectleave', this._onSelectLeave, this);
            						this.entity.element[onOrOff]('click', this._onClick, this);
            						this._hasHitElementListeners = isAdding;
            				}
            		}
            		_storeDefaultVisualState() {
            				var _this__imageEntity;
            				var element = (_this__imageEntity = this._imageEntity) == null ? void 0 : _this__imageEntity.element;
            				if (!element || element.type === ELEMENTTYPE_GROUP) {
            						return;
            				}
            				this._storeDefaultColor(element.color);
            				this._storeDefaultOpacity(element.opacity);
            				this._storeDefaultSpriteAsset(element.spriteAsset);
            				this._storeDefaultSpriteFrame(element.spriteFrame);
            		}
            		_storeDefaultColor(color) {
            				this._defaultTint.r = color.r;
            				this._defaultTint.g = color.g;
            				this._defaultTint.b = color.b;
            		}
            		_storeDefaultOpacity(opacity) {
            				this._defaultTint.a = opacity;
            		}
            		_storeDefaultSpriteAsset(spriteAsset) {
            				this._defaultSpriteAsset = spriteAsset;
            		}
            		_storeDefaultSpriteFrame(spriteFrame) {
            				this._defaultSpriteFrame = spriteFrame;
            		}
            		_onSetColor(color) {
            				if (!this._isApplyingTint) {
            						this._storeDefaultColor(color);
            						this._forceReapplyVisualState();
            				}
            		}
            		_onSetOpacity(opacity) {
            				if (!this._isApplyingTint) {
            						this._storeDefaultOpacity(opacity);
            						this._forceReapplyVisualState();
            				}
            		}
            		_onSetSpriteAsset(spriteAsset) {
            				if (!this._isApplyingSprite) {
            						this._storeDefaultSpriteAsset(spriteAsset);
            						this._forceReapplyVisualState();
            				}
            		}
            		_onSetSpriteFrame(spriteFrame) {
            				if (!this._isApplyingSprite) {
            						this._storeDefaultSpriteFrame(spriteFrame);
            						this._forceReapplyVisualState();
            				}
            		}
            		_onMouseEnter(event) {
            				this._isHovering = true;
            				this._updateVisualState();
            				this._fireIfActive('mouseenter', event);
            		}
            		_onMouseLeave(event) {
            				this._isHovering = false;
            				this._isPressed = false;
            				this._updateVisualState();
            				this._fireIfActive('mouseleave', event);
            		}
            		_onMouseDown(event) {
            				this._isPressed = true;
            				this._updateVisualState();
            				this._fireIfActive('mousedown', event);
            		}
            		_onMouseUp(event) {
            				this._isPressed = false;
            				this._updateVisualState();
            				this._fireIfActive('mouseup', event);
            		}
            		_onTouchStart(event) {
            				this._isPressed = true;
            				this._updateVisualState();
            				this._fireIfActive('touchstart', event);
            		}
            		_onTouchEnd(event) {
            				event.event.preventDefault();
            				this._isPressed = false;
            				this._updateVisualState();
            				this._fireIfActive('touchend', event);
            		}
            		_onTouchLeave(event) {
            				this._isPressed = false;
            				this._updateVisualState();
            				this._fireIfActive('touchleave', event);
            		}
            		_onTouchCancel(event) {
            				this._isPressed = false;
            				this._updateVisualState();
            				this._fireIfActive('touchcancel', event);
            		}
            		_onSelectStart(event) {
            				this._isPressed = true;
            				this._updateVisualState();
            				this._fireIfActive('selectstart', event);
            		}
            		_onSelectEnd(event) {
            				this._isPressed = false;
            				this._updateVisualState();
            				this._fireIfActive('selectend', event);
            		}
            		_onSelectEnter(event) {
            				this._hoveringCounter++;
            				if (this._hoveringCounter === 1) {
            						this._isHovering = true;
            						this._updateVisualState();
            				}
            				this._fireIfActive('selectenter', event);
            		}
            		_onSelectLeave(event) {
            				this._hoveringCounter--;
            				if (this._hoveringCounter === 0) {
            						this._isHovering = false;
            						this._isPressed = false;
            						this._updateVisualState();
            				}
            				this._fireIfActive('selectleave', event);
            		}
            		_onClick(event) {
            				this._fireIfActive('click', event);
            		}
            		_fireIfActive(name, event) {
            				if (this.data.active) {
            						this.fire(name, event);
            				}
            		}
            		_updateVisualState(force) {
            				var oldVisualState = this._visualState;
            				var newVisualState = this._determineVisualState();
            				if ((oldVisualState !== newVisualState || force) && this.enabled) {
            						this._visualState = newVisualState;
            						if (oldVisualState === VisualState.HOVER) {
            								this._fireIfActive('hoverend');
            						}
            						if (oldVisualState === VisualState.PRESSED) {
            								this._fireIfActive('pressedend');
            						}
            						if (newVisualState === VisualState.HOVER) {
            								this._fireIfActive('hoverstart');
            						}
            						if (newVisualState === VisualState.PRESSED) {
            								this._fireIfActive('pressedstart');
            						}
            						switch(this.transitionMode){
            								case BUTTON_TRANSITION_MODE_TINT:
            										{
            												var tintName = STATES_TO_TINT_NAMES[this._visualState];
            												var tintColor = this[tintName];
            												this._applyTint(tintColor);
            												break;
            										}
            								case BUTTON_TRANSITION_MODE_SPRITE_CHANGE:
            										{
            												var spriteAssetName = STATES_TO_SPRITE_ASSET_NAMES[this._visualState];
            												var spriteFrameName = STATES_TO_SPRITE_FRAME_NAMES[this._visualState];
            												var spriteAsset = this[spriteAssetName];
            												var spriteFrame = this[spriteFrameName];
            												this._applySprite(spriteAsset, spriteFrame);
            												break;
            										}
            						}
            				}
            		}
            		_forceReapplyVisualState() {
            				this._updateVisualState(true);
            		}
            		_resetToDefaultVisualState(transitionMode) {
            				var _this__imageEntity;
            				if (!((_this__imageEntity = this._imageEntity) == null ? void 0 : _this__imageEntity.element)) {
            						return;
            				}
            				switch(transitionMode){
            						case BUTTON_TRANSITION_MODE_TINT:
            								this._cancelTween();
            								this._applyTintImmediately(this._defaultTint);
            								break;
            						case BUTTON_TRANSITION_MODE_SPRITE_CHANGE:
            								this._applySprite(this._defaultSpriteAsset, this._defaultSpriteFrame);
            								break;
            				}
            		}
            		_determineVisualState() {
            				if (!this.active) {
            						return VisualState.INACTIVE;
            				} else if (this._isPressed) {
            						return VisualState.PRESSED;
            				} else if (this._isHovering) {
            						return VisualState.HOVER;
            				}
            				return VisualState.DEFAULT;
            		}
            		_applySprite(spriteAsset, spriteFrame) {
            				var _this__imageEntity;
            				var element = (_this__imageEntity = this._imageEntity) == null ? void 0 : _this__imageEntity.element;
            				if (!element) {
            						return;
            				}
            				spriteFrame = spriteFrame || 0;
            				this._isApplyingSprite = true;
            				if (element.spriteAsset !== spriteAsset) {
            						element.spriteAsset = spriteAsset;
            				}
            				if (element.spriteFrame !== spriteFrame) {
            						element.spriteFrame = spriteFrame;
            				}
            				this._isApplyingSprite = false;
            		}
            		_applyTint(tintColor) {
            				this._cancelTween();
            				if (this.fadeDuration === 0) {
            						this._applyTintImmediately(tintColor);
            				} else {
            						this._applyTintWithTween(tintColor);
            				}
            		}
            		_applyTintImmediately(tintColor) {
            				var _this__imageEntity;
            				var element = (_this__imageEntity = this._imageEntity) == null ? void 0 : _this__imageEntity.element;
            				if (!tintColor || !element || element.type === ELEMENTTYPE_GROUP) {
            						return;
            				}
            				var color3 = toColor3(tintColor);
            				this._isApplyingTint = true;
            				if (!color3.equals(element.color)) {
            						element.color = color3;
            				}
            				if (element.opacity !== tintColor.a) {
            						element.opacity = tintColor.a;
            				}
            				this._isApplyingTint = false;
            		}
            		_applyTintWithTween(tintColor) {
            				var _this__imageEntity;
            				var element = (_this__imageEntity = this._imageEntity) == null ? void 0 : _this__imageEntity.element;
            				if (!tintColor || !element || element.type === ELEMENTTYPE_GROUP) {
            						return;
            				}
            				var color3 = toColor3(tintColor);
            				var color = element.color;
            				var opacity = element.opacity;
            				if (color3.equals(color) && tintColor.a === opacity) return;
            				this._tweenInfo = {
            						startTime: now(),
            						from: new Color(color.r, color.g, color.b, opacity),
            						to: tintColor.clone(),
            						lerpColor: new Color()
            				};
            		}
            		_updateTintTween() {
            				var elapsedTime = now() - this._tweenInfo.startTime;
            				var elapsedProportion = this.fadeDuration === 0 ? 1 : elapsedTime / this.fadeDuration;
            				elapsedProportion = math.clamp(elapsedProportion, 0, 1);
            				if (Math.abs(elapsedProportion - 1) > 1e-5) {
            						var lerpColor = this._tweenInfo.lerpColor;
            						lerpColor.lerp(this._tweenInfo.from, this._tweenInfo.to, elapsedProportion);
            						this._applyTintImmediately(new Color(lerpColor.r, lerpColor.g, lerpColor.b, lerpColor.a));
            				} else {
            						this._applyTintImmediately(this._tweenInfo.to);
            						this._cancelTween();
            				}
            		}
            		_cancelTween() {
            				delete this._tweenInfo;
            		}
            		onUpdate() {
            				if (this._tweenInfo) {
            						this._updateTintTween();
            				}
            		}
            		onEnable() {
            				this._isHovering = false;
            				this._hoveringCounter = 0;
            				this._isPressed = false;
            				this._toggleHitElementListeners('on');
            				this._forceReapplyVisualState();
            		}
            		onDisable() {
            				this._toggleHitElementListeners('off');
            				this._resetToDefaultVisualState(this.transitionMode);
            		}
            		onRemove() {
            				this._imageEntityUnsubscribe();
            				this._toggleLifecycleListeners('off', this.system);
            				this.onDisable();
            		}
            		resolveDuplicatedEntityReferenceProperties(oldButton, duplicatedIdsMap) {
            				if (oldButton.imageEntity) {
            						this.imageEntity = duplicatedIdsMap[oldButton.imageEntity.getGuid()];
            				}
            		}
            		constructor(system, entity){
            				super(system, entity), this._visualState = VisualState.DEFAULT, this._isHovering = false, this._hoveringCounter = 0, this._isPressed = false, this._defaultTint = new Color(1, 1, 1, 1), this._defaultSpriteAsset = null, this._defaultSpriteFrame = 0, this._imageEntity = null, this._evtElementAdd = null, this._evtImageEntityElementAdd = null, this._evtImageEntityElementRemove = null, this._evtImageEntityElementColor = null, this._evtImageEntityElementOpacity = null, this._evtImageEntityElementSpriteAsset = null, this._evtImageEntityElementSpriteFrame = null;
            				this._visualState = VisualState.DEFAULT;
            				this._isHovering = false;
            				this._hoveringCounter = 0;
            				this._isPressed = false;
            				this._defaultTint = new Color(1, 1, 1, 1);
            				this._defaultSpriteAsset = null;
            				this._defaultSpriteFrame = 0;
            				this._toggleLifecycleListeners('on', system);
            		}
            }
            ButtonComponent.EVENT_MOUSEDOWN = 'mousedown';
            ButtonComponent.EVENT_MOUSEUP = 'mouseup';
            ButtonComponent.EVENT_MOUSEENTER = 'mouseenter';
            ButtonComponent.EVENT_MOUSELEAVE = 'mouseleave';
            ButtonComponent.EVENT_CLICK = 'click';
            ButtonComponent.EVENT_TOUCHSTART = 'touchstart';
            ButtonComponent.EVENT_TOUCHEND = 'touchend';
            ButtonComponent.EVENT_TOUCHCANCEL = 'touchcancel';
            ButtonComponent.EVENT_TOUCHLEAVE = 'touchleave';
            ButtonComponent.EVENT_SELECTSTART = 'selectstart';
            ButtonComponent.EVENT_SELECTEND = 'selectend';
            ButtonComponent.EVENT_SELECTENTER = 'selectenter';
            ButtonComponent.EVENT_SELECTLEAVE = 'selectleave';
            ButtonComponent.EVENT_HOVERSTART = 'hoverstart';
            ButtonComponent.EVENT_HOVEREND = 'hoverend';
            ButtonComponent.EVENT_PRESSEDSTART = 'pressedstart';
            ButtonComponent.EVENT_PRESSEDEND = 'pressedend';
            function toColor3(color4) {
            		return new Color(color4.r, color4.g, color4.b);
            }
            
            class ButtonComponentData {
            		constructor(){
            				this.enabled = true;
            				this.active = true;
            				this.imageEntity = null;
            				this.hitPadding = new Vec4();
            				this.transitionMode = BUTTON_TRANSITION_MODE_TINT;
            				this.hoverTint = new Color(0.75, 0.75, 0.75);
            				this.pressedTint = new Color(0.5, 0.5, 0.5);
            				this.inactiveTint = new Color(0.25, 0.25, 0.25);
            				this.fadeDuration = 0;
            				this.hoverSpriteAsset = null;
            				this.hoverSpriteFrame = 0;
            				this.pressedSpriteAsset = null;
            				this.pressedSpriteFrame = 0;
            				this.inactiveSpriteAsset = null;
            				this.inactiveSpriteFrame = 0;
            		}
            }
            
            var _schema$h = [
            		'enabled',
            		'active',
            		{
            				name: 'hitPadding',
            				type: 'vec4'
            		},
            		'transitionMode',
            		{
            				name: 'hoverTint',
            				type: 'rgba'
            		},
            		{
            				name: 'pressedTint',
            				type: 'rgba'
            		},
            		{
            				name: 'inactiveTint',
            				type: 'rgba'
            		},
            		'fadeDuration',
            		'hoverSpriteAsset',
            		'hoverSpriteFrame',
            		'pressedSpriteAsset',
            		'pressedSpriteFrame',
            		'inactiveSpriteAsset',
            		'inactiveSpriteFrame'
            ];
            class ButtonComponentSystem extends ComponentSystem {
            		initializeComponentData(component, data, properties) {
            				component.imageEntity = data.imageEntity;
            				super.initializeComponentData(component, data, _schema$h);
            		}
            		onUpdate(dt) {
            				var components = this.store;
            				for(var id in components){
            						var entity = components[id].entity;
            						var component = entity.button;
            						if (component.enabled && entity.enabled) {
            								component.onUpdate();
            						}
            				}
            		}
            		_onRemoveComponent(entity, component) {
            				component.onRemove();
            		}
            		destroy() {
            				super.destroy();
            				this.app.systems.off('update', this.onUpdate, this);
            		}
            		constructor(app){
            				super(app);
            				this.id = 'button';
            				this.ComponentType = ButtonComponent;
            				this.DataType = ButtonComponentData;
            				this.schema = _schema$h;
            				this.on('beforeremove', this._onRemoveComponent, this);
            				this.app.systems.on('update', this.onUpdate, this);
            		}
            }
            
            var _vec3$1 = new Vec3();
            var _quat = new Quat();
            class CollisionComponent extends Component {
            		get data() {
            				var record = this.system.store[this.entity.getGuid()];
            				return record ? record.data : null;
            		}
            		set enabled(arg) {
            				this._setValue('enabled', arg);
            		}
            		get enabled() {
            				return this.data.enabled;
            		}
            		set type(arg) {
            				this._setValue('type', arg);
            		}
            		get type() {
            				return this.data.type;
            		}
            		set halfExtents(arg) {
            				this._setValue('halfExtents', arg);
            		}
            		get halfExtents() {
            				return this.data.halfExtents;
            		}
            		set linearOffset(arg) {
            				this._setValue('linearOffset', arg);
            		}
            		get linearOffset() {
            				return this.data.linearOffset;
            		}
            		set angularOffset(arg) {
            				this._setValue('angularOffset', arg);
            		}
            		get angularOffset() {
            				return this.data.angularOffset;
            		}
            		set radius(arg) {
            				this._setValue('radius', arg);
            		}
            		get radius() {
            				return this.data.radius;
            		}
            		set axis(arg) {
            				this._setValue('axis', arg);
            		}
            		get axis() {
            				return this.data.axis;
            		}
            		set height(arg) {
            				this._setValue('height', arg);
            		}
            		get height() {
            				return this.data.height;
            		}
            		set asset(arg) {
            				this._setValue('asset', arg);
            		}
            		get asset() {
            				return this.data.asset;
            		}
            		set renderAsset(arg) {
            				this._setValue('renderAsset', arg);
            		}
            		get renderAsset() {
            				return this.data.renderAsset;
            		}
            		set convexHull(arg) {
            				this._setValue('convexHull', arg);
            		}
            		get convexHull() {
            				return this.data.convexHull;
            		}
            		set shape(arg) {
            				this._setValue('shape', arg);
            		}
            		get shape() {
            				return this.data.shape;
            		}
            		set model(arg) {
            				this._setValue('model', arg);
            		}
            		get model() {
            				return this.data.model;
            		}
            		set render(arg) {
            				this._setValue('render', arg);
            		}
            		get render() {
            				return this.data.render;
            		}
            		set checkVertexDuplicates(arg) {
            				this._setValue('checkVertexDuplicates', arg);
            		}
            		get checkVertexDuplicates() {
            				return this.data.checkVertexDuplicates;
            		}
            		_setValue(name, value) {
            				var data = this.data;
            				var oldValue = data[name];
            				data[name] = value;
            				this.fire('set', name, oldValue, value);
            		}
            		onSetType(name, oldValue, newValue) {
            				if (oldValue !== newValue) {
            						this.system.changeType(this, oldValue, newValue);
            				}
            		}
            		onSetHalfExtents(name, oldValue, newValue) {
            				var t = this.data.type;
            				if (this.data.initialized && t === 'box') {
            						this.system.recreatePhysicalShapes(this);
            				}
            		}
            		onSetOffset(name, oldValue, newValue) {
            				this._hasOffset = !this.data.linearOffset.equals(Vec3.ZERO) || !this.data.angularOffset.equals(Quat.IDENTITY);
            				if (this.data.initialized) {
            						this.system.recreatePhysicalShapes(this);
            				}
            		}
            		onSetRadius(name, oldValue, newValue) {
            				var t = this.data.type;
            				if (this.data.initialized && (t === 'sphere' || t === 'capsule' || t === 'cylinder' || t === 'cone')) {
            						this.system.recreatePhysicalShapes(this);
            				}
            		}
            		onSetHeight(name, oldValue, newValue) {
            				var t = this.data.type;
            				if (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {
            						this.system.recreatePhysicalShapes(this);
            				}
            		}
            		onSetAxis(name, oldValue, newValue) {
            				var t = this.data.type;
            				if (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {
            						this.system.recreatePhysicalShapes(this);
            				}
            		}
            		onSetAsset(name, oldValue, newValue) {
            				var assets = this.system.app.assets;
            				if (oldValue) {
            						var asset = assets.get(oldValue);
            						if (asset) {
            								asset.off('remove', this.onAssetRemoved, this);
            						}
            				}
            				if (newValue) {
            						if (newValue instanceof Asset) {
            								this.data.asset = newValue.id;
            						}
            						var asset1 = assets.get(this.data.asset);
            						if (asset1) {
            								asset1.off('remove', this.onAssetRemoved, this);
            								asset1.on('remove', this.onAssetRemoved, this);
            						}
            				}
            				if (this.data.initialized && this.data.type === 'mesh') {
            						if (!newValue) {
            								this.data.model = null;
            						}
            						this.system.recreatePhysicalShapes(this);
            				}
            		}
            		onSetRenderAsset(name, oldValue, newValue) {
            				var assets = this.system.app.assets;
            				if (oldValue) {
            						var asset = assets.get(oldValue);
            						if (asset) {
            								asset.off('remove', this.onRenderAssetRemoved, this);
            						}
            				}
            				if (newValue) {
            						if (newValue instanceof Asset) {
            								this.data.renderAsset = newValue.id;
            						}
            						var asset1 = assets.get(this.data.renderAsset);
            						if (asset1) {
            								asset1.off('remove', this.onRenderAssetRemoved, this);
            								asset1.on('remove', this.onRenderAssetRemoved, this);
            						}
            				}
            				if (this.data.initialized && this.data.type === 'mesh') {
            						if (!newValue) {
            								this.data.render = null;
            						}
            						this.system.recreatePhysicalShapes(this);
            				}
            		}
            		onSetModel(name, oldValue, newValue) {
            				if (this.data.initialized && this.data.type === 'mesh') {
            						this.system.implementations.mesh.doRecreatePhysicalShape(this);
            				}
            		}
            		onSetRender(name, oldValue, newValue) {
            				this.onSetModel(name, oldValue, newValue);
            		}
            		onAssetRemoved(asset) {
            				asset.off('remove', this.onAssetRemoved, this);
            				if (this.data.asset === asset.id) {
            						this.asset = null;
            				}
            		}
            		onRenderAssetRemoved(asset) {
            				asset.off('remove', this.onRenderAssetRemoved, this);
            				if (this.data.renderAsset === asset.id) {
            						this.renderAsset = null;
            				}
            		}
            		getCompoundChildShapeIndex(shape) {
            				var compound = this.data.shape;
            				var shapes = compound.getNumChildShapes();
            				for(var i = 0; i < shapes; i++){
            						var childShape = compound.getChildShape(i);
            						if (Ammo.getPointer(childShape) === Ammo.getPointer(shape)) {
            								return i;
            						}
            				}
            				return null;
            		}
            		_onInsert(parent) {
            				if (typeof Ammo === 'undefined') {
            						return;
            				}
            				if (this._compoundParent) {
            						this.system.recreatePhysicalShapes(this);
            				} else if (!this.entity.rigidbody) {
            						var ancestor = this.entity.parent;
            						while(ancestor){
            								if (ancestor.collision && ancestor.collision.type === 'compound') {
            										if (ancestor.collision.shape.getNumChildShapes() === 0) {
            												this.system.recreatePhysicalShapes(ancestor.collision);
            										} else {
            												this.system.recreatePhysicalShapes(this);
            										}
            										break;
            								}
            								ancestor = ancestor.parent;
            						}
            				}
            		}
            		_updateCompound() {
            				var entity = this.entity;
            				if (entity._dirtyWorld) {
            						var dirty = entity._dirtyLocal;
            						var parent = entity;
            						while(parent && !dirty){
            								if (parent.collision && parent.collision === this._compoundParent) {
            										break;
            								}
            								if (parent._dirtyLocal) {
            										dirty = true;
            								}
            								parent = parent.parent;
            						}
            						if (dirty) {
            								entity.forEach(this.system.implementations.compound._updateEachDescendantTransform, entity);
            								var bodyComponent = this._compoundParent.entity.rigidbody;
            								if (bodyComponent) {
            										bodyComponent.activate();
            								}
            						}
            				}
            		}
            		getShapePosition() {
            				var pos = this.entity.getPosition();
            				if (this._hasOffset) {
            						var rot = this.entity.getRotation();
            						var lo = this.data.linearOffset;
            						_quat.copy(rot).transformVector(lo, _vec3$1);
            						return _vec3$1.add(pos);
            				}
            				return pos;
            		}
            		getShapeRotation() {
            				var rot = this.entity.getRotation();
            				if (this._hasOffset) {
            						return _quat.copy(rot).mul(this.data.angularOffset);
            				}
            				return rot;
            		}
            		onEnable() {
            				if (this.data.type === 'mesh' && (this.data.asset || this.data.renderAsset) && this.data.initialized) {
            						var asset = this.system.app.assets.get(this.data.asset || this.data.renderAsset);
            						if (asset && (!asset.resource || !this.data.shape)) {
            								this.system.recreatePhysicalShapes(this);
            								return;
            						}
            				}
            				if (this.entity.rigidbody) {
            						if (this.entity.rigidbody.enabled) {
            								this.entity.rigidbody.enableSimulation();
            						}
            				} else if (this._compoundParent && this !== this._compoundParent) {
            						if (this._compoundParent.shape.getNumChildShapes() === 0) {
            								this.system.recreatePhysicalShapes(this._compoundParent);
            						} else {
            								var transform = this.system._getNodeTransform(this.entity, this._compoundParent.entity);
            								this._compoundParent.shape.addChildShape(transform, this.data.shape);
            								Ammo.destroy(transform);
            								if (this._compoundParent.entity.rigidbody) {
            										this._compoundParent.entity.rigidbody.activate();
            								}
            						}
            				} else if (this.entity.trigger) {
            						this.entity.trigger.enable();
            				}
            		}
            		onDisable() {
            				if (this.entity.rigidbody) {
            						this.entity.rigidbody.disableSimulation();
            				} else if (this._compoundParent && this !== this._compoundParent) {
            						if (!this._compoundParent.entity._destroying) {
            								this.system._removeCompoundChild(this._compoundParent, this.data.shape);
            								if (this._compoundParent.entity.rigidbody) {
            										this._compoundParent.entity.rigidbody.activate();
            								}
            						}
            				} else if (this.entity.trigger) {
            						this.entity.trigger.disable();
            				}
            		}
            		onBeforeRemove() {
            				if (this.asset) {
            						this.asset = null;
            				}
            				if (this.renderAsset) {
            						this.renderAsset = null;
            				}
            				this.entity.off('insert', this._onInsert, this);
            				this.off();
            		}
            		constructor(system, entity){
            				super(system, entity), this._compoundParent = null, this._hasOffset = false;
            				this.entity.on('insert', this._onInsert, this);
            				this.on('set_type', this.onSetType, this);
            				this.on('set_convexHull', this.onSetModel, this);
            				this.on('set_halfExtents', this.onSetHalfExtents, this);
            				this.on('set_linearOffset', this.onSetOffset, this);
            				this.on('set_angularOffset', this.onSetOffset, this);
            				this.on('set_radius', this.onSetRadius, this);
            				this.on('set_height', this.onSetHeight, this);
            				this.on('set_axis', this.onSetAxis, this);
            				this.on('set_asset', this.onSetAsset, this);
            				this.on('set_renderAsset', this.onSetRenderAsset, this);
            				this.on('set_model', this.onSetModel, this);
            				this.on('set_render', this.onSetRender, this);
            		}
            }
            CollisionComponent.EVENT_CONTACT = 'contact';
            CollisionComponent.EVENT_COLLISIONSTART = 'collisionstart';
            CollisionComponent.EVENT_COLLISIONEND = 'collisionend';
            CollisionComponent.EVENT_TRIGGERENTER = 'triggerenter';
            CollisionComponent.EVENT_TRIGGERLEAVE = 'triggerleave';
            
            class CollisionComponentData {
            		constructor(){
            				this.enabled = true;
            				this.type = 'box';
            				this.halfExtents = new Vec3(0.5, 0.5, 0.5);
            				this.linearOffset = new Vec3();
            				this.angularOffset = new Quat();
            				this.radius = 0.5;
            				this.axis = 1;
            				this.height = 2;
            				this.convexHull = false;
            				this.asset = null;
            				this.renderAsset = null;
            				this.checkVertexDuplicates = true;
            				this.shape = null;
            				this.model = null;
            				this.render = null;
            				this.initialized = false;
            		}
            }
            
            var BODYTYPE_STATIC = 'static';
            var BODYTYPE_DYNAMIC = 'dynamic';
            var BODYTYPE_KINEMATIC = 'kinematic';
            var BODYFLAG_KINEMATIC_OBJECT = 2;
            var BODYFLAG_NORESPONSE_OBJECT = 4;
            var BODYSTATE_ACTIVE_TAG = 1;
            var BODYSTATE_DISABLE_DEACTIVATION = 4;
            var BODYSTATE_DISABLE_SIMULATION = 5;
            var BODYGROUP_DYNAMIC = 1;
            var BODYGROUP_STATIC = 2;
            var BODYGROUP_KINEMATIC = 4;
            var BODYGROUP_TRIGGER = 16;
            var BODYMASK_ALL = 65535;
            var BODYMASK_NOT_STATIC = 65535 ^ 2;
            
            var _ammoVec1$1, _ammoQuat$1, _ammoTransform$1;
            class Trigger {
            		initialize(data) {
            				var entity = this.entity;
            				var shape = data.shape;
            				if (shape && typeof Ammo !== 'undefined') {
            						if (entity.trigger) {
            								entity.trigger.destroy();
            						}
            						var mass = 1;
            						var component = this.component;
            						if (component) {
            								var bodyPos = component.getShapePosition();
            								var bodyRot = component.getShapeRotation();
            								_ammoVec1$1.setValue(bodyPos.x, bodyPos.y, bodyPos.z);
            								_ammoQuat$1.setValue(bodyRot.x, bodyRot.y, bodyRot.z, bodyRot.w);
            						} else {
            								var pos = entity.getPosition();
            								var rot = entity.getRotation();
            								_ammoVec1$1.setValue(pos.x, pos.y, pos.z);
            								_ammoQuat$1.setValue(rot.x, rot.y, rot.z, rot.w);
            						}
            						_ammoTransform$1.setOrigin(_ammoVec1$1);
            						_ammoTransform$1.setRotation(_ammoQuat$1);
            						var body = this.app.systems.rigidbody.createBody(mass, shape, _ammoTransform$1);
            						body.setRestitution(0);
            						body.setFriction(0);
            						body.setDamping(0, 0);
            						_ammoVec1$1.setValue(0, 0, 0);
            						body.setLinearFactor(_ammoVec1$1);
            						body.setAngularFactor(_ammoVec1$1);
            						body.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_NORESPONSE_OBJECT);
            						body.entity = entity;
            						this.body = body;
            						if (this.component.enabled && entity.enabled) {
            								this.enable();
            						}
            				}
            		}
            		destroy() {
            				if (!this.body) return;
            				this.disable();
            				this.app.systems.rigidbody.destroyBody(this.body);
            				this.body = null;
            		}
            		_getEntityTransform(transform) {
            				var component = this.component;
            				if (component) {
            						var bodyPos = component.getShapePosition();
            						var bodyRot = component.getShapeRotation();
            						_ammoVec1$1.setValue(bodyPos.x, bodyPos.y, bodyPos.z);
            						_ammoQuat$1.setValue(bodyRot.x, bodyRot.y, bodyRot.z, bodyRot.w);
            				} else {
            						var pos = this.entity.getPosition();
            						var rot = this.entity.getRotation();
            						_ammoVec1$1.setValue(pos.x, pos.y, pos.z);
            						_ammoQuat$1.setValue(rot.x, rot.y, rot.z, rot.w);
            				}
            				transform.setOrigin(_ammoVec1$1);
            				transform.setRotation(_ammoQuat$1);
            		}
            		updateTransform() {
            				this._getEntityTransform(_ammoTransform$1);
            				var body = this.body;
            				body.setWorldTransform(_ammoTransform$1);
            				body.activate();
            		}
            		enable() {
            				var body = this.body;
            				if (!body) return;
            				var system = this.app.systems.rigidbody;
            				var idx = system._triggers.indexOf(this);
            				if (idx < 0) {
            						system.addBody(body, BODYGROUP_TRIGGER, BODYMASK_NOT_STATIC ^ BODYGROUP_TRIGGER);
            						system._triggers.push(this);
            				}
            				body.forceActivationState(BODYSTATE_ACTIVE_TAG);
            				this.updateTransform();
            		}
            		disable() {
            				var body = this.body;
            				if (!body) return;
            				var system = this.app.systems.rigidbody;
            				var idx = system._triggers.indexOf(this);
            				if (idx > -1) {
            						system.removeBody(body);
            						system._triggers.splice(idx, 1);
            				}
            				body.forceActivationState(BODYSTATE_DISABLE_SIMULATION);
            		}
            		constructor(app, component, data){
            				this.entity = component.entity;
            				this.component = component;
            				this.app = app;
            				if (typeof Ammo !== 'undefined' && !_ammoVec1$1) {
            						_ammoVec1$1 = new Ammo.btVector3();
            						_ammoQuat$1 = new Ammo.btQuaternion();
            						_ammoTransform$1 = new Ammo.btTransform();
            				}
            				this.initialize(data);
            		}
            }
            
            var mat4 = new Mat4();
            var p1 = new Vec3();
            var p2 = new Vec3();
            var quat$1 = new Quat();
            var tempGraphNode = new GraphNode();
            var _schema$g = [
            		'enabled',
            		'type',
            		'halfExtents',
            		'linearOffset',
            		'angularOffset',
            		'radius',
            		'axis',
            		'height',
            		'convexHull',
            		'asset',
            		'renderAsset',
            		'shape',
            		'model',
            		'render',
            		'checkVertexDuplicates'
            ];
            class CollisionSystemImpl {
            		beforeInitialize(component, data) {
            				data.shape = null;
            				data.model = new Model();
            				data.model.graph = new GraphNode();
            		}
            		afterInitialize(component, data) {
            				this.recreatePhysicalShapes(component);
            				component.data.initialized = true;
            		}
            		reset(component, data) {
            				this.beforeInitialize(component, data);
            				this.afterInitialize(component, data);
            		}
            		recreatePhysicalShapes(component) {
            				var entity = component.entity;
            				var data = component.data;
            				if (typeof Ammo !== 'undefined') {
            						if (entity.trigger) {
            								entity.trigger.destroy();
            								delete entity.trigger;
            						}
            						if (data.shape) {
            								if (component._compoundParent) {
            										if (component !== component._compoundParent) {
            												this.system._removeCompoundChild(component._compoundParent, data.shape);
            										}
            										if (component._compoundParent.entity.rigidbody) {
            												component._compoundParent.entity.rigidbody.activate();
            										}
            								}
            								this.destroyShape(data);
            						}
            						data.shape = this.createPhysicalShape(component.entity, data);
            						var firstCompoundChild = !component._compoundParent;
            						if (data.type === 'compound' && (!component._compoundParent || component === component._compoundParent)) {
            								component._compoundParent = component;
            								entity.forEach(this._addEachDescendant, component);
            						} else if (data.type !== 'compound') {
            								if (!component.rigidbody) {
            										component._compoundParent = null;
            										var parent = entity.parent;
            										while(parent){
            												if (parent.collision && parent.collision.type === 'compound') {
            														component._compoundParent = parent.collision;
            														break;
            												}
            												parent = parent.parent;
            										}
            								}
            						}
            						if (component._compoundParent) {
            								if (component !== component._compoundParent) {
            										if (firstCompoundChild && component._compoundParent.shape.getNumChildShapes() === 0) {
            												this.system.recreatePhysicalShapes(component._compoundParent);
            										} else {
            												this.system.updateCompoundChildTransform(entity, true);
            												if (component._compoundParent.entity.rigidbody) {
            														component._compoundParent.entity.rigidbody.activate();
            												}
            										}
            								}
            						}
            						if (entity.rigidbody) {
            								entity.rigidbody.disableSimulation();
            								entity.rigidbody.createBody();
            								if (entity.enabled && entity.rigidbody.enabled) {
            										entity.rigidbody.enableSimulation();
            								}
            						} else if (!component._compoundParent) {
            								if (!entity.trigger) {
            										entity.trigger = new Trigger(this.system.app, component, data);
            								} else {
            										entity.trigger.initialize(data);
            								}
            						}
            				}
            		}
            		createPhysicalShape(entity, data) {
            				return undefined;
            		}
            		updateTransform(component, position, rotation, scale) {
            				if (component.entity.trigger) {
            						component.entity.trigger.updateTransform();
            				}
            		}
            		destroyShape(data) {
            				if (data.shape) {
            						Ammo.destroy(data.shape);
            						data.shape = null;
            				}
            		}
            		beforeRemove(entity, component) {
            				if (component.data.shape) {
            						if (component._compoundParent && !component._compoundParent.entity._destroying) {
            								this.system._removeCompoundChild(component._compoundParent, component.data.shape);
            								if (component._compoundParent.entity.rigidbody) {
            										component._compoundParent.entity.rigidbody.activate();
            								}
            						}
            						component._compoundParent = null;
            						this.destroyShape(component.data);
            				}
            		}
            		remove(entity, data) {
            				if (entity.rigidbody && entity.rigidbody.body) {
            						entity.rigidbody.disableSimulation();
            				}
            				if (entity.trigger) {
            						entity.trigger.destroy();
            						delete entity.trigger;
            				}
            		}
            		clone(entity, clone) {
            				var src = this.system.store[entity.getGuid()];
            				var data = {
            						enabled: src.data.enabled,
            						type: src.data.type,
            						halfExtents: [
            								src.data.halfExtents.x,
            								src.data.halfExtents.y,
            								src.data.halfExtents.z
            						],
            						linearOffset: [
            								src.data.linearOffset.x,
            								src.data.linearOffset.y,
            								src.data.linearOffset.z
            						],
            						angularOffset: [
            								src.data.angularOffset.x,
            								src.data.angularOffset.y,
            								src.data.angularOffset.z,
            								src.data.angularOffset.w
            						],
            						radius: src.data.radius,
            						axis: src.data.axis,
            						height: src.data.height,
            						convexHull: src.data.convexHull,
            						asset: src.data.asset,
            						renderAsset: src.data.renderAsset,
            						model: src.data.model,
            						render: src.data.render,
            						checkVertexDuplicates: src.data.checkVertexDuplicates
            				};
            				return this.system.addComponent(clone, data);
            		}
            		constructor(system){
            				this.system = system;
            		}
            }
            class CollisionBoxSystemImpl extends CollisionSystemImpl {
            		createPhysicalShape(entity, data) {
            				if (typeof Ammo !== 'undefined') {
            						var he = data.halfExtents;
            						var ammoHe = new Ammo.btVector3(he ? he.x : 0.5, he ? he.y : 0.5, he ? he.z : 0.5);
            						var shape = new Ammo.btBoxShape(ammoHe);
            						Ammo.destroy(ammoHe);
            						return shape;
            				}
            				return undefined;
            		}
            }
            class CollisionSphereSystemImpl extends CollisionSystemImpl {
            		createPhysicalShape(entity, data) {
            				if (typeof Ammo !== 'undefined') {
            						return new Ammo.btSphereShape(data.radius);
            				}
            				return undefined;
            		}
            }
            class CollisionCapsuleSystemImpl extends CollisionSystemImpl {
            		createPhysicalShape(entity, data) {
            				var _data_axis;
            				var axis = (_data_axis = data.axis) != null ? _data_axis : 1;
            				var _data_radius;
            				var radius = (_data_radius = data.radius) != null ? _data_radius : 0.5;
            				var _data_height;
            				var height = Math.max(((_data_height = data.height) != null ? _data_height : 2) - 2 * radius, 0);
            				var shape = null;
            				if (typeof Ammo !== 'undefined') {
            						switch(axis){
            								case 0:
            										shape = new Ammo.btCapsuleShapeX(radius, height);
            										break;
            								case 1:
            										shape = new Ammo.btCapsuleShape(radius, height);
            										break;
            								case 2:
            										shape = new Ammo.btCapsuleShapeZ(radius, height);
            										break;
            						}
            				}
            				return shape;
            		}
            }
            class CollisionCylinderSystemImpl extends CollisionSystemImpl {
            		createPhysicalShape(entity, data) {
            				var _data_axis;
            				var axis = (_data_axis = data.axis) != null ? _data_axis : 1;
            				var _data_radius;
            				var radius = (_data_radius = data.radius) != null ? _data_radius : 0.5;
            				var _data_height;
            				var height = (_data_height = data.height) != null ? _data_height : 1;
            				var halfExtents = null;
            				var shape = null;
            				if (typeof Ammo !== 'undefined') {
            						switch(axis){
            								case 0:
            										halfExtents = new Ammo.btVector3(height * 0.5, radius, radius);
            										shape = new Ammo.btCylinderShapeX(halfExtents);
            										break;
            								case 1:
            										halfExtents = new Ammo.btVector3(radius, height * 0.5, radius);
            										shape = new Ammo.btCylinderShape(halfExtents);
            										break;
            								case 2:
            										halfExtents = new Ammo.btVector3(radius, radius, height * 0.5);
            										shape = new Ammo.btCylinderShapeZ(halfExtents);
            										break;
            						}
            				}
            				if (halfExtents) {
            						Ammo.destroy(halfExtents);
            				}
            				return shape;
            		}
            }
            class CollisionConeSystemImpl extends CollisionSystemImpl {
            		createPhysicalShape(entity, data) {
            				var _data_axis;
            				var axis = (_data_axis = data.axis) != null ? _data_axis : 1;
            				var _data_radius;
            				var radius = (_data_radius = data.radius) != null ? _data_radius : 0.5;
            				var _data_height;
            				var height = (_data_height = data.height) != null ? _data_height : 1;
            				var shape = null;
            				if (typeof Ammo !== 'undefined') {
            						switch(axis){
            								case 0:
            										shape = new Ammo.btConeShapeX(radius, height);
            										break;
            								case 1:
            										shape = new Ammo.btConeShape(radius, height);
            										break;
            								case 2:
            										shape = new Ammo.btConeShapeZ(radius, height);
            										break;
            						}
            				}
            				return shape;
            		}
            }
            class CollisionMeshSystemImpl extends CollisionSystemImpl {
            		beforeInitialize(component, data) {}
            		createAmmoHull(mesh, node, shape, scale) {
            				var hull = new Ammo.btConvexHullShape();
            				var point = new Ammo.btVector3();
            				var positions = [];
            				mesh.getPositions(positions);
            				for(var i = 0; i < positions.length; i += 3){
            						point.setValue(positions[i] * scale.x, positions[i + 1] * scale.y, positions[i + 2] * scale.z);
            						hull.addPoint(point, false);
            				}
            				Ammo.destroy(point);
            				hull.recalcLocalAabb();
            				hull.setMargin(0.01);
            				var transform = this.system._getNodeTransform(node);
            				shape.addChildShape(transform, hull);
            				Ammo.destroy(transform);
            		}
            		createAmmoMesh(mesh, node, shape, scale, checkDupes) {
            				if (checkDupes === void 0) checkDupes = true;
            				var system = this.system;
            				var triMesh;
            				if (system._triMeshCache[mesh.id]) {
            						triMesh = system._triMeshCache[mesh.id];
            				} else {
            						var vb = mesh.vertexBuffer;
            						var format = vb.getFormat();
            						var stride, positions;
            						for(var i = 0; i < format.elements.length; i++){
            								var element = format.elements[i];
            								if (element.name === SEMANTIC_POSITION) {
            										positions = new Float32Array(vb.lock(), element.offset);
            										stride = element.stride / 4;
            										break;
            								}
            						}
            						var indices = [];
            						mesh.getIndices(indices);
            						var numTriangles = mesh.primitive[0].count / 3;
            						var v1 = new Ammo.btVector3();
            						var i1, i2, i3;
            						var base = mesh.primitive[0].base;
            						triMesh = new Ammo.btTriangleMesh();
            						system._triMeshCache[mesh.id] = triMesh;
            						var vertexCache = new Map();
            						var indexedArray = triMesh.getIndexedMeshArray();
            						indexedArray.at(0).m_numTriangles = numTriangles;
            						var sx = scale ? scale.x : 1;
            						var sy = scale ? scale.y : 1;
            						var sz = scale ? scale.z : 1;
            						var addVertex = (index)=>{
            								var x = positions[index * stride] * sx;
            								var y = positions[index * stride + 1] * sy;
            								var z = positions[index * stride + 2] * sz;
            								var idx;
            								if (checkDupes) {
            										var str = x + ":" + y + ":" + z;
            										idx = vertexCache.get(str);
            										if (idx !== undefined) {
            												return idx;
            										}
            										v1.setValue(x, y, z);
            										idx = triMesh.findOrAddVertex(v1, false);
            										vertexCache.set(str, idx);
            								} else {
            										v1.setValue(x, y, z);
            										idx = triMesh.findOrAddVertex(v1, false);
            								}
            								return idx;
            						};
            						for(var i4 = 0; i4 < numTriangles; i4++){
            								i1 = addVertex(indices[base + i4 * 3]);
            								i2 = addVertex(indices[base + i4 * 3 + 1]);
            								i3 = addVertex(indices[base + i4 * 3 + 2]);
            								triMesh.addIndex(i1);
            								triMesh.addIndex(i2);
            								triMesh.addIndex(i3);
            						}
            						Ammo.destroy(v1);
            				}
            				var triMeshShape = new Ammo.btBvhTriangleMeshShape(triMesh, true);
            				if (!scale) {
            						var scaling = system._getNodeScaling(node);
            						triMeshShape.setLocalScaling(scaling);
            						Ammo.destroy(scaling);
            				}
            				var transform = system._getNodeTransform(node);
            				shape.addChildShape(transform, triMeshShape);
            				Ammo.destroy(transform);
            		}
            		createPhysicalShape(entity, data) {
            				if (typeof Ammo === 'undefined') return undefined;
            				if (data.model || data.render) {
            						var shape = new Ammo.btCompoundShape();
            						var entityTransform = entity.getWorldTransform();
            						var scale = entityTransform.getScale();
            						if (data.render) {
            								var meshes = data.render.meshes;
            								for(var i = 0; i < meshes.length; i++){
            										if (data.convexHull) {
            												this.createAmmoHull(meshes[i], tempGraphNode, shape, scale);
            										} else {
            												this.createAmmoMesh(meshes[i], tempGraphNode, shape, scale, data.checkVertexDuplicates);
            										}
            								}
            						} else if (data.model) {
            								var meshInstances = data.model.meshInstances;
            								for(var i1 = 0; i1 < meshInstances.length; i1++){
            										this.createAmmoMesh(meshInstances[i1].mesh, meshInstances[i1].node, shape, null, data.checkVertexDuplicates);
            								}
            								var vec = new Ammo.btVector3(scale.x, scale.y, scale.z);
            								shape.setLocalScaling(vec);
            								Ammo.destroy(vec);
            						}
            						return shape;
            				}
            				return undefined;
            		}
            		recreatePhysicalShapes(component) {
            				var data = component.data;
            				if (data.renderAsset || data.asset) {
            						if (component.enabled && component.entity.enabled) {
            								this.loadAsset(component, data.renderAsset || data.asset, data.renderAsset ? 'render' : 'model');
            								return;
            						}
            				}
            				this.doRecreatePhysicalShape(component);
            		}
            		loadAsset(component, id, property) {
            				var data = component.data;
            				var assets = this.system.app.assets;
            				var previousPropertyValue = data[property];
            				var onAssetFullyReady = (asset)=>{
            						if (data[property] !== previousPropertyValue) {
            								return;
            						}
            						data[property] = asset.resource;
            						this.doRecreatePhysicalShape(component);
            				};
            				var loadAndHandleAsset = (asset)=>{
            						asset.ready((asset)=>{
            								if (asset.data.containerAsset) {
            										var containerAsset = assets.get(asset.data.containerAsset);
            										if (containerAsset.loaded) {
            												onAssetFullyReady(asset);
            										} else {
            												containerAsset.ready(()=>{
            														onAssetFullyReady(asset);
            												});
            												assets.load(containerAsset);
            										}
            								} else {
            										onAssetFullyReady(asset);
            								}
            						});
            						assets.load(asset);
            				};
            				var asset = assets.get(id);
            				if (asset) {
            						loadAndHandleAsset(asset);
            				} else {
            						assets.once("add:" + id, loadAndHandleAsset);
            				}
            		}
            		doRecreatePhysicalShape(component) {
            				var entity = component.entity;
            				var data = component.data;
            				if (data.model || data.render) {
            						this.destroyShape(data);
            						data.shape = this.createPhysicalShape(entity, data);
            						if (entity.rigidbody) {
            								entity.rigidbody.disableSimulation();
            								entity.rigidbody.createBody();
            								if (entity.enabled && entity.rigidbody.enabled) {
            										entity.rigidbody.enableSimulation();
            								}
            						} else {
            								if (!entity.trigger) {
            										entity.trigger = new Trigger(this.system.app, component, data);
            								} else {
            										entity.trigger.initialize(data);
            								}
            						}
            				} else {
            						this.beforeRemove(entity, component);
            						this.remove(entity, data);
            				}
            		}
            		updateTransform(component, position, rotation, scale) {
            				if (component.shape) {
            						var entityTransform = component.entity.getWorldTransform();
            						var worldScale = entityTransform.getScale();
            						var previousScale = component.shape.getLocalScaling();
            						if (worldScale.x !== previousScale.x() || worldScale.y !== previousScale.y() || worldScale.z !== previousScale.z()) {
            								this.doRecreatePhysicalShape(component);
            						}
            				}
            				super.updateTransform(component, position, rotation, scale);
            		}
            		destroyShape(data) {
            				if (!data.shape) {
            						return;
            				}
            				var numShapes = data.shape.getNumChildShapes();
            				for(var i = 0; i < numShapes; i++){
            						var shape = data.shape.getChildShape(i);
            						Ammo.destroy(shape);
            				}
            				Ammo.destroy(data.shape);
            				data.shape = null;
            		}
            }
            class CollisionCompoundSystemImpl extends CollisionSystemImpl {
            		createPhysicalShape(entity, data) {
            				if (typeof Ammo !== 'undefined') {
            						return new Ammo.btCompoundShape();
            				}
            				return undefined;
            		}
            		_addEachDescendant(entity) {
            				if (!entity.collision || entity.rigidbody) {
            						return;
            				}
            				entity.collision._compoundParent = this;
            				if (entity !== this.entity) {
            						entity.collision.system.recreatePhysicalShapes(entity.collision);
            				}
            		}
            		_updateEachDescendant(entity) {
            				if (!entity.collision) {
            						return;
            				}
            				if (entity.collision._compoundParent !== this) {
            						return;
            				}
            				entity.collision._compoundParent = null;
            				if (entity !== this.entity && !entity.rigidbody) {
            						entity.collision.system.recreatePhysicalShapes(entity.collision);
            				}
            		}
            		_updateEachDescendantTransform(entity) {
            				if (!entity.collision || entity.collision._compoundParent !== this.collision._compoundParent) {
            						return;
            				}
            				this.collision.system.updateCompoundChildTransform(entity, false);
            		}
            }
            class CollisionComponentSystem extends ComponentSystem {
            		initializeComponentData(component, _data, properties) {
            				properties = [
            						'type',
            						'halfExtents',
            						'radius',
            						'axis',
            						'height',
            						'convexHull',
            						'shape',
            						'model',
            						'asset',
            						'render',
            						'renderAsset',
            						'enabled',
            						'linearOffset',
            						'angularOffset',
            						'checkVertexDuplicates'
            				];
            				var data = {};
            				for(var i = 0, len = properties.length; i < len; i++){
            						var property = properties[i];
            						data[property] = _data[property];
            				}
            				var idx;
            				if (_data.hasOwnProperty('asset')) {
            						idx = properties.indexOf('model');
            						if (idx !== -1) {
            								properties.splice(idx, 1);
            						}
            						idx = properties.indexOf('render');
            						if (idx !== -1) {
            								properties.splice(idx, 1);
            						}
            				} else if (_data.hasOwnProperty('model')) {
            						idx = properties.indexOf('asset');
            						if (idx !== -1) {
            								properties.splice(idx, 1);
            						}
            				}
            				if (!data.type) {
            						data.type = component.data.type;
            				}
            				component.data.type = data.type;
            				if (Array.isArray(data.halfExtents)) {
            						data.halfExtents = new Vec3(data.halfExtents);
            				}
            				if (Array.isArray(data.linearOffset)) {
            						data.linearOffset = new Vec3(data.linearOffset);
            				}
            				if (Array.isArray(data.angularOffset)) {
            						var values = data.angularOffset;
            						if (values.length === 3) {
            								data.angularOffset = new Quat().setFromEulerAngles(values[0], values[1], values[2]);
            						} else {
            								data.angularOffset = new Quat(data.angularOffset);
            						}
            				}
            				var impl = this._createImplementation(data.type);
            				impl.beforeInitialize(component, data);
            				super.initializeComponentData(component, data, properties);
            				impl.afterInitialize(component, data);
            		}
            		_createImplementation(type) {
            				if (this.implementations[type] === undefined) {
            						var impl;
            						switch(type){
            								case 'box':
            										impl = new CollisionBoxSystemImpl(this);
            										break;
            								case 'sphere':
            										impl = new CollisionSphereSystemImpl(this);
            										break;
            								case 'capsule':
            										impl = new CollisionCapsuleSystemImpl(this);
            										break;
            								case 'cylinder':
            										impl = new CollisionCylinderSystemImpl(this);
            										break;
            								case 'cone':
            										impl = new CollisionConeSystemImpl(this);
            										break;
            								case 'mesh':
            										impl = new CollisionMeshSystemImpl(this);
            										break;
            								case 'compound':
            										impl = new CollisionCompoundSystemImpl(this);
            										break;
            						}
            						this.implementations[type] = impl;
            				}
            				return this.implementations[type];
            		}
            		_getImplementation(entity) {
            				return this.implementations[entity.collision.data.type];
            		}
            		cloneComponent(entity, clone) {
            				return this._getImplementation(entity).clone(entity, clone);
            		}
            		onBeforeRemove(entity, component) {
            				this.implementations[component.data.type].beforeRemove(entity, component);
            				component.onBeforeRemove();
            		}
            		onRemove(entity, data) {
            				this.implementations[data.type].remove(entity, data);
            		}
            		updateCompoundChildTransform(entity, forceUpdate) {
            				var parentComponent = entity.collision._compoundParent;
            				if (parentComponent === entity.collision) return;
            				if (entity.enabled && entity.collision.enabled && (entity._dirtyLocal || forceUpdate)) {
            						var transform = this._getNodeTransform(entity, parentComponent.entity);
            						var idx = parentComponent.getCompoundChildShapeIndex(entity.collision.shape);
            						if (idx === null) {
            								parentComponent.shape.addChildShape(transform, entity.collision.data.shape);
            						} else {
            								parentComponent.shape.updateChildTransform(idx, transform, true);
            						}
            						Ammo.destroy(transform);
            				}
            		}
            		_removeCompoundChild(collision, shape) {
            				if (collision.shape.getNumChildShapes() === 0) {
            						return;
            				}
            				if (collision.shape.removeChildShape) {
            						collision.shape.removeChildShape(shape);
            				} else {
            						var ind = collision.getCompoundChildShapeIndex(shape);
            						if (ind !== null) {
            								collision.shape.removeChildShapeByIndex(ind);
            						}
            				}
            		}
            		onTransformChanged(component, position, rotation, scale) {
            				this.implementations[component.data.type].updateTransform(component, position, rotation, scale);
            		}
            		changeType(component, previousType, newType) {
            				this.implementations[previousType].beforeRemove(component.entity, component);
            				this.implementations[previousType].remove(component.entity, component.data);
            				this._createImplementation(newType).reset(component, component.data);
            		}
            		recreatePhysicalShapes(component) {
            				this.implementations[component.data.type].recreatePhysicalShapes(component);
            		}
            		_calculateNodeRelativeTransform(node, relative) {
            				if (node === relative) {
            						var scale = node.getWorldTransform().getScale();
            						mat4.setScale(scale.x, scale.y, scale.z);
            				} else {
            						this._calculateNodeRelativeTransform(node.parent, relative);
            						mat4.mul(node.getLocalTransform());
            				}
            		}
            		_getNodeScaling(node) {
            				var wtm = node.getWorldTransform();
            				var scl = wtm.getScale();
            				return new Ammo.btVector3(scl.x, scl.y, scl.z);
            		}
            		_getNodeTransform(node, relative) {
            				var pos, rot;
            				if (relative) {
            						this._calculateNodeRelativeTransform(node, relative);
            						pos = p1;
            						rot = quat$1;
            						mat4.getTranslation(pos);
            						rot.setFromMat4(mat4);
            				} else {
            						pos = node.getPosition();
            						rot = node.getRotation();
            				}
            				var ammoQuat = new Ammo.btQuaternion();
            				var transform = new Ammo.btTransform();
            				transform.setIdentity();
            				var origin = transform.getOrigin();
            				var component = node.collision;
            				if (component && component._hasOffset) {
            						var lo = component.data.linearOffset;
            						var ao = component.data.angularOffset;
            						var newOrigin = p2;
            						quat$1.copy(rot).transformVector(lo, newOrigin);
            						newOrigin.add(pos);
            						quat$1.copy(rot).mul(ao);
            						origin.setValue(newOrigin.x, newOrigin.y, newOrigin.z);
            						ammoQuat.setValue(quat$1.x, quat$1.y, quat$1.z, quat$1.w);
            				} else {
            						origin.setValue(pos.x, pos.y, pos.z);
            						ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
            				}
            				transform.setRotation(ammoQuat);
            				Ammo.destroy(ammoQuat);
            				return transform;
            		}
            		destroy() {
            				for(var key in this._triMeshCache){
            						Ammo.destroy(this._triMeshCache[key]);
            				}
            				this._triMeshCache = null;
            				super.destroy();
            		}
            		constructor(app){
            				super(app);
            				this.id = 'collision';
            				this.ComponentType = CollisionComponent;
            				this.DataType = CollisionComponentData;
            				this.schema = _schema$g;
            				this.implementations = {};
            				this._triMeshCache = {};
            				this.on('beforeremove', this.onBeforeRemove, this);
            				this.on('remove', this.onRemove, this);
            		}
            }
            
            var _tempColor$1 = new Color();
            var _vertexFormatDeviceCache = new DeviceCache();
            class ImageRenderable {
            		destroy() {
            				var _this_meshInstance, _this_unmaskMeshInstance;
            				this.setMaterial(null);
            				this._element.removeModelFromLayers(this.model);
            				this.model.destroy();
            				this.model = null;
            				this.node = null;
            				this.mesh = null;
            				(_this_meshInstance = this.meshInstance) == null ? void 0 : _this_meshInstance.destroy();
            				this.meshInstance = null;
            				(_this_unmaskMeshInstance = this.unmaskMeshInstance) == null ? void 0 : _this_unmaskMeshInstance.destroy();
            				this.unmaskMeshInstance = null;
            				this._entity = null;
            				this._element = null;
            		}
            		setMesh(mesh) {
            				if (!this.meshInstance) return;
            				this.mesh = mesh;
            				this.meshInstance.mesh = mesh;
            				this.meshInstance.visible = !!mesh;
            				if (this.unmaskMeshInstance) {
            						this.unmaskMeshInstance.mesh = mesh;
            				}
            				this.forceUpdateAabb();
            		}
            		setMask(mask) {
            				if (!this.meshInstance) return;
            				if (this._entity.enabled && this._element.enabled) {
            						this._element.removeModelFromLayers(this.model);
            				}
            				if (mask) {
            						this.unmaskMeshInstance = new MeshInstance(this.mesh, this.meshInstance.material, this.node);
            						this.unmaskMeshInstance.name = "Unmask: " + this._entity.name;
            						this.unmaskMeshInstance.castShadow = false;
            						this.unmaskMeshInstance.receiveShadow = false;
            						this.unmaskMeshInstance.pick = false;
            						this.model.meshInstances.push(this.unmaskMeshInstance);
            						for(var name in this.meshInstance.parameters){
            								this.unmaskMeshInstance.setParameter(name, this.meshInstance.parameters[name].data);
            						}
            				} else {
            						var idx = this.model.meshInstances.indexOf(this.unmaskMeshInstance);
            						if (idx >= 0) {
            								this.model.meshInstances.splice(idx, 1);
            						}
            				}
            				if (this._entity.enabled && this._element.enabled) {
            						this._element.addModelToLayers(this.model);
            				}
            				if (!mask) {
            						var _this_unmaskMeshInstance;
            						(_this_unmaskMeshInstance = this.unmaskMeshInstance) == null ? void 0 : _this_unmaskMeshInstance.destroy();
            						this.unmaskMeshInstance = null;
            				}
            		}
            		setMaterial(material) {
            				if (!this.meshInstance) return;
            				this.meshInstance.material = material;
            				if (this.unmaskMeshInstance) {
            						this.unmaskMeshInstance.material = material;
            				}
            		}
            		setParameter(name, value) {
            				if (!this.meshInstance) return;
            				this.meshInstance.setParameter(name, value);
            				if (this.unmaskMeshInstance) {
            						this.unmaskMeshInstance.setParameter(name, value);
            				}
            		}
            		deleteParameter(name) {
            				if (!this.meshInstance) return;
            				this.meshInstance.deleteParameter(name);
            				if (this.unmaskMeshInstance) {
            						this.unmaskMeshInstance.deleteParameter(name);
            				}
            		}
            		setUnmaskDrawOrder() {
            				if (!this.meshInstance) return;
            				var getLastChild = function getLastChild1(e) {
            						var last;
            						var c = e.children;
            						var l = c.length;
            						if (l) {
            								for(var i = 0; i < l; i++){
            										if (c[i].element) {
            												last = c[i];
            										}
            								}
            								if (!last) return null;
            								var child = getLastChild(last);
            								if (child) {
            										return child;
            								}
            								return last;
            						}
            						return null;
            				};
            				if (this.unmaskMeshInstance) {
            						var lastChild = getLastChild(this._entity);
            						if (lastChild && lastChild.element) {
            								this.unmaskMeshInstance.drawOrder = lastChild.element.drawOrder + lastChild.element.getMaskOffset();
            						} else {
            								this.unmaskMeshInstance.drawOrder = this.meshInstance.drawOrder + this._element.getMaskOffset();
            						}
            				}
            		}
            		setDrawOrder(drawOrder) {
            				if (!this.meshInstance) {
            						return;
            				}
            				this.meshInstance.drawOrder = drawOrder;
            		}
            		setCull(cull) {
            				if (!this.meshInstance) return;
            				var element = this._element;
            				var visibleFn = null;
            				if (cull && element._isScreenSpace()) {
            						visibleFn = function visibleFn(camera) {
            								return element.isVisibleForCamera(camera);
            						};
            				}
            				this.meshInstance.cull = cull;
            				this.meshInstance.isVisibleFunc = visibleFn;
            				if (this.unmaskMeshInstance) {
            						this.unmaskMeshInstance.cull = cull;
            						this.unmaskMeshInstance.isVisibleFunc = visibleFn;
            				}
            		}
            		setScreenSpace(screenSpace) {
            				if (!this.meshInstance) return;
            				this.meshInstance.screenSpace = screenSpace;
            				if (this.unmaskMeshInstance) {
            						this.unmaskMeshInstance.screenSpace = screenSpace;
            				}
            		}
            		setLayer(layer) {
            				if (!this.meshInstance) return;
            				this.meshInstance.layer = layer;
            				if (this.unmaskMeshInstance) {
            						this.unmaskMeshInstance.layer = layer;
            				}
            		}
            		forceUpdateAabb(mask) {
            				if (!this.meshInstance) return;
            				this.meshInstance._aabbVer = -1;
            				if (this.unmaskMeshInstance) {
            						this.unmaskMeshInstance._aabbVer = -1;
            				}
            		}
            		setAabbFunc(fn) {
            				if (!this.meshInstance) return;
            				this.meshInstance._updateAabbFunc = fn;
            				if (this.unmaskMeshInstance) {
            						this.unmaskMeshInstance._updateAabbFunc = fn;
            				}
            		}
            		constructor(entity, mesh, material){
            				this._entity = entity;
            				this._element = entity.element;
            				this.model = new Model();
            				this.node = new GraphNode();
            				this.model.graph = this.node;
            				this.mesh = mesh;
            				this.meshInstance = new MeshInstance(this.mesh, material, this.node);
            				this.meshInstance.name = "ImageElement: " + entity.name;
            				this.meshInstance.castShadow = false;
            				this.meshInstance.receiveShadow = false;
            				this._meshDirty = false;
            				this.model.meshInstances.push(this.meshInstance);
            				this._entity.addChild(this.model.graph);
            				this.model._entity = this._entity;
            				this.unmaskMeshInstance = null;
            		}
            }
            class ImageElement {
            		destroy() {
            				this.textureAsset = null;
            				this.spriteAsset = null;
            				this.materialAsset = null;
            				this._renderable.setMesh(this._defaultMesh);
            				this._renderable.destroy();
            				this._defaultMesh = null;
            				this._element.off('resize', this._onParentResizeOrPivotChange, this);
            				this._element.off('set:pivot', this._onParentResizeOrPivotChange, this);
            				this._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);
            				this._element.off('set:screen', this._onScreenChange, this);
            				this._element.off('set:draworder', this._onDrawOrderChange, this);
            				this._element.off('screen:set:resolution', this._onResolutionChange, this);
            		}
            		_onResolutionChange(res) {}
            		_onParentResizeOrPivotChange() {
            				if (this._renderable.mesh) {
            						this._updateMesh(this._renderable.mesh);
            				}
            		}
            		_onScreenSpaceChange(value) {
            				this._updateMaterial(value);
            		}
            		_onScreenChange(screen, previous) {
            				if (screen) {
            						this._updateMaterial(screen.screen.screenSpace);
            				} else {
            						this._updateMaterial(false);
            				}
            		}
            		_onDrawOrderChange(order) {
            				this._renderable.setDrawOrder(order);
            				if (this.mask && this._element.screen) {
            						this._element.screen.screen.once('syncdraworder', function() {
            								this._renderable.setUnmaskDrawOrder();
            						}, this);
            				}
            		}
            		_hasUserMaterial() {
            				return !!this._materialAsset || !!this._material && this._system.defaultImageMaterials.indexOf(this._material) === -1;
            		}
            		_use9Slicing() {
            				return this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED);
            		}
            		_updateMaterial(screenSpace) {
            				var mask = !!this._mask;
            				var nineSliced = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_SLICED);
            				var nineTiled = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_TILED);
            				if (!this._hasUserMaterial()) {
            						this._material = this._system.getImageElementMaterial(screenSpace, mask, nineSliced, nineTiled);
            				}
            				if (this._renderable) {
            						this._renderable.setCull(!this._element._isScreenSpace() || this._element._isScreenCulled());
            						this._renderable.setMaterial(this._material);
            						this._renderable.setScreenSpace(screenSpace);
            						this._renderable.setLayer(screenSpace ? LAYER_HUD : LAYER_WORLD);
            				}
            		}
            		_createMesh() {
            				var element = this._element;
            				var w = element.calculatedWidth;
            				var h = element.calculatedHeight;
            				var r = this._rect;
            				var device = this._system.app.graphicsDevice;
            				var vertexData = new Float32Array([
            						w,
            						0,
            						0,
            						0,
            						0,
            						1,
            						r.x + r.z,
            						1.0 - r.y,
            						w,
            						h,
            						0,
            						0,
            						0,
            						1,
            						r.x + r.z,
            						1.0 - (r.y + r.w),
            						0,
            						0,
            						0,
            						0,
            						0,
            						1,
            						r.x,
            						1.0 - r.y,
            						0,
            						h,
            						0,
            						0,
            						0,
            						1,
            						r.x,
            						1.0 - (r.y + r.w)
            				]);
            				var vertexFormat = _vertexFormatDeviceCache.get(device, ()=>{
            						return new VertexFormat(device, [
            								{
            										semantic: SEMANTIC_POSITION,
            										components: 3,
            										type: TYPE_FLOAT32
            								},
            								{
            										semantic: SEMANTIC_NORMAL,
            										components: 3,
            										type: TYPE_FLOAT32
            								},
            								{
            										semantic: SEMANTIC_TEXCOORD0,
            										components: 2,
            										type: TYPE_FLOAT32
            								}
            						]);
            				});
            				var vertexBuffer = new VertexBuffer(device, vertexFormat, 4, {
            						data: vertexData.buffer
            				});
            				var mesh = new Mesh(device);
            				mesh.vertexBuffer = vertexBuffer;
            				mesh.primitive[0].type = PRIMITIVE_TRISTRIP;
            				mesh.primitive[0].base = 0;
            				mesh.primitive[0].count = 4;
            				mesh.primitive[0].indexed = false;
            				mesh.aabb.setMinMax(Vec3.ZERO, new Vec3(w, h, 0));
            				this._updateMesh(mesh);
            				return mesh;
            		}
            		_updateMesh(mesh) {
            				var element = this._element;
            				var w = element.calculatedWidth;
            				var h = element.calculatedHeight;
            				if (element.fitMode !== FITMODE_STRETCH && this._targetAspectRatio > 0) {
            						var actualRatio = element.calculatedWidth / element.calculatedHeight;
            						if (element.fitMode === FITMODE_CONTAIN && actualRatio > this._targetAspectRatio || element.fitMode === FITMODE_COVER && actualRatio < this._targetAspectRatio) {
            								w = element.calculatedHeight * this._targetAspectRatio;
            						} else {
            								h = element.calculatedWidth / this._targetAspectRatio;
            						}
            				}
            				var screenSpace = element._isScreenSpace();
            				this._updateMaterial(screenSpace);
            				if (this._renderable) this._renderable.forceUpdateAabb();
            				if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
            						var frameData = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
            						var borderWidthScale = 2 / frameData.rect.z;
            						var borderHeightScale = 2 / frameData.rect.w;
            						this._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);
            						var tex = this.sprite.atlas.texture;
            						this._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);
            						var ppu = this._pixelsPerUnit !== null ? this._pixelsPerUnit : this.sprite.pixelsPerUnit;
            						var scaleMulX = frameData.rect.z / ppu;
            						var scaleMulY = frameData.rect.w / ppu;
            						this._outerScale.set(Math.max(w, this._innerOffset.x * scaleMulX), Math.max(h, this._innerOffset.y * scaleMulY));
            						var scaleX = scaleMulX;
            						var scaleY = scaleMulY;
            						this._outerScale.x /= scaleMulX;
            						this._outerScale.y /= scaleMulY;
            						scaleX *= math.clamp(w / (this._innerOffset.x * scaleMulX), 0.0001, 1);
            						scaleY *= math.clamp(h / (this._innerOffset.y * scaleMulY), 0.0001, 1);
            						if (this._renderable) {
            								this._innerOffsetUniform[0] = this._innerOffset.x;
            								this._innerOffsetUniform[1] = this._innerOffset.y;
            								this._innerOffsetUniform[2] = this._innerOffset.z;
            								this._innerOffsetUniform[3] = this._innerOffset.w;
            								this._renderable.setParameter('innerOffset', this._innerOffsetUniform);
            								this._atlasRectUniform[0] = this._atlasRect.x;
            								this._atlasRectUniform[1] = this._atlasRect.y;
            								this._atlasRectUniform[2] = this._atlasRect.z;
            								this._atlasRectUniform[3] = this._atlasRect.w;
            								this._renderable.setParameter('atlasRect', this._atlasRectUniform);
            								this._outerScaleUniform[0] = this._outerScale.x;
            								this._outerScaleUniform[1] = this._outerScale.y;
            								this._renderable.setParameter('outerScale', this._outerScaleUniform);
            								this._renderable.setAabbFunc(this._updateAabbFunc);
            								this._renderable.node.setLocalScale(scaleX, scaleY, 1);
            								this._renderable.node.setLocalPosition((0.5 - element.pivot.x) * w, (0.5 - element.pivot.y) * h, 0);
            						}
            				} else {
            						var vb = mesh.vertexBuffer;
            						var vertexDataF32 = new Float32Array(vb.lock());
            						var hp = element.pivot.x;
            						var vp = element.pivot.y;
            						vertexDataF32[0] = w - hp * w;
            						vertexDataF32[1] = 0 - vp * h;
            						vertexDataF32[8] = w - hp * w;
            						vertexDataF32[9] = h - vp * h;
            						vertexDataF32[16] = 0 - hp * w;
            						vertexDataF32[17] = 0 - vp * h;
            						vertexDataF32[24] = 0 - hp * w;
            						vertexDataF32[25] = h - vp * h;
            						var atlasTextureWidth = 1;
            						var atlasTextureHeight = 1;
            						var rect = this._rect;
            						if (this._sprite && this._sprite.frameKeys[this._spriteFrame] && this._sprite.atlas) {
            								var frame = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
            								if (frame) {
            										rect = frame.rect;
            										atlasTextureWidth = this._sprite.atlas.texture.width;
            										atlasTextureHeight = this._sprite.atlas.texture.height;
            								}
            						}
            						vertexDataF32[6] = (rect.x + rect.z) / atlasTextureWidth;
            						vertexDataF32[7] = 1.0 - rect.y / atlasTextureHeight;
            						vertexDataF32[14] = (rect.x + rect.z) / atlasTextureWidth;
            						vertexDataF32[15] = 1.0 - (rect.y + rect.w) / atlasTextureHeight;
            						vertexDataF32[22] = rect.x / atlasTextureWidth;
            						vertexDataF32[23] = 1.0 - rect.y / atlasTextureHeight;
            						vertexDataF32[30] = rect.x / atlasTextureWidth;
            						vertexDataF32[31] = 1.0 - (rect.y + rect.w) / atlasTextureHeight;
            						vb.unlock();
            						var min = new Vec3(0 - hp * w, 0 - vp * h, 0);
            						var max = new Vec3(w - hp * w, h - vp * h, 0);
            						mesh.aabb.setMinMax(min, max);
            						if (this._renderable) {
            								this._renderable.node.setLocalScale(1, 1, 1);
            								this._renderable.node.setLocalPosition(0, 0, 0);
            								this._renderable.setAabbFunc(null);
            						}
            				}
            				this._meshDirty = false;
            		}
            		_updateSprite() {
            				var nineSlice = false;
            				var mesh = null;
            				this._targetAspectRatio = -1;
            				if (this._sprite && this._sprite.atlas) {
            						mesh = this._sprite.meshes[this.spriteFrame];
            						nineSlice = this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED;
            						var frameData = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];
            						if ((frameData == null ? void 0 : frameData.rect.w) > 0) {
            								this._targetAspectRatio = frameData.rect.z / frameData.rect.w;
            						}
            				}
            				this.mesh = nineSlice ? mesh : this._defaultMesh;
            				this.refreshMesh();
            		}
            		refreshMesh() {
            				if (this.mesh) {
            						if (!this._element._beingInitialized) {
            								this._updateMesh(this.mesh);
            						} else {
            								this._meshDirty = true;
            						}
            				}
            		}
            		_updateAabb(aabb) {
            				aabb.center.set(0, 0, 0);
            				aabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);
            				aabb.setFromTransformedAabb(aabb, this._renderable.node.getWorldTransform());
            				return aabb;
            		}
            		_toggleMask() {
            				this._element._dirtifyMask();
            				var screenSpace = this._element._isScreenSpace();
            				this._updateMaterial(screenSpace);
            				this._renderable.setMask(!!this._mask);
            		}
            		_onMaterialLoad(asset) {
            				this.material = asset.resource;
            		}
            		_onMaterialAdded(asset) {
            				this._system.app.assets.off("add:" + asset.id, this._onMaterialAdded, this);
            				if (this._materialAsset === asset.id) {
            						this._bindMaterialAsset(asset);
            				}
            		}
            		_bindMaterialAsset(asset) {
            				if (!this._entity.enabled) return;
            				asset.on('load', this._onMaterialLoad, this);
            				asset.on('change', this._onMaterialChange, this);
            				asset.on('remove', this._onMaterialRemove, this);
            				if (asset.resource) {
            						this._onMaterialLoad(asset);
            				} else {
            						this._system.app.assets.load(asset);
            				}
            		}
            		_unbindMaterialAsset(asset) {
            				asset.off('load', this._onMaterialLoad, this);
            				asset.off('change', this._onMaterialChange, this);
            				asset.off('remove', this._onMaterialRemove, this);
            		}
            		_onMaterialChange() {}
            		_onMaterialRemove() {}
            		_onTextureAdded(asset) {
            				this._system.app.assets.off("add:" + asset.id, this._onTextureAdded, this);
            				if (this._textureAsset === asset.id) {
            						this._bindTextureAsset(asset);
            				}
            		}
            		_bindTextureAsset(asset) {
            				if (!this._entity.enabled) return;
            				asset.on('load', this._onTextureLoad, this);
            				asset.on('change', this._onTextureChange, this);
            				asset.on('remove', this._onTextureRemove, this);
            				if (asset.resource) {
            						this._onTextureLoad(asset);
            				} else {
            						this._system.app.assets.load(asset);
            				}
            		}
            		_unbindTextureAsset(asset) {
            				asset.off('load', this._onTextureLoad, this);
            				asset.off('change', this._onTextureChange, this);
            				asset.off('remove', this._onTextureRemove, this);
            		}
            		_onTextureLoad(asset) {
            				this.texture = asset.resource;
            		}
            		_onTextureChange(asset) {}
            		_onTextureRemove(asset) {}
            		_onSpriteAssetAdded(asset) {
            				this._system.app.assets.off("add:" + asset.id, this._onSpriteAssetAdded, this);
            				if (this._spriteAsset === asset.id) {
            						this._bindSpriteAsset(asset);
            				}
            		}
            		_bindSpriteAsset(asset) {
            				if (!this._entity.enabled) return;
            				asset.on('load', this._onSpriteAssetLoad, this);
            				asset.on('change', this._onSpriteAssetChange, this);
            				asset.on('remove', this._onSpriteAssetRemove, this);
            				if (asset.resource) {
            						this._onSpriteAssetLoad(asset);
            				} else {
            						this._system.app.assets.load(asset);
            				}
            		}
            		_unbindSpriteAsset(asset) {
            				asset.off('load', this._onSpriteAssetLoad, this);
            				asset.off('change', this._onSpriteAssetChange, this);
            				asset.off('remove', this._onSpriteAssetRemove, this);
            				if (asset.data.textureAtlasAsset) {
            						this._system.app.assets.off("load:" + asset.data.textureAtlasAsset, this._onTextureAtlasLoad, this);
            				}
            		}
            		_onSpriteAssetLoad(asset) {
            				if (!asset || !asset.resource) {
            						this.sprite = null;
            				} else {
            						if (!asset.resource.atlas) {
            								var atlasAssetId = asset.data.textureAtlasAsset;
            								if (atlasAssetId) {
            										var assets = this._system.app.assets;
            										assets.off("load:" + atlasAssetId, this._onTextureAtlasLoad, this);
            										assets.once("load:" + atlasAssetId, this._onTextureAtlasLoad, this);
            								}
            						} else {
            								this.sprite = asset.resource;
            						}
            				}
            		}
            		_onSpriteAssetChange(asset) {
            				this._onSpriteAssetLoad(asset);
            		}
            		_onSpriteAssetRemove(asset) {}
            		_bindSprite(sprite) {
            				this._evtSetMeshes = sprite.on('set:meshes', this._onSpriteMeshesChange, this);
            				sprite.on('set:pixelsPerUnit', this._onSpritePpuChange, this);
            				sprite.on('set:atlas', this._onAtlasTextureChange, this);
            				if (sprite.atlas) {
            						sprite.atlas.on('set:texture', this._onAtlasTextureChange, this);
            				}
            		}
            		_unbindSprite(sprite) {
            				var _this__evtSetMeshes;
            				(_this__evtSetMeshes = this._evtSetMeshes) == null ? void 0 : _this__evtSetMeshes.off();
            				this._evtSetMeshes = null;
            				sprite.off('set:pixelsPerUnit', this._onSpritePpuChange, this);
            				sprite.off('set:atlas', this._onAtlasTextureChange, this);
            				if (sprite.atlas) {
            						sprite.atlas.off('set:texture', this._onAtlasTextureChange, this);
            				}
            		}
            		_onSpriteMeshesChange() {
            				if (this._sprite) {
            						this._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);
            				}
            				this._updateSprite();
            		}
            		_onSpritePpuChange() {
            				if (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE && this._pixelsPerUnit === null) {
            						this._updateSprite();
            				}
            		}
            		_onAtlasTextureChange() {
            				if (this.sprite && this.sprite.atlas && this.sprite.atlas.texture) {
            						this._renderable.setParameter('texture_emissiveMap', this._sprite.atlas.texture);
            						this._renderable.setParameter('texture_opacityMap', this._sprite.atlas.texture);
            				} else {
            						this._renderable.deleteParameter('texture_emissiveMap');
            						this._renderable.deleteParameter('texture_opacityMap');
            				}
            		}
            		_onTextureAtlasLoad(atlasAsset) {
            				var spriteAsset = this._spriteAsset;
            				if (spriteAsset instanceof Asset) {
            						this._onSpriteAssetLoad(spriteAsset);
            				} else {
            						this._onSpriteAssetLoad(this._system.app.assets.get(spriteAsset));
            				}
            		}
            		onEnable() {
            				if (this._materialAsset) {
            						var asset = this._system.app.assets.get(this._materialAsset);
            						if (asset && asset.resource !== this._material) {
            								this._bindMaterialAsset(asset);
            						}
            				}
            				if (this._textureAsset) {
            						var asset1 = this._system.app.assets.get(this._textureAsset);
            						if (asset1 && asset1.resource !== this._texture) {
            								this._bindTextureAsset(asset1);
            						}
            				}
            				if (this._spriteAsset) {
            						var asset2 = this._system.app.assets.get(this._spriteAsset);
            						if (asset2 && asset2.resource !== this._sprite) {
            								this._bindSpriteAsset(asset2);
            						}
            				}
            				this._element.addModelToLayers(this._renderable.model);
            		}
            		onDisable() {
            				this._element.removeModelFromLayers(this._renderable.model);
            		}
            		_setStencil(stencilParams) {
            				this._renderable.meshInstance.stencilFront = stencilParams;
            				this._renderable.meshInstance.stencilBack = stencilParams;
            				var ref = 0;
            				if (this._element.maskedBy) {
            						ref = this._element.maskedBy.element._image._maskRef;
            				}
            				if (this._renderable.unmaskMeshInstance) {
            						var sp = new StencilParameters({
            								ref: ref + 1,
            								func: FUNC_EQUAL,
            								zpass: STENCILOP_DECREMENT
            						});
            						this._renderable.unmaskMeshInstance.stencilFront = sp;
            						this._renderable.unmaskMeshInstance.stencilBack = sp;
            				}
            		}
            		_updateRenderableEmissive() {
            				_tempColor$1.linear(this._color);
            				this._colorUniform[0] = _tempColor$1.r;
            				this._colorUniform[1] = _tempColor$1.g;
            				this._colorUniform[2] = _tempColor$1.b;
            				this._renderable.setParameter('material_emissive', this._colorUniform);
            		}
            		set color(value) {
            				var { r, g, b } = value;
            				if (this._color.r !== r || this._color.g !== g || this._color.b !== b) {
            						this._color.r = r;
            						this._color.g = g;
            						this._color.b = b;
            						this._updateRenderableEmissive();
            				}
            				if (this._element) {
            						this._element.fire('set:color', this._color);
            				}
            		}
            		get color() {
            				return this._color;
            		}
            		set opacity(value) {
            				if (value !== this._color.a) {
            						this._color.a = value;
            						this._renderable.setParameter('material_opacity', value);
            				}
            				if (this._element) {
            						this._element.fire('set:opacity', value);
            				}
            		}
            		get opacity() {
            				return this._color.a;
            		}
            		set rect(value) {
            				var x, y, z, w;
            				if (value instanceof Vec4) {
            						x = value.x;
            						y = value.y;
            						z = value.z;
            						w = value.w;
            				} else {
            						x = value[0];
            						y = value[1];
            						z = value[2];
            						w = value[3];
            				}
            				if (x === this._rect.x && y === this._rect.y && z === this._rect.z && w === this._rect.w) {
            						return;
            				}
            				this._rect.set(x, y, z, w);
            				if (this._renderable.mesh) {
            						if (!this._element._beingInitialized) {
            								this._updateMesh(this._renderable.mesh);
            						} else {
            								this._meshDirty = true;
            						}
            				}
            		}
            		get rect() {
            				return this._rect;
            		}
            		_removeMaterialAssetEvents() {
            				if (this._materialAsset) {
            						var assets = this._system.app.assets;
            						assets.off("add:" + this._materialAsset, this._onMaterialAdded, this);
            						var asset = assets.get(this._materialAsset);
            						if (asset) {
            								asset.off('load', this._onMaterialLoad, this);
            								asset.off('change', this._onMaterialChange, this);
            								asset.off('remove', this._onMaterialRemove, this);
            						}
            				}
            		}
            		set material(value) {
            				if (this._material === value) return;
            				if (!value) {
            						var screenSpace = this._element._isScreenSpace();
            						if (this.mask) {
            								value = screenSpace ? this._system.defaultScreenSpaceImageMaskMaterial : this._system.defaultImageMaskMaterial;
            						} else {
            								value = screenSpace ? this._system.defaultScreenSpaceImageMaterial : this._system.defaultImageMaterial;
            						}
            				}
            				this._material = value;
            				if (this._materialAsset) {
            						var asset = this._system.app.assets.get(this._materialAsset);
            						if (!asset || asset.resource !== value) {
            								this._removeMaterialAssetEvents();
            								this._materialAsset = null;
            						}
            				}
            				if (value) {
            						this._renderable.setMaterial(value);
            						if (this._hasUserMaterial()) {
            								this._renderable.deleteParameter('material_opacity');
            								this._renderable.deleteParameter('material_emissive');
            						} else {
            								this._updateRenderableEmissive();
            								this._renderable.setParameter('material_opacity', this._color.a);
            						}
            				}
            		}
            		get material() {
            				return this._material;
            		}
            		set materialAsset(value) {
            				var assets = this._system.app.assets;
            				var _id = value;
            				if (value instanceof Asset) {
            						_id = value.id;
            				}
            				if (this._materialAsset !== _id) {
            						this._removeMaterialAssetEvents();
            						this._materialAsset = _id;
            						if (this._materialAsset) {
            								var asset = assets.get(this._materialAsset);
            								if (!asset) {
            										this._materialAsset = null;
            										this.material = null;
            										this._materialAsset = _id;
            										assets.on("add:" + this._materialAsset, this._onMaterialAdded, this);
            								} else {
            										this._bindMaterialAsset(asset);
            								}
            						} else {
            								this._materialAsset = null;
            								this.material = null;
            								this._materialAsset = _id;
            						}
            				}
            		}
            		get materialAsset() {
            				return this._materialAsset;
            		}
            		set texture(value) {
            				if (this._texture === value) return;
            				if (this._textureAsset) {
            						var textureAsset = this._system.app.assets.get(this._textureAsset);
            						if (textureAsset && textureAsset.resource !== value) {
            								this.textureAsset = null;
            						}
            				}
            				this._texture = value;
            				if (value) {
            						if (this._spriteAsset) {
            								this.spriteAsset = null;
            						}
            						this._renderable.setParameter('texture_emissiveMap', this._texture);
            						this._renderable.setParameter('texture_opacityMap', this._texture);
            						this._updateRenderableEmissive();
            						this._renderable.setParameter('material_opacity', this._color.a);
            						var newAspectRatio = this._texture.width / this._texture.height;
            						if (newAspectRatio !== this._targetAspectRatio) {
            								this._targetAspectRatio = newAspectRatio;
            								if (this._element.fitMode !== FITMODE_STRETCH) {
            										this.refreshMesh();
            								}
            						}
            				} else {
            						this._renderable.deleteParameter('texture_emissiveMap');
            						this._renderable.deleteParameter('texture_opacityMap');
            						this._targetAspectRatio = -1;
            						if (this._element.fitMode !== FITMODE_STRETCH) {
            								this.refreshMesh();
            						}
            				}
            		}
            		get texture() {
            				return this._texture;
            		}
            		set textureAsset(value) {
            				var assets = this._system.app.assets;
            				var _id = value;
            				if (value instanceof Asset) {
            						_id = value.id;
            				}
            				if (this._textureAsset !== _id) {
            						if (this._textureAsset) {
            								assets.off("add:" + this._textureAsset, this._onTextureAdded, this);
            								var _prev = assets.get(this._textureAsset);
            								if (_prev) {
            										_prev.off('load', this._onTextureLoad, this);
            										_prev.off('change', this._onTextureChange, this);
            										_prev.off('remove', this._onTextureRemove, this);
            								}
            						}
            						this._textureAsset = _id;
            						if (this._textureAsset) {
            								var asset = assets.get(this._textureAsset);
            								if (!asset) {
            										this.texture = null;
            										assets.on("add:" + this._textureAsset, this._onTextureAdded, this);
            								} else {
            										this._bindTextureAsset(asset);
            								}
            						} else {
            								this.texture = null;
            						}
            				}
            		}
            		get textureAsset() {
            				return this._textureAsset;
            		}
            		set spriteAsset(value) {
            				var assets = this._system.app.assets;
            				var _id = value;
            				if (value instanceof Asset) {
            						_id = value.id;
            				}
            				if (this._spriteAsset !== _id) {
            						if (this._spriteAsset) {
            								assets.off("add:" + this._spriteAsset, this._onSpriteAssetAdded, this);
            								var _prev = assets.get(this._spriteAsset);
            								if (_prev) {
            										this._unbindSpriteAsset(_prev);
            								}
            						}
            						this._spriteAsset = _id;
            						if (this._spriteAsset) {
            								var asset = assets.get(this._spriteAsset);
            								if (!asset) {
            										this.sprite = null;
            										assets.on("add:" + this._spriteAsset, this._onSpriteAssetAdded, this);
            								} else {
            										this._bindSpriteAsset(asset);
            								}
            						} else {
            								this.sprite = null;
            						}
            				}
            				if (this._element) {
            						this._element.fire('set:spriteAsset', _id);
            				}
            		}
            		get spriteAsset() {
            				return this._spriteAsset;
            		}
            		set sprite(value) {
            				if (this._sprite === value) return;
            				if (this._sprite) {
            						this._unbindSprite(this._sprite);
            				}
            				if (this._spriteAsset) {
            						var spriteAsset = this._system.app.assets.get(this._spriteAsset);
            						if (spriteAsset && spriteAsset.resource !== value) {
            								this.spriteAsset = null;
            						}
            				}
            				this._sprite = value;
            				if (this._sprite) {
            						this._bindSprite(this._sprite);
            						if (this._textureAsset) {
            								this.textureAsset = null;
            						}
            				}
            				if (this._sprite && this._sprite.atlas && this._sprite.atlas.texture) {
            						this._renderable.setParameter('texture_emissiveMap', this._sprite.atlas.texture);
            						this._renderable.setParameter('texture_opacityMap', this._sprite.atlas.texture);
            				} else {
            						this._renderable.deleteParameter('texture_emissiveMap');
            						this._renderable.deleteParameter('texture_opacityMap');
            				}
            				if (this._sprite) {
            						this._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);
            				}
            				this._updateSprite();
            		}
            		get sprite() {
            				return this._sprite;
            		}
            		set spriteFrame(value) {
            				var oldValue = this._spriteFrame;
            				if (this._sprite) {
            						this._spriteFrame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);
            				} else {
            						this._spriteFrame = value;
            				}
            				if (this._spriteFrame !== oldValue) {
            						this._updateSprite();
            				}
            				if (this._element) {
            						this._element.fire('set:spriteFrame', value);
            				}
            		}
            		get spriteFrame() {
            				return this._spriteFrame;
            		}
            		set mesh(value) {
            				this._renderable.setMesh(value);
            				if (this._defaultMesh === value) {
            						this._renderable.setAabbFunc(null);
            				} else {
            						this._renderable.setAabbFunc(this._updateAabbFunc);
            				}
            		}
            		get mesh() {
            				return this._renderable.mesh;
            		}
            		set mask(value) {
            				if (this._mask !== value) {
            						this._mask = value;
            						this._toggleMask();
            				}
            		}
            		get mask() {
            				return this._mask;
            		}
            		set pixelsPerUnit(value) {
            				if (this._pixelsPerUnit === value) return;
            				this._pixelsPerUnit = value;
            				if (this._sprite && (this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
            						this._updateSprite();
            				}
            		}
            		get pixelsPerUnit() {
            				return this._pixelsPerUnit;
            		}
            		get aabb() {
            				if (this._renderable.meshInstance) {
            						return this._renderable.meshInstance.aabb;
            				}
            				return null;
            		}
            		constructor(element){
            				this._evtSetMeshes = null;
            				this._element = element;
            				this._entity = element.entity;
            				this._system = element.system;
            				this._textureAsset = null;
            				this._texture = null;
            				this._materialAsset = null;
            				this._material = null;
            				this._spriteAsset = null;
            				this._sprite = null;
            				this._spriteFrame = 0;
            				this._pixelsPerUnit = null;
            				this._targetAspectRatio = -1;
            				this._rect = new Vec4(0, 0, 1, 1);
            				this._mask = false;
            				this._maskRef = 0;
            				this._outerScale = new Vec2();
            				this._outerScaleUniform = new Float32Array(2);
            				this._innerOffset = new Vec4();
            				this._innerOffsetUniform = new Float32Array(4);
            				this._atlasRect = new Vec4();
            				this._atlasRectUniform = new Float32Array(4);
            				this._defaultMesh = this._createMesh();
            				this._renderable = new ImageRenderable(this._entity, this._defaultMesh, this._material);
            				this._color = new Color(1, 1, 1, 1);
            				this._colorUniform = new Float32Array([
            						1,
            						1,
            						1
            				]);
            				this._updateRenderableEmissive();
            				this._renderable.setParameter('material_opacity', 1);
            				this._updateAabbFunc = this._updateAabb.bind(this);
            				this._onScreenChange(this._element.screen);
            				this._element.on('resize', this._onParentResizeOrPivotChange, this);
            				this._element.on('set:pivot', this._onParentResizeOrPivotChange, this);
            				this._element.on('screen:set:screenspace', this._onScreenSpaceChange, this);
            				this._element.on('set:screen', this._onScreenChange, this);
            				this._element.on('set:draworder', this._onDrawOrderChange, this);
            				this._element.on('screen:set:resolution', this._onResolutionChange, this);
            		}
            }
            
            class LocalizedAsset extends EventHandler {
            		set defaultAsset(value) {
            				var id = value instanceof Asset ? value.id : value;
            				if (this._defaultAsset === id) return;
            				if (this._defaultAsset) {
            						this._unbindDefaultAsset();
            				}
            				this._defaultAsset = id;
            				if (this._defaultAsset) {
            						this._bindDefaultAsset();
            				}
            				this._onSetLocale(this._app.i18n.locale);
            		}
            		get defaultAsset() {
            				return this._defaultAsset;
            		}
            		set localizedAsset(value) {
            				var id = value instanceof Asset ? value.id : value;
            				if (this._localizedAsset === id) {
            						return;
            				}
            				if (this._localizedAsset) {
            						this._app.assets.off("add:" + this._localizedAsset, this._onLocalizedAssetAdd, this);
            						this._unbindLocalizedAsset();
            				}
            				this._localizedAsset = id;
            				if (this._localizedAsset) {
            						var asset = this._app.assets.get(this._localizedAsset);
            						if (!asset) {
            								this._app.assets.once("add:" + this._localizedAsset, this._onLocalizedAssetAdd, this);
            						} else {
            								this._bindLocalizedAsset();
            						}
            				}
            		}
            		get localizedAsset() {
            				return this._localizedAsset;
            		}
            		set autoLoad(value) {
            				if (this._autoLoad === value) return;
            				this._autoLoad = value;
            				if (this._autoLoad && this._localizedAsset) {
            						this._unbindLocalizedAsset();
            						this._bindLocalizedAsset();
            				}
            		}
            		get autoLoad() {
            				return this._autoLoad;
            		}
            		set disableLocalization(value) {
            				if (this._disableLocalization === value) return;
            				this._disableLocalization = value;
            				this._onSetLocale(this._app.i18n.locale);
            		}
            		get disableLocalization() {
            				return this._disableLocalization;
            		}
            		_bindDefaultAsset() {
            				var asset = this._app.assets.get(this._defaultAsset);
            				if (!asset) {
            						this._app.assets.once("add:" + this._defaultAsset, this._onDefaultAssetAdd, this);
            				} else {
            						this._onDefaultAssetAdd(asset);
            				}
            		}
            		_unbindDefaultAsset() {
            				if (!this._defaultAsset) return;
            				this._app.assets.off("add:" + this._defaultAsset, this._onDefaultAssetAdd, this);
            				var asset = this._app.assets.get(this._defaultAsset);
            				if (!asset) return;
            				asset.off('add:localized', this._onLocaleAdd, this);
            				asset.off('remove:localized', this._onLocaleRemove, this);
            				asset.off('remove', this._onDefaultAssetRemove, this);
            		}
            		_onDefaultAssetAdd(asset) {
            				if (this._defaultAsset !== asset.id) return;
            				asset.on('add:localized', this._onLocaleAdd, this);
            				asset.on('remove:localized', this._onLocaleRemove, this);
            				asset.once('remove', this._onDefaultAssetRemove, this);
            		}
            		_onDefaultAssetRemove(asset) {
            				if (this._defaultAsset !== asset.id) return;
            				asset.off('add:localized', this._onLocaleAdd, this);
            				asset.off('remove:localized', this._onLocaleAdd, this);
            				this._app.assets.once("add:" + this._defaultAsset, this._onDefaultAssetAdd, this);
            		}
            		_bindLocalizedAsset() {
            				if (!this._autoLoad) return;
            				var asset = this._app.assets.get(this._localizedAsset);
            				if (!asset) return;
            				asset.on('load', this._onLocalizedAssetLoad, this);
            				asset.on('change', this._onLocalizedAssetChange, this);
            				asset.on('remove', this._onLocalizedAssetRemove, this);
            				if (asset.resource) {
            						this._onLocalizedAssetLoad(asset);
            				} else {
            						this._app.assets.load(asset);
            				}
            		}
            		_unbindLocalizedAsset() {
            				var asset = this._app.assets.get(this._localizedAsset);
            				if (!asset) return;
            				asset.off('load', this._onLocalizedAssetLoad, this);
            				asset.off('change', this._onLocalizedAssetChange, this);
            				asset.off('remove', this._onLocalizedAssetRemove, this);
            		}
            		_onLocalizedAssetAdd(asset) {
            				if (this._localizedAsset !== asset.id) return;
            				this._bindLocalizedAsset();
            		}
            		_onLocalizedAssetLoad(asset) {
            				this.fire('load', asset);
            		}
            		_onLocalizedAssetChange(asset, name, newValue, oldValue) {
            				this.fire('change', asset, name, newValue, oldValue);
            		}
            		_onLocalizedAssetRemove(asset) {
            				if (this._localizedAsset === asset.id) {
            						this.localizedAsset = this._defaultAsset;
            				}
            				this.fire('remove', asset);
            		}
            		_onLocaleAdd(locale, assetId) {
            				if (this._app.i18n.locale !== locale) return;
            				this._onSetLocale(locale);
            		}
            		_onLocaleRemove(locale, assetId) {
            				if (this._app.i18n.locale !== locale) return;
            				this._onSetLocale(locale);
            		}
            		_onSetLocale(locale) {
            				if (!this._defaultAsset) {
            						this.localizedAsset = null;
            						return;
            				}
            				var asset = this._app.assets.get(this._defaultAsset);
            				if (!asset || this._disableLocalization) {
            						this.localizedAsset = this._defaultAsset;
            						return;
            				}
            				var localizedAssetId = asset.getLocalizedAssetId(locale);
            				if (!localizedAssetId) {
            						this.localizedAsset = this._defaultAsset;
            						return;
            				}
            				this.localizedAsset = localizedAssetId;
            		}
            		destroy() {
            				this.defaultAsset = null;
            				this._app.i18n.off('set:locale', this._onSetLocale, this);
            				this.off();
            		}
            		constructor(app){
            				super();
            				this._app = app;
            				app.i18n.on('set:locale', this._onSetLocale, this);
            				this._autoLoad = false;
            				this._disableLocalization = false;
            				this._defaultAsset = null;
            				this._localizedAsset = null;
            		}
            }
            
            var FONT_MSDF = 'msdf';
            var FONT_BITMAP = 'bitmap';
            
            var EOF_TOKEN = 0;
            var ERROR_TOKEN = 1;
            var TEXT_TOKEN = 2;
            var OPEN_BRACKET_TOKEN = 3;
            var CLOSE_BRACKET_TOKEN = 4;
            var EQUALS_TOKEN = 5;
            var STRING_TOKEN = 6;
            var IDENTIFIER_TOKEN = 7;
            var WHITESPACE_TOKEN = 8;
            var WHITESPACE_CHARS = ' \t\n\r\v\f';
            var IDENTIFIER_REGEX = /[\w|/]/;
            class Scanner {
            		read() {
            				var token = this._read();
            				while(token === WHITESPACE_TOKEN){
            						token = this._read();
            				}
            				if (token !== EOF_TOKEN && token !== ERROR_TOKEN) {
            						this._last = this._index;
            				}
            				return token;
            		}
            		buf() {
            				return this._buf;
            		}
            		last() {
            				return this._last;
            		}
            		error() {
            				return this._error;
            		}
            		debugPrint() {
            				var tokenStrings = [
            						'EOF',
            						'ERROR',
            						'TEXT',
            						'OPEN_BRACKET',
            						'CLOSE_BRACKET',
            						'EQUALS',
            						'STRING',
            						'IDENTIFIER',
            						'WHITESPACE'
            				];
            				var token = this.read();
            				var result = '';
            				while(true){
            						result += (result.length > 0 ? '\n' : '') + tokenStrings[token] + " '" + this.buf().join('') + "'";
            						if (token === EOF_TOKEN || token === ERROR_TOKEN) {
            								break;
            						}
            						token = this.read();
            				}
            				return result;
            		}
            		_read() {
            				this._buf = [];
            				if (this._eof()) {
            						return EOF_TOKEN;
            				}
            				return this._mode === 'text' ? this._text() : this._tag();
            		}
            		_text() {
            				while(true){
            						switch(this._cur){
            								case null:
            										return this._buf.length > 0 ? TEXT_TOKEN : EOF_TOKEN;
            								case '[':
            										this._mode = 'tag';
            										return this._buf.length > 0 ? TEXT_TOKEN : this._tag();
            								case '\\':
            										this._next();
            										switch(this._cur){
            												case '[':
            														this._store();
            														break;
            												default:
            														this._output('\\');
            														break;
            										}
            										break;
            								default:
            										this._store();
            										break;
            						}
            				}
            		}
            		_tag() {
            				switch(this._cur){
            						case null:
            								this._error = 'unexpected end of input reading tag';
            								return ERROR_TOKEN;
            						case '[':
            								this._store();
            								return OPEN_BRACKET_TOKEN;
            						case ']':
            								this._store();
            								this._mode = 'text';
            								return CLOSE_BRACKET_TOKEN;
            						case '=':
            								this._store();
            								return EQUALS_TOKEN;
            						case ' ':
            						case '\t':
            						case '\n':
            						case '\r':
            						case '\v':
            						case '\f':
            								return this._whitespace();
            						case '"':
            								return this._string();
            						default:
            								if (!this._isIdentifierSymbol(this._cur)) {
            										this._error = 'unrecognized character';
            										return ERROR_TOKEN;
            								}
            								return this._identifier();
            				}
            		}
            		_whitespace() {
            				this._store();
            				while(WHITESPACE_CHARS.indexOf(this._cur) !== -1){
            						this._store();
            				}
            				return WHITESPACE_TOKEN;
            		}
            		_string() {
            				this._next();
            				while(true){
            						switch(this._cur){
            								case null:
            										this._error = 'unexpected end of input reading string';
            										return ERROR_TOKEN;
            								case '"':
            										this._next();
            										return STRING_TOKEN;
            								default:
            										this._store();
            										break;
            						}
            				}
            		}
            		_identifier() {
            				this._store();
            				while(this._cur !== null && this._isIdentifierSymbol(this._cur)){
            						this._store();
            				}
            				return IDENTIFIER_TOKEN;
            		}
            		_isIdentifierSymbol(s) {
            				return s.length === 1 && s.match(IDENTIFIER_REGEX) !== null;
            		}
            		_eof() {
            				return this._cur === null;
            		}
            		_next() {
            				if (!this._eof()) {
            						this._index++;
            						this._cur = this._index < this._symbols.length ? this._symbols[this._index] : null;
            				}
            				return this._cur;
            		}
            		_store() {
            				this._buf.push(this._cur);
            				return this._next();
            		}
            		_output(c) {
            				this._buf.push(c);
            		}
            		constructor(symbols){
            				this._symbols = symbols;
            				this._index = 0;
            				this._last = 0;
            				this._cur = this._symbols.length > 0 ? this._symbols[0] : null;
            				this._buf = [];
            				this._mode = 'text';
            				this._error = null;
            		}
            }
            class Parser {
            		parse(symbols, tags) {
            				while(true){
            						var token = this._scanner.read();
            						switch(token){
            								case EOF_TOKEN:
            										return true;
            								case ERROR_TOKEN:
            										return false;
            								case TEXT_TOKEN:
            										Array.prototype.push.apply(symbols, this._scanner.buf());
            										break;
            								case OPEN_BRACKET_TOKEN:
            										if (!this._parseTag(symbols, tags)) {
            												return false;
            										}
            										break;
            								default:
            										return false;
            						}
            				}
            		}
            		error() {
            				return "Error evaluating markup at #" + this._scanner.last().toString() + " (" + (this._scanner.error() || this._error) + ")";
            		}
            		_parseTag(symbols, tags) {
            				var token = this._scanner.read();
            				if (token !== IDENTIFIER_TOKEN) {
            						this._error = 'expected identifier';
            						return false;
            				}
            				var name = this._scanner.buf().join('');
            				if (name[0] === '/') {
            						for(var index = tags.length - 1; index >= 0; --index){
            								if (name === "/" + tags[index].name && tags[index].end === null) {
            										tags[index].end = symbols.length;
            										token = this._scanner.read();
            										if (token !== CLOSE_BRACKET_TOKEN) {
            												this._error = 'expected close bracket';
            												return false;
            										}
            										return true;
            								}
            						}
            						this._error = 'failed to find matching tag';
            						return false;
            				}
            				var tag = {
            						name: name,
            						value: null,
            						attributes: {},
            						start: symbols.length,
            						end: null
            				};
            				token = this._scanner.read();
            				if (token === EQUALS_TOKEN) {
            						token = this._scanner.read();
            						if (token !== STRING_TOKEN) {
            								this._error = 'expected string';
            								return false;
            						}
            						tag.value = this._scanner.buf().join('');
            						token = this._scanner.read();
            				}
            				while(true){
            						switch(token){
            								case CLOSE_BRACKET_TOKEN:
            										tags.push(tag);
            										return true;
            								case IDENTIFIER_TOKEN:
            										{
            												var identifier = this._scanner.buf().join('');
            												token = this._scanner.read();
            												if (token !== EQUALS_TOKEN) {
            														this._error = 'expected equals';
            														return false;
            												}
            												token = this._scanner.read();
            												if (token !== STRING_TOKEN) {
            														this._error = 'expected string';
            														return false;
            												}
            												var value = this._scanner.buf().join('');
            												tag.attributes[identifier] = value;
            												break;
            										}
            								default:
            										this._error = 'expected close bracket or identifier';
            										return false;
            						}
            						token = this._scanner.read();
            				}
            		}
            		constructor(symbols){
            				this._scanner = new Scanner(symbols);
            				this._error = null;
            		}
            }
            function merge(target, source) {
            		for(var key in source){
            				if (!source.hasOwnProperty(key)) {
            						continue;
            				}
            				var value = source[key];
            				if (value instanceof Object) {
            						if (!target.hasOwnProperty(key)) {
            								target[key] = {};
            						}
            						merge(target[key], source[key]);
            				} else {
            						target[key] = value;
            				}
            		}
            }
            function combineTags(tags) {
            		if (tags.length === 0) {
            				return null;
            		}
            		var result = {};
            		for(var index = 0; index < tags.length; ++index){
            				var tag = tags[index];
            				var tmp = {};
            				tmp[tag.name] = {
            						value: tag.value,
            						attributes: tag.attributes
            				};
            				merge(result, tmp);
            		}
            		return result;
            }
            function resolveMarkupTags(tags, numSymbols) {
            		if (tags.length === 0) {
            				return null;
            		}
            		var edges = {};
            		for(var index = 0; index < tags.length; ++index){
            				var tag = tags[index];
            				if (!edges.hasOwnProperty(tag.start)) {
            						edges[tag.start] = {
            								open: [
            										tag
            								],
            								close: null
            						};
            				} else {
            						if (edges[tag.start].open === null) {
            								edges[tag.start].open = [
            										tag
            								];
            						} else {
            								edges[tag.start].open.push(tag);
            						}
            				}
            				if (!edges.hasOwnProperty(tag.end)) {
            						edges[tag.end] = {
            								open: null,
            								close: [
            										tag
            								]
            						};
            				} else {
            						if (edges[tag.end].close === null) {
            								edges[tag.end].close = [
            										tag
            								];
            						} else {
            								edges[tag.end].close.push(tag);
            						}
            				}
            		}
            		var tagStack = [];
            		function removeTags(tags) {
            				tagStack = tagStack.filter((tag)=>{
            						return tags.find((t)=>{
            								return t === tag;
            						}) === undefined;
            				});
            		}
            		function addTags(tags) {
            				for(var index = 0; index < tags.length; ++index){
            						tagStack.push(tags[index]);
            				}
            		}
            		var edgeKeys = Object.keys(edges).sort((a, b)=>{
            				return a - b;
            		});
            		var resolvedTags = [];
            		for(var index1 = 0; index1 < edgeKeys.length; ++index1){
            				var edge = edges[edgeKeys[index1]];
            				if (edge.close !== null) {
            						removeTags(edge.close);
            				}
            				if (edge.open !== null) {
            						addTags(edge.open);
            				}
            				resolvedTags.push({
            						start: edgeKeys[index1],
            						tags: combineTags(tagStack)
            				});
            		}
            		var result = [];
            		var prevTag = null;
            		for(var index2 = 0; index2 < resolvedTags.length; ++index2){
            				var resolvedTag = resolvedTags[index2];
            				while(result.length < resolvedTag.start){
            						result.push(prevTag ? prevTag.tags : null);
            				}
            				prevTag = resolvedTag;
            		}
            		while(result.length < numSymbols){
            				result.push(null);
            		}
            		return result;
            }
            function evaluateMarkup(symbols) {
            		var parser = new Parser(symbols);
            		var stripped_symbols = [];
            		var tags = [];
            		if (!parser.parse(stripped_symbols, tags)) {
            				console.warn(parser.error());
            				return {
            						symbols: symbols,
            						tags: null
            				};
            		}
            		var invalidTag = tags.find((t)=>{
            				return t.end === null;
            		});
            		if (invalidTag) {
            				console.warn("Markup error: found unclosed tag='" + invalidTag.name + "'");
            				return {
            						symbols: symbols,
            						tags: null
            				};
            		}
            		var resolved_tags = resolveMarkupTags(tags, stripped_symbols.length);
            		return {
            				symbols: stripped_symbols,
            				tags: resolved_tags
            		};
            }
            class Markup {
            		static evaluate(symbols) {
            				return evaluateMarkup(symbols);
            		}
            }
            
            class MeshInfo {
            		constructor(){
            				this.count = 0;
            				this.quad = 0;
            				this.lines = {};
            				this.positions = [];
            				this.normals = [];
            				this.uvs = [];
            				this.colors = [];
            				this.indices = [];
            				this.outlines = [];
            				this.shadows = [];
            				this.meshInstance = null;
            		}
            }
            function createTextMesh(device, meshInfo) {
            		var mesh = new Mesh(device);
            		mesh.setPositions(meshInfo.positions);
            		mesh.setNormals(meshInfo.normals);
            		mesh.setColors32(meshInfo.colors);
            		mesh.setUvs(0, meshInfo.uvs);
            		mesh.setIndices(meshInfo.indices);
            		mesh.setVertexStream(SEMANTIC_ATTR8, meshInfo.outlines, 3, undefined, TYPE_FLOAT32, false);
            		mesh.setVertexStream(SEMANTIC_ATTR9, meshInfo.shadows, 3, undefined, TYPE_FLOAT32, false);
            		mesh.update();
            		return mesh;
            }
            var LINE_BREAK_CHAR = /^[\r\n]$/;
            var WHITESPACE_CHAR = /^[ \t]$/;
            var WORD_BOUNDARY_CHAR = /^[ \t\-]|\u200b$/;
            var ALPHANUMERIC_CHAR = /^[a-z0-9]$/i;
            var CJK_CHAR = /^[\u1100-\u11ff]|[\u3000-\u9fff\ua960-\ua97f]|[\uac00-\ud7ff]$/;
            var NO_LINE_BREAK_CJK_CHAR = /^[]$/;
            var CONTROL_CHARS = [
            		'\u200B',
            		'\u061C',
            		'\u200E',
            		'\u200F',
            		'\u202A',
            		'\u202B',
            		'\u202C',
            		'\u202D',
            		'\u202E',
            		'\u2066',
            		'\u2067',
            		'\u2068',
            		'\u2069'
            ];
            var CONTROL_GLYPH_DATA = {
            		width: 0,
            		height: 0,
            		xadvance: 0,
            		xoffset: 0,
            		yoffset: 0
            };
            var colorTmp = new Color();
            var vec2Tmp = new Vec2();
            var _tempColor = new Color();
            class TextElement {
            		destroy() {
            				this._setMaterial(null);
            				if (this._model) {
            						this._element.removeModelFromLayers(this._model);
            						this._model.destroy();
            						this._model = null;
            				}
            				this._fontAsset.destroy();
            				this.font = null;
            				this._element.off('resize', this._onParentResize, this);
            				this._element.off('set:screen', this._onScreenChange, this);
            				this._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);
            				this._element.off('set:draworder', this._onDrawOrderChange, this);
            				this._element.off('set:pivot', this._onPivotChange, this);
            				this._system.app.i18n.off('set:locale', this._onLocaleSet, this);
            				this._system.app.i18n.off('data:add', this._onLocalizationData, this);
            				this._system.app.i18n.off('data:remove', this._onLocalizationData, this);
            		}
            		_onParentResize(width, height) {
            				if (this._noResize) return;
            				if (this._font) this._updateText();
            		}
            		_onScreenChange(screen) {
            				if (screen) {
            						this._updateMaterial(screen.screen.screenSpace);
            				} else {
            						this._updateMaterial(false);
            				}
            		}
            		_onScreenSpaceChange(value) {
            				this._updateMaterial(value);
            		}
            		_onDrawOrderChange(order) {
            				this._drawOrder = order;
            				if (this._model) {
            						for(var i = 0, len = this._model.meshInstances.length; i < len; i++){
            								this._model.meshInstances[i].drawOrder = order;
            						}
            				}
            		}
            		_onPivotChange(pivot) {
            				if (this._font) {
            						this._updateText();
            				}
            		}
            		_onLocaleSet(locale) {
            				if (!this._i18nKey) return;
            				if (this.fontAsset) {
            						var asset = this._system.app.assets.get(this.fontAsset);
            						if (!asset || !asset.resource || asset.resource !== this._font) {
            								this.font = null;
            						}
            				}
            				this._resetLocalizedText();
            		}
            		_onLocalizationData(locale, messages) {
            				if (this._i18nKey && messages[this._i18nKey]) {
            						this._resetLocalizedText();
            				}
            		}
            		_resetLocalizedText() {
            				this._setText(this._system.app.i18n.getText(this._i18nKey));
            		}
            		_setText(text) {
            				if (this.unicodeConverter) {
            						var unicodeConverterFunc = this._system.getUnicodeConverter();
            						if (unicodeConverterFunc) {
            								text = unicodeConverterFunc(text);
            						} else {
            								console.warn('Element created with unicodeConverter option but no unicodeConverter function registered');
            						}
            				}
            				if (this._text !== text) {
            						if (this._font) {
            								this._updateText(text);
            						}
            						this._text = text;
            				}
            		}
            		_updateText(text) {
            				var tags;
            				if (text === undefined) text = this._text;
            				this._symbols = string.getSymbols(text.normalize ? text.normalize('NFC') : text);
            				if (this._symbols.length === 0) {
            						this._symbols = [
            								' '
            						];
            				}
            				if (this._enableMarkup) {
            						var results = Markup.evaluate(this._symbols);
            						this._symbols = results.symbols;
            						tags = results.tags || [];
            				}
            				if (this._rtlReorder) {
            						var rtlReorderFunc = this._system.app.systems.element.getRtlReorder();
            						if (rtlReorderFunc) {
            								var results1 = rtlReorderFunc(this._symbols);
            								this._rtl = results1.rtl;
            								this._symbols = results1.mapping.map(function(v) {
            										return this._symbols[v];
            								}, this);
            								if (tags) {
            										tags = results1.mapping.map((v)=>{
            												return tags[v];
            										});
            								}
            						} else {
            								console.warn('Element created with rtlReorder option but no rtlReorder function registered');
            						}
            				} else {
            						this._rtl = false;
            				}
            				var getColorThicknessHash = (color, thickness)=>{
            						return color.toString(true).toLowerCase() + ":" + thickness.toFixed(2);
            				};
            				var getColorOffsetHash = (color, offset)=>{
            						return color.toString(true).toLowerCase() + ":" + offset.x.toFixed(2) + ":" + offset.y.toFixed(2);
            				};
            				if (tags) {
            						var paletteMap = {};
            						var outlinePaletteMap = {};
            						var shadowPaletteMap = {};
            						this._colorPalette = [
            								Math.round(this._color.r * 255),
            								Math.round(this._color.g * 255),
            								Math.round(this._color.b * 255)
            						];
            						this._outlinePalette = [
            								Math.round(this._outlineColor.r * 255),
            								Math.round(this._outlineColor.g * 255),
            								Math.round(this._outlineColor.b * 255),
            								Math.round(this._outlineColor.a * 255),
            								Math.round(this._outlineThickness * 255)
            						];
            						this._shadowPalette = [
            								Math.round(this._shadowColor.r * 255),
            								Math.round(this._shadowColor.g * 255),
            								Math.round(this._shadowColor.b * 255),
            								Math.round(this._shadowColor.a * 255),
            								Math.round(this._shadowOffset.x * 127),
            								Math.round(this._shadowOffset.y * 127)
            						];
            						this._symbolColors = [];
            						this._symbolOutlineParams = [];
            						this._symbolShadowParams = [];
            						paletteMap[this._color.toString(false).toLowerCase()] = 0;
            						outlinePaletteMap[getColorThicknessHash(this._outlineColor, this._outlineThickness)] = 0;
            						shadowPaletteMap[getColorOffsetHash(this._shadowColor, this._shadowOffset)] = 0;
            						for(var i = 0, len = this._symbols.length; i < len; ++i){
            								var tag = tags[i];
            								var color = 0;
            								if (tag && tag.color && tag.color.value) {
            										var c = tag.color.value;
            										if (c.length === 7 && c[0] === '#') {
            												var hex = c.substring(1).toLowerCase();
            												if (paletteMap.hasOwnProperty(hex)) {
            														color = paletteMap[hex];
            												} else {
            														if (/^[0-9a-f]{6}$/.test(hex)) {
            																color = this._colorPalette.length / 3;
            																paletteMap[hex] = color;
            																this._colorPalette.push(parseInt(hex.substring(0, 2), 16));
            																this._colorPalette.push(parseInt(hex.substring(2, 4), 16));
            																this._colorPalette.push(parseInt(hex.substring(4, 6), 16));
            														}
            												}
            										}
            								}
            								this._symbolColors.push(color);
            								var outline = 0;
            								if (tag && tag.outline && (tag.outline.attributes.color || tag.outline.attributes.thickness)) {
            										var color1 = tag.outline.attributes.color ? colorTmp.fromString(tag.outline.attributes.color) : this._outlineColor;
            										var thickness = Number(tag.outline.attributes.thickness);
            										if (Number.isNaN(color1.r) || Number.isNaN(color1.g) || Number.isNaN(color1.b) || Number.isNaN(color1.a)) {
            												color1 = this._outlineColor;
            										}
            										if (Number.isNaN(thickness)) {
            												thickness = this._outlineThickness;
            										}
            										var outlineHash = getColorThicknessHash(color1, thickness);
            										if (outlinePaletteMap.hasOwnProperty(outlineHash)) {
            												outline = outlinePaletteMap[outlineHash];
            										} else {
            												outline = this._outlinePalette.length / 5;
            												outlinePaletteMap[outlineHash] = outline;
            												this._outlinePalette.push(Math.round(color1.r * 255), Math.round(color1.g * 255), Math.round(color1.b * 255), Math.round(color1.a * 255), Math.round(thickness * 255));
            										}
            								}
            								this._symbolOutlineParams.push(outline);
            								var shadow = 0;
            								if (tag && tag.shadow && (tag.shadow.attributes.color || tag.shadow.attributes.offset || tag.shadow.attributes.offsetX || tag.shadow.attributes.offsetY)) {
            										var color2 = tag.shadow.attributes.color ? colorTmp.fromString(tag.shadow.attributes.color) : this._shadowColor;
            										var off = Number(tag.shadow.attributes.offset);
            										var offX = Number(tag.shadow.attributes.offsetX);
            										var offY = Number(tag.shadow.attributes.offsetY);
            										if (Number.isNaN(color2.r) || Number.isNaN(color2.g) || Number.isNaN(color2.b) || Number.isNaN(color2.a)) {
            												color2 = this._shadowColor;
            										}
            										var offset = vec2Tmp.set(!Number.isNaN(offX) ? offX : !Number.isNaN(off) ? off : this._shadowOffset.x, !Number.isNaN(offY) ? offY : !Number.isNaN(off) ? off : this._shadowOffset.y);
            										var shadowHash = getColorOffsetHash(color2, offset);
            										if (shadowPaletteMap.hasOwnProperty(shadowHash)) {
            												shadow = shadowPaletteMap[shadowHash];
            										} else {
            												shadow = this._shadowPalette.length / 6;
            												shadowPaletteMap[shadowHash] = shadow;
            												this._shadowPalette.push(Math.round(color2.r * 255), Math.round(color2.g * 255), Math.round(color2.b * 255), Math.round(color2.a * 255), Math.round(offset.x * 127), Math.round(offset.y * 127));
            										}
            								}
            								this._symbolShadowParams.push(shadow);
            						}
            				} else {
            						this._colorPalette = [];
            						this._symbolColors = null;
            						this._symbolOutlineParams = null;
            						this._symbolShadowParams = null;
            				}
            				this._updateMaterialEmissive();
            				this._updateMaterialOutline();
            				this._updateMaterialShadow();
            				var charactersPerTexture = this._calculateCharsPerTexture();
            				var removedModel = false;
            				var element = this._element;
            				var screenSpace = element._isScreenSpace();
            				var screenCulled = element._isScreenCulled();
            				var visibleFn = function visibleFn(camera) {
            						return element.isVisibleForCamera(camera);
            				};
            				for(var i1 = 0, len1 = this._meshInfo.length; i1 < len1; i1++){
            						var l = charactersPerTexture[i1] || 0;
            						var meshInfo = this._meshInfo[i1];
            						if (meshInfo.count !== l) {
            								if (!removedModel) {
            										element.removeModelFromLayers(this._model);
            										removedModel = true;
            								}
            								meshInfo.count = l;
            								meshInfo.positions.length = meshInfo.normals.length = l * 3 * 4;
            								meshInfo.indices.length = l * 3 * 2;
            								meshInfo.uvs.length = l * 2 * 4;
            								meshInfo.colors.length = l * 4 * 4;
            								meshInfo.outlines.length = l * 4 * 3;
            								meshInfo.shadows.length = l * 4 * 3;
            								if (meshInfo.meshInstance) {
            										this._removeMeshInstance(meshInfo.meshInstance);
            								}
            								if (l === 0) {
            										meshInfo.meshInstance = null;
            										continue;
            								}
            								for(var v = 0; v < l; v++){
            										meshInfo.indices[v * 3 * 2 + 0] = v * 4;
            										meshInfo.indices[v * 3 * 2 + 1] = v * 4 + 1;
            										meshInfo.indices[v * 3 * 2 + 2] = v * 4 + 3;
            										meshInfo.indices[v * 3 * 2 + 3] = v * 4 + 2;
            										meshInfo.indices[v * 3 * 2 + 4] = v * 4 + 3;
            										meshInfo.indices[v * 3 * 2 + 5] = v * 4 + 1;
            										meshInfo.normals[v * 4 * 3 + 0] = 0;
            										meshInfo.normals[v * 4 * 3 + 1] = 0;
            										meshInfo.normals[v * 4 * 3 + 2] = -1;
            										meshInfo.normals[v * 4 * 3 + 3] = 0;
            										meshInfo.normals[v * 4 * 3 + 4] = 0;
            										meshInfo.normals[v * 4 * 3 + 5] = -1;
            										meshInfo.normals[v * 4 * 3 + 6] = 0;
            										meshInfo.normals[v * 4 * 3 + 7] = 0;
            										meshInfo.normals[v * 4 * 3 + 8] = -1;
            										meshInfo.normals[v * 4 * 3 + 9] = 0;
            										meshInfo.normals[v * 4 * 3 + 10] = 0;
            										meshInfo.normals[v * 4 * 3 + 11] = -1;
            								}
            								var mesh = createTextMesh(this._system.app.graphicsDevice, meshInfo);
            								var mi = new MeshInstance(mesh, this._material, this._node);
            								mi.name = "Text Element: " + this._entity.name;
            								mi.castShadow = false;
            								mi.receiveShadow = false;
            								mi.cull = !screenSpace;
            								mi.screenSpace = screenSpace;
            								mi.drawOrder = this._drawOrder;
            								if (screenCulled) {
            										mi.cull = true;
            										mi.isVisibleFunc = visibleFn;
            								}
            								this._setTextureParams(mi, this._font.textures[i1]);
            								mi.setParameter('material_emissive', this._colorUniform);
            								mi.setParameter('material_opacity', this._color.a);
            								mi.setParameter('font_sdfIntensity', this._font.intensity);
            								mi.setParameter('font_pxrange', this._getPxRange(this._font));
            								mi.setParameter('font_textureWidth', this._font.data.info.maps[i1].width);
            								mi.setParameter('outline_color', this._outlineColorUniform);
            								mi.setParameter('outline_thickness', this._outlineThicknessScale * this._outlineThickness);
            								mi.setParameter('shadow_color', this._shadowColorUniform);
            								if (this._symbolShadowParams) {
            										this._shadowOffsetUniform[0] = 0;
            										this._shadowOffsetUniform[1] = 0;
            								} else {
            										var ratio = -this._font.data.info.maps[i1].width / this._font.data.info.maps[i1].height;
            										this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;
            										this._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;
            								}
            								mi.setParameter('shadow_offset', this._shadowOffsetUniform);
            								meshInfo.meshInstance = mi;
            								this._model.meshInstances.push(mi);
            						}
            				}
            				if (this._element.maskedBy) {
            						this._element._setMaskedBy(this._element.maskedBy);
            				}
            				if (removedModel && this._element.enabled && this._entity.enabled) {
            						this._element.addModelToLayers(this._model);
            				}
            				this._updateMeshes();
            				this._rangeStart = 0;
            				this._rangeEnd = this._symbols.length;
            				this._updateRenderRange();
            		}
            		_removeMeshInstance(meshInstance) {
            				meshInstance.destroy();
            				var idx = this._model.meshInstances.indexOf(meshInstance);
            				if (idx !== -1) {
            						this._model.meshInstances.splice(idx, 1);
            				}
            		}
            		_setMaterial(material) {
            				this._material = material;
            				if (this._model) {
            						for(var i = 0, len = this._model.meshInstances.length; i < len; i++){
            								var mi = this._model.meshInstances[i];
            								mi.material = material;
            						}
            				}
            		}
            		_updateMaterial(screenSpace) {
            				var element = this._element;
            				var screenCulled = element._isScreenCulled();
            				var visibleFn = function visibleFn(camera) {
            						return element.isVisibleForCamera(camera);
            				};
            				var msdf = this._font && this._font.type === FONT_MSDF;
            				this._material = this._system.getTextElementMaterial(screenSpace, msdf, this._enableMarkup);
            				if (this._model) {
            						for(var i = 0, len = this._model.meshInstances.length; i < len; i++){
            								var mi = this._model.meshInstances[i];
            								mi.cull = !screenSpace;
            								mi.material = this._material;
            								mi.screenSpace = screenSpace;
            								if (screenCulled) {
            										mi.cull = true;
            										mi.isVisibleFunc = visibleFn;
            								} else {
            										mi.isVisibleFunc = null;
            								}
            						}
            				}
            		}
            		_updateMaterialEmissive() {
            				if (this._symbolColors) {
            						this._colorUniform[0] = 1;
            						this._colorUniform[1] = 1;
            						this._colorUniform[2] = 1;
            				} else {
            						_tempColor.linear(this._color);
            						this._colorUniform[0] = _tempColor.r;
            						this._colorUniform[1] = _tempColor.g;
            						this._colorUniform[2] = _tempColor.b;
            				}
            		}
            		_updateMaterialOutline() {
            				if (this._symbolOutlineParams) {
            						this._outlineColorUniform[0] = 0;
            						this._outlineColorUniform[1] = 0;
            						this._outlineColorUniform[2] = 0;
            						this._outlineColorUniform[3] = 1;
            				} else {
            						_tempColor.linear(this._outlineColor);
            						this._outlineColorUniform[0] = _tempColor.r;
            						this._outlineColorUniform[1] = _tempColor.g;
            						this._outlineColorUniform[2] = _tempColor.b;
            						this._outlineColorUniform[3] = _tempColor.a;
            				}
            		}
            		_updateMaterialShadow() {
            				if (this._symbolOutlineParams) {
            						this._shadowColorUniform[0] = 0;
            						this._shadowColorUniform[1] = 0;
            						this._shadowColorUniform[2] = 0;
            						this._shadowColorUniform[3] = 0;
            				} else {
            						_tempColor.linear(this._shadowColor);
            						this._shadowColorUniform[0] = _tempColor.r;
            						this._shadowColorUniform[1] = _tempColor.g;
            						this._shadowColorUniform[2] = _tempColor.b;
            						this._shadowColorUniform[3] = _tempColor.a;
            				}
            		}
            		_isWordBoundary(char) {
            				return WORD_BOUNDARY_CHAR.test(char);
            		}
            		_isValidNextChar(nextchar) {
            				return nextchar !== null && !NO_LINE_BREAK_CJK_CHAR.test(nextchar);
            		}
            		_isNextCJKBoundary(char, nextchar) {
            				return CJK_CHAR.test(char) && (WORD_BOUNDARY_CHAR.test(nextchar) || ALPHANUMERIC_CHAR.test(nextchar));
            		}
            		_isNextCJKWholeWord(nextchar) {
            				return CJK_CHAR.test(nextchar);
            		}
            		_updateMeshes() {
            				var json = this._font.data;
            				var self = this;
            				var minFont = Math.min(this._minFontSize, this._maxFontSize);
            				var maxFont = this._maxFontSize;
            				var autoFit = this._shouldAutoFit();
            				if (autoFit) {
            						this._fontSize = this._maxFontSize;
            				}
            				var MAGIC = 32;
            				var l = this._symbols.length;
            				var _x = 0;
            				var _y = 0;
            				var _z = 0;
            				var _xMinusTrailingWhitespace = 0;
            				var lines = 1;
            				var wordStartX = 0;
            				var wordStartIndex = 0;
            				var lineStartIndex = 0;
            				var numWordsThisLine = 0;
            				var numCharsThisLine = 0;
            				var numBreaksThisLine = 0;
            				var splitHorizontalAnchors = Math.abs(this._element.anchor.x - this._element.anchor.z) >= 0.0001;
            				var maxLineWidth = this._element.calculatedWidth;
            				if (this.autoWidth && !splitHorizontalAnchors || !this._wrapLines) {
            						maxLineWidth = Number.POSITIVE_INFINITY;
            				}
            				var fontMinY = 0;
            				var fontMaxY = 0;
            				var char, data, quad, nextchar;
            				function breakLine(symbols, lineBreakIndex, lineBreakX) {
            						self._lineWidths.push(Math.abs(lineBreakX));
            						var sliceStart = lineStartIndex > lineBreakIndex ? lineBreakIndex + 1 : lineStartIndex;
            						var sliceEnd = lineStartIndex > lineBreakIndex ? lineStartIndex + 1 : lineBreakIndex;
            						var chars = symbols.slice(sliceStart, sliceEnd);
            						if (numBreaksThisLine) {
            								var i = chars.length;
            								while(i-- && numBreaksThisLine > 0){
            										if (LINE_BREAK_CHAR.test(chars[i])) {
            												chars.splice(i, 1);
            												numBreaksThisLine--;
            										}
            								}
            						}
            						self._lineContents.push(chars.join(''));
            						_x = 0;
            						_y -= self._scaledLineHeight;
            						lines++;
            						numWordsThisLine = 0;
            						numCharsThisLine = 0;
            						numBreaksThisLine = 0;
            						wordStartX = 0;
            						lineStartIndex = lineBreakIndex;
            				}
            				var retryUpdateMeshes = true;
            				while(retryUpdateMeshes){
            						retryUpdateMeshes = false;
            						if (autoFit) {
            								this._scaledLineHeight = this._lineHeight * this._fontSize / (this._maxFontSize || 0.0001);
            						} else {
            								this._scaledLineHeight = this._lineHeight;
            						}
            						this.width = 0;
            						this.height = 0;
            						this._lineWidths = [];
            						this._lineContents = [];
            						_x = 0;
            						_y = 0;
            						_z = 0;
            						_xMinusTrailingWhitespace = 0;
            						lines = 1;
            						wordStartX = 0;
            						wordStartIndex = 0;
            						lineStartIndex = 0;
            						numWordsThisLine = 0;
            						numCharsThisLine = 0;
            						numBreaksThisLine = 0;
            						var scale = this._fontSize / MAGIC;
            						fontMinY = this._fontMinY * scale;
            						fontMaxY = this._fontMaxY * scale;
            						for(var i = 0; i < this._meshInfo.length; i++){
            								this._meshInfo[i].quad = 0;
            								this._meshInfo[i].lines = {};
            						}
            						var color_r = 255;
            						var color_g = 255;
            						var color_b = 255;
            						var outline_color_rg = 255 + 255 * 256;
            						var outline_color_ba = 255 + 255 * 256;
            						var outline_thickness = 0;
            						var shadow_color_rg = 255 + 255 * 256;
            						var shadow_color_ba = 255 + 255 * 256;
            						var shadow_offset_xy = 127 + 127 * 256;
            						for(var i1 = 0; i1 < l; i1++){
            								char = this._symbols[i1];
            								nextchar = i1 + 1 >= l ? null : this._symbols[i1 + 1];
            								var isLineBreak = LINE_BREAK_CHAR.test(char);
            								if (isLineBreak) {
            										numBreaksThisLine++;
            										if (!this._wrapLines || this._maxLines < 0 || lines < this._maxLines) {
            												breakLine(this._symbols, i1, _xMinusTrailingWhitespace);
            												wordStartIndex = i1 + 1;
            												lineStartIndex = i1 + 1;
            										}
            										continue;
            								}
            								var x = 0;
            								var y = 0;
            								var advance = 0;
            								var quadsize = 1;
            								var dataScale = void 0, size = void 0;
            								data = json.chars[char];
            								if (!data) {
            										if (CONTROL_CHARS.indexOf(char) !== -1) {
            												data = CONTROL_GLYPH_DATA;
            										} else {
            												if (json.chars[' ']) {
            														data = json.chars[' '];
            												} else {
            														for(var key in json.chars){
            																data = json.chars[key];
            																break;
            														}
            												}
            										}
            								}
            								if (data) {
            										var kerning = 0;
            										if (numCharsThisLine > 0) {
            												var kernTable = this._font.data.kerning;
            												if (kernTable) {
            														var kernLeft = kernTable[string.getCodePoint(this._symbols[i1 - 1]) || 0];
            														if (kernLeft) {
            																kerning = kernLeft[string.getCodePoint(this._symbols[i1]) || 0] || 0;
            														}
            												}
            										}
            										dataScale = data.scale || 1;
            										size = (data.width + data.height) / 2;
            										quadsize = scale * size / dataScale;
            										advance = (data.xadvance + kerning) * scale;
            										x = (data.xoffset - kerning) * scale;
            										y = data.yoffset * scale;
            								} else {
            										console.error("Couldn't substitute missing character: '" + char + "'");
            								}
            								var isWhitespace = WHITESPACE_CHAR.test(char);
            								var meshInfoId = data && data.map || 0;
            								var ratio = -this._font.data.info.maps[meshInfoId].width / this._font.data.info.maps[meshInfoId].height;
            								var meshInfo = this._meshInfo[meshInfoId];
            								var candidateLineWidth = _x + this._spacing * advance;
            								if (candidateLineWidth > maxLineWidth && numCharsThisLine > 0 && !isWhitespace) {
            										if (this._maxLines < 0 || lines < this._maxLines) {
            												if (numWordsThisLine === 0) {
            														wordStartIndex = i1;
            														breakLine(this._symbols, i1, _xMinusTrailingWhitespace);
            												} else {
            														var backtrack = Math.max(i1 - wordStartIndex, 0);
            														if (this._meshInfo.length <= 1) {
            																meshInfo.lines[lines - 1] -= backtrack;
            																meshInfo.quad -= backtrack;
            														} else {
            																var backtrackStart = wordStartIndex;
            																var backtrackEnd = i1;
            																for(var j = backtrackStart; j < backtrackEnd; j++){
            																		var backChar = this._symbols[j];
            																		var backCharData = json.chars[backChar];
            																		var backMeshInfo = this._meshInfo[backCharData && backCharData.map || 0];
            																		backMeshInfo.lines[lines - 1] -= 1;
            																		backMeshInfo.quad -= 1;
            																}
            														}
            														i1 -= backtrack + 1;
            														breakLine(this._symbols, wordStartIndex, wordStartX);
            														continue;
            												}
            										}
            								}
            								quad = meshInfo.quad;
            								meshInfo.lines[lines - 1] = quad;
            								var left = _x - x;
            								var right = left + quadsize;
            								var bottom = _y - y;
            								var top = bottom + quadsize;
            								if (this._rtl) {
            										var shift = quadsize - x - this._spacing * advance - x;
            										left -= shift;
            										right -= shift;
            								}
            								meshInfo.positions[quad * 4 * 3 + 0] = left;
            								meshInfo.positions[quad * 4 * 3 + 1] = bottom;
            								meshInfo.positions[quad * 4 * 3 + 2] = _z;
            								meshInfo.positions[quad * 4 * 3 + 3] = right;
            								meshInfo.positions[quad * 4 * 3 + 4] = bottom;
            								meshInfo.positions[quad * 4 * 3 + 5] = _z;
            								meshInfo.positions[quad * 4 * 3 + 6] = right;
            								meshInfo.positions[quad * 4 * 3 + 7] = top;
            								meshInfo.positions[quad * 4 * 3 + 8] = _z;
            								meshInfo.positions[quad * 4 * 3 + 9] = left;
            								meshInfo.positions[quad * 4 * 3 + 10] = top;
            								meshInfo.positions[quad * 4 * 3 + 11] = _z;
            								this.width = Math.max(this.width, candidateLineWidth);
            								var fontSize = void 0;
            								if (this._shouldAutoFitWidth() && this.width > this._element.calculatedWidth) {
            										fontSize = Math.floor(this._element.fontSize * this._element.calculatedWidth / (this.width || 0.0001));
            										fontSize = math.clamp(fontSize, minFont, maxFont);
            										if (fontSize !== this._element.fontSize) {
            												this._fontSize = fontSize;
            												retryUpdateMeshes = true;
            												break;
            										}
            								}
            								this.height = Math.max(this.height, fontMaxY - (_y + fontMinY));
            								if (this._shouldAutoFitHeight() && this.height > this._element.calculatedHeight) {
            										fontSize = math.clamp(this._fontSize - 1, minFont, maxFont);
            										if (fontSize !== this._element.fontSize) {
            												this._fontSize = fontSize;
            												retryUpdateMeshes = true;
            												break;
            										}
            								}
            								_x += this._spacing * advance;
            								if (!isWhitespace) {
            										_xMinusTrailingWhitespace = _x;
            								}
            								if (this._isWordBoundary(char) || this._isValidNextChar(nextchar) && (this._isNextCJKBoundary(char, nextchar) || this._isNextCJKWholeWord(nextchar))) {
            										numWordsThisLine++;
            										wordStartX = _xMinusTrailingWhitespace;
            										wordStartIndex = i1 + 1;
            								}
            								numCharsThisLine++;
            								var uv = this._getUv(char);
            								meshInfo.uvs[quad * 4 * 2 + 0] = uv[0];
            								meshInfo.uvs[quad * 4 * 2 + 1] = 1.0 - uv[1];
            								meshInfo.uvs[quad * 4 * 2 + 2] = uv[2];
            								meshInfo.uvs[quad * 4 * 2 + 3] = 1.0 - uv[1];
            								meshInfo.uvs[quad * 4 * 2 + 4] = uv[2];
            								meshInfo.uvs[quad * 4 * 2 + 5] = 1.0 - uv[3];
            								meshInfo.uvs[quad * 4 * 2 + 6] = uv[0];
            								meshInfo.uvs[quad * 4 * 2 + 7] = 1.0 - uv[3];
            								if (this._symbolColors) {
            										var colorIdx = this._symbolColors[i1] * 3;
            										color_r = this._colorPalette[colorIdx];
            										color_g = this._colorPalette[colorIdx + 1];
            										color_b = this._colorPalette[colorIdx + 2];
            								}
            								meshInfo.colors[quad * 4 * 4 + 0] = color_r;
            								meshInfo.colors[quad * 4 * 4 + 1] = color_g;
            								meshInfo.colors[quad * 4 * 4 + 2] = color_b;
            								meshInfo.colors[quad * 4 * 4 + 3] = 255;
            								meshInfo.colors[quad * 4 * 4 + 4] = color_r;
            								meshInfo.colors[quad * 4 * 4 + 5] = color_g;
            								meshInfo.colors[quad * 4 * 4 + 6] = color_b;
            								meshInfo.colors[quad * 4 * 4 + 7] = 255;
            								meshInfo.colors[quad * 4 * 4 + 8] = color_r;
            								meshInfo.colors[quad * 4 * 4 + 9] = color_g;
            								meshInfo.colors[quad * 4 * 4 + 10] = color_b;
            								meshInfo.colors[quad * 4 * 4 + 11] = 255;
            								meshInfo.colors[quad * 4 * 4 + 12] = color_r;
            								meshInfo.colors[quad * 4 * 4 + 13] = color_g;
            								meshInfo.colors[quad * 4 * 4 + 14] = color_b;
            								meshInfo.colors[quad * 4 * 4 + 15] = 255;
            								if (this._symbolOutlineParams) {
            										var outlineIdx = this._symbolOutlineParams[i1] * 5;
            										outline_color_rg = this._outlinePalette[outlineIdx] + this._outlinePalette[outlineIdx + 1] * 256;
            										outline_color_ba = this._outlinePalette[outlineIdx + 2] + this._outlinePalette[outlineIdx + 3] * 256;
            										outline_thickness = this._outlinePalette[outlineIdx + 4];
            								}
            								meshInfo.outlines[quad * 4 * 3 + 0] = outline_color_rg;
            								meshInfo.outlines[quad * 4 * 3 + 1] = outline_color_ba;
            								meshInfo.outlines[quad * 4 * 3 + 2] = outline_thickness;
            								meshInfo.outlines[quad * 4 * 3 + 3] = outline_color_rg;
            								meshInfo.outlines[quad * 4 * 3 + 4] = outline_color_ba;
            								meshInfo.outlines[quad * 4 * 3 + 5] = outline_thickness;
            								meshInfo.outlines[quad * 4 * 3 + 6] = outline_color_rg;
            								meshInfo.outlines[quad * 4 * 3 + 7] = outline_color_ba;
            								meshInfo.outlines[quad * 4 * 3 + 8] = outline_thickness;
            								meshInfo.outlines[quad * 4 * 3 + 9] = outline_color_rg;
            								meshInfo.outlines[quad * 4 * 3 + 10] = outline_color_ba;
            								meshInfo.outlines[quad * 4 * 3 + 11] = outline_thickness;
            								if (this._symbolShadowParams) {
            										var shadowIdx = this._symbolShadowParams[i1] * 6;
            										shadow_color_rg = this._shadowPalette[shadowIdx] + this._shadowPalette[shadowIdx + 1] * 256;
            										shadow_color_ba = this._shadowPalette[shadowIdx + 2] + this._shadowPalette[shadowIdx + 3] * 256;
            										shadow_offset_xy = this._shadowPalette[shadowIdx + 4] + 127 + Math.round(ratio * this._shadowPalette[shadowIdx + 5] + 127) * 256;
            								}
            								meshInfo.shadows[quad * 4 * 3 + 0] = shadow_color_rg;
            								meshInfo.shadows[quad * 4 * 3 + 1] = shadow_color_ba;
            								meshInfo.shadows[quad * 4 * 3 + 2] = shadow_offset_xy;
            								meshInfo.shadows[quad * 4 * 3 + 3] = shadow_color_rg;
            								meshInfo.shadows[quad * 4 * 3 + 4] = shadow_color_ba;
            								meshInfo.shadows[quad * 4 * 3 + 5] = shadow_offset_xy;
            								meshInfo.shadows[quad * 4 * 3 + 6] = shadow_color_rg;
            								meshInfo.shadows[quad * 4 * 3 + 7] = shadow_color_ba;
            								meshInfo.shadows[quad * 4 * 3 + 8] = shadow_offset_xy;
            								meshInfo.shadows[quad * 4 * 3 + 9] = shadow_color_rg;
            								meshInfo.shadows[quad * 4 * 3 + 10] = shadow_color_ba;
            								meshInfo.shadows[quad * 4 * 3 + 11] = shadow_offset_xy;
            								meshInfo.quad++;
            						}
            						if (retryUpdateMeshes) {
            								continue;
            						}
            						if (lineStartIndex < l) {
            								breakLine(this._symbols, l, _x);
            						}
            				}
            				this._noResize = true;
            				this.autoWidth = this._autoWidth;
            				this.autoHeight = this._autoHeight;
            				this._noResize = false;
            				var hp = this._element.pivot.x;
            				var vp = this._element.pivot.y;
            				var ha = this._alignment.x;
            				var va = this._alignment.y;
            				for(var i2 = 0; i2 < this._meshInfo.length; i2++){
            						if (this._meshInfo[i2].count === 0) continue;
            						var prevQuad = 0;
            						for(var line in this._meshInfo[i2].lines){
            								var index = this._meshInfo[i2].lines[line];
            								var lw = this._lineWidths[parseInt(line, 10)];
            								var hoffset = -hp * this._element.calculatedWidth + ha * (this._element.calculatedWidth - lw) * (this._rtl ? -1 : 1);
            								var voffset = (1 - vp) * this._element.calculatedHeight - fontMaxY - (1 - va) * (this._element.calculatedHeight - this.height);
            								for(var quad1 = prevQuad; quad1 <= index; quad1++){
            										this._meshInfo[i2].positions[quad1 * 4 * 3] += hoffset;
            										this._meshInfo[i2].positions[quad1 * 4 * 3 + 3] += hoffset;
            										this._meshInfo[i2].positions[quad1 * 4 * 3 + 6] += hoffset;
            										this._meshInfo[i2].positions[quad1 * 4 * 3 + 9] += hoffset;
            										this._meshInfo[i2].positions[quad1 * 4 * 3 + 1] += voffset;
            										this._meshInfo[i2].positions[quad1 * 4 * 3 + 4] += voffset;
            										this._meshInfo[i2].positions[quad1 * 4 * 3 + 7] += voffset;
            										this._meshInfo[i2].positions[quad1 * 4 * 3 + 10] += voffset;
            								}
            								if (this._rtl) {
            										for(var quad2 = prevQuad; quad2 <= index; quad2++){
            												var idx = quad2 * 4 * 3;
            												for(var vert = 0; vert < 4; ++vert){
            														this._meshInfo[i2].positions[idx + vert * 3] = this._element.calculatedWidth - this._meshInfo[i2].positions[idx + vert * 3] + hoffset * 2;
            												}
            												var tmp0 = this._meshInfo[i2].positions[idx + 3];
            												var tmp1 = this._meshInfo[i2].positions[idx + 6];
            												this._meshInfo[i2].positions[idx + 3] = this._meshInfo[i2].positions[idx + 0];
            												this._meshInfo[i2].positions[idx + 6] = this._meshInfo[i2].positions[idx + 9];
            												this._meshInfo[i2].positions[idx + 0] = tmp0;
            												this._meshInfo[i2].positions[idx + 9] = tmp1;
            										}
            								}
            								prevQuad = index + 1;
            						}
            						var numVertices = this._meshInfo[i2].count * 4;
            						var vertMax = this._meshInfo[i2].quad * 4;
            						var it = new VertexIterator(this._meshInfo[i2].meshInstance.mesh.vertexBuffer);
            						for(var v = 0; v < numVertices; v++){
            								if (v >= vertMax) {
            										it.element[SEMANTIC_POSITION].set(0, 0, 0);
            										it.element[SEMANTIC_TEXCOORD0].set(0, 0);
            										it.element[SEMANTIC_COLOR].set(0, 0, 0, 0);
            										it.element[SEMANTIC_ATTR8].set(0, 0, 0, 0);
            										it.element[SEMANTIC_ATTR9].set(0, 0, 0, 0);
            								} else {
            										it.element[SEMANTIC_POSITION].set(this._meshInfo[i2].positions[v * 3 + 0], this._meshInfo[i2].positions[v * 3 + 1], this._meshInfo[i2].positions[v * 3 + 2]);
            										it.element[SEMANTIC_TEXCOORD0].set(this._meshInfo[i2].uvs[v * 2 + 0], this._meshInfo[i2].uvs[v * 2 + 1]);
            										it.element[SEMANTIC_COLOR].set(this._meshInfo[i2].colors[v * 4 + 0], this._meshInfo[i2].colors[v * 4 + 1], this._meshInfo[i2].colors[v * 4 + 2], this._meshInfo[i2].colors[v * 4 + 3]);
            										it.element[SEMANTIC_ATTR8].set(this._meshInfo[i2].outlines[v * 3 + 0], this._meshInfo[i2].outlines[v * 3 + 1], this._meshInfo[i2].outlines[v * 3 + 2]);
            										it.element[SEMANTIC_ATTR9].set(this._meshInfo[i2].shadows[v * 3 + 0], this._meshInfo[i2].shadows[v * 3 + 1], this._meshInfo[i2].shadows[v * 3 + 2]);
            								}
            								it.next();
            						}
            						it.end();
            						this._meshInfo[i2].meshInstance.mesh.aabb.compute(this._meshInfo[i2].positions);
            						this._meshInfo[i2].meshInstance._aabbVer = -1;
            				}
            				this._aabbDirty = true;
            		}
            		_onFontRender() {
            				this.font = this._font;
            		}
            		_onFontLoad(asset) {
            				if (this.font !== asset.resource) {
            						this.font = asset.resource;
            				}
            		}
            		_onFontChange(asset, name, _new, _old) {
            				if (name === 'data') {
            						this._font.data = _new;
            						var maps = this._font.data.info.maps.length;
            						for(var i = 0; i < maps; i++){
            								if (!this._meshInfo[i]) continue;
            								var mi = this._meshInfo[i].meshInstance;
            								if (mi) {
            										mi.setParameter('font_sdfIntensity', this._font.intensity);
            										mi.setParameter('font_pxrange', this._getPxRange(this._font));
            										mi.setParameter('font_textureWidth', this._font.data.info.maps[i].width);
            								}
            						}
            				}
            		}
            		_onFontRemove(asset) {}
            		_setTextureParams(mi, texture) {
            				if (this._font) {
            						if (this._font.type === FONT_MSDF) {
            								mi.deleteParameter('texture_emissiveMap');
            								mi.deleteParameter('texture_opacityMap');
            								mi.setParameter('texture_msdfMap', texture);
            						} else if (this._font.type === FONT_BITMAP) {
            								mi.deleteParameter('texture_msdfMap');
            								mi.setParameter('texture_emissiveMap', texture);
            								mi.setParameter('texture_opacityMap', texture);
            						}
            				}
            		}
            		_getPxRange(font) {
            				var keys = Object.keys(this._font.data.chars);
            				for(var i = 0; i < keys.length; i++){
            						var char = this._font.data.chars[keys[i]];
            						if (char.range) {
            								return (char.scale || 1) * char.range;
            						}
            				}
            				return 2;
            		}
            		_getUv(char) {
            				var data = this._font.data;
            				if (!data.chars[char]) {
            						var space = ' ';
            						if (data.chars[space]) {
            								return this._getUv(space);
            						}
            						return [
            								0,
            								0,
            								0,
            								0
            						];
            				}
            				var map = data.chars[char].map;
            				var width = data.info.maps[map].width;
            				var height = data.info.maps[map].height;
            				var x = data.chars[char].x;
            				var y = data.chars[char].y;
            				var x1 = x;
            				var y1 = y;
            				var x2 = x + data.chars[char].width;
            				var y2 = y - data.chars[char].height;
            				var edge = 1 - data.chars[char].height / height;
            				return [
            						x1 / width,
            						edge - y1 / height,
            						x2 / width,
            						edge - y2 / height
            				];
            		}
            		onEnable() {
            				this._fontAsset.autoLoad = true;
            				if (this._model) {
            						this._element.addModelToLayers(this._model);
            				}
            		}
            		onDisable() {
            				this._fontAsset.autoLoad = false;
            				if (this._model) {
            						this._element.removeModelFromLayers(this._model);
            				}
            		}
            		_setStencil(stencilParams) {
            				if (this._model) {
            						var instances = this._model.meshInstances;
            						for(var i = 0; i < instances.length; i++){
            								instances[i].stencilFront = stencilParams;
            								instances[i].stencilBack = stencilParams;
            						}
            				}
            		}
            		_shouldAutoFitWidth() {
            				return this._autoFitWidth && !this._autoWidth;
            		}
            		_shouldAutoFitHeight() {
            				return this._autoFitHeight && !this._autoHeight;
            		}
            		_shouldAutoFit() {
            				return this._autoFitWidth && !this._autoWidth || this._autoFitHeight && !this._autoHeight;
            		}
            		_calculateCharsPerTexture(symbolIndex) {
            				var charactersPerTexture = {};
            				if (symbolIndex === undefined) {
            						symbolIndex = this._symbols.length;
            				}
            				for(var i = 0, len = symbolIndex; i < len; i++){
            						var char = this._symbols[i];
            						var info = this._font.data.chars[char];
            						if (!info) {
            								info = this._font.data.chars[' '];
            								if (!info) {
            										info = this._font.data.chars[Object.keys(this._font.data.chars)[0]];
            								}
            						}
            						var map = info.map;
            						if (!charactersPerTexture[map]) {
            								charactersPerTexture[map] = 1;
            						} else {
            								charactersPerTexture[map]++;
            						}
            				}
            				return charactersPerTexture;
            		}
            		_updateRenderRange() {
            				var startChars = this._rangeStart === 0 ? 0 : this._calculateCharsPerTexture(this._rangeStart);
            				var endChars = this._rangeEnd === 0 ? 0 : this._calculateCharsPerTexture(this._rangeEnd);
            				for(var i = 0, len = this._meshInfo.length; i < len; i++){
            						var start = startChars[i] || 0;
            						var end = endChars[i] || 0;
            						var instance = this._meshInfo[i].meshInstance;
            						if (instance) {
            								var mesh = instance.mesh;
            								if (mesh) {
            										mesh.primitive[0].base = start * 3 * 2;
            										mesh.primitive[0].count = (end - start) * 3 * 2;
            								}
            						}
            				}
            		}
            		set text(value) {
            				this._i18nKey = null;
            				var str = value != null && value.toString() || '';
            				this._setText(str);
            		}
            		get text() {
            				return this._text;
            		}
            		set key(value) {
            				var str = value !== null ? value.toString() : null;
            				if (this._i18nKey === str) {
            						return;
            				}
            				this._i18nKey = str;
            				if (str) {
            						this._fontAsset.disableLocalization = false;
            						this._resetLocalizedText();
            				} else {
            						this._fontAsset.disableLocalization = true;
            				}
            		}
            		get key() {
            				return this._i18nKey;
            		}
            		set color(value) {
            				var r = value.r;
            				var g = value.g;
            				var b = value.b;
            				if (this._color.r === r && this._color.g === g && this._color.b === b) {
            						return;
            				}
            				this._color.r = r;
            				this._color.g = g;
            				this._color.b = b;
            				if (!this._model) {
            						return;
            				}
            				if (this._symbolColors) {
            						if (this._font) {
            								this._updateText();
            						}
            				} else {
            						_tempColor.linear(this._color);
            						this._colorUniform[0] = _tempColor.r;
            						this._colorUniform[1] = _tempColor.g;
            						this._colorUniform[2] = _tempColor.b;
            						for(var i = 0, len = this._model.meshInstances.length; i < len; i++){
            								var mi = this._model.meshInstances[i];
            								mi.setParameter('material_emissive', this._colorUniform);
            						}
            				}
            				if (this._element) {
            						this._element.fire('set:color', this._color);
            				}
            		}
            		get color() {
            				return this._color;
            		}
            		set opacity(value) {
            				if (this._color.a !== value) {
            						this._color.a = value;
            						if (this._model) {
            								for(var i = 0, len = this._model.meshInstances.length; i < len; i++){
            										var mi = this._model.meshInstances[i];
            										mi.setParameter('material_opacity', value);
            								}
            						}
            				}
            				if (this._element) {
            						this._element.fire('set:opacity', value);
            				}
            		}
            		get opacity() {
            				return this._color.a;
            		}
            		set lineHeight(value) {
            				var _prev = this._lineHeight;
            				this._lineHeight = value;
            				this._scaledLineHeight = value;
            				if (_prev !== value && this._font) {
            						this._updateText();
            				}
            		}
            		get lineHeight() {
            				return this._lineHeight;
            		}
            		set wrapLines(value) {
            				var _prev = this._wrapLines;
            				this._wrapLines = value;
            				if (_prev !== value && this._font) {
            						this._updateText();
            				}
            		}
            		get wrapLines() {
            				return this._wrapLines;
            		}
            		get lines() {
            				return this._lineContents;
            		}
            		set spacing(value) {
            				var _prev = this._spacing;
            				this._spacing = value;
            				if (_prev !== value && this._font) {
            						this._updateText();
            				}
            		}
            		get spacing() {
            				return this._spacing;
            		}
            		set fontSize(value) {
            				var _prev = this._fontSize;
            				this._fontSize = value;
            				this._originalFontSize = value;
            				if (_prev !== value && this._font) {
            						this._updateText();
            				}
            		}
            		get fontSize() {
            				return this._fontSize;
            		}
            		set fontAsset(value) {
            				this._fontAsset.defaultAsset = value;
            		}
            		get fontAsset() {
            				return this._fontAsset.localizedAsset;
            		}
            		set font(value) {
            				var previousFontType;
            				if (this._font) {
            						previousFontType = this._font.type;
            						if (this._font.off) this._font.off('render', this._onFontRender, this);
            				}
            				this._font = value;
            				this._fontMinY = 0;
            				this._fontMaxY = 0;
            				if (!value) return;
            				var json = this._font.data;
            				for(var charId in json.chars){
            						var data = json.chars[charId];
            						if (data.bounds) {
            								this._fontMinY = Math.min(this._fontMinY, data.bounds[1]);
            								this._fontMaxY = Math.max(this._fontMaxY, data.bounds[3]);
            						}
            				}
            				if (this._font.on) this._font.on('render', this._onFontRender, this);
            				if (this._fontAsset.localizedAsset) {
            						var asset = this._system.app.assets.get(this._fontAsset.localizedAsset);
            						if (asset.resource !== this._font) {
            								this._fontAsset.defaultAsset = null;
            						}
            				}
            				if (value.type !== previousFontType) {
            						var screenSpace = this._element._isScreenSpace();
            						this._updateMaterial(screenSpace);
            				}
            				for(var i = 0, len = this._font.textures.length; i < len; i++){
            						if (!this._meshInfo[i]) {
            								this._meshInfo[i] = new MeshInfo();
            						} else {
            								var mi = this._meshInfo[i].meshInstance;
            								if (mi) {
            										mi.setParameter('font_sdfIntensity', this._font.intensity);
            										mi.setParameter('font_pxrange', this._getPxRange(this._font));
            										mi.setParameter('font_textureWidth', this._font.data.info.maps[i].width);
            										this._setTextureParams(mi, this._font.textures[i]);
            								}
            						}
            				}
            				var removedModel = false;
            				for(var i1 = this._font.textures.length; i1 < this._meshInfo.length; i1++){
            						if (this._meshInfo[i1].meshInstance) {
            								if (!removedModel) {
            										this._element.removeModelFromLayers(this._model);
            										removedModel = true;
            								}
            								this._removeMeshInstance(this._meshInfo[i1].meshInstance);
            						}
            				}
            				if (this._meshInfo.length > this._font.textures.length) {
            						this._meshInfo.length = this._font.textures.length;
            				}
            				this._updateText();
            		}
            		get font() {
            				return this._font;
            		}
            		set alignment(value) {
            				if (value instanceof Vec2) {
            						this._alignment.set(value.x, value.y);
            				} else {
            						this._alignment.set(value[0], value[1]);
            				}
            				if (this._font) {
            						this._updateText();
            				}
            		}
            		get alignment() {
            				return this._alignment;
            		}
            		set autoWidth(value) {
            				var old = this._autoWidth;
            				this._autoWidth = value;
            				if (value && Math.abs(this._element.anchor.x - this._element.anchor.z) < 0.0001) {
            						this._element.width = this.width;
            				}
            				if (old !== value) {
            						var newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
            						if (newFontSize !== this._fontSize) {
            								this._fontSize = newFontSize;
            								if (this._font) {
            										this._updateText();
            								}
            						}
            				}
            		}
            		get autoWidth() {
            				return this._autoWidth;
            		}
            		set autoHeight(value) {
            				var old = this._autoHeight;
            				this._autoHeight = value;
            				if (value && Math.abs(this._element.anchor.y - this._element.anchor.w) < 0.0001) {
            						this._element.height = this.height;
            				}
            				if (old !== value) {
            						var newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
            						if (newFontSize !== this._fontSize) {
            								this._fontSize = newFontSize;
            								if (this._font) {
            										this._updateText();
            								}
            						}
            				}
            		}
            		get autoHeight() {
            				return this._autoHeight;
            		}
            		set rtlReorder(value) {
            				if (this._rtlReorder !== value) {
            						this._rtlReorder = value;
            						if (this._font) {
            								this._updateText();
            						}
            				}
            		}
            		get rtlReorder() {
            				return this._rtlReorder;
            		}
            		set unicodeConverter(value) {
            				if (this._unicodeConverter !== value) {
            						this._unicodeConverter = value;
            						this._setText(this._text);
            				}
            		}
            		get unicodeConverter() {
            				return this._unicodeConverter;
            		}
            		get aabb() {
            				if (this._aabbDirty) {
            						var initialized = false;
            						for(var i = 0; i < this._meshInfo.length; i++){
            								if (!this._meshInfo[i].meshInstance) continue;
            								if (!initialized) {
            										this._aabb.copy(this._meshInfo[i].meshInstance.aabb);
            										initialized = true;
            								} else {
            										this._aabb.add(this._meshInfo[i].meshInstance.aabb);
            								}
            						}
            						this._aabbDirty = false;
            				}
            				return this._aabb;
            		}
            		set outlineColor(value) {
            				var r = value instanceof Color ? value.r : value[0];
            				var g = value instanceof Color ? value.g : value[1];
            				var b = value instanceof Color ? value.b : value[2];
            				var a = value instanceof Color ? value.a : value[3];
            				if (this._outlineColor.r === r && this._outlineColor.g === g && this._outlineColor.b === b && this._outlineColor.a === a) {
            						return;
            				}
            				this._outlineColor.r = r;
            				this._outlineColor.g = g;
            				this._outlineColor.b = b;
            				this._outlineColor.a = a;
            				if (!this._model) {
            						return;
            				}
            				if (this._symbolOutlineParams) {
            						if (this._font) {
            								this._updateText();
            						}
            				} else {
            						_tempColor.linear(this._outlineColor);
            						this._outlineColorUniform[0] = _tempColor.r;
            						this._outlineColorUniform[1] = _tempColor.g;
            						this._outlineColorUniform[2] = _tempColor.b;
            						this._outlineColorUniform[3] = _tempColor.a;
            						for(var i = 0, len = this._model.meshInstances.length; i < len; i++){
            								var mi = this._model.meshInstances[i];
            								mi.setParameter('outline_color', this._outlineColorUniform);
            						}
            				}
            				if (this._element) {
            						this._element.fire('set:outline', this._color);
            				}
            		}
            		get outlineColor() {
            				return this._outlineColor;
            		}
            		set outlineThickness(value) {
            				var _prev = this._outlineThickness;
            				this._outlineThickness = value;
            				if (_prev !== value && this._font) {
            						if (!this._model) {
            								return;
            						}
            						if (this._symbolOutlineParams) {
            								if (this._font) {
            										this._updateText();
            								}
            						} else {
            								for(var i = 0, len = this._model.meshInstances.length; i < len; i++){
            										var mi = this._model.meshInstances[i];
            										mi.setParameter('outline_thickness', this._outlineThicknessScale * this._outlineThickness);
            								}
            						}
            				}
            		}
            		get outlineThickness() {
            				return this._outlineThickness;
            		}
            		set shadowColor(value) {
            				var r = value instanceof Color ? value.r : value[0];
            				var g = value instanceof Color ? value.g : value[1];
            				var b = value instanceof Color ? value.b : value[2];
            				var a = value instanceof Color ? value.a : value[3];
            				if (this._shadowColor.r === r && this._shadowColor.g === g && this._shadowColor.b === b && this._shadowColor.a === a) {
            						return;
            				}
            				this._shadowColor.r = r;
            				this._shadowColor.g = g;
            				this._shadowColor.b = b;
            				this._shadowColor.a = a;
            				if (!this._model) {
            						return;
            				}
            				if (this._symbolShadowParams) {
            						if (this._font) {
            								this._updateText();
            						}
            				} else {
            						_tempColor.linear(this._shadowColor);
            						this._shadowColorUniform[0] = _tempColor.r;
            						this._shadowColorUniform[1] = _tempColor.g;
            						this._shadowColorUniform[2] = _tempColor.b;
            						this._shadowColorUniform[3] = _tempColor.a;
            						for(var i = 0, len = this._model.meshInstances.length; i < len; i++){
            								var mi = this._model.meshInstances[i];
            								mi.setParameter('shadow_color', this._shadowColorUniform);
            						}
            				}
            		}
            		get shadowColor() {
            				return this._shadowColor;
            		}
            		set shadowOffset(value) {
            				var x = value instanceof Vec2 ? value.x : value[0], y = value instanceof Vec2 ? value.y : value[1];
            				if (this._shadowOffset.x === x && this._shadowOffset.y === y) {
            						return;
            				}
            				this._shadowOffset.set(x, y);
            				if (this._font && this._model) {
            						if (this._symbolShadowParams) {
            								this._updateText();
            						} else {
            								for(var i = 0, len = this._model.meshInstances.length; i < len; i++){
            										var ratio = -this._font.data.info.maps[i].width / this._font.data.info.maps[i].height;
            										this._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;
            										this._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;
            										var mi = this._model.meshInstances[i];
            										mi.setParameter('shadow_offset', this._shadowOffsetUniform);
            								}
            						}
            				}
            		}
            		get shadowOffset() {
            				return this._shadowOffset;
            		}
            		set minFontSize(value) {
            				if (this._minFontSize === value) return;
            				this._minFontSize = value;
            				if (this.font && this._shouldAutoFit()) {
            						this._updateText();
            				}
            		}
            		get minFontSize() {
            				return this._minFontSize;
            		}
            		set maxFontSize(value) {
            				if (this._maxFontSize === value) return;
            				this._maxFontSize = value;
            				if (this.font && this._shouldAutoFit()) {
            						this._updateText();
            				}
            		}
            		get maxFontSize() {
            				return this._maxFontSize;
            		}
            		set autoFitWidth(value) {
            				if (this._autoFitWidth === value) return;
            				this._autoFitWidth = value;
            				this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
            				if (this.font) {
            						this._updateText();
            				}
            		}
            		get autoFitWidth() {
            				return this._autoFitWidth;
            		}
            		set autoFitHeight(value) {
            				if (this._autoFitHeight === value) return;
            				this._autoFitHeight = value;
            				this._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;
            				if (this.font) {
            						this._updateText();
            				}
            		}
            		get autoFitHeight() {
            				return this._autoFitHeight;
            		}
            		set maxLines(value) {
            				if (this._maxLines === value) return;
            				if (value === null && this._maxLines === -1) return;
            				this._maxLines = value === null ? -1 : value;
            				if (this.font && this._wrapLines) {
            						this._updateText();
            				}
            		}
            		get maxLines() {
            				return this._maxLines;
            		}
            		set enableMarkup(value) {
            				value = !!value;
            				if (this._enableMarkup === value) return;
            				this._enableMarkup = value;
            				if (this.font) {
            						this._updateText();
            				}
            				var screenSpace = this._element._isScreenSpace();
            				this._updateMaterial(screenSpace);
            		}
            		get enableMarkup() {
            				return this._enableMarkup;
            		}
            		get symbols() {
            				return this._symbols;
            		}
            		get symbolColors() {
            				if (this._symbolColors === null) {
            						return null;
            				}
            				return this._symbolColors.map(function(c) {
            						return this._colorPalette.slice(c * 3, c * 3 + 3);
            				}, this);
            		}
            		get symbolOutlineParams() {
            				if (this._symbolOutlineParams === null) {
            						return null;
            				}
            				return this._symbolOutlineParams.map(function(paramId) {
            						return this._outlinePalette.slice(paramId * 5, paramId * 5 + 5);
            				}, this);
            		}
            		get symbolShadowParams() {
            				if (this._symbolShadowParams === null) {
            						return null;
            				}
            				return this._symbolShadowParams.map(function(paramId) {
            						return this._shadowPalette.slice(paramId * 6, paramId * 6 + 6);
            				}, this);
            		}
            		get rtl() {
            				return this._rtl;
            		}
            		set rangeStart(rangeStart) {
            				rangeStart = Math.max(0, Math.min(rangeStart, this._symbols.length));
            				if (rangeStart !== this._rangeStart) {
            						this._rangeStart = rangeStart;
            						this._updateRenderRange();
            				}
            		}
            		get rangeStart() {
            				return this._rangeStart;
            		}
            		set rangeEnd(rangeEnd) {
            				rangeEnd = Math.max(this._rangeStart, Math.min(rangeEnd, this._symbols.length));
            				if (rangeEnd !== this._rangeEnd) {
            						this._rangeEnd = rangeEnd;
            						this._updateRenderRange();
            				}
            		}
            		get rangeEnd() {
            				return this._rangeEnd;
            		}
            		constructor(element){
            				this._element = element;
            				this._system = element.system;
            				this._entity = element.entity;
            				this._text = '';
            				this._symbols = [];
            				this._colorPalette = [];
            				this._outlinePalette = [];
            				this._shadowPalette = [];
            				this._symbolColors = null;
            				this._symbolOutlineParams = null;
            				this._symbolShadowParams = null;
            				this._i18nKey = null;
            				this._fontAsset = new LocalizedAsset(this._system.app);
            				this._fontAsset.disableLocalization = true;
            				this._fontAsset.on('load', this._onFontLoad, this);
            				this._fontAsset.on('change', this._onFontChange, this);
            				this._fontAsset.on('remove', this._onFontRemove, this);
            				this._font = null;
            				this._color = new Color(1, 1, 1, 1);
            				this._colorUniform = new Float32Array(3);
            				this._spacing = 1;
            				this._fontSize = 32;
            				this._fontMinY = 0;
            				this._fontMaxY = 0;
            				this._originalFontSize = 32;
            				this._maxFontSize = 32;
            				this._minFontSize = 8;
            				this._autoFitWidth = false;
            				this._autoFitHeight = false;
            				this._maxLines = -1;
            				this._lineHeight = 32;
            				this._scaledLineHeight = 32;
            				this._wrapLines = false;
            				this._drawOrder = 0;
            				this._alignment = new Vec2(0.5, 0.5);
            				this._autoWidth = true;
            				this._autoHeight = true;
            				this.width = 0;
            				this.height = 0;
            				this._node = new GraphNode();
            				this._model = new Model();
            				this._model.graph = this._node;
            				this._entity.addChild(this._node);
            				this._meshInfo = [];
            				this._material = null;
            				this._aabbDirty = true;
            				this._aabb = new BoundingBox();
            				this._noResize = false;
            				this._currentMaterialType = null;
            				this._maskedMaterialSrc = null;
            				this._rtlReorder = false;
            				this._unicodeConverter = false;
            				this._rtl = false;
            				this._outlineColor = new Color(0, 0, 0, 1);
            				this._outlineColorUniform = new Float32Array(4);
            				this._outlineThicknessScale = 0.2;
            				this._outlineThickness = 0.0;
            				this._shadowColor = new Color(0, 0, 0, 1);
            				this._shadowColorUniform = new Float32Array(4);
            				this._shadowOffsetScale = 0.005;
            				this._shadowOffset = new Vec2(0, 0);
            				this._shadowOffsetUniform = new Float32Array(2);
            				this._enableMarkup = false;
            				this._onScreenChange(this._element.screen);
            				element.on('resize', this._onParentResize, this);
            				element.on('set:screen', this._onScreenChange, this);
            				element.on('screen:set:screenspace', this._onScreenSpaceChange, this);
            				element.on('set:draworder', this._onDrawOrderChange, this);
            				element.on('set:pivot', this._onPivotChange, this);
            				this._system.app.i18n.on('set:locale', this._onLocaleSet, this);
            				this._system.app.i18n.on('data:add', this._onLocalizationData, this);
            				this._system.app.i18n.on('data:remove', this._onLocalizationData, this);
            				this._rangeStart = 0;
            				this._rangeEnd = 0;
            		}
            }
            
            var position = new Vec3();
            var invParentWtm = new Mat4();
            var vecA$1 = new Vec3();
            var vecB$1 = new Vec3();
            var matA = new Mat4();
            var matB = new Mat4();
            var matC = new Mat4();
            var matD = new Mat4();
            class ElementComponent extends Component {
            		get data() {
            				var record = this.system.store[this.entity.getGuid()];
            				return record ? record.data : null;
            		}
            		set enabled(value) {
            				var data = this.data;
            				var oldValue = data.enabled;
            				data.enabled = value;
            				this.fire('set', 'enabled', oldValue, value);
            		}
            		get enabled() {
            				return this.data.enabled;
            		}
            		get _absLeft() {
            				return this._localAnchor.x + this._margin.x;
            		}
            		get _absRight() {
            				return this._localAnchor.z - this._margin.z;
            		}
            		get _absTop() {
            				return this._localAnchor.w - this._margin.w;
            		}
            		get _absBottom() {
            				return this._localAnchor.y + this._margin.y;
            		}
            		get _hasSplitAnchorsX() {
            				return Math.abs(this._anchor.x - this._anchor.z) > 0.001;
            		}
            		get _hasSplitAnchorsY() {
            				return Math.abs(this._anchor.y - this._anchor.w) > 0.001;
            		}
            		get aabb() {
            				if (this._image) {
            						return this._image.aabb;
            				}
            				if (this._text) {
            						return this._text.aabb;
            				}
            				return null;
            		}
            		set anchor(value) {
            				if (value instanceof Vec4) {
            						this._anchor.copy(value);
            				} else {
            						this._anchor.set(...value);
            				}
            				if (!this.entity._parent && !this.screen) {
            						this._calculateLocalAnchors();
            				} else {
            						this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
            				}
            				this._anchorDirty = true;
            				if (!this.entity._dirtyLocal) {
            						this.entity._dirtifyLocal();
            				}
            				this.fire('set:anchor', this._anchor);
            		}
            		get anchor() {
            				return this._anchor;
            		}
            		set batchGroupId(value) {
            				if (this._batchGroupId === value) {
            						return;
            				}
            				if (this.entity.enabled && this._batchGroupId >= 0) {
            						var _this_system_app_batcher;
            						(_this_system_app_batcher = this.system.app.batcher) == null ? void 0 : _this_system_app_batcher.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
            				}
            				if (this.entity.enabled && value >= 0) {
            						var _this_system_app_batcher1;
            						(_this_system_app_batcher1 = this.system.app.batcher) == null ? void 0 : _this_system_app_batcher1.insert(BatchGroup.ELEMENT, value, this.entity);
            				}
            				if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
            						if (this._image && this._image._renderable.model) {
            								this.addModelToLayers(this._image._renderable.model);
            						} else if (this._text && this._text._model) {
            								this.addModelToLayers(this._text._model);
            						}
            				}
            				this._batchGroupId = value;
            		}
            		get batchGroupId() {
            				return this._batchGroupId;
            		}
            		set bottom(value) {
            				this._margin.y = value;
            				var p = this.entity.getLocalPosition();
            				var wt = this._absTop;
            				var wb = this._localAnchor.y + value;
            				this._setHeight(wt - wb);
            				p.y = value + this._calculatedHeight * this._pivot.y;
            				this.entity.setLocalPosition(p);
            		}
            		get bottom() {
            				return this._margin.y;
            		}
            		set calculatedWidth(value) {
            				this._setCalculatedWidth(value, true);
            		}
            		get calculatedWidth() {
            				return this._calculatedWidth;
            		}
            		set calculatedHeight(value) {
            				this._setCalculatedHeight(value, true);
            		}
            		get calculatedHeight() {
            				return this._calculatedHeight;
            		}
            		get canvasCorners() {
            				if (!this._canvasCornersDirty || !this.screen || !this.screen.screen.screenSpace) {
            						return this._canvasCorners;
            				}
            				var device = this.system.app.graphicsDevice;
            				var screenCorners = this.screenCorners;
            				var sx = device.canvas.clientWidth / device.width;
            				var sy = device.canvas.clientHeight / device.height;
            				for(var i = 0; i < 4; i++){
            						this._canvasCorners[i].set(screenCorners[i].x * sx, (device.height - screenCorners[i].y) * sy);
            				}
            				this._canvasCornersDirty = false;
            				return this._canvasCorners;
            		}
            		set drawOrder(value) {
            				var priority = 0;
            				if (this.screen) {
            						priority = this.screen.screen.priority;
            				}
            				if (value > 0xFFFFFF) {
            						value = 0xFFFFFF;
            				}
            				this._drawOrder = (priority << 24) + value;
            				this.fire('set:draworder', this._drawOrder);
            		}
            		get drawOrder() {
            				return this._drawOrder;
            		}
            		set height(value) {
            				this._height = value;
            				if (!this._hasSplitAnchorsY) {
            						this._setCalculatedHeight(value, true);
            				}
            				this.fire('set:height', this._height);
            		}
            		get height() {
            				return this._height;
            		}
            		set layers(value) {
            				if (this._addedModels.length) {
            						for(var i = 0; i < this._layers.length; i++){
            								var layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
            								if (layer) {
            										for(var j = 0; j < this._addedModels.length; j++){
            												layer.removeMeshInstances(this._addedModels[j].meshInstances);
            										}
            								}
            						}
            				}
            				this._layers = value;
            				if (!this.enabled || !this.entity.enabled || !this._addedModels.length) {
            						return;
            				}
            				for(var i1 = 0; i1 < this._layers.length; i1++){
            						var layer1 = this.system.app.scene.layers.getLayerById(this._layers[i1]);
            						if (layer1) {
            								for(var j1 = 0; j1 < this._addedModels.length; j1++){
            										layer1.addMeshInstances(this._addedModels[j1].meshInstances);
            								}
            						}
            				}
            		}
            		get layers() {
            				return this._layers;
            		}
            		set left(value) {
            				this._margin.x = value;
            				var p = this.entity.getLocalPosition();
            				var wr = this._absRight;
            				var wl = this._localAnchor.x + value;
            				this._setWidth(wr - wl);
            				p.x = value + this._calculatedWidth * this._pivot.x;
            				this.entity.setLocalPosition(p);
            		}
            		get left() {
            				return this._margin.x;
            		}
            		set margin(value) {
            				this._margin.copy(value);
            				this._calculateSize(true, true);
            				this.fire('set:margin', this._margin);
            		}
            		get margin() {
            				return this._margin;
            		}
            		get maskedBy() {
            				return this._maskedBy;
            		}
            		set pivot(value) {
            				var { pivot, margin } = this;
            				var prevX = pivot.x;
            				var prevY = pivot.y;
            				if (value instanceof Vec2) {
            						pivot.copy(value);
            				} else {
            						pivot.set(...value);
            				}
            				var mx = margin.x + margin.z;
            				var dx = pivot.x - prevX;
            				margin.x += mx * dx;
            				margin.z -= mx * dx;
            				var my = margin.y + margin.w;
            				var dy = pivot.y - prevY;
            				margin.y += my * dy;
            				margin.w -= my * dy;
            				this._anchorDirty = true;
            				this._cornersDirty = true;
            				this._worldCornersDirty = true;
            				this._calculateSize(false, false);
            				this._flagChildrenAsDirty();
            				this.fire('set:pivot', pivot);
            		}
            		get pivot() {
            				return this._pivot;
            		}
            		set right(value) {
            				this._margin.z = value;
            				var p = this.entity.getLocalPosition();
            				var wl = this._absLeft;
            				var wr = this._localAnchor.z - value;
            				this._setWidth(wr - wl);
            				p.x = this._localAnchor.z - this._localAnchor.x - value - this._calculatedWidth * (1 - this._pivot.x);
            				this.entity.setLocalPosition(p);
            		}
            		get right() {
            				return this._margin.z;
            		}
            		get screenCorners() {
            				if (!this._cornersDirty || !this.screen) {
            						return this._screenCorners;
            				}
            				var parentBottomLeft = this.entity.parent && this.entity.parent.element && this.entity.parent.element.screenCorners[0];
            				this._screenCorners[0].set(this._absLeft, this._absBottom, 0);
            				this._screenCorners[1].set(this._absRight, this._absBottom, 0);
            				this._screenCorners[2].set(this._absRight, this._absTop, 0);
            				this._screenCorners[3].set(this._absLeft, this._absTop, 0);
            				var screenSpace = this.screen.screen.screenSpace;
            				for(var i = 0; i < 4; i++){
            						this._screenTransform.transformPoint(this._screenCorners[i], this._screenCorners[i]);
            						if (screenSpace) {
            								this._screenCorners[i].mulScalar(this.screen.screen.scale);
            						}
            						if (parentBottomLeft) {
            								this._screenCorners[i].add(parentBottomLeft);
            						}
            				}
            				this._cornersDirty = false;
            				this._canvasCornersDirty = true;
            				this._worldCornersDirty = true;
            				return this._screenCorners;
            		}
            		get textWidth() {
            				return this._text ? this._text.width : 0;
            		}
            		get textHeight() {
            				return this._text ? this._text.height : 0;
            		}
            		set top(value) {
            				this._margin.w = value;
            				var p = this.entity.getLocalPosition();
            				var wb = this._absBottom;
            				var wt = this._localAnchor.w - value;
            				this._setHeight(wt - wb);
            				p.y = this._localAnchor.w - this._localAnchor.y - value - this._calculatedHeight * (1 - this._pivot.y);
            				this.entity.setLocalPosition(p);
            		}
            		get top() {
            				return this._margin.w;
            		}
            		set type(value) {
            				if (value !== this._type) {
            						this._type = value;
            						if (this._image) {
            								this._image.destroy();
            								this._image = null;
            						}
            						if (this._text) {
            								this._text.destroy();
            								this._text = null;
            						}
            						if (value === ELEMENTTYPE_IMAGE) {
            								this._image = new ImageElement(this);
            						} else if (value === ELEMENTTYPE_TEXT) {
            								this._text = new TextElement(this);
            						}
            				}
            		}
            		get type() {
            				return this._type;
            		}
            		set useInput(value) {
            				if (this._useInput === value) {
            						return;
            				}
            				this._useInput = value;
            				if (this.system.app.elementInput) {
            						if (value) {
            								if (this.enabled && this.entity.enabled) {
            										this.system.app.elementInput.addElement(this);
            								}
            						} else {
            								this.system.app.elementInput.removeElement(this);
            						}
            				} else {
            						if (this._useInput === true) ;
            				}
            				this.fire('set:useInput', value);
            		}
            		get useInput() {
            				return this._useInput;
            		}
            		set fitMode(value) {
            				this._fitMode = value;
            				this._calculateSize(true, true);
            				if (this._image) {
            						this._image.refreshMesh();
            				}
            		}
            		get fitMode() {
            				return this._fitMode;
            		}
            		set width(value) {
            				this._width = value;
            				if (!this._hasSplitAnchorsX) {
            						this._setCalculatedWidth(value, true);
            				}
            				this.fire('set:width', this._width);
            		}
            		get width() {
            				return this._width;
            		}
            		get worldCorners() {
            				if (!this._worldCornersDirty) {
            						return this._worldCorners;
            				}
            				if (this.screen) {
            						var screenCorners = this.screenCorners;
            						if (!this.screen.screen.screenSpace) {
            								matA.copy(this.screen.screen._screenMatrix);
            								matA.data[13] = -matA.data[13];
            								matA.mul2(this.screen.getWorldTransform(), matA);
            								for(var i = 0; i < 4; i++){
            										matA.transformPoint(screenCorners[i], this._worldCorners[i]);
            								}
            						}
            				} else {
            						var localPos = this.entity.getLocalPosition();
            						matA.setTranslate(-localPos.x, -localPos.y, -localPos.z);
            						matB.setTRS(Vec3.ZERO, this.entity.getLocalRotation(), this.entity.getLocalScale());
            						matC.setTranslate(localPos.x, localPos.y, localPos.z);
            						var entity = this.entity.parent ? this.entity.parent : this.entity;
            						matD.copy(entity.getWorldTransform());
            						matD.mul(matC).mul(matB).mul(matA);
            						vecA$1.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);
            						matD.transformPoint(vecA$1, this._worldCorners[0]);
            						vecA$1.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);
            						matD.transformPoint(vecA$1, this._worldCorners[1]);
            						vecA$1.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);
            						matD.transformPoint(vecA$1, this._worldCorners[2]);
            						vecA$1.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);
            						matD.transformPoint(vecA$1, this._worldCorners[3]);
            				}
            				this._worldCornersDirty = false;
            				return this._worldCorners;
            		}
            		set fontSize(arg) {
            				this._setValue('fontSize', arg);
            		}
            		get fontSize() {
            				if (this._text) {
            						return this._text.fontSize;
            				}
            				return null;
            		}
            		set minFontSize(arg) {
            				this._setValue('minFontSize', arg);
            		}
            		get minFontSize() {
            				if (this._text) {
            						return this._text.minFontSize;
            				}
            				return null;
            		}
            		set maxFontSize(arg) {
            				this._setValue('maxFontSize', arg);
            		}
            		get maxFontSize() {
            				if (this._text) {
            						return this._text.maxFontSize;
            				}
            				return null;
            		}
            		set maxLines(arg) {
            				this._setValue('maxLines', arg);
            		}
            		get maxLines() {
            				if (this._text) {
            						return this._text.maxLines;
            				}
            				return null;
            		}
            		set autoFitWidth(arg) {
            				this._setValue('autoFitWidth', arg);
            		}
            		get autoFitWidth() {
            				if (this._text) {
            						return this._text.autoFitWidth;
            				}
            				return null;
            		}
            		set autoFitHeight(arg) {
            				this._setValue('autoFitHeight', arg);
            		}
            		get autoFitHeight() {
            				if (this._text) {
            						return this._text.autoFitHeight;
            				}
            				return null;
            		}
            		set color(arg) {
            				this._setValue('color', arg);
            		}
            		get color() {
            				if (this._text) {
            						return this._text.color;
            				}
            				if (this._image) {
            						return this._image.color;
            				}
            				return null;
            		}
            		set font(arg) {
            				this._setValue('font', arg);
            		}
            		get font() {
            				if (this._text) {
            						return this._text.font;
            				}
            				return null;
            		}
            		set fontAsset(arg) {
            				this._setValue('fontAsset', arg);
            		}
            		get fontAsset() {
            				if (this._text && typeof this._text.fontAsset === 'number') {
            						return this._text.fontAsset;
            				}
            				return null;
            		}
            		set spacing(arg) {
            				this._setValue('spacing', arg);
            		}
            		get spacing() {
            				if (this._text) {
            						return this._text.spacing;
            				}
            				return null;
            		}
            		set lineHeight(arg) {
            				this._setValue('lineHeight', arg);
            		}
            		get lineHeight() {
            				if (this._text) {
            						return this._text.lineHeight;
            				}
            				return null;
            		}
            		set wrapLines(arg) {
            				this._setValue('wrapLines', arg);
            		}
            		get wrapLines() {
            				if (this._text) {
            						return this._text.wrapLines;
            				}
            				return null;
            		}
            		set lines(arg) {
            				this._setValue('lines', arg);
            		}
            		get lines() {
            				if (this._text) {
            						return this._text.lines;
            				}
            				return null;
            		}
            		set alignment(arg) {
            				this._setValue('alignment', arg);
            		}
            		get alignment() {
            				if (this._text) {
            						return this._text.alignment;
            				}
            				return null;
            		}
            		set autoWidth(arg) {
            				this._setValue('autoWidth', arg);
            		}
            		get autoWidth() {
            				if (this._text) {
            						return this._text.autoWidth;
            				}
            				return null;
            		}
            		set autoHeight(arg) {
            				this._setValue('autoHeight', arg);
            		}
            		get autoHeight() {
            				if (this._text) {
            						return this._text.autoHeight;
            				}
            				return null;
            		}
            		set rtlReorder(arg) {
            				this._setValue('rtlReorder', arg);
            		}
            		get rtlReorder() {
            				if (this._text) {
            						return this._text.rtlReorder;
            				}
            				return null;
            		}
            		set unicodeConverter(arg) {
            				this._setValue('unicodeConverter', arg);
            		}
            		get unicodeConverter() {
            				if (this._text) {
            						return this._text.unicodeConverter;
            				}
            				return null;
            		}
            		set text(arg) {
            				this._setValue('text', arg);
            		}
            		get text() {
            				if (this._text) {
            						return this._text.text;
            				}
            				return null;
            		}
            		set key(arg) {
            				this._setValue('key', arg);
            		}
            		get key() {
            				if (this._text) {
            						return this._text.key;
            				}
            				return null;
            		}
            		set texture(arg) {
            				this._setValue('texture', arg);
            		}
            		get texture() {
            				if (this._image) {
            						return this._image.texture;
            				}
            				return null;
            		}
            		set textureAsset(arg) {
            				this._setValue('textureAsset', arg);
            		}
            		get textureAsset() {
            				if (this._image) {
            						return this._image.textureAsset;
            				}
            				return null;
            		}
            		set material(arg) {
            				this._setValue('material', arg);
            		}
            		get material() {
            				if (this._image) {
            						return this._image.material;
            				}
            				return null;
            		}
            		set materialAsset(arg) {
            				this._setValue('materialAsset', arg);
            		}
            		get materialAsset() {
            				if (this._image) {
            						return this._image.materialAsset;
            				}
            				return null;
            		}
            		set sprite(arg) {
            				this._setValue('sprite', arg);
            		}
            		get sprite() {
            				if (this._image) {
            						return this._image.sprite;
            				}
            				return null;
            		}
            		set spriteAsset(arg) {
            				this._setValue('spriteAsset', arg);
            		}
            		get spriteAsset() {
            				if (this._image) {
            						return this._image.spriteAsset;
            				}
            				return null;
            		}
            		set spriteFrame(arg) {
            				this._setValue('spriteFrame', arg);
            		}
            		get spriteFrame() {
            				if (this._image) {
            						return this._image.spriteFrame;
            				}
            				return null;
            		}
            		set pixelsPerUnit(arg) {
            				this._setValue('pixelsPerUnit', arg);
            		}
            		get pixelsPerUnit() {
            				if (this._image) {
            						return this._image.pixelsPerUnit;
            				}
            				return null;
            		}
            		set opacity(arg) {
            				this._setValue('opacity', arg);
            		}
            		get opacity() {
            				if (this._text) {
            						return this._text.opacity;
            				}
            				if (this._image) {
            						return this._image.opacity;
            				}
            				return null;
            		}
            		set rect(arg) {
            				this._setValue('rect', arg);
            		}
            		get rect() {
            				if (this._image) {
            						return this._image.rect;
            				}
            				return null;
            		}
            		set mask(arg) {
            				this._setValue('mask', arg);
            		}
            		get mask() {
            				if (this._image) {
            						return this._image.mask;
            				}
            				return null;
            		}
            		set outlineColor(arg) {
            				this._setValue('outlineColor', arg);
            		}
            		get outlineColor() {
            				if (this._text) {
            						return this._text.outlineColor;
            				}
            				return null;
            		}
            		set outlineThickness(arg) {
            				this._setValue('outlineThickness', arg);
            		}
            		get outlineThickness() {
            				if (this._text) {
            						return this._text.outlineThickness;
            				}
            				return null;
            		}
            		set shadowColor(arg) {
            				this._setValue('shadowColor', arg);
            		}
            		get shadowColor() {
            				if (this._text) {
            						return this._text.shadowColor;
            				}
            				return null;
            		}
            		set shadowOffset(arg) {
            				this._setValue('shadowOffset', arg);
            		}
            		get shadowOffset() {
            				if (this._text) {
            						return this._text.shadowOffset;
            				}
            				return null;
            		}
            		set enableMarkup(arg) {
            				this._setValue('enableMarkup', arg);
            		}
            		get enableMarkup() {
            				if (this._text) {
            						return this._text.enableMarkup;
            				}
            				return null;
            		}
            		set rangeStart(arg) {
            				this._setValue('rangeStart', arg);
            		}
            		get rangeStart() {
            				if (this._text) {
            						return this._text.rangeStart;
            				}
            				return null;
            		}
            		set rangeEnd(arg) {
            				this._setValue('rangeEnd', arg);
            		}
            		get rangeEnd() {
            				if (this._text) {
            						return this._text.rangeEnd;
            				}
            				return null;
            		}
            		_setValue(name, value) {
            				if (this._text) {
            						if (this._text[name] !== value) {
            								this._dirtyBatch();
            						}
            						this._text[name] = value;
            				} else if (this._image) {
            						if (this._image[name] !== value) {
            								this._dirtyBatch();
            						}
            						this._image[name] = value;
            				}
            		}
            		_patch() {
            				this.entity._sync = this._sync;
            				this.entity.setPosition = this._setPosition;
            				this.entity.setLocalPosition = this._setLocalPosition;
            		}
            		_unpatch() {
            				this.entity._sync = Entity.prototype._sync;
            				this.entity.setPosition = Entity.prototype.setPosition;
            				this.entity.setLocalPosition = Entity.prototype.setLocalPosition;
            		}
            		_setPosition(x, y, z) {
            				if (!this.element.screen) {
            						Entity.prototype.setPosition.call(this, x, y, z);
            						return;
            				}
            				if (x instanceof Vec3) {
            						position.copy(x);
            				} else {
            						position.set(x, y, z);
            				}
            				this.getWorldTransform();
            				invParentWtm.copy(this.element._screenToWorld).invert();
            				invParentWtm.transformPoint(position, this.localPosition);
            				if (!this._dirtyLocal) {
            						this._dirtifyLocal();
            				}
            		}
            		_setLocalPosition(x, y, z) {
            				if (x instanceof Vec3) {
            						this.localPosition.copy(x);
            				} else {
            						this.localPosition.set(x, y, z);
            				}
            				var element = this.element;
            				var p = this.localPosition;
            				var pvt = element._pivot;
            				element._margin.x = p.x - element._calculatedWidth * pvt.x;
            				element._margin.z = element._localAnchor.z - element._localAnchor.x - element._calculatedWidth - element._margin.x;
            				element._margin.y = p.y - element._calculatedHeight * pvt.y;
            				element._margin.w = element._localAnchor.w - element._localAnchor.y - element._calculatedHeight - element._margin.y;
            				if (!this._dirtyLocal) {
            						this._dirtifyLocal();
            				}
            		}
            		_sync() {
            				var element = this.element;
            				var screen = element.screen;
            				if (screen) {
            						if (element._anchorDirty) {
            								var resx = 0;
            								var resy = 0;
            								var px = 0;
            								var py = 1;
            								if (this._parent && this._parent.element) {
            										resx = this._parent.element.calculatedWidth;
            										resy = this._parent.element.calculatedHeight;
            										px = this._parent.element.pivot.x;
            										py = this._parent.element.pivot.y;
            								} else {
            										var resolution = screen.screen.resolution;
            										resx = resolution.x / screen.screen.scale;
            										resy = resolution.y / screen.screen.scale;
            								}
            								element._anchorTransform.setTranslate(resx * (element.anchor.x - px), -(resy * (py - element.anchor.y)), 0);
            								element._anchorDirty = false;
            								element._calculateLocalAnchors();
            						}
            						if (element._sizeDirty) {
            								element._calculateSize(false, false);
            						}
            				}
            				if (this._dirtyLocal) {
            						this.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);
            						var p = this.localPosition;
            						var pvt = element._pivot;
            						element._margin.x = p.x - element._calculatedWidth * pvt.x;
            						element._margin.z = element._localAnchor.z - element._localAnchor.x - element._calculatedWidth - element._margin.x;
            						element._margin.y = p.y - element._calculatedHeight * pvt.y;
            						element._margin.w = element._localAnchor.w - element._localAnchor.y - element._calculatedHeight - element._margin.y;
            						this._dirtyLocal = false;
            				}
            				if (!screen) {
            						if (this._dirtyWorld) {
            								element._cornersDirty = true;
            								element._canvasCornersDirty = true;
            								element._worldCornersDirty = true;
            						}
            						Entity.prototype._sync.call(this);
            						return;
            				}
            				if (this._dirtyWorld) {
            						if (this._parent === null) {
            								this.worldTransform.copy(this.localTransform);
            						} else {
            								if (this._parent.element) {
            										element._screenToWorld.mul2(this._parent.element._modelTransform, element._anchorTransform);
            								} else {
            										element._screenToWorld.copy(element._anchorTransform);
            								}
            								element._modelTransform.mul2(element._screenToWorld, this.localTransform);
            								if (screen) {
            										element._screenToWorld.mul2(screen.screen._screenMatrix, element._screenToWorld);
            										if (!screen.screen.screenSpace) {
            												element._screenToWorld.mul2(screen.worldTransform, element._screenToWorld);
            										}
            										this.worldTransform.mul2(element._screenToWorld, this.localTransform);
            										var parentWorldTransform = element._parentWorldTransform;
            										parentWorldTransform.setIdentity();
            										var parent = this._parent;
            										if (parent && parent.element && parent !== screen) {
            												matA.setTRS(Vec3.ZERO, parent.getLocalRotation(), parent.getLocalScale());
            												parentWorldTransform.mul2(parent.element._parentWorldTransform, matA);
            										}
            										var depthOffset = vecA$1;
            										depthOffset.set(0, 0, this.localPosition.z);
            										var pivotOffset = vecB$1;
            										pivotOffset.set(element._absLeft + element._pivot.x * element.calculatedWidth, element._absBottom + element._pivot.y * element.calculatedHeight, 0);
            										matA.setTranslate(-pivotOffset.x, -pivotOffset.y, -pivotOffset.z);
            										matB.setTRS(depthOffset, this.getLocalRotation(), this.getLocalScale());
            										matC.setTranslate(pivotOffset.x, pivotOffset.y, pivotOffset.z);
            										element._screenTransform.mul2(element._parentWorldTransform, matC).mul(matB).mul(matA);
            										element._cornersDirty = true;
            										element._canvasCornersDirty = true;
            										element._worldCornersDirty = true;
            								} else {
            										this.worldTransform.copy(element._modelTransform);
            								}
            						}
            						this._dirtyWorld = false;
            				}
            		}
            		_onInsert(parent) {
            				var result = this._parseUpToScreen();
            				this.entity._dirtifyWorld();
            				this._updateScreen(result.screen);
            				this._dirtifyMask();
            		}
            		_dirtifyMask() {
            				var current = this.entity;
            				while(current){
            						var next = current.parent;
            						if ((next === null || next.screen) && current.element) {
            								if (!this.system._prerender || !this.system._prerender.length) {
            										this.system._prerender = [];
            										this.system.app.once('prerender', this._onPrerender, this);
            								}
            								var i = this.system._prerender.indexOf(this.entity);
            								if (i >= 0) {
            										this.system._prerender.splice(i, 1);
            								}
            								var j = this.system._prerender.indexOf(current);
            								if (j < 0) {
            										this.system._prerender.push(current);
            								}
            						}
            						current = next;
            				}
            		}
            		_onPrerender() {
            				for(var i = 0; i < this.system._prerender.length; i++){
            						var mask = this.system._prerender[i];
            						if (mask.element) {
            								var depth = 1;
            								mask.element.syncMask(depth);
            						}
            				}
            				this.system._prerender.length = 0;
            		}
            		_bindScreen(screen) {
            				screen._bindElement(this);
            		}
            		_unbindScreen(screen) {
            				screen._unbindElement(this);
            		}
            		_updateScreen(screen) {
            				if (this.screen && this.screen !== screen) {
            						this._unbindScreen(this.screen.screen);
            				}
            				var previousScreen = this.screen;
            				this.screen = screen;
            				if (this.screen) {
            						this._bindScreen(this.screen.screen);
            				}
            				this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
            				this.fire('set:screen', this.screen, previousScreen);
            				this._anchorDirty = true;
            				var children = this.entity.children;
            				for(var i = 0, l = children.length; i < l; i++){
            						if (children[i].element) {
            								children[i].element._updateScreen(screen);
            						}
            				}
            				if (this.screen) {
            						this.screen.screen.syncDrawOrder();
            				}
            		}
            		syncMask(depth) {
            				var result = this._parseUpToScreen();
            				this._updateMask(result.mask, depth);
            		}
            		_setMaskedBy(mask) {
            				var renderableElement = this._image || this._text;
            				if (mask) {
            						var ref = mask.element._image._maskRef;
            						renderableElement == null ? void 0 : renderableElement._setStencil(new StencilParameters({
            								ref: ref,
            								func: FUNC_EQUAL
            						}));
            						this._maskedBy = mask;
            				} else {
            						renderableElement == null ? void 0 : renderableElement._setStencil(null);
            						this._maskedBy = null;
            				}
            		}
            		_updateMask(currentMask, depth) {
            				if (currentMask) {
            						this._setMaskedBy(currentMask);
            						if (this.mask) {
            								var ref = currentMask.element._image._maskRef;
            								var sp = new StencilParameters({
            										ref: ref,
            										func: FUNC_EQUAL,
            										zpass: STENCILOP_INCREMENT
            								});
            								this._image._setStencil(sp);
            								this._image._maskRef = depth;
            								depth++;
            								currentMask = this.entity;
            						}
            						var children = this.entity.children;
            						for(var i = 0, l = children.length; i < l; i++){
            								var _children_i_element;
            								(_children_i_element = children[i].element) == null ? void 0 : _children_i_element._updateMask(currentMask, depth);
            						}
            						if (this.mask) depth--;
            				} else {
            						this._setMaskedBy(null);
            						if (this.mask) {
            								var sp1 = new StencilParameters({
            										ref: depth,
            										func: FUNC_ALWAYS,
            										zpass: STENCILOP_REPLACE
            								});
            								this._image._setStencil(sp1);
            								this._image._maskRef = depth;
            								depth++;
            								currentMask = this.entity;
            						}
            						var children1 = this.entity.children;
            						for(var i1 = 0, l1 = children1.length; i1 < l1; i1++){
            								var _children_i_element1;
            								(_children_i_element1 = children1[i1].element) == null ? void 0 : _children_i_element1._updateMask(currentMask, depth);
            						}
            						if (this.mask) {
            								depth--;
            						}
            				}
            		}
            		_parseUpToScreen() {
            				var result = {
            						screen: null,
            						mask: null
            				};
            				var parent = this.entity._parent;
            				while(parent && !parent.screen){
            						if (parent.element && parent.element.mask) {
            								if (!result.mask) result.mask = parent;
            						}
            						parent = parent.parent;
            				}
            				if (parent && parent.screen) {
            						result.screen = parent;
            				}
            				return result;
            		}
            		_onScreenResize(res) {
            				this._anchorDirty = true;
            				this._cornersDirty = true;
            				this._worldCornersDirty = true;
            				this._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);
            				this.fire('screen:set:resolution', res);
            		}
            		_onScreenSpaceChange() {
            				this.fire('screen:set:screenspace', this.screen.screen.screenSpace);
            		}
            		_onScreenRemove() {
            				if (this.screen) {
            						if (this.screen._destroying) {
            								this.screen = null;
            						} else {
            								this._updateScreen(null);
            						}
            				}
            		}
            		_calculateLocalAnchors() {
            				var resx = 1000;
            				var resy = 1000;
            				var parent = this.entity._parent;
            				if (parent && parent.element) {
            						resx = parent.element.calculatedWidth;
            						resy = parent.element.calculatedHeight;
            				} else if (this.screen) {
            						var res = this.screen.screen.resolution;
            						var scale = this.screen.screen.scale;
            						resx = res.x / scale;
            						resy = res.y / scale;
            				}
            				this._localAnchor.set(this._anchor.x * resx, this._anchor.y * resy, this._anchor.z * resx, this._anchor.w * resy);
            		}
            		getOffsetPosition(x, y) {
            				var p = this.entity.getLocalPosition().clone();
            				p.x += x;
            				p.y += y;
            				this._screenToWorld.transformPoint(p, p);
            				return p;
            		}
            		onLayersChanged(oldComp, newComp) {
            				this.addModelToLayers(this._image ? this._image._renderable.model : this._text._model);
            				oldComp.off('add', this.onLayerAdded, this);
            				oldComp.off('remove', this.onLayerRemoved, this);
            				newComp.on('add', this.onLayerAdded, this);
            				newComp.on('remove', this.onLayerRemoved, this);
            		}
            		onLayerAdded(layer) {
            				var index = this.layers.indexOf(layer.id);
            				if (index < 0) return;
            				if (this._image) {
            						layer.addMeshInstances(this._image._renderable.model.meshInstances);
            				} else if (this._text) {
            						layer.addMeshInstances(this._text._model.meshInstances);
            				}
            		}
            		onLayerRemoved(layer) {
            				var index = this.layers.indexOf(layer.id);
            				if (index < 0) return;
            				if (this._image) {
            						layer.removeMeshInstances(this._image._renderable.model.meshInstances);
            				} else if (this._text) {
            						layer.removeMeshInstances(this._text._model.meshInstances);
            				}
            		}
            		onEnable() {
            				var scene = this.system.app.scene;
            				var layers = scene.layers;
            				if (this._image) {
            						this._image.onEnable();
            				}
            				if (this._text) {
            						this._text.onEnable();
            				}
            				if (this._group) {
            						this._group.onEnable();
            				}
            				if (this.useInput && this.system.app.elementInput) {
            						this.system.app.elementInput.addElement(this);
            				}
            				this._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);
            				if (layers) {
            						this._evtLayerAdded = layers.on('add', this.onLayerAdded, this);
            						this._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);
            				}
            				if (this._batchGroupId >= 0) {
            						var _this_system_app_batcher;
            						(_this_system_app_batcher = this.system.app.batcher) == null ? void 0 : _this_system_app_batcher.insert(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
            				}
            				this.fire('enableelement');
            		}
            		onDisable() {
            				var _this__evtLayersChanged;
            				var scene = this.system.app.scene;
            				var layers = scene.layers;
            				(_this__evtLayersChanged = this._evtLayersChanged) == null ? void 0 : _this__evtLayersChanged.off();
            				this._evtLayersChanged = null;
            				if (layers) {
            						var _this__evtLayerAdded, _this__evtLayerRemoved;
            						(_this__evtLayerAdded = this._evtLayerAdded) == null ? void 0 : _this__evtLayerAdded.off();
            						this._evtLayerAdded = null;
            						(_this__evtLayerRemoved = this._evtLayerRemoved) == null ? void 0 : _this__evtLayerRemoved.off();
            						this._evtLayerRemoved = null;
            				}
            				if (this._image) this._image.onDisable();
            				if (this._text) this._text.onDisable();
            				if (this._group) this._group.onDisable();
            				if (this.system.app.elementInput && this.useInput) {
            						this.system.app.elementInput.removeElement(this);
            				}
            				if (this._batchGroupId >= 0) {
            						var _this_system_app_batcher;
            						(_this_system_app_batcher = this.system.app.batcher) == null ? void 0 : _this_system_app_batcher.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);
            				}
            				this.fire('disableelement');
            		}
            		onRemove() {
            				this.entity.off('insert', this._onInsert, this);
            				this._unpatch();
            				if (this._image) {
            						this._image.destroy();
            				}
            				if (this._text) {
            						this._text.destroy();
            				}
            				if (this.system.app.elementInput && this.useInput) {
            						this.system.app.elementInput.removeElement(this);
            				}
            				if (this.screen && this.screen.screen) {
            						this._unbindScreen(this.screen.screen);
            						this.screen.screen.syncDrawOrder();
            				}
            				this.off();
            		}
            		_calculateSize(propagateCalculatedWidth, propagateCalculatedHeight) {
            				if (!this.entity._parent && !this.screen) {
            						return;
            				}
            				this._calculateLocalAnchors();
            				var newWidth = this._absRight - this._absLeft;
            				var newHeight = this._absTop - this._absBottom;
            				if (propagateCalculatedWidth) {
            						this._setWidth(newWidth);
            				} else {
            						this._setCalculatedWidth(newWidth, false);
            				}
            				if (propagateCalculatedHeight) {
            						this._setHeight(newHeight);
            				} else {
            						this._setCalculatedHeight(newHeight, false);
            				}
            				var p = this.entity.getLocalPosition();
            				p.x = this._margin.x + this._calculatedWidth * this._pivot.x;
            				p.y = this._margin.y + this._calculatedHeight * this._pivot.y;
            				this.entity.setLocalPosition(p);
            				this._sizeDirty = false;
            		}
            		_setWidth(w) {
            				this._width = w;
            				this._setCalculatedWidth(w, false);
            				this.fire('set:width', this._width);
            		}
            		_setHeight(h) {
            				this._height = h;
            				this._setCalculatedHeight(h, false);
            				this.fire('set:height', this._height);
            		}
            		_setCalculatedWidth(value, updateMargins) {
            				if (Math.abs(value - this._calculatedWidth) <= 1e-4) {
            						return;
            				}
            				this._calculatedWidth = value;
            				this.entity._dirtifyLocal();
            				if (updateMargins) {
            						var p = this.entity.getLocalPosition();
            						var pvt = this._pivot;
            						this._margin.x = p.x - this._calculatedWidth * pvt.x;
            						this._margin.z = this._localAnchor.z - this._localAnchor.x - this._calculatedWidth - this._margin.x;
            				}
            				this._flagChildrenAsDirty();
            				this.fire('set:calculatedWidth', this._calculatedWidth);
            				this.fire('resize', this._calculatedWidth, this._calculatedHeight);
            		}
            		_setCalculatedHeight(value, updateMargins) {
            				if (Math.abs(value - this._calculatedHeight) <= 1e-4) {
            						return;
            				}
            				this._calculatedHeight = value;
            				this.entity._dirtifyLocal();
            				if (updateMargins) {
            						var p = this.entity.getLocalPosition();
            						var pvt = this._pivot;
            						this._margin.y = p.y - this._calculatedHeight * pvt.y;
            						this._margin.w = this._localAnchor.w - this._localAnchor.y - this._calculatedHeight - this._margin.y;
            				}
            				this._flagChildrenAsDirty();
            				this.fire('set:calculatedHeight', this._calculatedHeight);
            				this.fire('resize', this._calculatedWidth, this._calculatedHeight);
            		}
            		_flagChildrenAsDirty() {
            				var c = this.entity._children;
            				for(var i = 0, l = c.length; i < l; i++){
            						if (c[i].element) {
            								c[i].element._anchorDirty = true;
            								c[i].element._sizeDirty = true;
            						}
            				}
            		}
            		addModelToLayers(model) {
            				this._addedModels.push(model);
            				for(var i = 0; i < this.layers.length; i++){
            						var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
            						if (!layer) continue;
            						layer.addMeshInstances(model.meshInstances);
            				}
            		}
            		removeModelFromLayers(model) {
            				var idx = this._addedModels.indexOf(model);
            				if (idx >= 0) {
            						this._addedModels.splice(idx, 1);
            				}
            				for(var i = 0; i < this.layers.length; i++){
            						var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
            						if (!layer) {
            								continue;
            						}
            						layer.removeMeshInstances(model.meshInstances);
            				}
            		}
            		getMaskOffset() {
            				var frame = this.system.app.frame;
            				if (this._offsetReadAt !== frame) {
            						this._maskOffset = 0.5;
            						this._offsetReadAt = frame;
            				}
            				var mo = this._maskOffset;
            				this._maskOffset -= 0.001;
            				return mo;
            		}
            		isVisibleForCamera(camera) {
            				var clipL, clipR, clipT, clipB;
            				if (this.maskedBy) {
            						var corners = this.maskedBy.element.screenCorners;
            						clipL = Math.min(Math.min(corners[0].x, corners[1].x), Math.min(corners[2].x, corners[3].x));
            						clipR = Math.max(Math.max(corners[0].x, corners[1].x), Math.max(corners[2].x, corners[3].x));
            						clipB = Math.min(Math.min(corners[0].y, corners[1].y), Math.min(corners[2].y, corners[3].y));
            						clipT = Math.max(Math.max(corners[0].y, corners[1].y), Math.max(corners[2].y, corners[3].y));
            				} else {
            						var sw = this.system.app.graphicsDevice.width;
            						var sh = this.system.app.graphicsDevice.height;
            						var cameraWidth = camera._rect.z * sw;
            						var cameraHeight = camera._rect.w * sh;
            						clipL = camera._rect.x * sw;
            						clipR = clipL + cameraWidth;
            						clipT = (1 - camera._rect.y) * sh;
            						clipB = clipT - cameraHeight;
            				}
            				var hitCorners = this.screenCorners;
            				var left = Math.min(Math.min(hitCorners[0].x, hitCorners[1].x), Math.min(hitCorners[2].x, hitCorners[3].x));
            				var right = Math.max(Math.max(hitCorners[0].x, hitCorners[1].x), Math.max(hitCorners[2].x, hitCorners[3].x));
            				var bottom = Math.min(Math.min(hitCorners[0].y, hitCorners[1].y), Math.min(hitCorners[2].y, hitCorners[3].y));
            				var top = Math.max(Math.max(hitCorners[0].y, hitCorners[1].y), Math.max(hitCorners[2].y, hitCorners[3].y));
            				if (right < clipL || left > clipR || bottom > clipT || top < clipB) {
            						return false;
            				}
            				return true;
            		}
            		_isScreenSpace() {
            				if (this.screen && this.screen.screen) {
            						return this.screen.screen.screenSpace;
            				}
            				return false;
            		}
            		_isScreenCulled() {
            				if (this.screen && this.screen.screen) {
            						return this.screen.screen.cull;
            				}
            				return false;
            		}
            		_dirtyBatch() {
            				if (this.batchGroupId !== -1) {
            						var _this_system_app_batcher;
            						(_this_system_app_batcher = this.system.app.batcher) == null ? void 0 : _this_system_app_batcher.markGroupDirty(this.batchGroupId);
            				}
            		}
            		constructor(system, entity){
            				super(system, entity), this._evtLayersChanged = null, this._evtLayerAdded = null, this._evtLayerRemoved = null;
            				this._beingInitialized = false;
            				this._anchor = new Vec4();
            				this._localAnchor = new Vec4();
            				this._pivot = new Vec2();
            				this._width = this._calculatedWidth = 32;
            				this._height = this._calculatedHeight = 32;
            				this._margin = new Vec4(0, 0, -32, -32);
            				this._modelTransform = new Mat4();
            				this._screenToWorld = new Mat4();
            				this._anchorTransform = new Mat4();
            				this._anchorDirty = true;
            				this._parentWorldTransform = new Mat4();
            				this._screenTransform = new Mat4();
            				this._screenCorners = [
            						new Vec3(),
            						new Vec3(),
            						new Vec3(),
            						new Vec3()
            				];
            				this._canvasCorners = [
            						new Vec2(),
            						new Vec2(),
            						new Vec2(),
            						new Vec2()
            				];
            				this._worldCorners = [
            						new Vec3(),
            						new Vec3(),
            						new Vec3(),
            						new Vec3()
            				];
            				this._cornersDirty = true;
            				this._canvasCornersDirty = true;
            				this._worldCornersDirty = true;
            				this.entity.on('insert', this._onInsert, this);
            				this._patch();
            				this.screen = null;
            				this._type = ELEMENTTYPE_GROUP;
            				this._image = null;
            				this._text = null;
            				this._group = null;
            				this._drawOrder = 0;
            				this._fitMode = FITMODE_STRETCH;
            				this._useInput = false;
            				this._layers = [
            						LAYERID_UI
            				];
            				this._addedModels = [];
            				this._batchGroupId = -1;
            				this._offsetReadAt = 0;
            				this._maskOffset = 0.5;
            				this._maskedBy = null;
            		}
            }
            ElementComponent.EVENT_MOUSEDOWN = 'mousedown';
            ElementComponent.EVENT_MOUSEUP = 'mouseup';
            ElementComponent.EVENT_MOUSEENTER = 'mouseenter';
            ElementComponent.EVENT_MOUSELEAVE = 'mouseleave';
            ElementComponent.EVENT_MOUSEMOVE = 'mousemove';
            ElementComponent.EVENT_MOUSEWHEEL = 'mousewheel';
            ElementComponent.EVENT_CLICK = 'click';
            ElementComponent.EVENT_TOUCHSTART = 'touchstart';
            ElementComponent.EVENT_TOUCHEND = 'touchend';
            ElementComponent.EVENT_TOUCHMOVE = 'touchmove';
            ElementComponent.EVENT_TOUCHCANCEL = 'touchcancel';
            
            class ElementComponentData {
            		constructor(){
            				this.enabled = true;
            		}
            }
            
            var _schema$f = [
            		'enabled'
            ];
            class ElementComponentSystem extends ComponentSystem {
            		destroy() {
            				super.destroy();
            				this._defaultTexture.destroy();
            		}
            		initializeComponentData(component, data, properties) {
            				component._beingInitialized = true;
            				if (data.anchor !== undefined) {
            						if (data.anchor instanceof Vec4) {
            								component.anchor.copy(data.anchor);
            						} else {
            								component.anchor.set(data.anchor[0], data.anchor[1], data.anchor[2], data.anchor[3]);
            						}
            				}
            				if (data.pivot !== undefined) {
            						if (data.pivot instanceof Vec2) {
            								component.pivot.copy(data.pivot);
            						} else {
            								component.pivot.set(data.pivot[0], data.pivot[1]);
            						}
            				}
            				var splitHorAnchors = Math.abs(component.anchor.x - component.anchor.z) > 0.001;
            				var splitVerAnchors = Math.abs(component.anchor.y - component.anchor.w) > 0.001;
            				var _marginChange = false;
            				var color;
            				if (data.margin !== undefined) {
            						if (data.margin instanceof Vec4) {
            								component.margin.copy(data.margin);
            						} else {
            								component._margin.set(data.margin[0], data.margin[1], data.margin[2], data.margin[3]);
            						}
            						_marginChange = true;
            				}
            				if (data.left !== undefined) {
            						component._margin.x = data.left;
            						_marginChange = true;
            				}
            				if (data.bottom !== undefined) {
            						component._margin.y = data.bottom;
            						_marginChange = true;
            				}
            				if (data.right !== undefined) {
            						component._margin.z = data.right;
            						_marginChange = true;
            				}
            				if (data.top !== undefined) {
            						component._margin.w = data.top;
            						_marginChange = true;
            				}
            				if (_marginChange) {
            						component.margin = component._margin;
            				}
            				var shouldForceSetAnchor = false;
            				if (data.width !== undefined && !splitHorAnchors) {
            						component.width = data.width;
            				} else if (splitHorAnchors) {
            						shouldForceSetAnchor = true;
            				}
            				if (data.height !== undefined && !splitVerAnchors) {
            						component.height = data.height;
            				} else if (splitVerAnchors) {
            						shouldForceSetAnchor = true;
            				}
            				if (shouldForceSetAnchor) {
            						component.anchor = component.anchor;
            				}
            				if (data.enabled !== undefined) {
            						component.enabled = data.enabled;
            				}
            				if (data.useInput !== undefined) {
            						component.useInput = data.useInput;
            				}
            				if (data.fitMode !== undefined) {
            						component.fitMode = data.fitMode;
            				}
            				component.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;
            				if (data.layers && Array.isArray(data.layers)) {
            						component.layers = data.layers.slice(0);
            				}
            				if (data.type !== undefined) {
            						component.type = data.type;
            				}
            				if (component.type === ELEMENTTYPE_IMAGE) {
            						if (data.rect !== undefined) {
            								component.rect = data.rect;
            						}
            						if (data.color !== undefined) {
            								color = data.color;
            								if (!(color instanceof Color)) {
            										color = new Color(data.color[0], data.color[1], data.color[2]);
            								}
            								component.color = color;
            						}
            						if (data.opacity !== undefined) component.opacity = data.opacity;
            						if (data.textureAsset !== undefined) component.textureAsset = data.textureAsset;
            						if (data.texture) component.texture = data.texture;
            						if (data.spriteAsset !== undefined) component.spriteAsset = data.spriteAsset;
            						if (data.sprite) component.sprite = data.sprite;
            						if (data.spriteFrame !== undefined) component.spriteFrame = data.spriteFrame;
            						if (data.pixelsPerUnit !== undefined && data.pixelsPerUnit !== null) component.pixelsPerUnit = data.pixelsPerUnit;
            						if (data.materialAsset !== undefined) component.materialAsset = data.materialAsset;
            						if (data.material) component.material = data.material;
            						if (data.mask !== undefined) {
            								component.mask = data.mask;
            						}
            				} else if (component.type === ELEMENTTYPE_TEXT) {
            						if (data.autoWidth !== undefined) component.autoWidth = data.autoWidth;
            						if (data.autoHeight !== undefined) component.autoHeight = data.autoHeight;
            						if (data.rtlReorder !== undefined) component.rtlReorder = data.rtlReorder;
            						if (data.unicodeConverter !== undefined) component.unicodeConverter = data.unicodeConverter;
            						if (data.text !== null && data.text !== undefined) {
            								component.text = data.text;
            						} else if (data.key !== null && data.key !== undefined) {
            								component.key = data.key;
            						}
            						if (data.color !== undefined) {
            								color = data.color;
            								if (!(color instanceof Color)) {
            										color = new Color(color[0], color[1], color[2]);
            								}
            								component.color = color;
            						}
            						if (data.opacity !== undefined) {
            								component.opacity = data.opacity;
            						}
            						if (data.spacing !== undefined) component.spacing = data.spacing;
            						if (data.fontSize !== undefined) {
            								component.fontSize = data.fontSize;
            								if (!data.lineHeight) component.lineHeight = data.fontSize;
            						}
            						if (data.lineHeight !== undefined) component.lineHeight = data.lineHeight;
            						if (data.maxLines !== undefined) component.maxLines = data.maxLines;
            						if (data.wrapLines !== undefined) component.wrapLines = data.wrapLines;
            						if (data.minFontSize !== undefined) component.minFontSize = data.minFontSize;
            						if (data.maxFontSize !== undefined) component.maxFontSize = data.maxFontSize;
            						if (data.autoFitWidth) component.autoFitWidth = data.autoFitWidth;
            						if (data.autoFitHeight) component.autoFitHeight = data.autoFitHeight;
            						if (data.fontAsset !== undefined) component.fontAsset = data.fontAsset;
            						if (data.font !== undefined) component.font = data.font;
            						if (data.alignment !== undefined) component.alignment = data.alignment;
            						if (data.outlineColor !== undefined) component.outlineColor = data.outlineColor;
            						if (data.outlineThickness !== undefined) component.outlineThickness = data.outlineThickness;
            						if (data.shadowColor !== undefined) component.shadowColor = data.shadowColor;
            						if (data.shadowOffset !== undefined) component.shadowOffset = data.shadowOffset;
            						if (data.enableMarkup !== undefined) component.enableMarkup = data.enableMarkup;
            				}
            				var result = component._parseUpToScreen();
            				if (result.screen) {
            						component._updateScreen(result.screen);
            				}
            				super.initializeComponentData(component, data, properties);
            				component._beingInitialized = false;
            				if (component.type === ELEMENTTYPE_IMAGE && component._image._meshDirty) {
            						component._image._updateMesh(component._image.mesh);
            				}
            		}
            		onAddComponent(entity, component) {
            				entity.fire('element:add');
            		}
            		onRemoveComponent(entity, component) {
            				component.onRemove();
            		}
            		cloneComponent(entity, clone) {
            				var source = entity.element;
            				var data = {
            						enabled: source.enabled,
            						width: source.width,
            						height: source.height,
            						anchor: source.anchor.clone(),
            						pivot: source.pivot.clone(),
            						margin: source.margin.clone(),
            						alignment: source.alignment && source.alignment.clone() || source.alignment,
            						autoWidth: source.autoWidth,
            						autoHeight: source.autoHeight,
            						type: source.type,
            						rect: source.rect && source.rect.clone() || source.rect,
            						rtlReorder: source.rtlReorder,
            						unicodeConverter: source.unicodeConverter,
            						materialAsset: source.materialAsset,
            						material: source.material,
            						color: source.color && source.color.clone() || source.color,
            						opacity: source.opacity,
            						textureAsset: source.textureAsset,
            						texture: source.texture,
            						spriteAsset: source.spriteAsset,
            						sprite: source.sprite,
            						spriteFrame: source.spriteFrame,
            						pixelsPerUnit: source.pixelsPerUnit,
            						spacing: source.spacing,
            						lineHeight: source.lineHeight,
            						wrapLines: source.wrapLines,
            						layers: source.layers,
            						fontSize: source.fontSize,
            						minFontSize: source.minFontSize,
            						maxFontSize: source.maxFontSize,
            						autoFitWidth: source.autoFitWidth,
            						autoFitHeight: source.autoFitHeight,
            						maxLines: source.maxLines,
            						fontAsset: source.fontAsset,
            						font: source.font,
            						useInput: source.useInput,
            						fitMode: source.fitMode,
            						batchGroupId: source.batchGroupId,
            						mask: source.mask,
            						outlineColor: source.outlineColor && source.outlineColor.clone() || source.outlineColor,
            						outlineThickness: source.outlineThickness,
            						shadowColor: source.shadowColor && source.shadowColor.clone() || source.shadowColor,
            						shadowOffset: source.shadowOffset && source.shadowOffset.clone() || source.shadowOffset,
            						enableMarkup: source.enableMarkup
            				};
            				if (source.key !== undefined && source.key !== null) {
            						data.key = source.key;
            				} else {
            						data.text = source.text;
            				}
            				return this.addComponent(clone, data);
            		}
            		getTextElementMaterial(screenSpace, msdf, textAttibutes) {
            				var hash = (screenSpace && 1 << 0) | (msdf && 1 << 1) | (textAttibutes && 1 << 2);
            				var material = this._defaultTextMaterials[hash];
            				if (material) {
            						return material;
            				}
            				var name = 'TextMaterial';
            				material = new StandardMaterial();
            				if (msdf) {
            						material.msdfMap = this._defaultTexture;
            						material.msdfTextAttribute = textAttibutes;
            						material.emissive.set(1, 1, 1);
            				} else {
            						name = "Bitmap" + name;
            						material.emissive.set(1, 1, 1);
            						material.emissiveMap = this._defaultTexture;
            						material.opacityMap = this._defaultTexture;
            						material.opacityMapChannel = 'a';
            				}
            				if (screenSpace) {
            						name = "ScreenSpace" + name;
            						material.depthTest = false;
            				}
            				material.name = "default" + name;
            				material.useLighting = false;
            				material.useTonemap = false;
            				material.useFog = false;
            				material.useSkybox = false;
            				material.diffuse.set(0, 0, 0);
            				material.opacity = 0.5;
            				material.blendType = BLEND_PREMULTIPLIED;
            				material.depthWrite = false;
            				material.emissiveVertexColor = true;
            				material.update();
            				this._defaultTextMaterials[hash] = material;
            				return material;
            		}
            		_createBaseImageMaterial() {
            				var material = new StandardMaterial();
            				material.diffuse.set(0, 0, 0);
            				material.emissive.set(1, 1, 1);
            				material.emissiveMap = this._defaultTexture;
            				material.opacityMap = this._defaultTexture;
            				material.opacityMapChannel = 'a';
            				material.useLighting = false;
            				material.useTonemap = false;
            				material.useFog = false;
            				material.useSkybox = false;
            				material.blendType = BLEND_PREMULTIPLIED;
            				material.depthWrite = false;
            				return material;
            		}
            		getImageElementMaterial(screenSpace, mask, nineSliced, nineSliceTiled) {
            				if (screenSpace) {
            						if (mask) {
            								if (nineSliced) {
            										if (!this.defaultScreenSpaceImageMask9SlicedMaterial) {
            												this.defaultScreenSpaceImageMask9SlicedMaterial = this._createBaseImageMaterial();
            												this.defaultScreenSpaceImageMask9SlicedMaterial.name = 'defaultScreenSpaceImageMask9SlicedMaterial';
            												this.defaultScreenSpaceImageMask9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
            												this.defaultScreenSpaceImageMask9SlicedMaterial.depthTest = false;
            												this.defaultScreenSpaceImageMask9SlicedMaterial.alphaTest = 1;
            												this.defaultScreenSpaceImageMask9SlicedMaterial.redWrite = false;
            												this.defaultScreenSpaceImageMask9SlicedMaterial.greenWrite = false;
            												this.defaultScreenSpaceImageMask9SlicedMaterial.blueWrite = false;
            												this.defaultScreenSpaceImageMask9SlicedMaterial.alphaWrite = false;
            												this.defaultScreenSpaceImageMask9SlicedMaterial.update();
            												this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9SlicedMaterial);
            										}
            										return this.defaultScreenSpaceImageMask9SlicedMaterial;
            								} else if (nineSliceTiled) {
            										if (!this.defaultScreenSpaceImageMask9TiledMaterial) {
            												this.defaultScreenSpaceImageMask9TiledMaterial = this.defaultScreenSpaceImage9TiledMaterial.clone();
            												this.defaultScreenSpaceImageMask9TiledMaterial.name = 'defaultScreenSpaceImageMask9TiledMaterial';
            												this.defaultScreenSpaceImageMask9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
            												this.defaultScreenSpaceImageMask9TiledMaterial.depthTest = false;
            												this.defaultScreenSpaceImageMask9TiledMaterial.alphaTest = 1;
            												this.defaultScreenSpaceImageMask9TiledMaterial.redWrite = false;
            												this.defaultScreenSpaceImageMask9TiledMaterial.greenWrite = false;
            												this.defaultScreenSpaceImageMask9TiledMaterial.blueWrite = false;
            												this.defaultScreenSpaceImageMask9TiledMaterial.alphaWrite = false;
            												this.defaultScreenSpaceImageMask9TiledMaterial.update();
            												this.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9TiledMaterial);
            										}
            										return this.defaultScreenSpaceImageMask9TiledMaterial;
            								} else {
            										if (!this.defaultScreenSpaceImageMaskMaterial) {
            												this.defaultScreenSpaceImageMaskMaterial = this._createBaseImageMaterial();
            												this.defaultScreenSpaceImageMaskMaterial.name = 'defaultScreenSpaceImageMaskMaterial';
            												this.defaultScreenSpaceImageMaskMaterial.depthTest = false;
            												this.defaultScreenSpaceImageMaskMaterial.alphaTest = 1;
            												this.defaultScreenSpaceImageMaskMaterial.redWrite = false;
            												this.defaultScreenSpaceImageMaskMaterial.greenWrite = false;
            												this.defaultScreenSpaceImageMaskMaterial.blueWrite = false;
            												this.defaultScreenSpaceImageMaskMaterial.alphaWrite = false;
            												this.defaultScreenSpaceImageMaskMaterial.update();
            												this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaskMaterial);
            										}
            										return this.defaultScreenSpaceImageMaskMaterial;
            								}
            						} else {
            								if (nineSliced) {
            										if (!this.defaultScreenSpaceImage9SlicedMaterial) {
            												this.defaultScreenSpaceImage9SlicedMaterial = this._createBaseImageMaterial();
            												this.defaultScreenSpaceImage9SlicedMaterial.name = 'defaultScreenSpaceImage9SlicedMaterial';
            												this.defaultScreenSpaceImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
            												this.defaultScreenSpaceImage9SlicedMaterial.depthTest = false;
            												this.defaultScreenSpaceImage9SlicedMaterial.update();
            												this.defaultImageMaterials.push(this.defaultScreenSpaceImage9SlicedMaterial);
            										}
            										return this.defaultScreenSpaceImage9SlicedMaterial;
            								} else if (nineSliceTiled) {
            										if (!this.defaultScreenSpaceImage9TiledMaterial) {
            												this.defaultScreenSpaceImage9TiledMaterial = this._createBaseImageMaterial();
            												this.defaultScreenSpaceImage9TiledMaterial.name = 'defaultScreenSpaceImage9TiledMaterial';
            												this.defaultScreenSpaceImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
            												this.defaultScreenSpaceImage9TiledMaterial.depthTest = false;
            												this.defaultScreenSpaceImage9TiledMaterial.update();
            												this.defaultImageMaterials.push(this.defaultScreenSpaceImage9TiledMaterial);
            										}
            										return this.defaultScreenSpaceImage9TiledMaterial;
            								} else {
            										if (!this.defaultScreenSpaceImageMaterial) {
            												this.defaultScreenSpaceImageMaterial = this._createBaseImageMaterial();
            												this.defaultScreenSpaceImageMaterial.name = 'defaultScreenSpaceImageMaterial';
            												this.defaultScreenSpaceImageMaterial.depthTest = false;
            												this.defaultScreenSpaceImageMaterial.update();
            												this.defaultImageMaterials.push(this.defaultScreenSpaceImageMaterial);
            										}
            										return this.defaultScreenSpaceImageMaterial;
            								}
            						}
            				} else {
            						if (mask) {
            								if (nineSliced) {
            										if (!this.defaultImage9SlicedMaskMaterial) {
            												this.defaultImage9SlicedMaskMaterial = this._createBaseImageMaterial();
            												this.defaultImage9SlicedMaskMaterial.name = 'defaultImage9SlicedMaskMaterial';
            												this.defaultImage9SlicedMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
            												this.defaultImage9SlicedMaskMaterial.alphaTest = 1;
            												this.defaultImage9SlicedMaskMaterial.redWrite = false;
            												this.defaultImage9SlicedMaskMaterial.greenWrite = false;
            												this.defaultImage9SlicedMaskMaterial.blueWrite = false;
            												this.defaultImage9SlicedMaskMaterial.alphaWrite = false;
            												this.defaultImage9SlicedMaskMaterial.update();
            												this.defaultImageMaterials.push(this.defaultImage9SlicedMaskMaterial);
            										}
            										return this.defaultImage9SlicedMaskMaterial;
            								} else if (nineSliceTiled) {
            										if (!this.defaultImage9TiledMaskMaterial) {
            												this.defaultImage9TiledMaskMaterial = this._createBaseImageMaterial();
            												this.defaultImage9TiledMaskMaterial.name = 'defaultImage9TiledMaskMaterial';
            												this.defaultImage9TiledMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
            												this.defaultImage9TiledMaskMaterial.alphaTest = 1;
            												this.defaultImage9TiledMaskMaterial.redWrite = false;
            												this.defaultImage9TiledMaskMaterial.greenWrite = false;
            												this.defaultImage9TiledMaskMaterial.blueWrite = false;
            												this.defaultImage9TiledMaskMaterial.alphaWrite = false;
            												this.defaultImage9TiledMaskMaterial.update();
            												this.defaultImageMaterials.push(this.defaultImage9TiledMaskMaterial);
            										}
            										return this.defaultImage9TiledMaskMaterial;
            								} else {
            										if (!this.defaultImageMaskMaterial) {
            												this.defaultImageMaskMaterial = this._createBaseImageMaterial();
            												this.defaultImageMaskMaterial.name = 'defaultImageMaskMaterial';
            												this.defaultImageMaskMaterial.alphaTest = 1;
            												this.defaultImageMaskMaterial.redWrite = false;
            												this.defaultImageMaskMaterial.greenWrite = false;
            												this.defaultImageMaskMaterial.blueWrite = false;
            												this.defaultImageMaskMaterial.alphaWrite = false;
            												this.defaultImageMaskMaterial.update();
            												this.defaultImageMaterials.push(this.defaultImageMaskMaterial);
            										}
            										return this.defaultImageMaskMaterial;
            								}
            						} else {
            								if (nineSliced) {
            										if (!this.defaultImage9SlicedMaterial) {
            												this.defaultImage9SlicedMaterial = this._createBaseImageMaterial();
            												this.defaultImage9SlicedMaterial.name = 'defaultImage9SlicedMaterial';
            												this.defaultImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
            												this.defaultImage9SlicedMaterial.update();
            												this.defaultImageMaterials.push(this.defaultImage9SlicedMaterial);
            										}
            										return this.defaultImage9SlicedMaterial;
            								} else if (nineSliceTiled) {
            										if (!this.defaultImage9TiledMaterial) {
            												this.defaultImage9TiledMaterial = this._createBaseImageMaterial();
            												this.defaultImage9TiledMaterial.name = 'defaultImage9TiledMaterial';
            												this.defaultImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;
            												this.defaultImage9TiledMaterial.update();
            												this.defaultImageMaterials.push(this.defaultImage9TiledMaterial);
            										}
            										return this.defaultImage9TiledMaterial;
            								} else {
            										if (!this.defaultImageMaterial) {
            												this.defaultImageMaterial = this._createBaseImageMaterial();
            												this.defaultImageMaterial.name = 'defaultImageMaterial';
            												this.defaultImageMaterial.update();
            												this.defaultImageMaterials.push(this.defaultImageMaterial);
            										}
            										return this.defaultImageMaterial;
            								}
            						}
            				}
            		}
            		registerUnicodeConverter(func) {
            				this._unicodeConverter = func;
            		}
            		registerRtlReorder(func) {
            				this._rtlReorder = func;
            		}
            		getUnicodeConverter() {
            				return this._unicodeConverter;
            		}
            		getRtlReorder() {
            				return this._rtlReorder;
            		}
            		constructor(app){
            				super(app);
            				this.id = 'element';
            				this.ComponentType = ElementComponent;
            				this.DataType = ElementComponentData;
            				this.schema = _schema$f;
            				this._unicodeConverter = null;
            				this._rtlReorder = null;
            				this._defaultTexture = new Texture(app.graphicsDevice, {
            						width: 1,
            						height: 1,
            						format: PIXELFORMAT_SRGBA8,
            						name: 'element-system'
            				});
            				var pixels = this._defaultTexture.lock();
            				var pixelData = new Uint8Array(4);
            				pixelData[0] = 255.0;
            				pixelData[1] = 255.0;
            				pixelData[2] = 255.0;
            				pixelData[3] = 255.0;
            				pixels.set(pixelData);
            				this._defaultTexture.unlock();
            				this.defaultImageMaterial = null;
            				this.defaultImage9SlicedMaterial = null;
            				this.defaultImage9TiledMaterial = null;
            				this.defaultImageMaskMaterial = null;
            				this.defaultImage9SlicedMaskMaterial = null;
            				this.defaultImage9TiledMaskMaterial = null;
            				this.defaultScreenSpaceImageMaterial = null;
            				this.defaultScreenSpaceImage9SlicedMaterial = null;
            				this.defaultScreenSpaceImage9TiledMaterial = null;
            				this.defaultScreenSpaceImageMask9SlicedMaterial = null;
            				this.defaultScreenSpaceImageMask9TiledMaterial = null;
            				this.defaultScreenSpaceImageMaskMaterial = null;
            				this._defaultTextMaterials = {};
            				this.defaultImageMaterials = [];
            				this.on('add', this.onAddComponent, this);
            				this.on('beforeremove', this.onRemoveComponent, this);
            		}
            }
            
            var MOTION_FREE = 'free';
            var MOTION_LIMITED = 'limited';
            var MOTION_LOCKED = 'locked';
            
            var properties$1 = [
            		'angularDampingX',
            		'angularDampingY',
            		'angularDampingZ',
            		'angularEquilibriumX',
            		'angularEquilibriumY',
            		'angularEquilibriumZ',
            		'angularLimitsX',
            		'angularLimitsY',
            		'angularLimitsZ',
            		'angularMotionX',
            		'angularMotionY',
            		'angularMotionZ',
            		'angularSpringX',
            		'angularSpringY',
            		'angularSpringZ',
            		'angularStiffnessX',
            		'angularStiffnessY',
            		'angularStiffnessZ',
            		'breakForce',
            		'enableCollision',
            		'enabled',
            		'entityA',
            		'entityB',
            		'linearDampingX',
            		'linearDampingY',
            		'linearDampingZ',
            		'linearEquilibriumX',
            		'linearEquilibriumY',
            		'linearEquilibriumZ',
            		'linearLimitsX',
            		'linearLimitsY',
            		'linearLimitsZ',
            		'linearMotionX',
            		'linearMotionY',
            		'linearMotionZ',
            		'linearSpringX',
            		'linearSpringY',
            		'linearSpringZ',
            		'linearStiffnessX',
            		'linearStiffnessY',
            		'linearStiffnessZ'
            ];
            class JointComponent extends Component {
            		set entityA(body) {
            				this._destroyConstraint();
            				this._entityA = body;
            				this._createConstraint();
            		}
            		get entityA() {
            				return this._entityA;
            		}
            		set entityB(body) {
            				this._destroyConstraint();
            				this._entityB = body;
            				this._createConstraint();
            		}
            		get entityB() {
            				return this._entityB;
            		}
            		set breakForce(force) {
            				if (this._constraint && this._breakForce !== force) {
            						this._constraint.setBreakingImpulseThreshold(force);
            						this._breakForce = force;
            				}
            		}
            		get breakForce() {
            				return this._breakForce;
            		}
            		set enableCollision(enableCollision) {
            				this._destroyConstraint();
            				this._enableCollision = enableCollision;
            				this._createConstraint();
            		}
            		get enableCollision() {
            				return this._enableCollision;
            		}
            		set angularLimitsX(limits) {
            				if (!this._angularLimitsX.equals(limits)) {
            						this._angularLimitsX.copy(limits);
            						this._updateAngularLimits();
            				}
            		}
            		get angularLimitsX() {
            				return this._angularLimitsX;
            		}
            		set angularMotionX(value) {
            				if (this._angularMotionX !== value) {
            						this._angularMotionX = value;
            						this._updateAngularLimits();
            				}
            		}
            		get angularMotionX() {
            				return this._angularMotionX;
            		}
            		set angularLimitsY(limits) {
            				if (!this._angularLimitsY.equals(limits)) {
            						this._angularLimitsY.copy(limits);
            						this._updateAngularLimits();
            				}
            		}
            		get angularLimitsY() {
            				return this._angularLimitsY;
            		}
            		set angularMotionY(value) {
            				if (this._angularMotionY !== value) {
            						this._angularMotionY = value;
            						this._updateAngularLimits();
            				}
            		}
            		get angularMotionY() {
            				return this._angularMotionY;
            		}
            		set angularLimitsZ(limits) {
            				if (!this._angularLimitsZ.equals(limits)) {
            						this._angularLimitsZ.copy(limits);
            						this._updateAngularLimits();
            				}
            		}
            		get angularLimitsZ() {
            				return this._angularLimitsZ;
            		}
            		set angularMotionZ(value) {
            				if (this._angularMotionZ !== value) {
            						this._angularMotionZ = value;
            						this._updateAngularLimits();
            				}
            		}
            		get angularMotionZ() {
            				return this._angularMotionZ;
            		}
            		set linearLimitsX(limits) {
            				if (!this._linearLimitsX.equals(limits)) {
            						this._linearLimitsX.copy(limits);
            						this._updateLinearLimits();
            				}
            		}
            		get linearLimitsX() {
            				return this._linearLimitsX;
            		}
            		set linearMotionX(value) {
            				if (this._linearMotionX !== value) {
            						this._linearMotionX = value;
            						this._updateLinearLimits();
            				}
            		}
            		get linearMotionX() {
            				return this._linearMotionX;
            		}
            		set linearLimitsY(limits) {
            				if (!this._linearLimitsY.equals(limits)) {
            						this._linearLimitsY.copy(limits);
            						this._updateLinearLimits();
            				}
            		}
            		get linearLimitsY() {
            				return this._linearLimitsY;
            		}
            		set linearMotionY(value) {
            				if (this._linearMotionY !== value) {
            						this._linearMotionY = value;
            						this._updateLinearLimits();
            				}
            		}
            		get linearMotionY() {
            				return this._linearMotionY;
            		}
            		set linearLimitsZ(limits) {
            				if (!this._linearLimitsZ.equals(limits)) {
            						this._linearLimitsZ.copy(limits);
            						this._updateLinearLimits();
            				}
            		}
            		get linearLimitsZ() {
            				return this._linearLimitsZ;
            		}
            		set linearMotionZ(value) {
            				if (this._linearMotionZ !== value) {
            						this._linearMotionZ = value;
            						this._updateLinearLimits();
            				}
            		}
            		get linearMotionZ() {
            				return this._linearMotionZ;
            		}
            		_convertTransform(pcTransform, ammoTransform) {
            				var pos = pcTransform.getTranslation();
            				var rot = new Quat();
            				rot.setFromMat4(pcTransform);
            				var ammoVec = new Ammo.btVector3(pos.x, pos.y, pos.z);
            				var ammoQuat = new Ammo.btQuaternion(rot.x, rot.y, rot.z, rot.w);
            				ammoTransform.setOrigin(ammoVec);
            				ammoTransform.setRotation(ammoQuat);
            				Ammo.destroy(ammoVec);
            				Ammo.destroy(ammoQuat);
            		}
            		_updateAngularLimits() {
            				var constraint = this._constraint;
            				if (constraint) {
            						var lx, ly, lz, ux, uy, uz;
            						if (this._angularMotionX === MOTION_LIMITED) {
            								lx = this._angularLimitsX.x * math.DEG_TO_RAD;
            								ux = this._angularLimitsX.y * math.DEG_TO_RAD;
            						} else if (this._angularMotionX === MOTION_FREE) {
            								lx = 1;
            								ux = 0;
            						} else {
            								lx = ux = 0;
            						}
            						if (this._angularMotionY === MOTION_LIMITED) {
            								ly = this._angularLimitsY.x * math.DEG_TO_RAD;
            								uy = this._angularLimitsY.y * math.DEG_TO_RAD;
            						} else if (this._angularMotionY === MOTION_FREE) {
            								ly = 1;
            								uy = 0;
            						} else {
            								ly = uy = 0;
            						}
            						if (this._angularMotionZ === MOTION_LIMITED) {
            								lz = this._angularLimitsZ.x * math.DEG_TO_RAD;
            								uz = this._angularLimitsZ.y * math.DEG_TO_RAD;
            						} else if (this._angularMotionZ === MOTION_FREE) {
            								lz = 1;
            								uz = 0;
            						} else {
            								lz = uz = 0;
            						}
            						var limits = new Ammo.btVector3(lx, ly, lz);
            						constraint.setAngularLowerLimit(limits);
            						limits.setValue(ux, uy, uz);
            						constraint.setAngularUpperLimit(limits);
            						Ammo.destroy(limits);
            				}
            		}
            		_updateLinearLimits() {
            				var constraint = this._constraint;
            				if (constraint) {
            						var lx, ly, lz, ux, uy, uz;
            						if (this._linearMotionX === MOTION_LIMITED) {
            								lx = this._linearLimitsX.x;
            								ux = this._linearLimitsX.y;
            						} else if (this._linearMotionX === MOTION_FREE) {
            								lx = 1;
            								ux = 0;
            						} else {
            								lx = ux = 0;
            						}
            						if (this._linearMotionY === MOTION_LIMITED) {
            								ly = this._linearLimitsY.x;
            								uy = this._linearLimitsY.y;
            						} else if (this._linearMotionY === MOTION_FREE) {
            								ly = 1;
            								uy = 0;
            						} else {
            								ly = uy = 0;
            						}
            						if (this._linearMotionZ === MOTION_LIMITED) {
            								lz = this._linearLimitsZ.x;
            								uz = this._linearLimitsZ.y;
            						} else if (this._linearMotionZ === MOTION_FREE) {
            								lz = 1;
            								uz = 0;
            						} else {
            								lz = uz = 0;
            						}
            						var limits = new Ammo.btVector3(lx, ly, lz);
            						constraint.setLinearLowerLimit(limits);
            						limits.setValue(ux, uy, uz);
            						constraint.setLinearUpperLimit(limits);
            						Ammo.destroy(limits);
            				}
            		}
            		_createConstraint() {
            				if (this._entityA && this._entityA.rigidbody) {
            						this._destroyConstraint();
            						var mat = new Mat4();
            						var bodyA = this._entityA.rigidbody.body;
            						bodyA.activate();
            						var jointWtm = this.entity.getWorldTransform();
            						var entityAWtm = this._entityA.getWorldTransform();
            						var invEntityAWtm = entityAWtm.clone().invert();
            						mat.mul2(invEntityAWtm, jointWtm);
            						var frameA = new Ammo.btTransform();
            						this._convertTransform(mat, frameA);
            						if (this._entityB && this._entityB.rigidbody) {
            								var bodyB = this._entityB.rigidbody.body;
            								bodyB.activate();
            								var entityBWtm = this._entityB.getWorldTransform();
            								var invEntityBWtm = entityBWtm.clone().invert();
            								mat.mul2(invEntityBWtm, jointWtm);
            								var frameB = new Ammo.btTransform();
            								this._convertTransform(mat, frameB);
            								this._constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA, bodyB, frameA, frameB, !this._enableCollision);
            								Ammo.destroy(frameB);
            						} else {
            								this._constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA, frameA, !this._enableCollision);
            						}
            						Ammo.destroy(frameA);
            						var axis = [
            								'X',
            								'Y',
            								'Z',
            								'X',
            								'Y',
            								'Z'
            						];
            						for(var i = 0; i < 6; i++){
            								var type = i < 3 ? '_linear' : '_angular';
            								this._constraint.enableSpring(i, this[type + "Spring" + axis[i]]);
            								this._constraint.setDamping(i, this[type + "Damping" + axis[i]]);
            								this._constraint.setEquilibriumPoint(i, this[type + "Equilibrium" + axis[i]]);
            								this._constraint.setStiffness(i, this[type + "Stiffness" + axis[i]]);
            						}
            						this._constraint.setBreakingImpulseThreshold(this._breakForce);
            						this._updateLinearLimits();
            						this._updateAngularLimits();
            						var app = this.system.app;
            						var dynamicsWorld = app.systems.rigidbody.dynamicsWorld;
            						dynamicsWorld.addConstraint(this._constraint, !this._enableCollision);
            				}
            		}
            		_destroyConstraint() {
            				if (this._constraint) {
            						var app = this.system.app;
            						var dynamicsWorld = app.systems.rigidbody.dynamicsWorld;
            						dynamicsWorld.removeConstraint(this._constraint);
            						Ammo.destroy(this._constraint);
            						this._constraint = null;
            				}
            		}
            		initFromData(data) {
            				for (var prop of properties$1){
            						if (data.hasOwnProperty(prop)) {
            								if (data[prop] instanceof Vec2) {
            										this["_" + prop].copy(data[prop]);
            								} else {
            										this["_" + prop] = data[prop];
            								}
            						}
            				}
            				this._createConstraint();
            		}
            		onEnable() {
            				this._createConstraint();
            		}
            		onDisable() {
            				this._destroyConstraint();
            		}
            		_onSetEnabled(prop, old, value) {}
            		_onBeforeRemove() {
            				this.fire('remove');
            		}
            		constructor(system, entity){
            				super(system, entity);
            				this._constraint = null;
            				this._entityA = null;
            				this._entityB = null;
            				this._breakForce = 3.4e+38;
            				this._enableCollision = true;
            				this._linearMotionX = MOTION_LOCKED;
            				this._linearLimitsX = new Vec2(0, 0);
            				this._linearSpringX = false;
            				this._linearStiffnessX = 0;
            				this._linearDampingX = 1;
            				this._linearEquilibriumX = 0;
            				this._linearMotionY = MOTION_LOCKED;
            				this._linearLimitsY = new Vec2(0, 0);
            				this._linearSpringY = false;
            				this._linearStiffnessY = 0;
            				this._linearDampingY = 1;
            				this._linearEquilibriumY = 0;
            				this._linearMotionZ = MOTION_LOCKED;
            				this._linearLimitsZ = new Vec2(0, 0);
            				this._linearSpringZ = false;
            				this._linearStiffnessZ = 0;
            				this._linearDampingZ = 1;
            				this._linearEquilibriumZ = 0;
            				this._angularMotionX = MOTION_LOCKED;
            				this._angularLimitsX = new Vec2(0, 0);
            				this._angularSpringX = false;
            				this._angularStiffnessX = 0;
            				this._angularDampingX = 1;
            				this._angularEquilibriumX = 0;
            				this._angularMotionY = MOTION_LOCKED;
            				this._angularLimitsY = new Vec2(0, 0);
            				this._angularSpringY = false;
            				this._angularStiffnessY = 0;
            				this._angularDampingY = 1;
            				this._angularEquilibriumY = 0;
            				this._angularMotionZ = MOTION_LOCKED;
            				this._angularLimitsZ = new Vec2(0, 0);
            				this._angularSpringZ = false;
            				this._angularEquilibriumZ = 0;
            				this._angularDampingZ = 1;
            				this._angularStiffnessZ = 0;
            				this.on('set_enabled', this._onSetEnabled, this);
            		}
            }
            var functionMap = {
            		Damping: 'setDamping',
            		Equilibrium: 'setEquilibriumPoint',
            		Spring: 'enableSpring',
            		Stiffness: 'setStiffness'
            };
            [
            		'linear',
            		'angular'
            ].forEach((type)=>{
            		[
            				'Damping',
            				'Equilibrium',
            				'Spring',
            				'Stiffness'
            		].forEach((name)=>{
            				[
            						'X',
            						'Y',
            						'Z'
            				].forEach((axis)=>{
            						var prop = type + name + axis;
            						var propInternal = "_" + prop;
            						var index = type === 'linear' ? 0 : 3;
            						if (axis === 'Y') index += 1;
            						if (axis === 'Z') index += 2;
            						Object.defineProperty(JointComponent.prototype, prop, {
            								get: function get() {
            										return this[propInternal];
            								},
            								set: function set(value) {
            										if (this[propInternal] !== value) {
            												this[propInternal] = value;
            												this._constraint[functionMap[name]](index, value);
            										}
            								}
            						});
            				});
            		});
            });
            
            class JointComponentData {
            		constructor(){
            				this.enabled = true;
            		}
            }
            
            var _schema$e = [
            		'enabled'
            ];
            class JointComponentSystem extends ComponentSystem {
            		initializeComponentData(component, data, properties) {
            				component.initFromData(data);
            				super.initializeComponentData(component, data, _schema$e);
            		}
            		constructor(app){
            				super(app);
            				this.id = 'joint';
            				this.app = app;
            				this.ComponentType = JointComponent;
            				this.DataType = JointComponentData;
            				this.schema = _schema$e;
            		}
            }
            Component._buildAccessors(JointComponent.prototype, _schema$e);
            
            class LayoutChildComponent extends Component {
            		set minWidth(value) {
            				if (value !== this._minWidth) {
            						this._minWidth = value;
            						this.fire('resize');
            				}
            		}
            		get minWidth() {
            				return this._minWidth;
            		}
            		set minHeight(value) {
            				if (value !== this._minHeight) {
            						this._minHeight = value;
            						this.fire('resize');
            				}
            		}
            		get minHeight() {
            				return this._minHeight;
            		}
            		set maxWidth(value) {
            				if (value !== this._maxWidth) {
            						this._maxWidth = value;
            						this.fire('resize');
            				}
            		}
            		get maxWidth() {
            				return this._maxWidth;
            		}
            		set maxHeight(value) {
            				if (value !== this._maxHeight) {
            						this._maxHeight = value;
            						this.fire('resize');
            				}
            		}
            		get maxHeight() {
            				return this._maxHeight;
            		}
            		set fitWidthProportion(value) {
            				if (value !== this._fitWidthProportion) {
            						this._fitWidthProportion = value;
            						this.fire('resize');
            				}
            		}
            		get fitWidthProportion() {
            				return this._fitWidthProportion;
            		}
            		set fitHeightProportion(value) {
            				if (value !== this._fitHeightProportion) {
            						this._fitHeightProportion = value;
            						this.fire('resize');
            				}
            		}
            		get fitHeightProportion() {
            				return this._fitHeightProportion;
            		}
            		set excludeFromLayout(value) {
            				if (value !== this._excludeFromLayout) {
            						this._excludeFromLayout = value;
            						this.fire('resize');
            				}
            		}
            		get excludeFromLayout() {
            				return this._excludeFromLayout;
            		}
            		constructor(...args){
            				super(...args), this._minWidth = 0, this._minHeight = 0, this._maxWidth = null, this._maxHeight = null, this._fitWidthProportion = 0, this._fitHeightProportion = 0, this._excludeFromLayout = false;
            		}
            }
            
            class LayoutChildComponentData {
            		constructor(){
            				this.enabled = true;
            		}
            }
            
            var _schema$d = [
            		'enabled'
            ];
            class LayoutChildComponentSystem extends ComponentSystem {
            		initializeComponentData(component, data, properties) {
            				if (data.enabled !== undefined) component.enabled = data.enabled;
            				if (data.minWidth !== undefined) component.minWidth = data.minWidth;
            				if (data.minHeight !== undefined) component.minHeight = data.minHeight;
            				if (data.maxWidth !== undefined) component.maxWidth = data.maxWidth;
            				if (data.maxHeight !== undefined) component.maxHeight = data.maxHeight;
            				if (data.fitWidthProportion !== undefined) component.fitWidthProportion = data.fitWidthProportion;
            				if (data.fitHeightProportion !== undefined) component.fitHeightProportion = data.fitHeightProportion;
            				if (data.excludeFromLayout !== undefined) component.excludeFromLayout = data.excludeFromLayout;
            				super.initializeComponentData(component, data, properties);
            		}
            		cloneComponent(entity, clone) {
            				var layoutChild = entity.layoutchild;
            				return this.addComponent(clone, {
            						enabled: layoutChild.enabled,
            						minWidth: layoutChild.minWidth,
            						minHeight: layoutChild.minHeight,
            						maxWidth: layoutChild.maxWidth,
            						maxHeight: layoutChild.maxHeight,
            						fitWidthProportion: layoutChild.fitWidthProportion,
            						fitHeightProportion: layoutChild.fitHeightProportion,
            						excludeFromLayout: layoutChild.excludeFromLayout
            				});
            		}
            		constructor(app){
            				super(app);
            				this.id = 'layoutchild';
            				this.ComponentType = LayoutChildComponent;
            				this.DataType = LayoutChildComponentData;
            				this.schema = _schema$d;
            		}
            }
            Component._buildAccessors(LayoutChildComponent.prototype, _schema$d);
            
            var FITTING_NONE = 0;
            var FITTING_STRETCH = 1;
            var FITTING_SHRINK = 2;
            var FITTING_BOTH = 3;
            
            var AXIS_MAPPINGS = {};
            AXIS_MAPPINGS[ORIENTATION_HORIZONTAL] = {
            		axis: 'x',
            		size: 'width',
            		calculatedSize: 'calculatedWidth',
            		minSize: 'minWidth',
            		maxSize: 'maxWidth',
            		fitting: 'widthFitting',
            		fittingProportion: 'fitWidthProportion'
            };
            AXIS_MAPPINGS[ORIENTATION_VERTICAL] = {
            		axis: 'y',
            		size: 'height',
            		calculatedSize: 'calculatedHeight',
            		minSize: 'minHeight',
            		maxSize: 'maxHeight',
            		fitting: 'heightFitting',
            		fittingProportion: 'fitHeightProportion'
            };
            var OPPOSITE_ORIENTATION = {};
            OPPOSITE_ORIENTATION[ORIENTATION_HORIZONTAL] = ORIENTATION_VERTICAL;
            OPPOSITE_ORIENTATION[ORIENTATION_VERTICAL] = ORIENTATION_HORIZONTAL;
            var PROPERTY_DEFAULTS = {
            		minWidth: 0,
            		minHeight: 0,
            		maxWidth: Number.POSITIVE_INFINITY,
            		maxHeight: Number.POSITIVE_INFINITY,
            		width: null,
            		height: null,
            		fitWidthProportion: 0,
            		fitHeightProportion: 0
            };
            var FITTING_ACTION = {
            		NONE: 'NONE',
            		APPLY_STRETCHING: 'APPLY_STRETCHING',
            		APPLY_SHRINKING: 'APPLY_SHRINKING'
            };
            var availableSpace = new Vec2();
            function createCalculator(orientation) {
            		var options;
            		var a = AXIS_MAPPINGS[orientation];
            		var b = AXIS_MAPPINGS[OPPOSITE_ORIENTATION[orientation]];
            		function minExtentA(element, size) {
            				return -size[a.size] * element.pivot[a.axis];
            		}
            		function minExtentB(element, size) {
            				return -size[b.size] * element.pivot[b.axis];
            		}
            		function maxExtentA(element, size) {
            				return size[a.size] * (1 - element.pivot[a.axis]);
            		}
            		function calculateAll(allElements, layoutOptions) {
            				allElements = allElements.filter(shouldIncludeInLayout);
            				options = layoutOptions;
            				availableSpace.x = options.containerSize.x - options.padding.x - options.padding.z;
            				availableSpace.y = options.containerSize.y - options.padding.y - options.padding.w;
            				resetAnchors(allElements);
            				var lines = reverseLinesIfRequired(splitLines(allElements));
            				var sizes = calculateSizesOnAxisB(lines, calculateSizesOnAxisA(lines));
            				var positions = calculateBasePositions(lines, sizes);
            				applyAlignmentAndPadding(lines, sizes, positions);
            				applySizesAndPositions(lines, sizes, positions);
            				return createLayoutInfo(lines);
            		}
            		function shouldIncludeInLayout(element) {
            				var layoutChildComponent = element.entity.layoutchild;
            				return !layoutChildComponent || !layoutChildComponent.enabled || !layoutChildComponent.excludeFromLayout;
            		}
            		function resetAnchors(allElements) {
            				for(var i = 0; i < allElements.length; ++i){
            						var element = allElements[i];
            						var anchor = element.anchor;
            						if (anchor.x !== 0 || anchor.y !== 0 || anchor.z !== 0 || anchor.w !== 0) {
            								element.anchor = Vec4.ZERO;
            						}
            				}
            		}
            		function splitLines(allElements) {
            				if (!options.wrap) {
            						return [
            								allElements
            						];
            				}
            				var lines = [
            						[]
            				];
            				var sizes = getElementSizeProperties(allElements);
            				var runningSize = 0;
            				var allowOverrun = options[a.fitting] === FITTING_SHRINK;
            				for(var i = 0; i < allElements.length; ++i){
            						if (lines[lines.length - 1].length > 0) {
            								runningSize += options.spacing[a.axis];
            						}
            						var idealElementSize = sizes[i][a.size];
            						runningSize += idealElementSize;
            						if (!allowOverrun && runningSize > availableSpace[a.axis] && lines[lines.length - 1].length !== 0) {
            								runningSize = idealElementSize;
            								lines.push([]);
            						}
            						lines[lines.length - 1].push(allElements[i]);
            						if (allowOverrun && runningSize > availableSpace[a.axis] && i !== allElements.length - 1) {
            								runningSize = 0;
            								lines.push([]);
            						}
            				}
            				return lines;
            		}
            		function reverseLinesIfRequired(lines) {
            				var reverseAxisA = options.orientation === ORIENTATION_HORIZONTAL && options.reverseX || options.orientation === ORIENTATION_VERTICAL && options.reverseY;
            				var reverseAxisB = options.orientation === ORIENTATION_HORIZONTAL && options.reverseY || options.orientation === ORIENTATION_VERTICAL && options.reverseX;
            				if (reverseAxisA) {
            						for(var lineIndex = 0; lineIndex < lines.length; ++lineIndex){
            								if (reverseAxisA) {
            										lines[lineIndex].reverse();
            								}
            						}
            				}
            				if (reverseAxisB) {
            						lines.reverse();
            				}
            				return lines;
            		}
            		function calculateSizesOnAxisA(lines) {
            				var sizesAllLines = [];
            				for(var lineIndex = 0; lineIndex < lines.length; ++lineIndex){
            						var line = lines[lineIndex];
            						var sizesThisLine = getElementSizeProperties(line);
            						var idealRequiredSpace = calculateTotalSpace(sizesThisLine, a);
            						var fittingAction = determineFittingAction(options[a.fitting], idealRequiredSpace, availableSpace[a.axis]);
            						if (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {
            								stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);
            						} else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {
            								shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);
            						}
            						sizesAllLines.push(sizesThisLine);
            				}
            				return sizesAllLines;
            		}
            		function calculateSizesOnAxisB(lines, sizesAllLines) {
            				var largestElementsForEachLine = [];
            				var largestSizesForEachLine = [];
            				for(var lineIndex = 0; lineIndex < lines.length; ++lineIndex){
            						var line = lines[lineIndex];
            						line.largestElement = null;
            						line.largestSize = {
            								width: Number.NEGATIVE_INFINITY,
            								height: Number.NEGATIVE_INFINITY
            						};
            						for(var elementIndex = 0; elementIndex < line.length; ++elementIndex){
            								var sizesThisElement = sizesAllLines[lineIndex][elementIndex];
            								if (sizesThisElement[b.size] > line.largestSize[b.size]) {
            										line.largestElement = line[elementIndex];
            										line.largestSize = sizesThisElement;
            								}
            						}
            						largestElementsForEachLine.push(line.largestElement);
            						largestSizesForEachLine.push(line.largestSize);
            				}
            				var idealRequiredSpace = calculateTotalSpace(largestSizesForEachLine, b);
            				var fittingAction = determineFittingAction(options[b.fitting], idealRequiredSpace, availableSpace[b.axis]);
            				if (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {
            						stretchSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);
            				} else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {
            						shrinkSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);
            				}
            				for(var lineIndex1 = 0; lineIndex1 < lines.length; ++lineIndex1){
            						var line1 = lines[lineIndex1];
            						for(var elementIndex1 = 0; elementIndex1 < line1.length; ++elementIndex1){
            								var sizesForThisElement = sizesAllLines[lineIndex1][elementIndex1];
            								var currentSize = sizesForThisElement[b.size];
            								var availableSize = lines.length === 1 ? availableSpace[b.axis] : line1.largestSize[b.size];
            								var elementFittingAction = determineFittingAction(options[b.fitting], currentSize, availableSize);
            								if (elementFittingAction === FITTING_ACTION.APPLY_STRETCHING) {
            										sizesForThisElement[b.size] = Math.min(availableSize, sizesForThisElement[b.maxSize]);
            								} else if (elementFittingAction === FITTING_ACTION.APPLY_SHRINKING) {
            										sizesForThisElement[b.size] = Math.max(availableSize, sizesForThisElement[b.minSize]);
            								}
            						}
            				}
            				return sizesAllLines;
            		}
            		function determineFittingAction(fittingMode, currentSize, availableSize) {
            				switch(fittingMode){
            						case FITTING_NONE:
            								return FITTING_ACTION.NONE;
            						case FITTING_STRETCH:
            								if (currentSize < availableSize) {
            										return FITTING_ACTION.APPLY_STRETCHING;
            								}
            								return FITTING_ACTION.NONE;
            						case FITTING_SHRINK:
            								if (currentSize >= availableSize) {
            										return FITTING_ACTION.APPLY_SHRINKING;
            								}
            								return FITTING_ACTION.NONE;
            						case FITTING_BOTH:
            								if (currentSize < availableSize) {
            										return FITTING_ACTION.APPLY_STRETCHING;
            								}
            								return FITTING_ACTION.APPLY_SHRINKING;
            						default:
            								throw new Error("Unrecognized fitting mode: " + fittingMode);
            				}
            		}
            		function calculateTotalSpace(sizes, axis) {
            				var totalSizes = sumValues(sizes, axis.size);
            				var totalSpacing = (sizes.length - 1) * options.spacing[axis.axis];
            				return totalSizes + totalSpacing;
            		}
            		function stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {
            				var ascendingMaxSizeOrder = getTraversalOrder(sizesThisLine, axis.maxSize);
            				var fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);
            				var fittingProportionSums = createSumArray(fittingProportions, ascendingMaxSizeOrder);
            				var remainingUndershoot = availableSpace[axis.axis] - idealRequiredSpace;
            				for(var i = 0; i < sizesThisLine.length; ++i){
            						var index = ascendingMaxSizeOrder[i];
            						var targetIncrease = calculateAdjustment(index, remainingUndershoot, fittingProportions, fittingProportionSums);
            						var targetSize = sizesThisLine[index][axis.size] + targetIncrease;
            						var maxSize = sizesThisLine[index][axis.maxSize];
            						var actualSize = Math.min(targetSize, maxSize);
            						sizesThisLine[index][axis.size] = actualSize;
            						var actualIncrease = Math.max(targetSize - actualSize, 0);
            						var appliedIncrease = targetIncrease - actualIncrease;
            						remainingUndershoot -= appliedIncrease;
            				}
            		}
            		function shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {
            				var descendingMinSizeOrder = getTraversalOrder(sizesThisLine, axis.minSize, true);
            				var fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);
            				var inverseFittingProportions = invertNormalizedValues(fittingProportions);
            				var inverseFittingProportionSums = createSumArray(inverseFittingProportions, descendingMinSizeOrder);
            				var remainingOvershoot = idealRequiredSpace - availableSpace[axis.axis];
            				for(var i = 0; i < sizesThisLine.length; ++i){
            						var index = descendingMinSizeOrder[i];
            						var targetReduction = calculateAdjustment(index, remainingOvershoot, inverseFittingProportions, inverseFittingProportionSums);
            						var targetSize = sizesThisLine[index][axis.size] - targetReduction;
            						var minSize = sizesThisLine[index][axis.minSize];
            						var actualSize = Math.max(targetSize, minSize);
            						sizesThisLine[index][axis.size] = actualSize;
            						var actualReduction = Math.max(actualSize - targetSize, 0);
            						var appliedReduction = targetReduction - actualReduction;
            						remainingOvershoot -= appliedReduction;
            				}
            		}
            		function calculateAdjustment(index, remainingAdjustment, fittingProportions, fittingProportionSums) {
            				var proportion = fittingProportions[index];
            				var sumOfRemainingProportions = fittingProportionSums[index];
            				if (Math.abs(proportion) < 1e-5 && Math.abs(sumOfRemainingProportions) < 1e-5) {
            						return remainingAdjustment;
            				}
            				return remainingAdjustment * proportion / sumOfRemainingProportions;
            		}
            		function calculateBasePositions(lines, sizes) {
            				var cursor = {};
            				cursor[a.axis] = 0;
            				cursor[b.axis] = 0;
            				lines[a.size] = Number.NEGATIVE_INFINITY;
            				var positionsAllLines = [];
            				for(var lineIndex = 0; lineIndex < lines.length; ++lineIndex){
            						var line = lines[lineIndex];
            						if (line.length === 0) {
            								positionsAllLines.push([]);
            								continue;
            						}
            						var positionsThisLine = [];
            						var sizesThisLine = sizes[lineIndex];
            						for(var elementIndex = 0; elementIndex < line.length; ++elementIndex){
            								var element = line[elementIndex];
            								var sizesThisElement = sizesThisLine[elementIndex];
            								cursor[b.axis] -= minExtentB(element, sizesThisElement);
            								cursor[a.axis] -= minExtentA(element, sizesThisElement);
            								positionsThisLine[elementIndex] = {};
            								positionsThisLine[elementIndex][a.axis] = cursor[a.axis];
            								positionsThisLine[elementIndex][b.axis] = cursor[b.axis];
            								cursor[b.axis] += minExtentB(element, sizesThisElement);
            								cursor[a.axis] += maxExtentA(element, sizesThisElement) + options.spacing[a.axis];
            						}
            						line[a.size] = cursor[a.axis] - options.spacing[a.axis];
            						line[b.size] = line.largestSize[b.size];
            						lines[a.size] = Math.max(lines[a.size], line[a.size]);
            						cursor[a.axis] = 0;
            						cursor[b.axis] += line[b.size] + options.spacing[b.axis];
            						positionsAllLines.push(positionsThisLine);
            				}
            				lines[b.size] = cursor[b.axis] - options.spacing[b.axis];
            				return positionsAllLines;
            		}
            		function applyAlignmentAndPadding(lines, sizes, positions) {
            				var alignmentA = options.alignment[a.axis];
            				var alignmentB = options.alignment[b.axis];
            				var paddingA = options.padding[a.axis];
            				var paddingB = options.padding[b.axis];
            				for(var lineIndex = 0; lineIndex < lines.length; ++lineIndex){
            						var line = lines[lineIndex];
            						var sizesThisLine = sizes[lineIndex];
            						var positionsThisLine = positions[lineIndex];
            						var axisAOffset = (availableSpace[a.axis] - line[a.size]) * alignmentA + paddingA;
            						var axisBOffset = (availableSpace[b.axis] - lines[b.size]) * alignmentB + paddingB;
            						for(var elementIndex = 0; elementIndex < line.length; ++elementIndex){
            								var withinLineAxisBOffset = (line[b.size] - sizesThisLine[elementIndex][b.size]) * options.alignment[b.axis];
            								positionsThisLine[elementIndex][a.axis] += axisAOffset;
            								positionsThisLine[elementIndex][b.axis] += axisBOffset + withinLineAxisBOffset;
            						}
            				}
            		}
            		function applySizesAndPositions(lines, sizes, positions) {
            				for(var lineIndex = 0; lineIndex < lines.length; ++lineIndex){
            						var line = lines[lineIndex];
            						var sizesThisLine = sizes[lineIndex];
            						var positionsThisLine = positions[lineIndex];
            						for(var elementIndex = 0; elementIndex < line.length; ++elementIndex){
            								var element = line[elementIndex];
            								element[a.calculatedSize] = sizesThisLine[elementIndex][a.size];
            								element[b.calculatedSize] = sizesThisLine[elementIndex][b.size];
            								if (options.orientation === ORIENTATION_HORIZONTAL) {
            										element.entity.setLocalPosition(positionsThisLine[elementIndex][a.axis], positionsThisLine[elementIndex][b.axis], element.entity.getLocalPosition().z);
            								} else {
            										element.entity.setLocalPosition(positionsThisLine[elementIndex][b.axis], positionsThisLine[elementIndex][a.axis], element.entity.getLocalPosition().z);
            								}
            						}
            				}
            		}
            		function createLayoutInfo(lines) {
            				var layoutWidth = lines.width;
            				var layoutHeight = lines.height;
            				var xOffset = (availableSpace.x - layoutWidth) * options.alignment.x + options.padding.x;
            				var yOffset = (availableSpace.y - layoutHeight) * options.alignment.y + options.padding.y;
            				return {
            						bounds: new Vec4(xOffset, yOffset, layoutWidth, layoutHeight)
            				};
            		}
            		function getElementSizeProperties(elements) {
            				var sizeProperties = [];
            				for(var i = 0; i < elements.length; ++i){
            						var element = elements[i];
            						var minWidth = Math.max(getProperty(element, 'minWidth'), 0);
            						var minHeight = Math.max(getProperty(element, 'minHeight'), 0);
            						var maxWidth = Math.max(getProperty(element, 'maxWidth'), minWidth);
            						var maxHeight = Math.max(getProperty(element, 'maxHeight'), minHeight);
            						var width = clamp(getProperty(element, 'width'), minWidth, maxWidth);
            						var height = clamp(getProperty(element, 'height'), minHeight, maxHeight);
            						var fitWidthProportion = getProperty(element, 'fitWidthProportion');
            						var fitHeightProportion = getProperty(element, 'fitHeightProportion');
            						sizeProperties.push({
            								minWidth: minWidth,
            								minHeight: minHeight,
            								maxWidth: maxWidth,
            								maxHeight: maxHeight,
            								width: width,
            								height: height,
            								fitWidthProportion: fitWidthProportion,
            								fitHeightProportion: fitHeightProportion
            						});
            				}
            				return sizeProperties;
            		}
            		function getProperty(element, propertyName) {
            				var layoutChildComponent = element.entity.layoutchild;
            				if (layoutChildComponent && layoutChildComponent.enabled && layoutChildComponent[propertyName] !== undefined && layoutChildComponent[propertyName] !== null) {
            						return layoutChildComponent[propertyName];
            				} else if (element[propertyName] !== undefined) {
            						return element[propertyName];
            				}
            				return PROPERTY_DEFAULTS[propertyName];
            		}
            		function clamp(value, min, max) {
            				return Math.min(Math.max(value, min), max);
            		}
            		function sumValues(items, propertyName) {
            				return items.reduce((accumulator, current)=>{
            						return accumulator + current[propertyName];
            				}, 0);
            		}
            		function getNormalizedValues(items, propertyName) {
            				var sum = sumValues(items, propertyName);
            				var normalizedValues = [];
            				var numItems = items.length;
            				if (sum === 0) {
            						for(var i = 0; i < numItems; ++i){
            								normalizedValues.push(1 / numItems);
            						}
            				} else {
            						for(var i1 = 0; i1 < numItems; ++i1){
            								normalizedValues.push(items[i1][propertyName] / sum);
            						}
            				}
            				return normalizedValues;
            		}
            		function invertNormalizedValues(values) {
            				if (values.length === 1) {
            						return [
            								1
            						];
            				}
            				var invertedValues = [];
            				var numValues = values.length;
            				for(var i = 0; i < numValues; ++i){
            						invertedValues.push((1 - values[i]) / (numValues - 1));
            				}
            				return invertedValues;
            		}
            		function getTraversalOrder(items, orderBy, descending) {
            				items.forEach(assignIndex);
            				return items.slice().sort((itemA, itemB)=>{
            						return descending ? itemB[orderBy] - itemA[orderBy] : itemA[orderBy] - itemB[orderBy];
            				}).map(getIndex);
            		}
            		function assignIndex(item, index) {
            				item.index = index;
            		}
            		function getIndex(item) {
            				return item.index;
            		}
            		function createSumArray(values, order) {
            				var sumArray = [];
            				sumArray[order[values.length - 1]] = values[order[values.length - 1]];
            				for(var i = values.length - 2; i >= 0; --i){
            						sumArray[order[i]] = sumArray[order[i + 1]] + values[order[i]];
            				}
            				return sumArray;
            		}
            		return calculateAll;
            }
            var CALCULATE_FNS = {};
            CALCULATE_FNS[ORIENTATION_HORIZONTAL] = createCalculator(ORIENTATION_HORIZONTAL);
            CALCULATE_FNS[ORIENTATION_VERTICAL] = createCalculator(ORIENTATION_VERTICAL);
            class LayoutCalculator {
            		calculateLayout(elements, options) {
            				var calculateFn = CALCULATE_FNS[options.orientation];
            				if (!calculateFn) {
            						throw new Error("Unrecognized orientation value: " + options.orientation);
            				} else {
            						return calculateFn(elements, options);
            				}
            		}
            }
            
            function getElement(entity) {
            		return entity.element;
            }
            function isEnabledAndHasEnabledElement(entity) {
            		return entity.enabled && entity.element && entity.element.enabled;
            }
            class LayoutGroupComponent extends Component {
            		set orientation(value) {
            				if (value !== this._orientation) {
            						this._orientation = value;
            						this._scheduleReflow();
            				}
            		}
            		get orientation() {
            				return this._orientation;
            		}
            		set reverseX(value) {
            				if (value !== this._reverseX) {
            						this._reverseX = value;
            						this._scheduleReflow();
            				}
            		}
            		get reverseX() {
            				return this._reverseX;
            		}
            		set reverseY(value) {
            				if (value !== this._reverseY) {
            						this._reverseY = value;
            						this._scheduleReflow();
            				}
            		}
            		get reverseY() {
            				return this._reverseY;
            		}
            		set alignment(value) {
            				if (!value.equals(this._alignment)) {
            						this._alignment.copy(value);
            						this._scheduleReflow();
            				}
            		}
            		get alignment() {
            				return this._alignment;
            		}
            		set padding(value) {
            				if (!value.equals(this._padding)) {
            						this._padding.copy(value);
            						this._scheduleReflow();
            				}
            		}
            		get padding() {
            				return this._padding;
            		}
            		set spacing(value) {
            				if (!value.equals(this._spacing)) {
            						this._spacing.copy(value);
            						this._scheduleReflow();
            				}
            		}
            		get spacing() {
            				return this._spacing;
            		}
            		set widthFitting(value) {
            				if (value !== this._widthFitting) {
            						this._widthFitting = value;
            						this._scheduleReflow();
            				}
            		}
            		get widthFitting() {
            				return this._widthFitting;
            		}
            		set heightFitting(value) {
            				if (value !== this._heightFitting) {
            						this._heightFitting = value;
            						this._scheduleReflow();
            				}
            		}
            		get heightFitting() {
            				return this._heightFitting;
            		}
            		set wrap(value) {
            				if (value !== this._wrap) {
            						this._wrap = value;
            						this._scheduleReflow();
            				}
            		}
            		get wrap() {
            				return this._wrap;
            		}
            		_isSelfOrChild(entity) {
            				return entity === this.entity || this.entity.children.indexOf(entity) !== -1;
            		}
            		_listenForReflowEvents(target, onOff) {
            				if (target.element) {
            						target.element[onOff]('enableelement', this._scheduleReflow, this);
            						target.element[onOff]('disableelement', this._scheduleReflow, this);
            						target.element[onOff]('resize', this._scheduleReflow, this);
            						target.element[onOff]('set:pivot', this._scheduleReflow, this);
            				}
            				if (target.layoutchild) {
            						target.layoutchild[onOff]('set_enabled', this._scheduleReflow, this);
            						target.layoutchild[onOff]('resize', this._scheduleReflow, this);
            				}
            		}
            		_onElementOrLayoutComponentAdd(entity) {
            				if (this._isSelfOrChild(entity)) {
            						this._listenForReflowEvents(entity, 'on');
            						this._scheduleReflow();
            				}
            		}
            		_onElementOrLayoutComponentRemove(entity) {
            				if (this._isSelfOrChild(entity)) {
            						this._listenForReflowEvents(entity, 'off');
            						this._scheduleReflow();
            				}
            		}
            		_onChildInsert(child) {
            				this._listenForReflowEvents(child, 'on');
            				this._scheduleReflow();
            		}
            		_onChildRemove(child) {
            				this._listenForReflowEvents(child, 'off');
            				this._scheduleReflow();
            		}
            		_scheduleReflow() {
            				if (this.enabled && this.entity && this.entity.enabled && !this._isPerformingReflow) {
            						this.system.scheduleReflow(this);
            				}
            		}
            		reflow() {
            				var container = getElement(this.entity);
            				var elements = this.entity.children.filter(isEnabledAndHasEnabledElement).map(getElement);
            				if (!container || elements.length === 0) {
            						return;
            				}
            				var containerWidth = Math.max(container.calculatedWidth, 0);
            				var containerHeight = Math.max(container.calculatedHeight, 0);
            				var options = {
            						orientation: this._orientation,
            						reverseX: this._reverseX,
            						reverseY: this._reverseY,
            						alignment: this._alignment,
            						padding: this._padding,
            						spacing: this._spacing,
            						widthFitting: this._widthFitting,
            						heightFitting: this._heightFitting,
            						wrap: this._wrap,
            						containerSize: new Vec2(containerWidth, containerHeight)
            				};
            				this._isPerformingReflow = true;
            				var layoutInfo = this._layoutCalculator.calculateLayout(elements, options);
            				this._isPerformingReflow = false;
            				this.fire('reflow', layoutInfo);
            		}
            		onEnable() {
            				this._scheduleReflow();
            		}
            		onRemove() {
            				this.entity.off('childinsert', this._onChildInsert, this);
            				this.entity.off('childremove', this._onChildRemove, this);
            				this._listenForReflowEvents(this.entity, 'off');
            				this.entity.children.forEach((child)=>{
            						this._listenForReflowEvents(child, 'off');
            				});
            				this.system.app.systems.element.off('add', this._onElementOrLayoutComponentAdd, this);
            				this.system.app.systems.element.off('beforeremove', this._onElementOrLayoutComponentRemove, this);
            				this.system.app.systems.layoutchild.off('add', this._onElementOrLayoutComponentAdd, this);
            				this.system.app.systems.layoutchild.off('beforeremove', this._onElementOrLayoutComponentRemove, this);
            		}
            		constructor(system, entity){
            				super(system, entity), this._orientation = ORIENTATION_HORIZONTAL, this._reverseX = false, this._reverseY = true, this._alignment = new Vec2(0, 1), this._padding = new Vec4(), this._spacing = new Vec2(), this._widthFitting = FITTING_NONE, this._heightFitting = FITTING_NONE, this._wrap = false, this._layoutCalculator = new LayoutCalculator();
            				this._listenForReflowEvents(this.entity, 'on');
            				this.entity.children.forEach((child)=>{
            						this._listenForReflowEvents(child, 'on');
            				});
            				this.entity.on('childinsert', this._onChildInsert, this);
            				this.entity.on('childremove', this._onChildRemove, this);
            				system.app.systems.element.on('add', this._onElementOrLayoutComponentAdd, this);
            				system.app.systems.element.on('beforeremove', this._onElementOrLayoutComponentRemove, this);
            				system.app.systems.layoutchild.on('add', this._onElementOrLayoutComponentAdd, this);
            				system.app.systems.layoutchild.on('beforeremove', this._onElementOrLayoutComponentRemove, this);
            		}
            }
            
            class LayoutGroupComponentData {
            		constructor(){
            				this.enabled = true;
            		}
            }
            
            var _schema$c = [
            		'enabled'
            ];
            var MAX_ITERATIONS = 100;
            class LayoutGroupComponentSystem extends ComponentSystem {
            		initializeComponentData(component, data, properties) {
            				if (data.enabled !== undefined) component.enabled = data.enabled;
            				if (data.orientation !== undefined) component.orientation = data.orientation;
            				if (data.reverseX !== undefined) component.reverseX = data.reverseX;
            				if (data.reverseY !== undefined) component.reverseY = data.reverseY;
            				if (data.alignment !== undefined) {
            						component.alignment = Array.isArray(data.alignment) ? new Vec2(data.alignment) : data.alignment;
            				}
            				if (data.padding !== undefined) {
            						component.padding = Array.isArray(data.padding) ? new Vec4(data.padding) : data.padding;
            				}
            				if (data.spacing !== undefined) {
            						component.spacing = Array.isArray(data.spacing) ? new Vec2(data.spacing) : data.spacing;
            				}
            				if (data.widthFitting !== undefined) component.widthFitting = data.widthFitting;
            				if (data.heightFitting !== undefined) component.heightFitting = data.heightFitting;
            				if (data.wrap !== undefined) component.wrap = data.wrap;
            				super.initializeComponentData(component, data, properties);
            		}
            		cloneComponent(entity, clone) {
            				var layoutGroup = entity.layoutgroup;
            				return this.addComponent(clone, {
            						enabled: layoutGroup.enabled,
            						orientation: layoutGroup.orientation,
            						reverseX: layoutGroup.reverseX,
            						reverseY: layoutGroup.reverseY,
            						alignment: layoutGroup.alignment,
            						padding: layoutGroup.padding,
            						spacing: layoutGroup.spacing,
            						widthFitting: layoutGroup.widthFitting,
            						heightFitting: layoutGroup.heightFitting,
            						wrap: layoutGroup.wrap
            				});
            		}
            		scheduleReflow(component) {
            				if (this._reflowQueue.indexOf(component) === -1) {
            						this._reflowQueue.push(component);
            				}
            		}
            		_onPostUpdate() {
            				this._processReflowQueue();
            		}
            		_processReflowQueue() {
            				if (this._reflowQueue.length === 0) {
            						return;
            				}
            				var iterationCount = 0;
            				while(this._reflowQueue.length > 0){
            						var queue = this._reflowQueue.slice();
            						this._reflowQueue.length = 0;
            						queue.sort((componentA, componentB)=>{
            								return componentA.entity.graphDepth - componentB.entity.graphDepth;
            						});
            						for(var i = 0; i < queue.length; ++i){
            								queue[i].reflow();
            						}
            						if (++iterationCount >= MAX_ITERATIONS) {
            								console.warn('Max reflow iterations limit reached, bailing.');
            								break;
            						}
            				}
            		}
            		_onRemoveComponent(entity, component) {
            				component.onRemove();
            		}
            		destroy() {
            				super.destroy();
            				this.app.systems.off('postUpdate', this._onPostUpdate, this);
            		}
            		constructor(app){
            				super(app);
            				this.id = 'layoutgroup';
            				this.ComponentType = LayoutGroupComponent;
            				this.DataType = LayoutGroupComponentData;
            				this.schema = _schema$c;
            				this._reflowQueue = [];
            				this.on('beforeremove', this._onRemoveComponent, this);
            				this.app.systems.on('postUpdate', this._onPostUpdate, this);
            		}
            }
            Component._buildAccessors(LayoutGroupComponent.prototype, _schema$c);
            
            class PrimitivesCache {
            		destroy(device) {
            				this.map.forEach((primData)=>primData.mesh.destroy());
            		}
            		constructor(){
            				this.map = new Map();
            		}
            }
            var _primitivesCache = new DeviceCache();
            var getShapePrimitive = (device, type)=>{
            		var cache = _primitivesCache.get(device, ()=>{
            				return new PrimitivesCache();
            		});
            		var primData = cache.map.get(type);
            		if (!primData) {
            				var mesh, area;
            				switch(type){
            						case 'box':
            								mesh = Mesh.fromGeometry(device, new BoxGeometry());
            								area = {
            										x: 2,
            										y: 2,
            										z: 2,
            										uv: 2.0 / 3
            								};
            								break;
            						case 'capsule':
            								mesh = Mesh.fromGeometry(device, new CapsuleGeometry({
            										radius: 0.5,
            										height: 2
            								}));
            								area = {
            										x: Math.PI * 2,
            										y: Math.PI,
            										z: Math.PI * 2,
            										uv: 1.0 / 3 + 1.0 / 3 / 3 * 2
            								};
            								break;
            						case 'cone':
            								mesh = Mesh.fromGeometry(device, new ConeGeometry({
            										baseRadius: 0.5,
            										peakRadius: 0,
            										height: 1
            								}));
            								area = {
            										x: 2.54,
            										y: 2.54,
            										z: 2.54,
            										uv: 1.0 / 3 + 1.0 / 3 / 3
            								};
            								break;
            						case 'cylinder':
            								mesh = Mesh.fromGeometry(device, new CylinderGeometry({
            										radius: 0.5,
            										height: 1
            								}));
            								area = {
            										x: Math.PI,
            										y: 0.79 * 2,
            										z: Math.PI,
            										uv: 1.0 / 3 + 1.0 / 3 / 3 * 2
            								};
            								break;
            						case 'plane':
            								mesh = Mesh.fromGeometry(device, new PlaneGeometry({
            										halfExtents: new Vec2(0.5, 0.5),
            										widthSegments: 1,
            										lengthSegments: 1
            								}));
            								area = {
            										x: 0,
            										y: 1,
            										z: 0,
            										uv: 1
            								};
            								break;
            						case 'sphere':
            								mesh = Mesh.fromGeometry(device, new SphereGeometry({
            										radius: 0.5
            								}));
            								area = {
            										x: Math.PI,
            										y: Math.PI,
            										z: Math.PI,
            										uv: 1
            								};
            								break;
            						case 'torus':
            								mesh = Mesh.fromGeometry(device, new TorusGeometry({
            										tubeRadius: 0.2,
            										ringRadius: 0.3
            								}));
            								area = {
            										x: Math.PI * 0.5 * 0.5 - Math.PI * 0.1 * 0.1,
            										y: 0.4,
            										z: 0.4,
            										uv: 1
            								};
            								break;
            						default:
            								throw new Error("Invalid primitive type: " + type);
            				}
            				mesh.incRefCount();
            				primData = {
            						mesh: mesh,
            						area: area
            				};
            				cache.map.set(type, primData);
            		}
            		return primData;
            };
            
            class ModelComponent extends Component {
            		set meshInstances(value) {
            				if (!this._model) {
            						return;
            				}
            				this._model.meshInstances = value;
            		}
            		get meshInstances() {
            				if (!this._model) {
            						return null;
            				}
            				return this._model.meshInstances;
            		}
            		set customAabb(value) {
            				this._customAabb = value;
            				if (this._model) {
            						var mi = this._model.meshInstances;
            						if (mi) {
            								for(var i = 0; i < mi.length; i++){
            										mi[i].setCustomAabb(this._customAabb);
            								}
            						}
            				}
            		}
            		get customAabb() {
            				return this._customAabb;
            		}
            		set type(value) {
            				if (this._type === value) return;
            				this._area = null;
            				this._type = value;
            				if (value === 'asset') {
            						if (this._asset !== null) {
            								this._bindModelAsset(this._asset);
            						} else {
            								this.model = null;
            						}
            				} else {
            						var primData = getShapePrimitive(this.system.app.graphicsDevice, value);
            						this._area = primData.area;
            						var mesh = primData.mesh;
            						var node = new GraphNode();
            						var model = new Model();
            						model.graph = node;
            						model.meshInstances = [
            								new MeshInstance(mesh, this._material, node)
            						];
            						this.model = model;
            						this._asset = null;
            				}
            		}
            		get type() {
            				return this._type;
            		}
            		set asset(value) {
            				var assets = this.system.app.assets;
            				var _id = value;
            				if (value instanceof Asset) {
            						_id = value.id;
            				}
            				if (this._asset !== _id) {
            						if (this._asset) {
            								assets.off("add:" + this._asset, this._onModelAssetAdded, this);
            								var _prev = assets.get(this._asset);
            								if (_prev) {
            										this._unbindModelAsset(_prev);
            								}
            						}
            						this._asset = _id;
            						if (this._asset) {
            								var asset = assets.get(this._asset);
            								if (!asset) {
            										this.model = null;
            										assets.on("add:" + this._asset, this._onModelAssetAdded, this);
            								} else {
            										this._bindModelAsset(asset);
            								}
            						} else {
            								this.model = null;
            						}
            				}
            		}
            		get asset() {
            				return this._asset;
            		}
            		set model(value) {
            				if (this._model === value) {
            						return;
            				}
            				if (value && value._immutable) {
            						return;
            				}
            				if (this._model) {
            						this._model._immutable = false;
            						this.removeModelFromLayers();
            						this._model.getGraph().destroy();
            						delete this._model._entity;
            						if (this._clonedModel) {
            								this._model.destroy();
            								this._clonedModel = false;
            						}
            				}
            				this._model = value;
            				if (this._model) {
            						this._model._immutable = true;
            						var meshInstances = this._model.meshInstances;
            						for(var i = 0; i < meshInstances.length; i++){
            								meshInstances[i].castShadow = this._castShadows;
            								meshInstances[i].receiveShadow = this._receiveShadows;
            								meshInstances[i].setCustomAabb(this._customAabb);
            						}
            						this.lightmapped = this._lightmapped;
            						this.entity.addChild(this._model.graph);
            						if (this.enabled && this.entity.enabled) {
            								this.addModelToLayers();
            						}
            						this._model._entity = this.entity;
            						if (this.entity.animation) {
            								this.entity.animation.setModel(this._model);
            						}
            						if (this.entity.anim) {
            								this.entity.anim.rebind();
            						}
            						if (this.type === 'asset') {
            								this.mapping = this._mapping;
            						} else {
            								this._unsetMaterialEvents();
            						}
            				}
            		}
            		get model() {
            				return this._model;
            		}
            		set lightmapped(value) {
            				if (value !== this._lightmapped) {
            						this._lightmapped = value;
            						if (this._model) {
            								var mi = this._model.meshInstances;
            								for(var i = 0; i < mi.length; i++){
            										mi[i].setLightmapped(value);
            								}
            						}
            				}
            		}
            		get lightmapped() {
            				return this._lightmapped;
            		}
            		set castShadows(value) {
            				if (this._castShadows === value) return;
            				var model = this._model;
            				if (model) {
            						var layers = this.layers;
            						var scene = this.system.app.scene;
            						if (this._castShadows && !value) {
            								for(var i = 0; i < layers.length; i++){
            										var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
            										if (!layer) continue;
            										layer.removeShadowCasters(model.meshInstances);
            								}
            						}
            						var meshInstances = model.meshInstances;
            						for(var i1 = 0; i1 < meshInstances.length; i1++){
            								meshInstances[i1].castShadow = value;
            						}
            						if (!this._castShadows && value) {
            								for(var i2 = 0; i2 < layers.length; i2++){
            										var layer1 = scene.layers.getLayerById(layers[i2]);
            										if (!layer1) continue;
            										layer1.addShadowCasters(model.meshInstances);
            								}
            						}
            				}
            				this._castShadows = value;
            		}
            		get castShadows() {
            				return this._castShadows;
            		}
            		set receiveShadows(value) {
            				if (this._receiveShadows === value) return;
            				this._receiveShadows = value;
            				if (this._model) {
            						var meshInstances = this._model.meshInstances;
            						for(var i = 0, len = meshInstances.length; i < len; i++){
            								meshInstances[i].receiveShadow = value;
            						}
            				}
            		}
            		get receiveShadows() {
            				return this._receiveShadows;
            		}
            		set castShadowsLightmap(value) {
            				this._castShadowsLightmap = value;
            		}
            		get castShadowsLightmap() {
            				return this._castShadowsLightmap;
            		}
            		set lightmapSizeMultiplier(value) {
            				this._lightmapSizeMultiplier = value;
            		}
            		get lightmapSizeMultiplier() {
            				return this._lightmapSizeMultiplier;
            		}
            		set layers(value) {
            				var layers = this.system.app.scene.layers;
            				if (this.meshInstances) {
            						for(var i = 0; i < this._layers.length; i++){
            								var layer = layers.getLayerById(this._layers[i]);
            								if (!layer) continue;
            								layer.removeMeshInstances(this.meshInstances);
            						}
            				}
            				this._layers.length = 0;
            				for(var i1 = 0; i1 < value.length; i1++){
            						this._layers[i1] = value[i1];
            				}
            				if (!this.enabled || !this.entity.enabled || !this.meshInstances) return;
            				for(var i2 = 0; i2 < this._layers.length; i2++){
            						var layer1 = layers.getLayerById(this._layers[i2]);
            						if (!layer1) continue;
            						layer1.addMeshInstances(this.meshInstances);
            				}
            		}
            		get layers() {
            				return this._layers;
            		}
            		set batchGroupId(value) {
            				if (this._batchGroupId === value) return;
            				if (this.entity.enabled && this._batchGroupId >= 0) {
            						var _this_system_app_batcher;
            						(_this_system_app_batcher = this.system.app.batcher) == null ? void 0 : _this_system_app_batcher.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);
            				}
            				if (this.entity.enabled && value >= 0) {
            						var _this_system_app_batcher1;
            						(_this_system_app_batcher1 = this.system.app.batcher) == null ? void 0 : _this_system_app_batcher1.insert(BatchGroup.MODEL, value, this.entity);
            				}
            				if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
            						this.addModelToLayers();
            				}
            				this._batchGroupId = value;
            		}
            		get batchGroupId() {
            				return this._batchGroupId;
            		}
            		set materialAsset(value) {
            				var _id = value;
            				if (value instanceof Asset) {
            						_id = value.id;
            				}
            				var assets = this.system.app.assets;
            				if (_id !== this._materialAsset) {
            						if (this._materialAsset) {
            								assets.off("add:" + this._materialAsset, this._onMaterialAssetAdd, this);
            								var _prev = assets.get(this._materialAsset);
            								if (_prev) {
            										this._unbindMaterialAsset(_prev);
            								}
            						}
            						this._materialAsset = _id;
            						if (this._materialAsset) {
            								var asset = assets.get(this._materialAsset);
            								if (!asset) {
            										this._setMaterial(this.system.defaultMaterial);
            										assets.on("add:" + this._materialAsset, this._onMaterialAssetAdd, this);
            								} else {
            										this._bindMaterialAsset(asset);
            								}
            						} else {
            								this._setMaterial(this.system.defaultMaterial);
            						}
            				}
            		}
            		get materialAsset() {
            				return this._materialAsset;
            		}
            		set material(value) {
            				if (this._material === value) {
            						return;
            				}
            				this.materialAsset = null;
            				this._setMaterial(value);
            		}
            		get material() {
            				return this._material;
            		}
            		set mapping(value) {
            				if (this._type !== 'asset') {
            						return;
            				}
            				this._unsetMaterialEvents();
            				if (!value) {
            						value = {};
            				}
            				this._mapping = value;
            				if (!this._model) return;
            				var meshInstances = this._model.meshInstances;
            				var modelAsset = this.asset ? this.system.app.assets.get(this.asset) : null;
            				var assetMapping = modelAsset ? modelAsset.data.mapping : null;
            				var asset = null;
            				for(var i = 0, len = meshInstances.length; i < len; i++){
            						if (value[i] !== undefined) {
            								if (value[i]) {
            										asset = this.system.app.assets.get(value[i]);
            										this._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);
            								} else {
            										meshInstances[i].material = this.system.defaultMaterial;
            								}
            						} else if (assetMapping) {
            								if (assetMapping[i] && (assetMapping[i].material || assetMapping[i].path)) {
            										if (assetMapping[i].material !== undefined) {
            												asset = this.system.app.assets.get(assetMapping[i].material);
            										} else if (assetMapping[i].path !== undefined) {
            												var url = this._getMaterialAssetUrl(assetMapping[i].path);
            												if (url) {
            														asset = this.system.app.assets.getByUrl(url);
            												}
            										}
            										this._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);
            								} else {
            										meshInstances[i].material = this.system.defaultMaterial;
            								}
            						}
            				}
            		}
            		get mapping() {
            				return this._mapping;
            		}
            		addModelToLayers() {
            				var layers = this.system.app.scene.layers;
            				for(var i = 0; i < this._layers.length; i++){
            						var layer = layers.getLayerById(this._layers[i]);
            						if (layer) {
            								layer.addMeshInstances(this.meshInstances);
            						}
            				}
            		}
            		removeModelFromLayers() {
            				var layers = this.system.app.scene.layers;
            				for(var i = 0; i < this._layers.length; i++){
            						var layer = layers.getLayerById(this._layers[i]);
            						if (!layer) continue;
            						layer.removeMeshInstances(this.meshInstances);
            				}
            		}
            		onRemoveChild() {
            				if (this._model) {
            						this.removeModelFromLayers();
            				}
            		}
            		onInsertChild() {
            				if (this._model && this.enabled && this.entity.enabled) {
            						this.addModelToLayers();
            				}
            		}
            		onRemove() {
            				this.asset = null;
            				this.model = null;
            				this.materialAsset = null;
            				this._unsetMaterialEvents();
            				this.entity.off('remove', this.onRemoveChild, this);
            				this.entity.off('insert', this.onInsertChild, this);
            		}
            		onLayersChanged(oldComp, newComp) {
            				this.addModelToLayers();
            				oldComp.off('add', this.onLayerAdded, this);
            				oldComp.off('remove', this.onLayerRemoved, this);
            				newComp.on('add', this.onLayerAdded, this);
            				newComp.on('remove', this.onLayerRemoved, this);
            		}
            		onLayerAdded(layer) {
            				var index = this.layers.indexOf(layer.id);
            				if (index < 0) return;
            				layer.addMeshInstances(this.meshInstances);
            		}
            		onLayerRemoved(layer) {
            				var index = this.layers.indexOf(layer.id);
            				if (index < 0) return;
            				layer.removeMeshInstances(this.meshInstances);
            		}
            		_setMaterialEvent(index, event, id, handler) {
            				var evt = event + ":" + id;
            				this.system.app.assets.on(evt, handler, this);
            				if (!this._materialEvents) {
            						this._materialEvents = [];
            				}
            				if (!this._materialEvents[index]) {
            						this._materialEvents[index] = {};
            				}
            				this._materialEvents[index][evt] = {
            						id: id,
            						handler: handler
            				};
            		}
            		_unsetMaterialEvents() {
            				var assets = this.system.app.assets;
            				var events = this._materialEvents;
            				if (!events) {
            						return;
            				}
            				for(var i = 0, len = events.length; i < len; i++){
            						if (!events[i]) continue;
            						var evt = events[i];
            						for(var key in evt){
            								assets.off(key, evt[key].handler, this);
            						}
            				}
            				this._materialEvents = null;
            		}
            		_getAssetByIdOrPath(idOrPath) {
            				var asset = null;
            				var isPath = isNaN(parseInt(idOrPath, 10));
            				if (!isPath) {
            						asset = this.system.app.assets.get(idOrPath);
            				} else if (this.asset) {
            						var url = this._getMaterialAssetUrl(idOrPath);
            						if (url) {
            								asset = this.system.app.assets.getByUrl(url);
            						}
            				}
            				return asset;
            		}
            		_getMaterialAssetUrl(path) {
            				if (!this.asset) return null;
            				var modelAsset = this.system.app.assets.get(this.asset);
            				return modelAsset ? modelAsset.getAbsoluteUrl(path) : null;
            		}
            		_loadAndSetMeshInstanceMaterial(materialAsset, meshInstance, index) {
            				var assets = this.system.app.assets;
            				if (!materialAsset) {
            						return;
            				}
            				if (materialAsset.resource) {
            						meshInstance.material = materialAsset.resource;
            						this._setMaterialEvent(index, 'remove', materialAsset.id, function() {
            								meshInstance.material = this.system.defaultMaterial;
            						});
            				} else {
            						this._setMaterialEvent(index, 'load', materialAsset.id, function(asset) {
            								meshInstance.material = asset.resource;
            								this._setMaterialEvent(index, 'remove', materialAsset.id, function() {
            										meshInstance.material = this.system.defaultMaterial;
            								});
            						});
            						if (this.enabled && this.entity.enabled) {
            								assets.load(materialAsset);
            						}
            				}
            		}
            		onEnable() {
            				var app = this.system.app;
            				var scene = app.scene;
            				var layers = scene == null ? void 0 : scene.layers;
            				this._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);
            				if (layers) {
            						this._evtLayerAdded = layers.on('add', this.onLayerAdded, this);
            						this._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);
            				}
            				var isAsset = this._type === 'asset';
            				var asset;
            				if (this._model) {
            						this.addModelToLayers();
            				} else if (isAsset && this._asset) {
            						asset = app.assets.get(this._asset);
            						if (asset && asset.resource !== this._model) {
            								this._bindModelAsset(asset);
            						}
            				}
            				if (this._materialAsset) {
            						asset = app.assets.get(this._materialAsset);
            						if (asset && asset.resource !== this._material) {
            								this._bindMaterialAsset(asset);
            						}
            				}
            				if (isAsset) {
            						if (this._mapping) {
            								for(var index in this._mapping){
            										if (this._mapping[index]) {
            												asset = this._getAssetByIdOrPath(this._mapping[index]);
            												if (asset && !asset.resource) {
            														app.assets.load(asset);
            												}
            										}
            								}
            						}
            				}
            				if (this._batchGroupId >= 0) {
            						var _app_batcher;
            						(_app_batcher = app.batcher) == null ? void 0 : _app_batcher.insert(BatchGroup.MODEL, this.batchGroupId, this.entity);
            				}
            		}
            		onDisable() {
            				var _this__evtLayersChanged;
            				var app = this.system.app;
            				var scene = app.scene;
            				var layers = scene.layers;
            				(_this__evtLayersChanged = this._evtLayersChanged) == null ? void 0 : _this__evtLayersChanged.off();
            				this._evtLayersChanged = null;
            				if (layers) {
            						var _this__evtLayerAdded, _this__evtLayerRemoved;
            						(_this__evtLayerAdded = this._evtLayerAdded) == null ? void 0 : _this__evtLayerAdded.off();
            						this._evtLayerAdded = null;
            						(_this__evtLayerRemoved = this._evtLayerRemoved) == null ? void 0 : _this__evtLayerRemoved.off();
            						this._evtLayerRemoved = null;
            				}
            				if (this._batchGroupId >= 0) {
            						var _app_batcher;
            						(_app_batcher = app.batcher) == null ? void 0 : _app_batcher.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);
            				}
            				if (this._model) {
            						this.removeModelFromLayers();
            				}
            		}
            		hide() {
            				if (this._model) {
            						var instances = this._model.meshInstances;
            						for(var i = 0, l = instances.length; i < l; i++){
            								instances[i].visible = false;
            						}
            				}
            		}
            		show() {
            				if (this._model) {
            						var instances = this._model.meshInstances;
            						for(var i = 0, l = instances.length; i < l; i++){
            								instances[i].visible = true;
            						}
            				}
            		}
            		_bindMaterialAsset(asset) {
            				asset.on('load', this._onMaterialAssetLoad, this);
            				asset.on('unload', this._onMaterialAssetUnload, this);
            				asset.on('remove', this._onMaterialAssetRemove, this);
            				asset.on('change', this._onMaterialAssetChange, this);
            				if (asset.resource) {
            						this._onMaterialAssetLoad(asset);
            				} else {
            						if (!this.enabled || !this.entity.enabled) return;
            						this.system.app.assets.load(asset);
            				}
            		}
            		_unbindMaterialAsset(asset) {
            				asset.off('load', this._onMaterialAssetLoad, this);
            				asset.off('unload', this._onMaterialAssetUnload, this);
            				asset.off('remove', this._onMaterialAssetRemove, this);
            				asset.off('change', this._onMaterialAssetChange, this);
            		}
            		_onMaterialAssetAdd(asset) {
            				this.system.app.assets.off("add:" + asset.id, this._onMaterialAssetAdd, this);
            				if (this._materialAsset === asset.id) {
            						this._bindMaterialAsset(asset);
            				}
            		}
            		_onMaterialAssetLoad(asset) {
            				this._setMaterial(asset.resource);
            		}
            		_onMaterialAssetUnload(asset) {
            				this._setMaterial(this.system.defaultMaterial);
            		}
            		_onMaterialAssetRemove(asset) {
            				this._onMaterialAssetUnload(asset);
            		}
            		_onMaterialAssetChange(asset) {}
            		_bindModelAsset(asset) {
            				this._unbindModelAsset(asset);
            				asset.on('load', this._onModelAssetLoad, this);
            				asset.on('unload', this._onModelAssetUnload, this);
            				asset.on('change', this._onModelAssetChange, this);
            				asset.on('remove', this._onModelAssetRemove, this);
            				if (asset.resource) {
            						this._onModelAssetLoad(asset);
            				} else {
            						if (!this.enabled || !this.entity.enabled) return;
            						this.system.app.assets.load(asset);
            				}
            		}
            		_unbindModelAsset(asset) {
            				asset.off('load', this._onModelAssetLoad, this);
            				asset.off('unload', this._onModelAssetUnload, this);
            				asset.off('change', this._onModelAssetChange, this);
            				asset.off('remove', this._onModelAssetRemove, this);
            		}
            		_onModelAssetAdded(asset) {
            				this.system.app.assets.off("add:" + asset.id, this._onModelAssetAdded, this);
            				if (asset.id === this._asset) {
            						this._bindModelAsset(asset);
            				}
            		}
            		_onModelAssetLoad(asset) {
            				this.model = asset.resource.clone();
            				this._clonedModel = true;
            		}
            		_onModelAssetUnload(asset) {
            				this.model = null;
            		}
            		_onModelAssetChange(asset, attr, _new, _old) {
            				if (attr === 'data') {
            						this.mapping = this._mapping;
            				}
            		}
            		_onModelAssetRemove(asset) {
            				this.model = null;
            		}
            		_setMaterial(material) {
            				if (this._material === material) {
            						return;
            				}
            				this._material = material;
            				var model = this._model;
            				if (model && this._type !== 'asset') {
            						var meshInstances = model.meshInstances;
            						for(var i = 0, len = meshInstances.length; i < len; i++){
            								meshInstances[i].material = material;
            						}
            				}
            		}
            		constructor(system, entity){
            				super(system, entity), this._type = 'asset', this._asset = null, this._model = null, this._mapping = {}, this._castShadows = true, this._receiveShadows = true, this._materialAsset = null, this._castShadowsLightmap = true, this._lightmapped = false, this._lightmapSizeMultiplier = 1, this.isStatic = false, this._layers = [
            						LAYERID_WORLD
            				], this._batchGroupId = -1, this._customAabb = null, this._area = null, this._materialEvents = null, this._clonedModel = false, this._evtLayersChanged = null, this._evtLayerAdded = null, this._evtLayerRemoved = null;
            				this._material = system.defaultMaterial;
            				entity.on('remove', this.onRemoveChild, this);
            				entity.on('removehierarchy', this.onRemoveChild, this);
            				entity.on('insert', this.onInsertChild, this);
            				entity.on('inserthierarchy', this.onInsertChild, this);
            		}
            }
            
            class ModelComponentData {
            		constructor(){
            				this.enabled = true;
            		}
            }
            
            var _schema$b = [
            		'enabled'
            ];
            class ModelComponentSystem extends ComponentSystem {
            		initializeComponentData(component, _data, properties) {
            				properties = [
            						'material',
            						'materialAsset',
            						'asset',
            						'castShadows',
            						'receiveShadows',
            						'castShadowsLightmap',
            						'lightmapped',
            						'lightmapSizeMultiplier',
            						'type',
            						'mapping',
            						'layers',
            						'isStatic',
            						'batchGroupId'
            				];
            				if (_data.batchGroupId === null || _data.batchGroupId === undefined) {
            						_data.batchGroupId = -1;
            				}
            				if (_data.layers && _data.layers.length) {
            						_data.layers = _data.layers.slice(0);
            				}
            				for(var i = 0; i < properties.length; i++){
            						if (_data.hasOwnProperty(properties[i])) {
            								component[properties[i]] = _data[properties[i]];
            						}
            				}
            				if (_data.aabbCenter && _data.aabbHalfExtents) {
            						component.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));
            				}
            				super.initializeComponentData(component, _data, [
            						'enabled'
            				]);
            		}
            		cloneComponent(entity, clone) {
            				var data = {
            						type: entity.model.type,
            						asset: entity.model.asset,
            						castShadows: entity.model.castShadows,
            						receiveShadows: entity.model.receiveShadows,
            						castShadowsLightmap: entity.model.castShadowsLightmap,
            						lightmapped: entity.model.lightmapped,
            						lightmapSizeMultiplier: entity.model.lightmapSizeMultiplier,
            						isStatic: entity.model.isStatic,
            						enabled: entity.model.enabled,
            						layers: entity.model.layers,
            						batchGroupId: entity.model.batchGroupId,
            						mapping: extend({}, entity.model.mapping)
            				};
            				var materialAsset = entity.model.materialAsset;
            				if (!(materialAsset instanceof Asset) && materialAsset != null) {
            						materialAsset = this.app.assets.get(materialAsset);
            				}
            				var material = entity.model.material;
            				if (!material || material === this.defaultMaterial || !materialAsset || material === materialAsset.resource) {
            						data.materialAsset = materialAsset;
            				}
            				var component = this.addComponent(clone, data);
            				if (entity.model.model && entity.model.type === 'asset' && !entity.model.asset) {
            						component.model = entity.model.model.clone();
            						component._clonedModel = true;
            				}
            				if (!data.materialAsset) {
            						component.material = material;
            				}
            				if (entity.model.model) {
            						var meshInstances = entity.model.model.meshInstances;
            						var meshInstancesClone = component.model.meshInstances;
            						for(var i = 0; i < meshInstances.length; i++){
            								meshInstancesClone[i].mask = meshInstances[i].mask;
            								meshInstancesClone[i].material = meshInstances[i].material;
            								meshInstancesClone[i].layer = meshInstances[i].layer;
            								meshInstancesClone[i].receiveShadow = meshInstances[i].receiveShadow;
            						}
            				}
            				if (entity.model.customAabb) {
            						component.customAabb = entity.model.customAabb.clone();
            				}
            				return component;
            		}
            		onRemove(entity, component) {
            				component.onRemove();
            		}
            		constructor(app){
            				super(app);
            				this.id = 'model';
            				this.ComponentType = ModelComponent;
            				this.DataType = ModelComponentData;
            				this.schema = _schema$b;
            				this.defaultMaterial = getDefaultMaterial(app.graphicsDevice);
            				this.on('beforeremove', this.onRemove, this);
            		}
            }
            Component._buildAccessors(ModelComponent.prototype, _schema$b);
            
            var SIMPLE_PROPERTIES = [
            		'emitterExtents',
            		'emitterRadius',
            		'emitterExtentsInner',
            		'emitterRadiusInner',
            		'loop',
            		'initialVelocity',
            		'animSpeed',
            		'normalMap',
            		'particleNormal'
            ];
            var COMPLEX_PROPERTIES = [
            		'numParticles',
            		'lifetime',
            		'rate',
            		'rate2',
            		'startAngle',
            		'startAngle2',
            		'lighting',
            		'halfLambert',
            		'intensity',
            		'wrap',
            		'wrapBounds',
            		'depthWrite',
            		'noFog',
            		'sort',
            		'stretch',
            		'alignToMotion',
            		'preWarm',
            		'emitterShape',
            		'animTilesX',
            		'animTilesY',
            		'animStartFrame',
            		'animNumFrames',
            		'animNumAnimations',
            		'animIndex',
            		'randomizeAnimIndex',
            		'animLoop',
            		'colorMap',
            		'localSpace',
            		'screenSpace',
            		'orientation'
            ];
            var GRAPH_PROPERTIES = [
            		'scaleGraph',
            		'scaleGraph2',
            		'colorGraph',
            		'colorGraph2',
            		'alphaGraph',
            		'alphaGraph2',
            		'velocityGraph',
            		'velocityGraph2',
            		'localVelocityGraph',
            		'localVelocityGraph2',
            		'rotationSpeedGraph',
            		'rotationSpeedGraph2',
            		'radialSpeedGraph',
            		'radialSpeedGraph2'
            ];
            var ASSET_PROPERTIES = [
            		'colorMapAsset',
            		'normalMapAsset',
            		'meshAsset',
            		'renderAsset'
            ];
            var depthLayer;
            class ParticleSystemComponent extends Component {
            		get data() {
            				var record = this.system.store[this.entity.getGuid()];
            				return record ? record.data : null;
            		}
            		set enabled(arg) {
            				this._setValue('enabled', arg);
            		}
            		get enabled() {
            				return this.data.enabled;
            		}
            		set autoPlay(arg) {
            				this._setValue('autoPlay', arg);
            		}
            		get autoPlay() {
            				return this.data.autoPlay;
            		}
            		set numParticles(arg) {
            				this._setValue('numParticles', arg);
            		}
            		get numParticles() {
            				return this.data.numParticles;
            		}
            		set lifetime(arg) {
            				this._setValue('lifetime', arg);
            		}
            		get lifetime() {
            				return this.data.lifetime;
            		}
            		set rate(arg) {
            				this._setValue('rate', arg);
            		}
            		get rate() {
            				return this.data.rate;
            		}
            		set rate2(arg) {
            				this._setValue('rate2', arg);
            		}
            		get rate2() {
            				return this.data.rate2;
            		}
            		set startAngle(arg) {
            				this._setValue('startAngle', arg);
            		}
            		get startAngle() {
            				return this.data.startAngle;
            		}
            		set startAngle2(arg) {
            				this._setValue('startAngle2', arg);
            		}
            		get startAngle2() {
            				return this.data.startAngle2;
            		}
            		set loop(arg) {
            				this._setValue('loop', arg);
            		}
            		get loop() {
            				return this.data.loop;
            		}
            		set preWarm(arg) {
            				this._setValue('preWarm', arg);
            		}
            		get preWarm() {
            				return this.data.preWarm;
            		}
            		set lighting(arg) {
            				this._setValue('lighting', arg);
            		}
            		get lighting() {
            				return this.data.lighting;
            		}
            		set halfLambert(arg) {
            				this._setValue('halfLambert', arg);
            		}
            		get halfLambert() {
            				return this.data.halfLambert;
            		}
            		set intensity(arg) {
            				this._setValue('intensity', arg);
            		}
            		get intensity() {
            				return this.data.intensity;
            		}
            		set depthWrite(arg) {
            				this._setValue('depthWrite', arg);
            		}
            		get depthWrite() {
            				return this.data.depthWrite;
            		}
            		set noFog(arg) {
            				this._setValue('noFog', arg);
            		}
            		get noFog() {
            				return this.data.noFog;
            		}
            		set depthSoftening(arg) {
            				this._setValue('depthSoftening', arg);
            		}
            		get depthSoftening() {
            				return this.data.depthSoftening;
            		}
            		set sort(arg) {
            				this._setValue('sort', arg);
            		}
            		get sort() {
            				return this.data.sort;
            		}
            		set blendType(arg) {
            				this._setValue('blendType', arg);
            		}
            		get blendType() {
            				return this.data.blendType;
            		}
            		set stretch(arg) {
            				this._setValue('stretch', arg);
            		}
            		get stretch() {
            				return this.data.stretch;
            		}
            		set alignToMotion(arg) {
            				this._setValue('alignToMotion', arg);
            		}
            		get alignToMotion() {
            				return this.data.alignToMotion;
            		}
            		set emitterShape(arg) {
            				this._setValue('emitterShape', arg);
            		}
            		get emitterShape() {
            				return this.data.emitterShape;
            		}
            		set emitterExtents(arg) {
            				this._setValue('emitterExtents', arg);
            		}
            		get emitterExtents() {
            				return this.data.emitterExtents;
            		}
            		set emitterExtentsInner(arg) {
            				this._setValue('emitterExtentsInner', arg);
            		}
            		get emitterExtentsInner() {
            				return this.data.emitterExtentsInner;
            		}
            		set emitterRadius(arg) {
            				this._setValue('emitterRadius', arg);
            		}
            		get emitterRadius() {
            				return this.data.emitterRadius;
            		}
            		set emitterRadiusInner(arg) {
            				this._setValue('emitterRadiusInner', arg);
            		}
            		get emitterRadiusInner() {
            				return this.data.emitterRadiusInner;
            		}
            		set initialVelocity(arg) {
            				this._setValue('initialVelocity', arg);
            		}
            		get initialVelocity() {
            				return this.data.initialVelocity;
            		}
            		set wrap(arg) {
            				this._setValue('wrap', arg);
            		}
            		get wrap() {
            				return this.data.wrap;
            		}
            		set wrapBounds(arg) {
            				this._setValue('wrapBounds', arg);
            		}
            		get wrapBounds() {
            				return this.data.wrapBounds;
            		}
            		set localSpace(arg) {
            				this._setValue('localSpace', arg);
            		}
            		get localSpace() {
            				return this.data.localSpace;
            		}
            		set screenSpace(arg) {
            				this._setValue('screenSpace', arg);
            		}
            		get screenSpace() {
            				return this.data.screenSpace;
            		}
            		set colorMapAsset(arg) {
            				this._setValue('colorMapAsset', arg);
            		}
            		get colorMapAsset() {
            				return this.data.colorMapAsset;
            		}
            		set normalMapAsset(arg) {
            				this._setValue('normalMapAsset', arg);
            		}
            		get normalMapAsset() {
            				return this.data.normalMapAsset;
            		}
            		set mesh(arg) {
            				this._setValue('mesh', arg);
            		}
            		get mesh() {
            				return this.data.mesh;
            		}
            		set meshAsset(arg) {
            				this._setValue('meshAsset', arg);
            		}
            		get meshAsset() {
            				return this.data.meshAsset;
            		}
            		set renderAsset(arg) {
            				this._setValue('renderAsset', arg);
            		}
            		get renderAsset() {
            				return this.data.renderAsset;
            		}
            		set orientation(arg) {
            				this._setValue('orientation', arg);
            		}
            		get orientation() {
            				return this.data.orientation;
            		}
            		set particleNormal(arg) {
            				this._setValue('particleNormal', arg);
            		}
            		get particleNormal() {
            				return this.data.particleNormal;
            		}
            		set localVelocityGraph(arg) {
            				this._setValue('localVelocityGraph', arg);
            		}
            		get localVelocityGraph() {
            				return this.data.localVelocityGraph;
            		}
            		set localVelocityGraph2(arg) {
            				this._setValue('localVelocityGraph2', arg);
            		}
            		get localVelocityGraph2() {
            				return this.data.localVelocityGraph2;
            		}
            		set velocityGraph(arg) {
            				this._setValue('velocityGraph', arg);
            		}
            		get velocityGraph() {
            				return this.data.velocityGraph;
            		}
            		set velocityGraph2(arg) {
            				this._setValue('velocityGraph2', arg);
            		}
            		get velocityGraph2() {
            				return this.data.velocityGraph2;
            		}
            		set rotationSpeedGraph(arg) {
            				this._setValue('rotationSpeedGraph', arg);
            		}
            		get rotationSpeedGraph() {
            				return this.data.rotationSpeedGraph;
            		}
            		set rotationSpeedGraph2(arg) {
            				this._setValue('rotationSpeedGraph2', arg);
            		}
            		get rotationSpeedGraph2() {
            				return this.data.rotationSpeedGraph2;
            		}
            		set radialSpeedGraph(arg) {
            				this._setValue('radialSpeedGraph', arg);
            		}
            		get radialSpeedGraph() {
            				return this.data.radialSpeedGraph;
            		}
            		set radialSpeedGraph2(arg) {
            				this._setValue('radialSpeedGraph2', arg);
            		}
            		get radialSpeedGraph2() {
            				return this.data.radialSpeedGraph2;
            		}
            		set scaleGraph(arg) {
            				this._setValue('scaleGraph', arg);
            		}
            		get scaleGraph() {
            				return this.data.scaleGraph;
            		}
            		set scaleGraph2(arg) {
            				this._setValue('scaleGraph2', arg);
            		}
            		get scaleGraph2() {
            				return this.data.scaleGraph2;
            		}
            		set colorGraph(arg) {
            				this._setValue('colorGraph', arg);
            		}
            		get colorGraph() {
            				return this.data.colorGraph;
            		}
            		set colorGraph2(arg) {
            				this._setValue('colorGraph2', arg);
            		}
            		get colorGraph2() {
            				return this.data.colorGraph2;
            		}
            		set alphaGraph(arg) {
            				this._setValue('alphaGraph', arg);
            		}
            		get alphaGraph() {
            				return this.data.alphaGraph;
            		}
            		set alphaGraph2(arg) {
            				this._setValue('alphaGraph2', arg);
            		}
            		get alphaGraph2() {
            				return this.data.alphaGraph2;
            		}
            		set colorMap(arg) {
            				this._setValue('colorMap', arg);
            		}
            		get colorMap() {
            				return this.data.colorMap;
            		}
            		set normalMap(arg) {
            				this._setValue('normalMap', arg);
            		}
            		get normalMap() {
            				return this.data.normalMap;
            		}
            		set animTilesX(arg) {
            				this._setValue('animTilesX', arg);
            		}
            		get animTilesX() {
            				return this.data.animTilesX;
            		}
            		set animTilesY(arg) {
            				this._setValue('animTilesY', arg);
            		}
            		get animTilesY() {
            				return this.data.animTilesY;
            		}
            		set animStartFrame(arg) {
            				this._setValue('animStartFrame', arg);
            		}
            		get animStartFrame() {
            				return this.data.animStartFrame;
            		}
            		set animNumFrames(arg) {
            				this._setValue('animNumFrames', arg);
            		}
            		get animNumFrames() {
            				return this.data.animNumFrames;
            		}
            		set animNumAnimations(arg) {
            				this._setValue('animNumAnimations', arg);
            		}
            		get animNumAnimations() {
            				return this.data.animNumAnimations;
            		}
            		set animIndex(arg) {
            				this._setValue('animIndex', arg);
            		}
            		get animIndex() {
            				return this.data.animIndex;
            		}
            		set randomizeAnimIndex(arg) {
            				this._setValue('randomizeAnimIndex', arg);
            		}
            		get randomizeAnimIndex() {
            				return this.data.randomizeAnimIndex;
            		}
            		set animSpeed(arg) {
            				this._setValue('animSpeed', arg);
            		}
            		get animSpeed() {
            				return this.data.animSpeed;
            		}
            		set animLoop(arg) {
            				this._setValue('animLoop', arg);
            		}
            		get animLoop() {
            				return this.data.animLoop;
            		}
            		set layers(arg) {
            				this._setValue('layers', arg);
            		}
            		get layers() {
            				return this.data.layers;
            		}
            		set drawOrder(drawOrder) {
            				this._drawOrder = drawOrder;
            				if (this.emitter) {
            						this.emitter.drawOrder = drawOrder;
            				}
            		}
            		get drawOrder() {
            				return this._drawOrder;
            		}
            		_setValue(name, value) {
            				var data = this.data;
            				var oldValue = data[name];
            				data[name] = value;
            				this.fire('set', name, oldValue, value);
            		}
            		addMeshInstanceToLayers() {
            				if (!this.emitter) return;
            				for(var i = 0; i < this.layers.length; i++){
            						var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
            						if (!layer) continue;
            						layer.addMeshInstances([
            								this.emitter.meshInstance
            						]);
            						this.emitter._layer = layer;
            				}
            		}
            		removeMeshInstanceFromLayers() {
            				if (!this.emitter) return;
            				for(var i = 0; i < this.layers.length; i++){
            						var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
            						if (!layer) continue;
            						layer.removeMeshInstances([
            								this.emitter.meshInstance
            						]);
            				}
            		}
            		onSetLayers(name, oldValue, newValue) {
            				if (!this.emitter) return;
            				for(var i = 0; i < oldValue.length; i++){
            						var layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
            						if (!layer) continue;
            						layer.removeMeshInstances([
            								this.emitter.meshInstance
            						]);
            				}
            				if (!this.enabled || !this.entity.enabled) return;
            				for(var i1 = 0; i1 < newValue.length; i1++){
            						var layer1 = this.system.app.scene.layers.getLayerById(newValue[i1]);
            						if (!layer1) continue;
            						layer1.addMeshInstances([
            								this.emitter.meshInstance
            						]);
            				}
            		}
            		onLayersChanged(oldComp, newComp) {
            				this.addMeshInstanceToLayers();
            				oldComp.off('add', this.onLayerAdded, this);
            				oldComp.off('remove', this.onLayerRemoved, this);
            				newComp.on('add', this.onLayerAdded, this);
            				newComp.on('remove', this.onLayerRemoved, this);
            		}
            		onLayerAdded(layer) {
            				if (!this.emitter) return;
            				var index = this.layers.indexOf(layer.id);
            				if (index < 0) return;
            				layer.addMeshInstances([
            						this.emitter.meshInstance
            				]);
            		}
            		onLayerRemoved(layer) {
            				if (!this.emitter) return;
            				var index = this.layers.indexOf(layer.id);
            				if (index < 0) return;
            				layer.removeMeshInstances([
            						this.emitter.meshInstance
            				]);
            		}
            		_bindColorMapAsset(asset) {
            				asset.on('load', this._onColorMapAssetLoad, this);
            				asset.on('unload', this._onColorMapAssetUnload, this);
            				asset.on('remove', this._onColorMapAssetRemove, this);
            				asset.on('change', this._onColorMapAssetChange, this);
            				if (asset.resource) {
            						this._onColorMapAssetLoad(asset);
            				} else {
            						if (!this.enabled || !this.entity.enabled) return;
            						this.system.app.assets.load(asset);
            				}
            		}
            		_unbindColorMapAsset(asset) {
            				asset.off('load', this._onColorMapAssetLoad, this);
            				asset.off('unload', this._onColorMapAssetUnload, this);
            				asset.off('remove', this._onColorMapAssetRemove, this);
            				asset.off('change', this._onColorMapAssetChange, this);
            		}
            		_onColorMapAssetLoad(asset) {
            				this.colorMap = asset.resource;
            		}
            		_onColorMapAssetUnload(asset) {
            				this.colorMap = null;
            		}
            		_onColorMapAssetRemove(asset) {
            				this._onColorMapAssetUnload(asset);
            		}
            		_onColorMapAssetChange(asset) {}
            		onSetColorMapAsset(name, oldValue, newValue) {
            				var assets = this.system.app.assets;
            				if (oldValue) {
            						var asset = assets.get(oldValue);
            						if (asset) {
            								this._unbindColorMapAsset(asset);
            						}
            				}
            				if (newValue) {
            						if (newValue instanceof Asset) {
            								this.data.colorMapAsset = newValue.id;
            								newValue = newValue.id;
            						}
            						var asset1 = assets.get(newValue);
            						if (asset1) {
            								this._bindColorMapAsset(asset1);
            						} else {
            								assets.once("add:" + newValue, (asset)=>{
            										this._bindColorMapAsset(asset);
            								});
            						}
            				} else {
            						this.colorMap = null;
            				}
            		}
            		_bindNormalMapAsset(asset) {
            				asset.on('load', this._onNormalMapAssetLoad, this);
            				asset.on('unload', this._onNormalMapAssetUnload, this);
            				asset.on('remove', this._onNormalMapAssetRemove, this);
            				asset.on('change', this._onNormalMapAssetChange, this);
            				if (asset.resource) {
            						this._onNormalMapAssetLoad(asset);
            				} else {
            						if (!this.enabled || !this.entity.enabled) return;
            						this.system.app.assets.load(asset);
            				}
            		}
            		_unbindNormalMapAsset(asset) {
            				asset.off('load', this._onNormalMapAssetLoad, this);
            				asset.off('unload', this._onNormalMapAssetUnload, this);
            				asset.off('remove', this._onNormalMapAssetRemove, this);
            				asset.off('change', this._onNormalMapAssetChange, this);
            		}
            		_onNormalMapAssetLoad(asset) {
            				this.normalMap = asset.resource;
            		}
            		_onNormalMapAssetUnload(asset) {
            				this.normalMap = null;
            		}
            		_onNormalMapAssetRemove(asset) {
            				this._onNormalMapAssetUnload(asset);
            		}
            		_onNormalMapAssetChange(asset) {}
            		onSetNormalMapAsset(name, oldValue, newValue) {
            				var assets = this.system.app.assets;
            				if (oldValue) {
            						var asset = assets.get(oldValue);
            						if (asset) {
            								this._unbindNormalMapAsset(asset);
            						}
            				}
            				if (newValue) {
            						if (newValue instanceof Asset) {
            								this.data.normalMapAsset = newValue.id;
            								newValue = newValue.id;
            						}
            						var asset1 = assets.get(newValue);
            						if (asset1) {
            								this._bindNormalMapAsset(asset1);
            						} else {
            								assets.once("add:" + newValue, (asset)=>{
            										this._bindNormalMapAsset(asset);
            								});
            						}
            				} else {
            						this.normalMap = null;
            				}
            		}
            		_bindMeshAsset(asset) {
            				asset.on('load', this._onMeshAssetLoad, this);
            				asset.on('unload', this._onMeshAssetUnload, this);
            				asset.on('remove', this._onMeshAssetRemove, this);
            				asset.on('change', this._onMeshAssetChange, this);
            				if (asset.resource) {
            						this._onMeshAssetLoad(asset);
            				} else {
            						if (!this.enabled || !this.entity.enabled) return;
            						this.system.app.assets.load(asset);
            				}
            		}
            		_unbindMeshAsset(asset) {
            				asset.off('load', this._onMeshAssetLoad, this);
            				asset.off('unload', this._onMeshAssetUnload, this);
            				asset.off('remove', this._onMeshAssetRemove, this);
            				asset.off('change', this._onMeshAssetChange, this);
            		}
            		_onMeshAssetLoad(asset) {
            				this._onMeshChanged(asset.resource);
            		}
            		_onMeshAssetUnload(asset) {
            				this.mesh = null;
            		}
            		_onMeshAssetRemove(asset) {
            				this._onMeshAssetUnload(asset);
            		}
            		_onMeshAssetChange(asset) {}
            		onSetMeshAsset(name, oldValue, newValue) {
            				var assets = this.system.app.assets;
            				if (oldValue) {
            						var asset = assets.get(oldValue);
            						if (asset) {
            								this._unbindMeshAsset(asset);
            						}
            				}
            				if (newValue) {
            						if (newValue instanceof Asset) {
            								this.data.meshAsset = newValue.id;
            								newValue = newValue.id;
            						}
            						var asset1 = assets.get(newValue);
            						if (asset1) {
            								this._bindMeshAsset(asset1);
            						}
            				} else {
            						this._onMeshChanged(null);
            				}
            		}
            		onSetMesh(name, oldValue, newValue) {
            				if (!newValue || newValue instanceof Asset || typeof newValue === 'number') {
            						this.meshAsset = newValue;
            				} else {
            						this._onMeshChanged(newValue);
            				}
            		}
            		_onMeshChanged(mesh) {
            				if (mesh && !(mesh instanceof Mesh)) {
            						if (mesh.meshInstances[0]) {
            								mesh = mesh.meshInstances[0].mesh;
            						} else {
            								mesh = null;
            						}
            				}
            				this.data.mesh = mesh;
            				if (this.emitter) {
            						this.emitter.mesh = mesh;
            						this.emitter.resetMaterial();
            						this.rebuild();
            				}
            		}
            		onSetRenderAsset(name, oldValue, newValue) {
            				var assets = this.system.app.assets;
            				if (oldValue) {
            						var asset = assets.get(oldValue);
            						if (asset) {
            								this._unbindRenderAsset(asset);
            						}
            				}
            				if (newValue) {
            						if (newValue instanceof Asset) {
            								this.data.renderAsset = newValue.id;
            								newValue = newValue.id;
            						}
            						var asset1 = assets.get(newValue);
            						if (asset1) {
            								this._bindRenderAsset(asset1);
            						}
            				} else {
            						this._onRenderChanged(null);
            				}
            		}
            		_bindRenderAsset(asset) {
            				asset.on('load', this._onRenderAssetLoad, this);
            				asset.on('unload', this._onRenderAssetUnload, this);
            				asset.on('remove', this._onRenderAssetRemove, this);
            				if (asset.resource) {
            						this._onRenderAssetLoad(asset);
            				} else {
            						if (!this.enabled || !this.entity.enabled) return;
            						this.system.app.assets.load(asset);
            				}
            		}
            		_unbindRenderAsset(asset) {
            				var _this__evtSetMeshes;
            				asset.off('load', this._onRenderAssetLoad, this);
            				asset.off('unload', this._onRenderAssetUnload, this);
            				asset.off('remove', this._onRenderAssetRemove, this);
            				(_this__evtSetMeshes = this._evtSetMeshes) == null ? void 0 : _this__evtSetMeshes.off();
            				this._evtSetMeshes = null;
            		}
            		_onRenderAssetLoad(asset) {
            				this._onRenderChanged(asset.resource);
            		}
            		_onRenderAssetUnload(asset) {
            				this._onRenderChanged(null);
            		}
            		_onRenderAssetRemove(asset) {
            				this._onRenderAssetUnload(asset);
            		}
            		_onRenderChanged(render) {
            				var _this__evtSetMeshes;
            				if (!render) {
            						this._onMeshChanged(null);
            						return;
            				}
            				(_this__evtSetMeshes = this._evtSetMeshes) == null ? void 0 : _this__evtSetMeshes.off();
            				this._evtSetMeshes = render.on('set:meshes', this._onRenderSetMeshes, this);
            				if (render.meshes) {
            						this._onRenderSetMeshes(render.meshes);
            				}
            		}
            		_onRenderSetMeshes(meshes) {
            				this._onMeshChanged(meshes && meshes[0]);
            		}
            		onSetLoop(name, oldValue, newValue) {
            				if (this.emitter) {
            						this.emitter[name] = newValue;
            						this.emitter.resetTime();
            				}
            		}
            		onSetBlendType(name, oldValue, newValue) {
            				if (this.emitter) {
            						this.emitter[name] = newValue;
            						this.emitter.material.blendType = newValue;
            						this.emitter.resetMaterial();
            						this.rebuild();
            				}
            		}
            		_requestDepth() {
            				if (this._requestedDepth) return;
            				if (!depthLayer) depthLayer = this.system.app.scene.layers.getLayerById(LAYERID_DEPTH);
            				if (depthLayer) {
            						depthLayer.incrementCounter();
            						this._requestedDepth = true;
            				}
            		}
            		_releaseDepth() {
            				if (!this._requestedDepth) return;
            				if (depthLayer) {
            						depthLayer.decrementCounter();
            						this._requestedDepth = false;
            				}
            		}
            		onSetDepthSoftening(name, oldValue, newValue) {
            				if (oldValue !== newValue) {
            						if (newValue) {
            								if (this.enabled && this.entity.enabled) this._requestDepth();
            								if (this.emitter) this.emitter[name] = newValue;
            						} else {
            								if (this.enabled && this.entity.enabled) this._releaseDepth();
            								if (this.emitter) this.emitter[name] = newValue;
            						}
            						if (this.emitter) {
            								this.reset();
            								this.emitter.resetMaterial();
            								this.rebuild();
            						}
            				}
            		}
            		onSetSimpleProperty(name, oldValue, newValue) {
            				if (this.emitter) {
            						this.emitter[name] = newValue;
            						this.emitter.resetMaterial();
            				}
            		}
            		onSetComplexProperty(name, oldValue, newValue) {
            				if (this.emitter) {
            						this.emitter[name] = newValue;
            						this.emitter.resetMaterial();
            						this.rebuild();
            						this.reset();
            				}
            		}
            		onSetGraphProperty(name, oldValue, newValue) {
            				if (this.emitter) {
            						this.emitter[name] = newValue;
            						this.emitter.rebuildGraphs();
            						this.emitter.resetMaterial();
            				}
            		}
            		onEnable() {
            				var scene = this.system.app.scene;
            				var layers = scene.layers;
            				var data = this.data;
            				for(var i = 0, len = ASSET_PROPERTIES.length; i < len; i++){
            						var asset = data[ASSET_PROPERTIES[i]];
            						if (asset) {
            								if (!(asset instanceof Asset)) {
            										var id = parseInt(asset, 10);
            										if (id >= 0) {
            												asset = this.system.app.assets.get(asset);
            										} else {
            												continue;
            										}
            								}
            								if (asset && !asset.resource) {
            										this.system.app.assets.load(asset);
            								}
            						}
            				}
            				if (this.system.app.graphicsDevice.disableParticleSystem) {
            						return;
            				}
            				if (!this.emitter) {
            						var mesh = data.mesh;
            						if (!(mesh instanceof Mesh)) {
            								mesh = null;
            						}
            						this.emitter = new ParticleEmitter(this.system.app.graphicsDevice, {
            								numParticles: data.numParticles,
            								emitterExtents: data.emitterExtents,
            								emitterExtentsInner: data.emitterExtentsInner,
            								emitterRadius: data.emitterRadius,
            								emitterRadiusInner: data.emitterRadiusInner,
            								emitterShape: data.emitterShape,
            								initialVelocity: data.initialVelocity,
            								wrap: data.wrap,
            								localSpace: data.localSpace,
            								screenSpace: data.screenSpace,
            								wrapBounds: data.wrapBounds,
            								lifetime: data.lifetime,
            								rate: data.rate,
            								rate2: data.rate2,
            								orientation: data.orientation,
            								particleNormal: data.particleNormal,
            								animTilesX: data.animTilesX,
            								animTilesY: data.animTilesY,
            								animStartFrame: data.animStartFrame,
            								animNumFrames: data.animNumFrames,
            								animNumAnimations: data.animNumAnimations,
            								animIndex: data.animIndex,
            								randomizeAnimIndex: data.randomizeAnimIndex,
            								animSpeed: data.animSpeed,
            								animLoop: data.animLoop,
            								startAngle: data.startAngle,
            								startAngle2: data.startAngle2,
            								scaleGraph: data.scaleGraph,
            								scaleGraph2: data.scaleGraph2,
            								colorGraph: data.colorGraph,
            								colorGraph2: data.colorGraph2,
            								alphaGraph: data.alphaGraph,
            								alphaGraph2: data.alphaGraph2,
            								localVelocityGraph: data.localVelocityGraph,
            								localVelocityGraph2: data.localVelocityGraph2,
            								velocityGraph: data.velocityGraph,
            								velocityGraph2: data.velocityGraph2,
            								rotationSpeedGraph: data.rotationSpeedGraph,
            								rotationSpeedGraph2: data.rotationSpeedGraph2,
            								radialSpeedGraph: data.radialSpeedGraph,
            								radialSpeedGraph2: data.radialSpeedGraph2,
            								colorMap: data.colorMap,
            								normalMap: data.normalMap,
            								loop: data.loop,
            								preWarm: data.preWarm,
            								sort: data.sort,
            								stretch: data.stretch,
            								alignToMotion: data.alignToMotion,
            								lighting: data.lighting,
            								halfLambert: data.halfLambert,
            								intensity: data.intensity,
            								depthSoftening: data.depthSoftening,
            								scene: this.system.app.scene,
            								mesh: mesh,
            								depthWrite: data.depthWrite,
            								noFog: data.noFog,
            								node: this.entity,
            								blendType: data.blendType
            						});
            						this.emitter.meshInstance.node = this.entity;
            						this.emitter.drawOrder = this.drawOrder;
            						if (!data.autoPlay) {
            								this.pause();
            								this.emitter.meshInstance.visible = false;
            						}
            				}
            				if (this.emitter.colorMap) {
            						this.addMeshInstanceToLayers();
            				}
            				this._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);
            				if (layers) {
            						this._evtLayerAdded = layers.on('add', this.onLayerAdded, this);
            						this._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);
            				}
            				if (this.enabled && this.entity.enabled && data.depthSoftening) {
            						this._requestDepth();
            				}
            		}
            		onDisable() {
            				var _this__evtLayersChanged;
            				var scene = this.system.app.scene;
            				var layers = scene.layers;
            				(_this__evtLayersChanged = this._evtLayersChanged) == null ? void 0 : _this__evtLayersChanged.off();
            				this._evtLayersChanged = null;
            				if (layers) {
            						var _this__evtLayerAdded, _this__evtLayerRemoved;
            						(_this__evtLayerAdded = this._evtLayerAdded) == null ? void 0 : _this__evtLayerAdded.off();
            						this._evtLayerAdded = null;
            						(_this__evtLayerRemoved = this._evtLayerRemoved) == null ? void 0 : _this__evtLayerRemoved.off();
            						this._evtLayerRemoved = null;
            				}
            				if (this.emitter) {
            						this.removeMeshInstanceFromLayers();
            						if (this.data.depthSoftening) this._releaseDepth();
            						this.emitter.camera = null;
            				}
            		}
            		onBeforeRemove() {
            				if (this.enabled) {
            						this.enabled = false;
            				}
            				if (this.emitter) {
            						this.emitter.destroy();
            						this.emitter = null;
            				}
            				for(var i = 0; i < ASSET_PROPERTIES.length; i++){
            						var prop = ASSET_PROPERTIES[i];
            						if (this.data[prop]) {
            								this[prop] = null;
            						}
            				}
            				this.off();
            		}
            		reset() {
            				if (this.emitter) {
            						this.emitter.reset();
            				}
            		}
            		stop() {
            				if (this.emitter) {
            						this.emitter.loop = false;
            						this.emitter.resetTime();
            						this.emitter.addTime(0, true);
            				}
            		}
            		pause() {
            				this.data.paused = true;
            		}
            		unpause() {
            				this.data.paused = false;
            		}
            		play() {
            				this.data.paused = false;
            				if (this.emitter) {
            						this.emitter.meshInstance.visible = true;
            						this.emitter.loop = this.data.loop;
            						this.emitter.resetTime();
            				}
            		}
            		isPlaying() {
            				if (this.data.paused) {
            						return false;
            				}
            				if (this.emitter && this.emitter.loop) {
            						return true;
            				}
            				return Date.now() <= this.emitter.endTime;
            		}
            		setInTools() {
            				var { emitter } = this;
            				if (emitter && !emitter.inTools) {
            						emitter.inTools = true;
            						this.rebuild();
            				}
            		}
            		rebuild() {
            				var enabled = this.enabled;
            				this.enabled = false;
            				if (this.emitter) {
            						this.emitter.rebuild();
            				}
            				this.enabled = enabled;
            		}
            		constructor(system, entity){
            				super(system, entity), this._requestedDepth = false, this._drawOrder = 0, this._evtLayersChanged = null, this._evtLayerAdded = null, this._evtLayerRemoved = null, this._evtSetMeshes = null;
            				this.on('set_colorMapAsset', this.onSetColorMapAsset, this);
            				this.on('set_normalMapAsset', this.onSetNormalMapAsset, this);
            				this.on('set_meshAsset', this.onSetMeshAsset, this);
            				this.on('set_mesh', this.onSetMesh, this);
            				this.on('set_renderAsset', this.onSetRenderAsset, this);
            				this.on('set_loop', this.onSetLoop, this);
            				this.on('set_blendType', this.onSetBlendType, this);
            				this.on('set_depthSoftening', this.onSetDepthSoftening, this);
            				this.on('set_layers', this.onSetLayers, this);
            				SIMPLE_PROPERTIES.forEach((prop)=>{
            						this.on("set_" + prop, this.onSetSimpleProperty, this);
            				});
            				COMPLEX_PROPERTIES.forEach((prop)=>{
            						this.on("set_" + prop, this.onSetComplexProperty, this);
            				});
            				GRAPH_PROPERTIES.forEach((prop)=>{
            						this.on("set_" + prop, this.onSetGraphProperty, this);
            				});
            		}
            }
            
            class ParticleSystemComponentData {
            		constructor(){
            				this.numParticles = 1;
            				this.rate = 1;
            				this.rate2 = null;
            				this.startAngle = 0;
            				this.startAngle2 = null;
            				this.lifetime = 50;
            				this.emitterExtents = new Vec3();
            				this.emitterExtentsInner = new Vec3();
            				this.emitterRadius = 0;
            				this.emitterRadiusInner = 0;
            				this.emitterShape = EMITTERSHAPE_BOX;
            				this.initialVelocity = 0;
            				this.wrap = false;
            				this.wrapBounds = new Vec3();
            				this.localSpace = false;
            				this.screenSpace = false;
            				this.colorMap = null;
            				this.colorMapAsset = null;
            				this.normalMap = null;
            				this.normalMapAsset = null;
            				this.loop = true;
            				this.preWarm = false;
            				this.sort = 0;
            				this.mode = PARTICLEMODE_GPU;
            				this.scene = null;
            				this.lighting = false;
            				this.halfLambert = false;
            				this.intensity = 1;
            				this.stretch = 0.0;
            				this.alignToMotion = false;
            				this.depthSoftening = 0;
            				this.renderAsset = null;
            				this.meshAsset = null;
            				this.mesh = null;
            				this.depthWrite = false;
            				this.noFog = false;
            				this.orientation = PARTICLEORIENTATION_SCREEN;
            				this.particleNormal = new Vec3(0, 1, 0);
            				this.animTilesX = 1;
            				this.animTilesY = 1;
            				this.animStartFrame = 0;
            				this.animNumFrames = 1;
            				this.animNumAnimations = 1;
            				this.animIndex = 0;
            				this.randomizeAnimIndex = false;
            				this.animSpeed = 1;
            				this.animLoop = true;
            				this.scaleGraph = null;
            				this.scaleGraph2 = null;
            				this.colorGraph = null;
            				this.colorGraph2 = null;
            				this.alphaGraph = null;
            				this.alphaGraph2 = null;
            				this.localVelocityGraph = null;
            				this.localVelocityGraph2 = null;
            				this.velocityGraph = null;
            				this.velocityGraph2 = null;
            				this.rotationSpeedGraph = null;
            				this.rotationSpeedGraph2 = null;
            				this.radialSpeedGraph = null;
            				this.radialSpeedGraph2 = null;
            				this.blendType = BLEND_NORMAL;
            				this.enabled = true;
            				this.paused = false;
            				this.autoPlay = true;
            				this.layers = [
            						LAYERID_WORLD
            				];
            		}
            }
            
            var _schema$a = [
            		'enabled',
            		'autoPlay',
            		'numParticles',
            		'lifetime',
            		'rate',
            		'rate2',
            		'startAngle',
            		'startAngle2',
            		'loop',
            		'preWarm',
            		'lighting',
            		'halfLambert',
            		'intensity',
            		'depthWrite',
            		'noFog',
            		'depthSoftening',
            		'sort',
            		'blendType',
            		'stretch',
            		'alignToMotion',
            		'emitterShape',
            		'emitterExtents',
            		'emitterExtentsInner',
            		'emitterRadius',
            		'emitterRadiusInner',
            		'initialVelocity',
            		'wrap',
            		'wrapBounds',
            		'localSpace',
            		'screenSpace',
            		'colorMapAsset',
            		'normalMapAsset',
            		'mesh',
            		'meshAsset',
            		'renderAsset',
            		'orientation',
            		'particleNormal',
            		'localVelocityGraph',
            		'localVelocityGraph2',
            		'velocityGraph',
            		'velocityGraph2',
            		'rotationSpeedGraph',
            		'rotationSpeedGraph2',
            		'radialSpeedGraph',
            		'radialSpeedGraph2',
            		'scaleGraph',
            		'scaleGraph2',
            		'colorGraph',
            		'colorGraph2',
            		'alphaGraph',
            		'alphaGraph2',
            		'colorMap',
            		'normalMap',
            		'animTilesX',
            		'animTilesY',
            		'animStartFrame',
            		'animNumFrames',
            		'animNumAnimations',
            		'animIndex',
            		'randomizeAnimIndex',
            		'animSpeed',
            		'animLoop',
            		'layers'
            ];
            class ParticleSystemComponentSystem extends ComponentSystem {
            		initializeComponentData(component, _data, properties) {
            				var data = {};
            				properties = [];
            				var types = this.propertyTypes;
            				if (_data.mesh instanceof Asset || typeof _data.mesh === 'number') {
            						_data.meshAsset = _data.mesh;
            						delete _data.mesh;
            				}
            				for(var prop in _data){
            						if (_data.hasOwnProperty(prop)) {
            								properties.push(prop);
            								data[prop] = _data[prop];
            						}
            						if (types[prop] === 'vec3') {
            								if (Array.isArray(data[prop])) {
            										data[prop] = new Vec3(data[prop][0], data[prop][1], data[prop][2]);
            								}
            						} else if (types[prop] === 'curve') {
            								if (!(data[prop] instanceof Curve)) {
            										var t = data[prop].type;
            										data[prop] = new Curve(data[prop].keys);
            										data[prop].type = t;
            								}
            						} else if (types[prop] === 'curveset') {
            								if (!(data[prop] instanceof CurveSet)) {
            										var t1 = data[prop].type;
            										data[prop] = new CurveSet(data[prop].keys);
            										data[prop].type = t1;
            								}
            						}
            						if (data.layers && Array.isArray(data.layers)) {
            								data.layers = data.layers.slice(0);
            						}
            				}
            				super.initializeComponentData(component, data, properties);
            		}
            		cloneComponent(entity, clone) {
            				var source = entity.particlesystem.data;
            				var schema = this.schema;
            				var data = {};
            				for(var i = 0, len = schema.length; i < len; i++){
            						var prop = schema[i];
            						var sourceProp = source[prop];
            						if (sourceProp instanceof Vec3 || sourceProp instanceof Curve || sourceProp instanceof CurveSet) {
            								sourceProp = sourceProp.clone();
            								data[prop] = sourceProp;
            						} else if (prop === 'layers') {
            								data.layers = source.layers.slice(0);
            						} else {
            								if (sourceProp !== null && sourceProp !== undefined) {
            										data[prop] = sourceProp;
            								}
            						}
            				}
            				return this.addComponent(clone, data);
            		}
            		onUpdate(dt) {
            				var components = this.store;
            				var numSteps;
            				var stats = this.app.stats.particles;
            				var composition = this.app.scene.layers;
            				for(var i = 0; i < composition.layerList.length; i++){
            						composition.layerList[i].requiresLightCube = false;
            				}
            				for(var id in components){
            						if (components.hasOwnProperty(id)) {
            								var component = components[id];
            								var entity = component.entity;
            								var data = component.data;
            								if (data.enabled && entity.enabled) {
            										var emitter = entity.particlesystem.emitter;
            										if (!(emitter == null ? void 0 : emitter.meshInstance.visible)) continue;
            										if (emitter.lighting) {
            												var layers = data.layers;
            												for(var i1 = 0; i1 < layers.length; i1++){
            														var layer = composition.getLayerById(layers[i1]);
            														if (layer) {
            																layer.requiresLightCube = true;
            														}
            												}
            										}
            										if (!data.paused) {
            												emitter.simTime += dt;
            												if (emitter.simTime > emitter.fixedTimeStep) {
            														numSteps = Math.floor(emitter.simTime / emitter.fixedTimeStep);
            														emitter.simTime -= numSteps * emitter.fixedTimeStep;
            												}
            												if (numSteps) {
            														numSteps = Math.min(numSteps, emitter.maxSubSteps);
            														for(var i2 = 0; i2 < numSteps; i2++){
            																emitter.addTime(emitter.fixedTimeStep, false);
            														}
            														stats._updatesPerFrame += numSteps;
            														stats._frameTime += emitter._addTimeTime;
            														emitter._addTimeTime = 0;
            												}
            												emitter.finishFrame();
            										}
            								}
            						}
            				}
            		}
            		onBeforeRemove(entity, component) {
            				component.onBeforeRemove();
            		}
            		destroy() {
            				super.destroy();
            				this.app.systems.off('update', this.onUpdate, this);
            		}
            		constructor(app){
            				super(app);
            				this.id = 'particlesystem';
            				this.ComponentType = ParticleSystemComponent;
            				this.DataType = ParticleSystemComponentData;
            				this.schema = _schema$a;
            				this.propertyTypes = {
            						emitterExtents: 'vec3',
            						emitterExtentsInner: 'vec3',
            						particleNormal: 'vec3',
            						wrapBounds: 'vec3',
            						localVelocityGraph: 'curveset',
            						localVelocityGraph2: 'curveset',
            						velocityGraph: 'curveset',
            						velocityGraph2: 'curveset',
            						colorGraph: 'curveset',
            						colorGraph2: 'curveset',
            						alphaGraph: 'curve',
            						alphaGraph2: 'curve',
            						rotationSpeedGraph: 'curve',
            						rotationSpeedGraph2: 'curve',
            						radialSpeedGraph: 'curve',
            						radialSpeedGraph2: 'curve',
            						scaleGraph: 'curve',
            						scaleGraph2: 'curve'
            				};
            				this.on('beforeremove', this.onBeforeRemove, this);
            				this.app.systems.on('update', this.onUpdate, this);
            		}
            }
            
            class SkinInstanceCachedObject extends RefCountedObject {
            		constructor(skin, skinInstance){
            				super();
            				this.skin = skin;
            				this.skinInstance = skinInstance;
            		}
            }
            class SkinInstanceCache {
            		static createCachedSkinInstance(skin, rootBone, entity) {
            				var skinInst = SkinInstanceCache.getCachedSkinInstance(skin, rootBone);
            				if (!skinInst) {
            						skinInst = new SkinInstance(skin);
            						skinInst.resolve(rootBone, entity);
            						SkinInstanceCache.addCachedSkinInstance(skin, rootBone, skinInst);
            				}
            				return skinInst;
            		}
            		static getCachedSkinInstance(skin, rootBone) {
            				var skinInstance = null;
            				var cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);
            				if (cachedObjArray) {
            						var cachedObj = cachedObjArray.find((element)=>element.skin === skin);
            						if (cachedObj) {
            								cachedObj.incRefCount();
            								skinInstance = cachedObj.skinInstance;
            						}
            				}
            				return skinInstance;
            		}
            		static addCachedSkinInstance(skin, rootBone, skinInstance) {
            				var cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);
            				if (!cachedObjArray) {
            						cachedObjArray = [];
            						SkinInstanceCache._skinInstanceCache.set(rootBone, cachedObjArray);
            				}
            				var cachedObj = cachedObjArray.find((element)=>element.skin === skin);
            				if (!cachedObj) {
            						cachedObj = new SkinInstanceCachedObject(skin, skinInstance);
            						cachedObjArray.push(cachedObj);
            				}
            				cachedObj.incRefCount();
            		}
            		static removeCachedSkinInstance(skinInstance) {
            				if (skinInstance) {
            						var rootBone = skinInstance.rootBone;
            						if (rootBone) {
            								var cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);
            								if (cachedObjArray) {
            										var cachedObjIndex = cachedObjArray.findIndex((element)=>element.skinInstance === skinInstance);
            										if (cachedObjIndex >= 0) {
            												var cachedObj = cachedObjArray[cachedObjIndex];
            												cachedObj.decRefCount();
            												if (cachedObj.refCount === 0) {
            														cachedObjArray.splice(cachedObjIndex, 1);
            														if (!cachedObjArray.length) {
            																SkinInstanceCache._skinInstanceCache.delete(rootBone);
            														}
            														if (skinInstance) {
            																skinInstance.destroy();
            																cachedObj.skinInstance = null;
            														}
            												}
            										}
            								}
            						}
            				}
            		}
            }
            SkinInstanceCache._skinInstanceCache = new Map();
            
            class AssetReference {
            		set id(value) {
            				if (this.url) throw Error('Can\'t set id and url');
            				this._unbind();
            				this._id = value;
            				this.asset = this._registry.get(this._id);
            				this._bind();
            		}
            		get id() {
            				return this._id;
            		}
            		set url(value) {
            				if (this.id) throw Error('Can\'t set id and url');
            				this._unbind();
            				this._url = value;
            				this.asset = this._registry.getByUrl(this._url);
            				this._bind();
            		}
            		get url() {
            				return this._url;
            		}
            		_bind() {
            				if (this.id) {
            						if (this._onAssetLoad) this._evtLoadById = this._registry.on("load:" + this.id, this._onLoad, this);
            						if (this._onAssetAdd) this._evtAddById = this._registry.once("add:" + this.id, this._onAdd, this);
            						if (this._onAssetRemove) this._evtRemoveById = this._registry.on("remove:" + this.id, this._onRemove, this);
            						if (this._onAssetUnload) this._evtUnloadById = this._registry.on("unload:" + this.id, this._onUnload, this);
            				}
            				if (this.url) {
            						if (this._onAssetLoad) this._evtLoadByUrl = this._registry.on("load:url:" + this.url, this._onLoad, this);
            						if (this._onAssetAdd) this._evtAddByUrl = this._registry.once("add:url:" + this.url, this._onAdd, this);
            						if (this._onAssetRemove) this._evtRemoveByUrl = this._registry.on("remove:url:" + this.url, this._onRemove, this);
            				}
            		}
            		_unbind() {
            				if (this.id) {
            						var _this__evtLoadById, _this__evtAddById, _this__evtRemoveById, _this__evtUnloadById;
            						(_this__evtLoadById = this._evtLoadById) == null ? void 0 : _this__evtLoadById.off();
            						this._evtLoadById = null;
            						(_this__evtAddById = this._evtAddById) == null ? void 0 : _this__evtAddById.off();
            						this._evtAddById = null;
            						(_this__evtRemoveById = this._evtRemoveById) == null ? void 0 : _this__evtRemoveById.off();
            						this._evtRemoveById = null;
            						(_this__evtUnloadById = this._evtUnloadById) == null ? void 0 : _this__evtUnloadById.off();
            						this._evtUnloadById = null;
            				}
            				if (this.url) {
            						var _this__evtLoadByUrl, _this__evtAddByUrl, _this__evtRemoveByUrl;
            						(_this__evtLoadByUrl = this._evtLoadByUrl) == null ? void 0 : _this__evtLoadByUrl.off();
            						this._evtLoadByUrl = null;
            						(_this__evtAddByUrl = this._evtAddByUrl) == null ? void 0 : _this__evtAddByUrl.off();
            						this._evtAddByUrl = null;
            						(_this__evtRemoveByUrl = this._evtRemoveByUrl) == null ? void 0 : _this__evtRemoveByUrl.off();
            						this._evtRemoveByUrl = null;
            				}
            		}
            		_onLoad(asset) {
            				this._onAssetLoad.call(this._scope, this.propertyName, this.parent, asset);
            		}
            		_onAdd(asset) {
            				this.asset = asset;
            				this._onAssetAdd.call(this._scope, this.propertyName, this.parent, asset);
            		}
            		_onRemove(asset) {
            				this._onAssetRemove.call(this._scope, this.propertyName, this.parent, asset);
            				this.asset = null;
            		}
            		_onUnload(asset) {
            				this._onAssetUnload.call(this._scope, this.propertyName, this.parent, asset);
            		}
            		constructor(propertyName, parent, registry, callbacks, scope){
            				this._evtLoadById = null;
            				this._evtUnloadById = null;
            				this._evtAddById = null;
            				this._evtRemoveById = null;
            				this._evtLoadByUrl = null;
            				this._evtAddByUrl = null;
            				this._evtRemoveByUrl = null;
            				this.propertyName = propertyName;
            				this.parent = parent;
            				this._scope = scope;
            				this._registry = registry;
            				this.id = null;
            				this.url = null;
            				this.asset = null;
            				this._onAssetLoad = callbacks.load;
            				this._onAssetAdd = callbacks.add;
            				this._onAssetRemove = callbacks.remove;
            				this._onAssetUnload = callbacks.unload;
            		}
            }
            
            class RenderComponent extends Component {
            		set renderStyle(renderStyle) {
            				if (this._renderStyle !== renderStyle) {
            						this._renderStyle = renderStyle;
            						MeshInstance._prepareRenderStyleForArray(this._meshInstances, renderStyle);
            				}
            		}
            		get renderStyle() {
            				return this._renderStyle;
            		}
            		set customAabb(value) {
            				this._customAabb = value;
            				var mi = this._meshInstances;
            				if (mi) {
            						for(var i = 0; i < mi.length; i++){
            								mi[i].setCustomAabb(this._customAabb);
            						}
            				}
            		}
            		get customAabb() {
            				return this._customAabb;
            		}
            		set type(value) {
            				if (this._type !== value) {
            						this._area = null;
            						this._type = value;
            						this.destroyMeshInstances();
            						if (value !== 'asset') {
            								var material = this._material;
            								if (!material || material === this.system.defaultMaterial) {
            										material = this._materialReferences[0] && this._materialReferences[0].asset && this._materialReferences[0].asset.resource;
            								}
            								var primData = getShapePrimitive(this.system.app.graphicsDevice, value);
            								this._area = primData.area;
            								this.meshInstances = [
            										new MeshInstance(primData.mesh, material || this.system.defaultMaterial, this.entity)
            								];
            						}
            				}
            		}
            		get type() {
            				return this._type;
            		}
            		set meshInstances(value) {
            				this.destroyMeshInstances();
            				this._meshInstances = value;
            				if (this._meshInstances) {
            						var mi = this._meshInstances;
            						for(var i = 0; i < mi.length; i++){
            								if (!mi[i].node) {
            										mi[i].node = this.entity;
            								}
            								mi[i].castShadow = this._castShadows;
            								mi[i].receiveShadow = this._receiveShadows;
            								mi[i].renderStyle = this._renderStyle;
            								mi[i].setLightmapped(this._lightmapped);
            								mi[i].setCustomAabb(this._customAabb);
            						}
            						if (this.enabled && this.entity.enabled) {
            								this.addToLayers();
            						}
            				}
            		}
            		get meshInstances() {
            				return this._meshInstances;
            		}
            		set lightmapped(value) {
            				if (value !== this._lightmapped) {
            						this._lightmapped = value;
            						var mi = this._meshInstances;
            						if (mi) {
            								for(var i = 0; i < mi.length; i++){
            										mi[i].setLightmapped(value);
            								}
            						}
            				}
            		}
            		get lightmapped() {
            				return this._lightmapped;
            		}
            		set castShadows(value) {
            				if (this._castShadows !== value) {
            						var mi = this._meshInstances;
            						if (mi) {
            								var layers = this.layers;
            								var scene = this.system.app.scene;
            								if (this._castShadows && !value) {
            										for(var i = 0; i < layers.length; i++){
            												var layer = scene.layers.getLayerById(this.layers[i]);
            												if (layer) {
            														layer.removeShadowCasters(mi);
            												}
            										}
            								}
            								for(var i1 = 0; i1 < mi.length; i1++){
            										mi[i1].castShadow = value;
            								}
            								if (!this._castShadows && value) {
            										for(var i2 = 0; i2 < layers.length; i2++){
            												var layer1 = scene.layers.getLayerById(layers[i2]);
            												if (layer1) {
            														layer1.addShadowCasters(mi);
            												}
            										}
            								}
            						}
            						this._castShadows = value;
            				}
            		}
            		get castShadows() {
            				return this._castShadows;
            		}
            		set receiveShadows(value) {
            				if (this._receiveShadows !== value) {
            						this._receiveShadows = value;
            						var mi = this._meshInstances;
            						if (mi) {
            								for(var i = 0; i < mi.length; i++){
            										mi[i].receiveShadow = value;
            								}
            						}
            				}
            		}
            		get receiveShadows() {
            				return this._receiveShadows;
            		}
            		set castShadowsLightmap(value) {
            				this._castShadowsLightmap = value;
            		}
            		get castShadowsLightmap() {
            				return this._castShadowsLightmap;
            		}
            		set lightmapSizeMultiplier(value) {
            				this._lightmapSizeMultiplier = value;
            		}
            		get lightmapSizeMultiplier() {
            				return this._lightmapSizeMultiplier;
            		}
            		set layers(value) {
            				var layers = this.system.app.scene.layers;
            				var layer;
            				if (this._meshInstances) {
            						for(var i = 0; i < this._layers.length; i++){
            								layer = layers.getLayerById(this._layers[i]);
            								if (layer) {
            										layer.removeMeshInstances(this._meshInstances);
            								}
            						}
            				}
            				this._layers.length = 0;
            				for(var i1 = 0; i1 < value.length; i1++){
            						this._layers[i1] = value[i1];
            				}
            				if (!this.enabled || !this.entity.enabled || !this._meshInstances) return;
            				for(var i2 = 0; i2 < this._layers.length; i2++){
            						layer = layers.getLayerById(this._layers[i2]);
            						if (layer) {
            								layer.addMeshInstances(this._meshInstances);
            						}
            				}
            		}
            		get layers() {
            				return this._layers;
            		}
            		set batchGroupId(value) {
            				if (this._batchGroupId !== value) {
            						if (this.entity.enabled && this._batchGroupId >= 0) {
            								var _this_system_app_batcher;
            								(_this_system_app_batcher = this.system.app.batcher) == null ? void 0 : _this_system_app_batcher.remove(BatchGroup.RENDER, this.batchGroupId, this.entity);
            						}
            						if (this.entity.enabled && value >= 0) {
            								var _this_system_app_batcher1;
            								(_this_system_app_batcher1 = this.system.app.batcher) == null ? void 0 : _this_system_app_batcher1.insert(BatchGroup.RENDER, value, this.entity);
            						}
            						if (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {
            								this.addToLayers();
            						}
            						this._batchGroupId = value;
            				}
            		}
            		get batchGroupId() {
            				return this._batchGroupId;
            		}
            		set material(value) {
            				if (this._material !== value) {
            						this._material = value;
            						if (this._meshInstances && this._type !== 'asset') {
            								for(var i = 0; i < this._meshInstances.length; i++){
            										this._meshInstances[i].material = value;
            								}
            						}
            				}
            		}
            		get material() {
            				return this._material;
            		}
            		set materialAssets(value) {
            				if (value === void 0) value = [];
            				if (this._materialReferences.length > value.length) {
            						for(var i = value.length; i < this._materialReferences.length; i++){
            								this._materialReferences[i].id = null;
            						}
            						this._materialReferences.length = value.length;
            				}
            				for(var i1 = 0; i1 < value.length; i1++){
            						if (!this._materialReferences[i1]) {
            								this._materialReferences.push(new AssetReference(i1, this, this.system.app.assets, {
            										add: this._onMaterialAdded,
            										load: this._onMaterialLoad,
            										remove: this._onMaterialRemove,
            										unload: this._onMaterialUnload
            								}, this));
            						}
            						if (value[i1]) {
            								var id = value[i1] instanceof Asset ? value[i1].id : value[i1];
            								if (this._materialReferences[i1].id !== id) {
            										this._materialReferences[i1].id = id;
            								}
            								if (this._materialReferences[i1].asset) {
            										this._onMaterialAdded(i1, this, this._materialReferences[i1].asset);
            								}
            						} else {
            								this._materialReferences[i1].id = null;
            								if (this._meshInstances[i1]) {
            										this._meshInstances[i1].material = this.system.defaultMaterial;
            								}
            						}
            				}
            		}
            		get materialAssets() {
            				return this._materialReferences.map((ref)=>{
            						return ref.id;
            				});
            		}
            		set asset(value) {
            				var id = value instanceof Asset ? value.id : value;
            				if (this._assetReference.id === id) return;
            				if (this._assetReference.asset && this._assetReference.asset.resource) {
            						this._onRenderAssetRemove();
            				}
            				this._assetReference.id = id;
            				if (this._assetReference.asset) {
            						this._onRenderAssetAdded();
            				}
            		}
            		get asset() {
            				return this._assetReference.id;
            		}
            		assignAsset(asset) {
            				var id = asset instanceof Asset ? asset.id : asset;
            				this._assetReference.id = id;
            		}
            		set rootBone(value) {
            				if (this._rootBone !== value) {
            						var isString = typeof value === 'string';
            						if (this._rootBone && isString && this._rootBone.getGuid() === value) {
            								return;
            						}
            						if (this._rootBone) {
            								this._clearSkinInstances();
            						}
            						if (value instanceof GraphNode) {
            								this._rootBone = value;
            						} else if (isString) {
            								this._rootBone = this.system.app.getEntityFromIndex(value) || null;
            								if (!this._rootBone) ;
            						} else {
            								this._rootBone = null;
            						}
            						if (this._rootBone) {
            								this._cloneSkinInstances();
            						}
            				}
            		}
            		get rootBone() {
            				return this._rootBone;
            		}
            		destroyMeshInstances() {
            				var meshInstances = this._meshInstances;
            				if (meshInstances) {
            						this.removeFromLayers();
            						this._clearSkinInstances();
            						for(var i = 0; i < meshInstances.length; i++){
            								meshInstances[i].destroy();
            						}
            						this._meshInstances.length = 0;
            				}
            		}
            		addToLayers() {
            				var layers = this.system.app.scene.layers;
            				for(var i = 0; i < this._layers.length; i++){
            						var layer = layers.getLayerById(this._layers[i]);
            						if (layer) {
            								layer.addMeshInstances(this._meshInstances);
            						}
            				}
            		}
            		removeFromLayers() {
            				if (this._meshInstances && this._meshInstances.length) {
            						var layers = this.system.app.scene.layers;
            						for(var i = 0; i < this._layers.length; i++){
            								var layer = layers.getLayerById(this._layers[i]);
            								if (layer) {
            										layer.removeMeshInstances(this._meshInstances);
            								}
            						}
            				}
            		}
            		onRemoveChild() {
            				this.removeFromLayers();
            		}
            		onInsertChild() {
            				if (this._meshInstances && this.enabled && this.entity.enabled) {
            						this.addToLayers();
            				}
            		}
            		onRemove() {
            				this.destroyMeshInstances();
            				this.asset = null;
            				this.materialAsset = null;
            				this._assetReference.id = null;
            				for(var i = 0; i < this._materialReferences.length; i++){
            						this._materialReferences[i].id = null;
            				}
            				this.entity.off('remove', this.onRemoveChild, this);
            				this.entity.off('insert', this.onInsertChild, this);
            		}
            		onLayersChanged(oldComp, newComp) {
            				this.addToLayers();
            				oldComp.off('add', this.onLayerAdded, this);
            				oldComp.off('remove', this.onLayerRemoved, this);
            				newComp.on('add', this.onLayerAdded, this);
            				newComp.on('remove', this.onLayerRemoved, this);
            		}
            		onLayerAdded(layer) {
            				var index = this.layers.indexOf(layer.id);
            				if (index < 0) return;
            				layer.addMeshInstances(this._meshInstances);
            		}
            		onLayerRemoved(layer) {
            				var index = this.layers.indexOf(layer.id);
            				if (index < 0) return;
            				layer.removeMeshInstances(this._meshInstances);
            		}
            		onEnable() {
            				var app = this.system.app;
            				var scene = app.scene;
            				var layers = scene.layers;
            				if (this._rootBone) {
            						this._cloneSkinInstances();
            				}
            				this._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);
            				if (layers) {
            						this._evtLayerAdded = layers.on('add', this.onLayerAdded, this);
            						this._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);
            				}
            				var isAsset = this._type === 'asset';
            				if (this._meshInstances && this._meshInstances.length) {
            						this.addToLayers();
            				} else if (isAsset && this.asset) {
            						this._onRenderAssetAdded();
            				}
            				for(var i = 0; i < this._materialReferences.length; i++){
            						if (this._materialReferences[i].asset) {
            								this.system.app.assets.load(this._materialReferences[i].asset);
            						}
            				}
            				if (this._batchGroupId >= 0) {
            						var _app_batcher;
            						(_app_batcher = app.batcher) == null ? void 0 : _app_batcher.insert(BatchGroup.RENDER, this.batchGroupId, this.entity);
            				}
            		}
            		onDisable() {
            				var _this__evtLayersChanged;
            				var app = this.system.app;
            				var scene = app.scene;
            				var layers = scene.layers;
            				(_this__evtLayersChanged = this._evtLayersChanged) == null ? void 0 : _this__evtLayersChanged.off();
            				this._evtLayersChanged = null;
            				if (this._rootBone) {
            						this._clearSkinInstances();
            				}
            				if (layers) {
            						var _this__evtLayerAdded, _this__evtLayerRemoved;
            						(_this__evtLayerAdded = this._evtLayerAdded) == null ? void 0 : _this__evtLayerAdded.off();
            						this._evtLayerAdded = null;
            						(_this__evtLayerRemoved = this._evtLayerRemoved) == null ? void 0 : _this__evtLayerRemoved.off();
            						this._evtLayerRemoved = null;
            				}
            				if (this._batchGroupId >= 0) {
            						var _app_batcher;
            						(_app_batcher = app.batcher) == null ? void 0 : _app_batcher.remove(BatchGroup.RENDER, this.batchGroupId, this.entity);
            				}
            				this.removeFromLayers();
            		}
            		hide() {
            				if (this._meshInstances) {
            						for(var i = 0; i < this._meshInstances.length; i++){
            								this._meshInstances[i].visible = false;
            						}
            				}
            		}
            		show() {
            				if (this._meshInstances) {
            						for(var i = 0; i < this._meshInstances.length; i++){
            								this._meshInstances[i].visible = true;
            						}
            				}
            		}
            		_onRenderAssetAdded() {
            				if (!this._assetReference.asset) return;
            				if (this._assetReference.asset.resource) {
            						this._onRenderAssetLoad();
            				} else if (this.enabled && this.entity.enabled) {
            						this.system.app.assets.load(this._assetReference.asset);
            				}
            		}
            		_onRenderAssetLoad() {
            				this.destroyMeshInstances();
            				if (this._assetReference.asset) {
            						var _this__evtSetMeshes;
            						var render = this._assetReference.asset.resource;
            						(_this__evtSetMeshes = this._evtSetMeshes) == null ? void 0 : _this__evtSetMeshes.off();
            						this._evtSetMeshes = render.on('set:meshes', this._onSetMeshes, this);
            						if (render.meshes) {
            								this._onSetMeshes(render.meshes);
            						}
            				}
            		}
            		_onSetMeshes(meshes) {
            				this._cloneMeshes(meshes);
            		}
            		_clearSkinInstances() {
            				for(var i = 0; i < this._meshInstances.length; i++){
            						var meshInstance = this._meshInstances[i];
            						SkinInstanceCache.removeCachedSkinInstance(meshInstance.skinInstance);
            						meshInstance.skinInstance = null;
            				}
            		}
            		_cloneSkinInstances() {
            				if (this._meshInstances.length && this._rootBone instanceof GraphNode) {
            						for(var i = 0; i < this._meshInstances.length; i++){
            								var meshInstance = this._meshInstances[i];
            								var mesh = meshInstance.mesh;
            								if (mesh.skin && !meshInstance.skinInstance) {
            										meshInstance.skinInstance = SkinInstanceCache.createCachedSkinInstance(mesh.skin, this._rootBone, this.entity);
            								}
            						}
            				}
            		}
            		_cloneMeshes(meshes) {
            				if (meshes && meshes.length) {
            						var meshInstances = [];
            						for(var i = 0; i < meshes.length; i++){
            								var mesh = meshes[i];
            								var material = this._materialReferences[i] && this._materialReferences[i].asset && this._materialReferences[i].asset.resource;
            								var meshInst = new MeshInstance(mesh, material || this.system.defaultMaterial, this.entity);
            								meshInstances.push(meshInst);
            								if (mesh.morph) {
            										meshInst.morphInstance = new MorphInstance(mesh.morph);
            								}
            						}
            						this.meshInstances = meshInstances;
            						this._cloneSkinInstances();
            				}
            		}
            		_onRenderAssetUnload() {
            				if (this._type === 'asset') {
            						this.destroyMeshInstances();
            				}
            		}
            		_onRenderAssetRemove() {
            				var _this__evtSetMeshes;
            				(_this__evtSetMeshes = this._evtSetMeshes) == null ? void 0 : _this__evtSetMeshes.off();
            				this._evtSetMeshes = null;
            				this._onRenderAssetUnload();
            		}
            		_onMaterialAdded(index, component, asset) {
            				if (asset.resource) {
            						this._onMaterialLoad(index, component, asset);
            				} else {
            						if (this.enabled && this.entity.enabled) {
            								this.system.app.assets.load(asset);
            						}
            				}
            		}
            		_updateMainMaterial(index, material) {
            				if (index === 0) {
            						this.material = material;
            				}
            		}
            		_onMaterialLoad(index, component, asset) {
            				if (this._meshInstances[index]) {
            						this._meshInstances[index].material = asset.resource;
            				}
            				this._updateMainMaterial(index, asset.resource);
            		}
            		_onMaterialRemove(index, component, asset) {
            				if (this._meshInstances[index]) {
            						this._meshInstances[index].material = this.system.defaultMaterial;
            				}
            				this._updateMainMaterial(index, this.system.defaultMaterial);
            		}
            		_onMaterialUnload(index, component, asset) {
            				if (this._meshInstances[index]) {
            						this._meshInstances[index].material = this.system.defaultMaterial;
            				}
            				this._updateMainMaterial(index, this.system.defaultMaterial);
            		}
            		resolveDuplicatedEntityReferenceProperties(oldRender, duplicatedIdsMap) {
            				if (oldRender.rootBone) {
            						this.rootBone = duplicatedIdsMap[oldRender.rootBone.getGuid()];
            				}
            		}
            		constructor(system, entity){
            				super(system, entity), this._type = 'asset', this._castShadows = true, this._receiveShadows = true, this._castShadowsLightmap = true, this._lightmapped = false, this._lightmapSizeMultiplier = 1, this.isStatic = false, this._batchGroupId = -1, this._layers = [
            						LAYERID_WORLD
            				], this._renderStyle = RENDERSTYLE_SOLID, this._meshInstances = [], this._customAabb = null, this._area = null, this._materialReferences = [], this._rootBone = null, this._evtLayersChanged = null, this._evtLayerAdded = null, this._evtLayerRemoved = null, this._evtSetMeshes = null;
            				this._assetReference = new AssetReference('asset', this, system.app.assets, {
            						add: this._onRenderAssetAdded,
            						load: this._onRenderAssetLoad,
            						remove: this._onRenderAssetRemove,
            						unload: this._onRenderAssetUnload
            				}, this);
            				this._material = system.defaultMaterial;
            				entity.on('remove', this.onRemoveChild, this);
            				entity.on('removehierarchy', this.onRemoveChild, this);
            				entity.on('insert', this.onInsertChild, this);
            				entity.on('inserthierarchy', this.onInsertChild, this);
            		}
            }
            
            class RenderComponentData {
            		constructor(){
            				this.enabled = true;
            		}
            }
            
            var _schema$9 = [
            		'enabled'
            ];
            var _properties$1 = [
            		'material',
            		'meshInstances',
            		'asset',
            		'materialAssets',
            		'castShadows',
            		'receiveShadows',
            		'castShadowsLightmap',
            		'lightmapped',
            		'lightmapSizeMultiplier',
            		'renderStyle',
            		'type',
            		'layers',
            		'isStatic',
            		'batchGroupId',
            		'rootBone'
            ];
            class RenderComponentSystem extends ComponentSystem {
            		initializeComponentData(component, _data, properties) {
            				if (_data.batchGroupId === null || _data.batchGroupId === undefined) {
            						_data.batchGroupId = -1;
            				}
            				if (_data.layers && _data.layers.length) {
            						_data.layers = _data.layers.slice(0);
            				}
            				for(var i = 0; i < _properties$1.length; i++){
            						if (_data.hasOwnProperty(_properties$1[i])) {
            								component[_properties$1[i]] = _data[_properties$1[i]];
            						}
            				}
            				if (_data.aabbCenter && _data.aabbHalfExtents) {
            						component.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));
            				}
            				super.initializeComponentData(component, _data, _schema$9);
            		}
            		cloneComponent(entity, clone) {
            				var data = {};
            				for(var i = 0; i < _properties$1.length; i++){
            						data[_properties$1[i]] = entity.render[_properties$1[i]];
            				}
            				data.enabled = entity.render.enabled;
            				delete data.meshInstances;
            				var component = this.addComponent(clone, data);
            				var srcMeshInstances = entity.render.meshInstances;
            				var meshes = srcMeshInstances.map((mi)=>mi.mesh);
            				component._onSetMeshes(meshes);
            				for(var m = 0; m < srcMeshInstances.length; m++){
            						component.meshInstances[m].material = srcMeshInstances[m].material;
            				}
            				if (entity.render.customAabb) {
            						component.customAabb = entity.render.customAabb.clone();
            				}
            				return component;
            		}
            		onRemove(entity, component) {
            				component.onRemove();
            		}
            		constructor(app){
            				super(app);
            				this.id = 'render';
            				this.ComponentType = RenderComponent;
            				this.DataType = RenderComponentData;
            				this.schema = _schema$9;
            				this.defaultMaterial = getDefaultMaterial(app.graphicsDevice);
            				this.on('beforeremove', this.onRemove, this);
            		}
            }
            Component._buildAccessors(RenderComponent.prototype, _schema$9);
            
            class ObjectPool {
            		_resize(size) {
            				if (size > this._pool.length) {
            						for(var i = this._pool.length; i < size; i++){
            								this._pool[i] = new this._constructor();
            						}
            				}
            		}
            		allocate() {
            				if (this._count >= this._pool.length) {
            						this._resize(this._pool.length * 2);
            				}
            				return this._pool[this._count++];
            		}
            		freeAll() {
            				this._count = 0;
            		}
            		constructor(constructorFunc, size){
            				this._pool = [];
            				this._count = 0;
            				this._constructor = constructorFunc;
            				this._resize(size);
            		}
            }
            
            var _ammoTransform;
            var _ammoVec1, _ammoVec2, _ammoQuat;
            var _quat1 = new Quat();
            var _quat2 = new Quat();
            var _vec3 = new Vec3();
            class RigidBodyComponent extends Component {
            		static onLibraryLoaded() {
            				if (typeof Ammo !== 'undefined') {
            						_ammoTransform = new Ammo.btTransform();
            						_ammoVec1 = new Ammo.btVector3();
            						_ammoVec2 = new Ammo.btVector3();
            						_ammoQuat = new Ammo.btQuaternion();
            				}
            		}
            		static onAppDestroy() {
            				Ammo.destroy(_ammoTransform);
            				Ammo.destroy(_ammoVec1);
            				Ammo.destroy(_ammoVec2);
            				Ammo.destroy(_ammoQuat);
            				_ammoTransform = null;
            				_ammoVec1 = null;
            				_ammoVec2 = null;
            				_ammoQuat = null;
            		}
            		set angularDamping(damping) {
            				if (this._angularDamping !== damping) {
            						this._angularDamping = damping;
            						if (this._body) {
            								this._body.setDamping(this._linearDamping, damping);
            						}
            				}
            		}
            		get angularDamping() {
            				return this._angularDamping;
            		}
            		set angularFactor(factor) {
            				if (!this._angularFactor.equals(factor)) {
            						this._angularFactor.copy(factor);
            						if (this._body && this._type === BODYTYPE_DYNAMIC) {
            								_ammoVec1.setValue(factor.x, factor.y, factor.z);
            								this._body.setAngularFactor(_ammoVec1);
            						}
            				}
            		}
            		get angularFactor() {
            				return this._angularFactor;
            		}
            		set angularVelocity(velocity) {
            				if (this._body && this._type === BODYTYPE_DYNAMIC) {
            						this._body.activate();
            						_ammoVec1.setValue(velocity.x, velocity.y, velocity.z);
            						this._body.setAngularVelocity(_ammoVec1);
            						this._angularVelocity.copy(velocity);
            				}
            		}
            		get angularVelocity() {
            				if (this._body && this._type === BODYTYPE_DYNAMIC) {
            						var velocity = this._body.getAngularVelocity();
            						this._angularVelocity.set(velocity.x(), velocity.y(), velocity.z());
            				}
            				return this._angularVelocity;
            		}
            		set body(body) {
            				if (this._body !== body) {
            						this._body = body;
            						if (body && this._simulationEnabled) {
            								body.activate();
            						}
            				}
            		}
            		get body() {
            				return this._body;
            		}
            		set friction(friction) {
            				if (this._friction !== friction) {
            						this._friction = friction;
            						if (this._body) {
            								this._body.setFriction(friction);
            						}
            				}
            		}
            		get friction() {
            				return this._friction;
            		}
            		set group(group) {
            				if (this._group !== group) {
            						this._group = group;
            						if (this.enabled && this.entity.enabled) {
            								this.disableSimulation();
            								this.enableSimulation();
            						}
            				}
            		}
            		get group() {
            				return this._group;
            		}
            		set linearDamping(damping) {
            				if (this._linearDamping !== damping) {
            						this._linearDamping = damping;
            						if (this._body) {
            								this._body.setDamping(damping, this._angularDamping);
            						}
            				}
            		}
            		get linearDamping() {
            				return this._linearDamping;
            		}
            		set linearFactor(factor) {
            				if (!this._linearFactor.equals(factor)) {
            						this._linearFactor.copy(factor);
            						if (this._body && this._type === BODYTYPE_DYNAMIC) {
            								_ammoVec1.setValue(factor.x, factor.y, factor.z);
            								this._body.setLinearFactor(_ammoVec1);
            						}
            				}
            		}
            		get linearFactor() {
            				return this._linearFactor;
            		}
            		set linearVelocity(velocity) {
            				if (this._body && this._type === BODYTYPE_DYNAMIC) {
            						this._body.activate();
            						_ammoVec1.setValue(velocity.x, velocity.y, velocity.z);
            						this._body.setLinearVelocity(_ammoVec1);
            						this._linearVelocity.copy(velocity);
            				}
            		}
            		get linearVelocity() {
            				if (this._body && this._type === BODYTYPE_DYNAMIC) {
            						var velocity = this._body.getLinearVelocity();
            						this._linearVelocity.set(velocity.x(), velocity.y(), velocity.z());
            				}
            				return this._linearVelocity;
            		}
            		set mask(mask) {
            				if (this._mask !== mask) {
            						this._mask = mask;
            						if (this.enabled && this.entity.enabled) {
            								this.disableSimulation();
            								this.enableSimulation();
            						}
            				}
            		}
            		get mask() {
            				return this._mask;
            		}
            		set mass(mass) {
            				if (this._mass !== mass) {
            						this._mass = mass;
            						if (this._body && this._type === BODYTYPE_DYNAMIC) {
            								var enabled = this.enabled && this.entity.enabled;
            								if (enabled) {
            										this.disableSimulation();
            								}
            								this._body.getCollisionShape().calculateLocalInertia(mass, _ammoVec1);
            								this._body.setMassProps(mass, _ammoVec1);
            								this._body.updateInertiaTensor();
            								if (enabled) {
            										this.enableSimulation();
            								}
            						}
            				}
            		}
            		get mass() {
            				return this._mass;
            		}
            		set restitution(restitution) {
            				if (this._restitution !== restitution) {
            						this._restitution = restitution;
            						if (this._body) {
            								this._body.setRestitution(restitution);
            						}
            				}
            		}
            		get restitution() {
            				return this._restitution;
            		}
            		set rollingFriction(friction) {
            				if (this._rollingFriction !== friction) {
            						this._rollingFriction = friction;
            						if (this._body) {
            								this._body.setRollingFriction(friction);
            						}
            				}
            		}
            		get rollingFriction() {
            				return this._rollingFriction;
            		}
            		set type(type) {
            				if (this._type !== type) {
            						this._type = type;
            						this.disableSimulation();
            						switch(type){
            								case BODYTYPE_DYNAMIC:
            										this._group = BODYGROUP_DYNAMIC;
            										this._mask = BODYMASK_ALL;
            										break;
            								case BODYTYPE_KINEMATIC:
            										this._group = BODYGROUP_KINEMATIC;
            										this._mask = BODYMASK_ALL;
            										break;
            								case BODYTYPE_STATIC:
            								default:
            										this._group = BODYGROUP_STATIC;
            										this._mask = BODYMASK_NOT_STATIC;
            										break;
            						}
            						this.createBody();
            				}
            		}
            		get type() {
            				return this._type;
            		}
            		createBody() {
            				var entity = this.entity;
            				var shape;
            				if (entity.collision) {
            						shape = entity.collision.shape;
            						if (entity.trigger) {
            								entity.trigger.destroy();
            								delete entity.trigger;
            						}
            				}
            				if (shape) {
            						if (this._body) {
            								this.system.removeBody(this._body);
            								this.system.destroyBody(this._body);
            								this._body = null;
            						}
            						var mass = this._type === BODYTYPE_DYNAMIC ? this._mass : 0;
            						this._getEntityTransform(_ammoTransform);
            						var body = this.system.createBody(mass, shape, _ammoTransform);
            						body.setRestitution(this._restitution);
            						body.setFriction(this._friction);
            						body.setRollingFriction(this._rollingFriction);
            						body.setDamping(this._linearDamping, this._angularDamping);
            						if (this._type === BODYTYPE_DYNAMIC) {
            								var linearFactor = this._linearFactor;
            								_ammoVec1.setValue(linearFactor.x, linearFactor.y, linearFactor.z);
            								body.setLinearFactor(_ammoVec1);
            								var angularFactor = this._angularFactor;
            								_ammoVec1.setValue(angularFactor.x, angularFactor.y, angularFactor.z);
            								body.setAngularFactor(_ammoVec1);
            						} else if (this._type === BODYTYPE_KINEMATIC) {
            								body.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_KINEMATIC_OBJECT);
            								body.setActivationState(BODYSTATE_DISABLE_DEACTIVATION);
            						}
            						body.entity = entity;
            						this.body = body;
            						if (this.enabled && entity.enabled) {
            								this.enableSimulation();
            						}
            				}
            		}
            		isActive() {
            				return this._body ? this._body.isActive() : false;
            		}
            		activate() {
            				if (this._body) {
            						this._body.activate();
            				}
            		}
            		enableSimulation() {
            				var entity = this.entity;
            				if (entity.collision && entity.collision.enabled && !this._simulationEnabled) {
            						var body = this._body;
            						if (body) {
            								this.system.addBody(body, this._group, this._mask);
            								switch(this._type){
            										case BODYTYPE_DYNAMIC:
            												this.system._dynamic.push(this);
            												body.forceActivationState(BODYSTATE_ACTIVE_TAG);
            												this.syncEntityToBody();
            												break;
            										case BODYTYPE_KINEMATIC:
            												this.system._kinematic.push(this);
            												body.forceActivationState(BODYSTATE_DISABLE_DEACTIVATION);
            												break;
            										case BODYTYPE_STATIC:
            												body.forceActivationState(BODYSTATE_ACTIVE_TAG);
            												this.syncEntityToBody();
            												break;
            								}
            								if (entity.collision.type === 'compound') {
            										this.system._compounds.push(entity.collision);
            								}
            								body.activate();
            								this._simulationEnabled = true;
            						}
            				}
            		}
            		disableSimulation() {
            				var body = this._body;
            				if (body && this._simulationEnabled) {
            						var system = this.system;
            						var idx = system._compounds.indexOf(this.entity.collision);
            						if (idx > -1) {
            								system._compounds.splice(idx, 1);
            						}
            						idx = system._dynamic.indexOf(this);
            						if (idx > -1) {
            								system._dynamic.splice(idx, 1);
            						}
            						idx = system._kinematic.indexOf(this);
            						if (idx > -1) {
            								system._kinematic.splice(idx, 1);
            						}
            						system.removeBody(body);
            						body.forceActivationState(BODYSTATE_DISABLE_SIMULATION);
            						this._simulationEnabled = false;
            				}
            		}
            		applyForce(x, y, z, px, py, pz) {
            				var body = this._body;
            				if (body) {
            						body.activate();
            						if (x instanceof Vec3) {
            								_ammoVec1.setValue(x.x, x.y, x.z);
            						} else {
            								_ammoVec1.setValue(x, y, z);
            						}
            						if (y instanceof Vec3) {
            								_ammoVec2.setValue(y.x, y.y, y.z);
            						} else if (px !== undefined) {
            								_ammoVec2.setValue(px, py, pz);
            						} else {
            								_ammoVec2.setValue(0, 0, 0);
            						}
            						body.applyForce(_ammoVec1, _ammoVec2);
            				}
            		}
            		applyTorque(x, y, z) {
            				var body = this._body;
            				if (body) {
            						body.activate();
            						if (x instanceof Vec3) {
            								_ammoVec1.setValue(x.x, x.y, x.z);
            						} else {
            								_ammoVec1.setValue(x, y, z);
            						}
            						body.applyTorque(_ammoVec1);
            				}
            		}
            		applyImpulse(x, y, z, px, py, pz) {
            				var body = this._body;
            				if (body) {
            						body.activate();
            						if (x instanceof Vec3) {
            								_ammoVec1.setValue(x.x, x.y, x.z);
            						} else {
            								_ammoVec1.setValue(x, y, z);
            						}
            						if (y instanceof Vec3) {
            								_ammoVec2.setValue(y.x, y.y, y.z);
            						} else if (px !== undefined) {
            								_ammoVec2.setValue(px, py, pz);
            						} else {
            								_ammoVec2.setValue(0, 0, 0);
            						}
            						body.applyImpulse(_ammoVec1, _ammoVec2);
            				}
            		}
            		applyTorqueImpulse(x, y, z) {
            				var body = this._body;
            				if (body) {
            						body.activate();
            						if (x instanceof Vec3) {
            								_ammoVec1.setValue(x.x, x.y, x.z);
            						} else {
            								_ammoVec1.setValue(x, y, z);
            						}
            						body.applyTorqueImpulse(_ammoVec1);
            				}
            		}
            		isStatic() {
            				return this._type === BODYTYPE_STATIC;
            		}
            		isStaticOrKinematic() {
            				return this._type === BODYTYPE_STATIC || this._type === BODYTYPE_KINEMATIC;
            		}
            		isKinematic() {
            				return this._type === BODYTYPE_KINEMATIC;
            		}
            		_getEntityTransform(transform) {
            				var entity = this.entity;
            				var component = entity.collision;
            				if (component) {
            						var bodyPos = component.getShapePosition();
            						var bodyRot = component.getShapeRotation();
            						_ammoVec1.setValue(bodyPos.x, bodyPos.y, bodyPos.z);
            						_ammoQuat.setValue(bodyRot.x, bodyRot.y, bodyRot.z, bodyRot.w);
            				} else {
            						var pos = entity.getPosition();
            						var rot = entity.getRotation();
            						_ammoVec1.setValue(pos.x, pos.y, pos.z);
            						_ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);
            				}
            				transform.setOrigin(_ammoVec1);
            				transform.setRotation(_ammoQuat);
            		}
            		syncEntityToBody() {
            				var body = this._body;
            				if (body) {
            						this._getEntityTransform(_ammoTransform);
            						body.setWorldTransform(_ammoTransform);
            						if (this._type === BODYTYPE_KINEMATIC) {
            								var motionState = body.getMotionState();
            								if (motionState) {
            										motionState.setWorldTransform(_ammoTransform);
            								}
            						}
            						body.activate();
            				}
            		}
            		_updateDynamic() {
            				var body = this._body;
            				if (body.isActive()) {
            						var motionState = body.getMotionState();
            						if (motionState) {
            								var entity = this.entity;
            								motionState.getWorldTransform(_ammoTransform);
            								var p = _ammoTransform.getOrigin();
            								var q = _ammoTransform.getRotation();
            								var component = entity.collision;
            								if (component && component._hasOffset) {
            										var lo = component.data.linearOffset;
            										var ao = component.data.angularOffset;
            										var invertedAo = _quat2.copy(ao).invert();
            										var entityRot = _quat1.set(q.x(), q.y(), q.z(), q.w()).mul(invertedAo);
            										entityRot.transformVector(lo, _vec3);
            										entity.setPosition(p.x() - _vec3.x, p.y() - _vec3.y, p.z() - _vec3.z);
            										entity.setRotation(entityRot);
            								} else {
            										entity.setPosition(p.x(), p.y(), p.z());
            										entity.setRotation(q.x(), q.y(), q.z(), q.w());
            								}
            						}
            				}
            		}
            		_updateKinematic() {
            				var motionState = this._body.getMotionState();
            				if (motionState) {
            						this._getEntityTransform(_ammoTransform);
            						motionState.setWorldTransform(_ammoTransform);
            				}
            		}
            		teleport(x, y, z, rx, ry, rz) {
            				if (x instanceof Vec3) {
            						this.entity.setPosition(x);
            				} else {
            						this.entity.setPosition(x, y, z);
            				}
            				if (y instanceof Quat) {
            						this.entity.setRotation(y);
            				} else if (y instanceof Vec3) {
            						this.entity.setEulerAngles(y);
            				} else if (rx !== undefined) {
            						this.entity.setEulerAngles(rx, ry, rz);
            				}
            				this.syncEntityToBody();
            		}
            		onEnable() {
            				if (!this._body) {
            						this.createBody();
            				}
            				this.enableSimulation();
            		}
            		onDisable() {
            				this.disableSimulation();
            		}
            		constructor(...args){
            				super(...args), this._angularDamping = 0, this._angularFactor = new Vec3(1, 1, 1), this._angularVelocity = new Vec3(), this._body = null, this._friction = 0.5, this._group = BODYGROUP_STATIC, this._linearDamping = 0, this._linearFactor = new Vec3(1, 1, 1), this._linearVelocity = new Vec3(), this._mask = BODYMASK_NOT_STATIC, this._mass = 1, this._restitution = 0, this._rollingFriction = 0, this._simulationEnabled = false, this._type = BODYTYPE_STATIC;
            		}
            }
            RigidBodyComponent.EVENT_CONTACT = 'contact';
            RigidBodyComponent.EVENT_COLLISIONSTART = 'collisionstart';
            RigidBodyComponent.EVENT_COLLISIONEND = 'collisionend';
            RigidBodyComponent.EVENT_TRIGGERENTER = 'triggerenter';
            RigidBodyComponent.EVENT_TRIGGERLEAVE = 'triggerleave';
            RigidBodyComponent.order = -1;
            
            class RigidBodyComponentData {
            		constructor(){
            				this.enabled = true;
            		}
            }
            
            var ammoRayStart, ammoRayEnd;
            class RaycastResult {
            		constructor(entity, point, normal, hitFraction){
            				this.entity = entity;
            				this.point = point;
            				this.normal = normal;
            				this.hitFraction = hitFraction;
            		}
            }
            class SingleContactResult {
            		constructor(a, b, contactPoint){
            				if (arguments.length !== 0) {
            						this.a = a;
            						this.b = b;
            						this.impulse = contactPoint.impulse;
            						this.localPointA = contactPoint.localPoint;
            						this.localPointB = contactPoint.localPointOther;
            						this.pointA = contactPoint.point;
            						this.pointB = contactPoint.pointOther;
            						this.normal = contactPoint.normal;
            				} else {
            						this.a = null;
            						this.b = null;
            						this.impulse = 0;
            						this.localPointA = new Vec3();
            						this.localPointB = new Vec3();
            						this.pointA = new Vec3();
            						this.pointB = new Vec3();
            						this.normal = new Vec3();
            				}
            		}
            }
            class ContactPoint {
            		constructor(localPoint = new Vec3(), localPointOther = new Vec3(), point = new Vec3(), pointOther = new Vec3(), normal = new Vec3(), impulse = 0){
            				this.localPoint = localPoint;
            				this.localPointOther = localPointOther;
            				this.point = point;
            				this.pointOther = pointOther;
            				this.normal = normal;
            				this.impulse = impulse;
            		}
            }
            class ContactResult {
            		constructor(other, contacts){
            				this.other = other;
            				this.contacts = contacts;
            		}
            }
            var _schema$8 = [
            		'enabled'
            ];
            class RigidBodyComponentSystem extends ComponentSystem {
            		onLibraryLoaded() {
            				if (typeof Ammo !== 'undefined') {
            						this.collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
            						this.dispatcher = new Ammo.btCollisionDispatcher(this.collisionConfiguration);
            						this.overlappingPairCache = new Ammo.btDbvtBroadphase();
            						this.solver = new Ammo.btSequentialImpulseConstraintSolver();
            						this.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(this.dispatcher, this.overlappingPairCache, this.solver, this.collisionConfiguration);
            						if (this.dynamicsWorld.setInternalTickCallback) {
            								var checkForCollisionsPointer = Ammo.addFunction(this._checkForCollisions.bind(this), 'vif');
            								this.dynamicsWorld.setInternalTickCallback(checkForCollisionsPointer);
            						}
            						ammoRayStart = new Ammo.btVector3();
            						ammoRayEnd = new Ammo.btVector3();
            						RigidBodyComponent.onLibraryLoaded();
            						this.contactPointPool = new ObjectPool(ContactPoint, 1);
            						this.contactResultPool = new ObjectPool(ContactResult, 1);
            						this.singleContactResultPool = new ObjectPool(SingleContactResult, 1);
            						this.app.systems.on('update', this.onUpdate, this);
            				} else {
            						this.app.systems.off('update', this.onUpdate, this);
            				}
            		}
            		initializeComponentData(component, data, properties) {
            				var props = [
            						'mass',
            						'linearDamping',
            						'angularDamping',
            						'linearFactor',
            						'angularFactor',
            						'friction',
            						'rollingFriction',
            						'restitution',
            						'type',
            						'group',
            						'mask'
            				];
            				for (var property of props){
            						if (data.hasOwnProperty(property)) {
            								var value = data[property];
            								if (Array.isArray(value)) {
            										component[property] = new Vec3(value[0], value[1], value[2]);
            								} else {
            										component[property] = value;
            								}
            						}
            				}
            				super.initializeComponentData(component, data, [
            						'enabled'
            				]);
            		}
            		cloneComponent(entity, clone) {
            				var rigidbody = entity.rigidbody;
            				var data = {
            						enabled: rigidbody.enabled,
            						mass: rigidbody.mass,
            						linearDamping: rigidbody.linearDamping,
            						angularDamping: rigidbody.angularDamping,
            						linearFactor: [
            								rigidbody.linearFactor.x,
            								rigidbody.linearFactor.y,
            								rigidbody.linearFactor.z
            						],
            						angularFactor: [
            								rigidbody.angularFactor.x,
            								rigidbody.angularFactor.y,
            								rigidbody.angularFactor.z
            						],
            						friction: rigidbody.friction,
            						rollingFriction: rigidbody.rollingFriction,
            						restitution: rigidbody.restitution,
            						type: rigidbody.type,
            						group: rigidbody.group,
            						mask: rigidbody.mask
            				};
            				return this.addComponent(clone, data);
            		}
            		onBeforeRemove(entity, component) {
            				if (component.enabled) {
            						component.enabled = false;
            				}
            				if (component.body) {
            						this.destroyBody(component.body);
            						component.body = null;
            				}
            		}
            		addBody(body, group, mask) {
            				if (group !== undefined && mask !== undefined) {
            						this.dynamicsWorld.addRigidBody(body, group, mask);
            				} else {
            						this.dynamicsWorld.addRigidBody(body);
            				}
            		}
            		removeBody(body) {
            				this.dynamicsWorld.removeRigidBody(body);
            		}
            		createBody(mass, shape, transform) {
            				var localInertia = new Ammo.btVector3(0, 0, 0);
            				if (mass !== 0) {
            						shape.calculateLocalInertia(mass, localInertia);
            				}
            				var motionState = new Ammo.btDefaultMotionState(transform);
            				var bodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);
            				var body = new Ammo.btRigidBody(bodyInfo);
            				Ammo.destroy(bodyInfo);
            				Ammo.destroy(localInertia);
            				return body;
            		}
            		destroyBody(body) {
            				var motionState = body.getMotionState();
            				if (motionState) {
            						Ammo.destroy(motionState);
            				}
            				Ammo.destroy(body);
            		}
            		raycastFirst(start, end, options) {
            				if (options === void 0) options = {};
            				if (options.filterTags || options.filterCallback) {
            						options.sort = true;
            						return this.raycastAll(start, end, options)[0] || null;
            				}
            				var result = null;
            				ammoRayStart.setValue(start.x, start.y, start.z);
            				ammoRayEnd.setValue(end.x, end.y, end.z);
            				var rayCallback = new Ammo.ClosestRayResultCallback(ammoRayStart, ammoRayEnd);
            				if (typeof options.filterCollisionGroup === 'number') {
            						rayCallback.set_m_collisionFilterGroup(options.filterCollisionGroup);
            				}
            				if (typeof options.filterCollisionMask === 'number') {
            						rayCallback.set_m_collisionFilterMask(options.filterCollisionMask);
            				}
            				this.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);
            				if (rayCallback.hasHit()) {
            						var collisionObj = rayCallback.get_m_collisionObject();
            						var body = Ammo.castObject(collisionObj, Ammo.btRigidBody);
            						if (body) {
            								var point = rayCallback.get_m_hitPointWorld();
            								var normal = rayCallback.get_m_hitNormalWorld();
            								result = new RaycastResult(body.entity, new Vec3(point.x(), point.y(), point.z()), new Vec3(normal.x(), normal.y(), normal.z()), rayCallback.get_m_closestHitFraction());
            						}
            				}
            				Ammo.destroy(rayCallback);
            				return result;
            		}
            		raycastAll(start, end, options) {
            				if (options === void 0) options = {};
            				var results = [];
            				ammoRayStart.setValue(start.x, start.y, start.z);
            				ammoRayEnd.setValue(end.x, end.y, end.z);
            				var rayCallback = new Ammo.AllHitsRayResultCallback(ammoRayStart, ammoRayEnd);
            				if (typeof options.filterCollisionGroup === 'number') {
            						rayCallback.set_m_collisionFilterGroup(options.filterCollisionGroup);
            				}
            				if (typeof options.filterCollisionMask === 'number') {
            						rayCallback.set_m_collisionFilterMask(options.filterCollisionMask);
            				}
            				this.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);
            				if (rayCallback.hasHit()) {
            						var collisionObjs = rayCallback.get_m_collisionObjects();
            						var points = rayCallback.get_m_hitPointWorld();
            						var normals = rayCallback.get_m_hitNormalWorld();
            						var hitFractions = rayCallback.get_m_hitFractions();
            						var numHits = collisionObjs.size();
            						for(var i = 0; i < numHits; i++){
            								var body = Ammo.castObject(collisionObjs.at(i), Ammo.btRigidBody);
            								if (body && body.entity) {
            										if (options.filterTags && !body.entity.tags.has(...options.filterTags) || options.filterCallback && !options.filterCallback(body.entity)) {
            												continue;
            										}
            										var point = points.at(i);
            										var normal = normals.at(i);
            										var result = new RaycastResult(body.entity, new Vec3(point.x(), point.y(), point.z()), new Vec3(normal.x(), normal.y(), normal.z()), hitFractions.at(i));
            										results.push(result);
            								}
            						}
            						if (options.sort) {
            								results.sort((a, b)=>a.hitFraction - b.hitFraction);
            						}
            				}
            				Ammo.destroy(rayCallback);
            				return results;
            		}
            		_storeCollision(entity, other) {
            				var isNewCollision = false;
            				var guid = entity.getGuid();
            				this.collisions[guid] = this.collisions[guid] || {
            						others: [],
            						entity: entity
            				};
            				if (this.collisions[guid].others.indexOf(other) < 0) {
            						this.collisions[guid].others.push(other);
            						isNewCollision = true;
            				}
            				this.frameCollisions[guid] = this.frameCollisions[guid] || {
            						others: [],
            						entity: entity
            				};
            				this.frameCollisions[guid].others.push(other);
            				return isNewCollision;
            		}
            		_createContactPointFromAmmo(contactPoint) {
            				var localPointA = contactPoint.get_m_localPointA();
            				var localPointB = contactPoint.get_m_localPointB();
            				var positionWorldOnA = contactPoint.getPositionWorldOnA();
            				var positionWorldOnB = contactPoint.getPositionWorldOnB();
            				var normalWorldOnB = contactPoint.get_m_normalWorldOnB();
            				var contact = this.contactPointPool.allocate();
            				contact.localPoint.set(localPointA.x(), localPointA.y(), localPointA.z());
            				contact.localPointOther.set(localPointB.x(), localPointB.y(), localPointB.z());
            				contact.point.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());
            				contact.pointOther.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());
            				contact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());
            				contact.impulse = contactPoint.getAppliedImpulse();
            				return contact;
            		}
            		_createReverseContactPointFromAmmo(contactPoint) {
            				var localPointA = contactPoint.get_m_localPointA();
            				var localPointB = contactPoint.get_m_localPointB();
            				var positionWorldOnA = contactPoint.getPositionWorldOnA();
            				var positionWorldOnB = contactPoint.getPositionWorldOnB();
            				var normalWorldOnB = contactPoint.get_m_normalWorldOnB();
            				var contact = this.contactPointPool.allocate();
            				contact.localPointOther.set(localPointA.x(), localPointA.y(), localPointA.z());
            				contact.localPoint.set(localPointB.x(), localPointB.y(), localPointB.z());
            				contact.pointOther.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());
            				contact.point.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());
            				contact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());
            				contact.impulse = contactPoint.getAppliedImpulse();
            				return contact;
            		}
            		_createSingleContactResult(a, b, contactPoint) {
            				var result = this.singleContactResultPool.allocate();
            				result.a = a;
            				result.b = b;
            				result.localPointA = contactPoint.localPoint;
            				result.localPointB = contactPoint.localPointOther;
            				result.pointA = contactPoint.point;
            				result.pointB = contactPoint.pointOther;
            				result.normal = contactPoint.normal;
            				result.impulse = contactPoint.impulse;
            				return result;
            		}
            		_createContactResult(other, contacts) {
            				var result = this.contactResultPool.allocate();
            				result.other = other;
            				result.contacts = contacts;
            				return result;
            		}
            		_cleanOldCollisions() {
            				for(var guid in this.collisions){
            						if (this.collisions.hasOwnProperty(guid)) {
            								var frameCollision = this.frameCollisions[guid];
            								var collision = this.collisions[guid];
            								var entity = collision.entity;
            								var entityCollision = entity.collision;
            								var entityRigidbody = entity.rigidbody;
            								var others = collision.others;
            								var length = others.length;
            								var i = length;
            								while(i--){
            										var other = others[i];
            										if (!frameCollision || frameCollision.others.indexOf(other) < 0) {
            												others.splice(i, 1);
            												if (entity.trigger) {
            														if (entityCollision) {
            																entityCollision.fire('triggerleave', other);
            														}
            														if (other.rigidbody) {
            																other.rigidbody.fire('triggerleave', entity);
            														}
            												} else if (!other.trigger) {
            														if (entityRigidbody) {
            																entityRigidbody.fire('collisionend', other);
            														}
            														if (entityCollision) {
            																entityCollision.fire('collisionend', other);
            														}
            												}
            										}
            								}
            								if (others.length === 0) {
            										delete this.collisions[guid];
            								}
            						}
            				}
            		}
            		_hasContactEvent(entity) {
            				var c = entity.collision;
            				if (c && (c.hasEvent('collisionstart') || c.hasEvent('collisionend') || c.hasEvent('contact'))) {
            						return true;
            				}
            				var r = entity.rigidbody;
            				return r && (r.hasEvent('collisionstart') || r.hasEvent('collisionend') || r.hasEvent('contact'));
            		}
            		_checkForCollisions(world, timeStep) {
            				var dynamicsWorld = Ammo.wrapPointer(world, Ammo.btDynamicsWorld);
            				var dispatcher = dynamicsWorld.getDispatcher();
            				var numManifolds = dispatcher.getNumManifolds();
            				this.frameCollisions = {};
            				for(var i = 0; i < numManifolds; i++){
            						var manifold = dispatcher.getManifoldByIndexInternal(i);
            						var body0 = manifold.getBody0();
            						var body1 = manifold.getBody1();
            						var wb0 = Ammo.castObject(body0, Ammo.btRigidBody);
            						var wb1 = Ammo.castObject(body1, Ammo.btRigidBody);
            						var e0 = wb0.entity;
            						var e1 = wb1.entity;
            						if (!e0 || !e1) {
            								continue;
            						}
            						var flags0 = wb0.getCollisionFlags();
            						var flags1 = wb1.getCollisionFlags();
            						var numContacts = manifold.getNumContacts();
            						var forwardContacts = [];
            						var reverseContacts = [];
            						var newCollision = void 0;
            						if (numContacts > 0) {
            								if (flags0 & BODYFLAG_NORESPONSE_OBJECT || flags1 & BODYFLAG_NORESPONSE_OBJECT) {
            										var e0Events = e0.collision && (e0.collision.hasEvent('triggerenter') || e0.collision.hasEvent('triggerleave'));
            										var e1Events = e1.collision && (e1.collision.hasEvent('triggerenter') || e1.collision.hasEvent('triggerleave'));
            										var e0BodyEvents = e0.rigidbody && (e0.rigidbody.hasEvent('triggerenter') || e0.rigidbody.hasEvent('triggerleave'));
            										var e1BodyEvents = e1.rigidbody && (e1.rigidbody.hasEvent('triggerenter') || e1.rigidbody.hasEvent('triggerleave'));
            										if (e0Events) {
            												newCollision = this._storeCollision(e0, e1);
            												if (newCollision && !(flags1 & BODYFLAG_NORESPONSE_OBJECT)) {
            														e0.collision.fire('triggerenter', e1);
            												}
            										}
            										if (e1Events) {
            												newCollision = this._storeCollision(e1, e0);
            												if (newCollision && !(flags0 & BODYFLAG_NORESPONSE_OBJECT)) {
            														e1.collision.fire('triggerenter', e0);
            												}
            										}
            										if (e0BodyEvents) {
            												if (!newCollision) {
            														newCollision = this._storeCollision(e1, e0);
            												}
            												if (newCollision) {
            														e0.rigidbody.fire('triggerenter', e1);
            												}
            										}
            										if (e1BodyEvents) {
            												if (!newCollision) {
            														newCollision = this._storeCollision(e0, e1);
            												}
            												if (newCollision) {
            														e1.rigidbody.fire('triggerenter', e0);
            												}
            										}
            								} else {
            										var e0Events1 = this._hasContactEvent(e0);
            										var e1Events1 = this._hasContactEvent(e1);
            										var globalEvents = this.hasEvent('contact');
            										if (globalEvents || e0Events1 || e1Events1) {
            												for(var j = 0; j < numContacts; j++){
            														var btContactPoint = manifold.getContactPoint(j);
            														var contactPoint = this._createContactPointFromAmmo(btContactPoint);
            														if (e0Events1 || e1Events1) {
            																forwardContacts.push(contactPoint);
            																var reverseContactPoint = this._createReverseContactPointFromAmmo(btContactPoint);
            																reverseContacts.push(reverseContactPoint);
            														}
            														if (globalEvents) {
            																var result = this._createSingleContactResult(e0, e1, contactPoint);
            																this.fire('contact', result);
            														}
            												}
            												if (e0Events1) {
            														var forwardResult = this._createContactResult(e1, forwardContacts);
            														newCollision = this._storeCollision(e0, e1);
            														if (e0.collision) {
            																e0.collision.fire('contact', forwardResult);
            																if (newCollision) {
            																		e0.collision.fire('collisionstart', forwardResult);
            																}
            														}
            														if (e0.rigidbody) {
            																e0.rigidbody.fire('contact', forwardResult);
            																if (newCollision) {
            																		e0.rigidbody.fire('collisionstart', forwardResult);
            																}
            														}
            												}
            												if (e1Events1) {
            														var reverseResult = this._createContactResult(e0, reverseContacts);
            														newCollision = this._storeCollision(e1, e0);
            														if (e1.collision) {
            																e1.collision.fire('contact', reverseResult);
            																if (newCollision) {
            																		e1.collision.fire('collisionstart', reverseResult);
            																}
            														}
            														if (e1.rigidbody) {
            																e1.rigidbody.fire('contact', reverseResult);
            																if (newCollision) {
            																		e1.rigidbody.fire('collisionstart', reverseResult);
            																}
            														}
            												}
            										}
            								}
            						}
            				}
            				this._cleanOldCollisions();
            				this.contactPointPool.freeAll();
            				this.contactResultPool.freeAll();
            				this.singleContactResultPool.freeAll();
            		}
            		onUpdate(dt) {
            				var i, len;
            				this._gravityFloat32[0] = this.gravity.x;
            				this._gravityFloat32[1] = this.gravity.y;
            				this._gravityFloat32[2] = this.gravity.z;
            				var gravity = this.dynamicsWorld.getGravity();
            				if (gravity.x() !== this._gravityFloat32[0] || gravity.y() !== this._gravityFloat32[1] || gravity.z() !== this._gravityFloat32[2]) {
            						gravity.setValue(this.gravity.x, this.gravity.y, this.gravity.z);
            						this.dynamicsWorld.setGravity(gravity);
            				}
            				var triggers = this._triggers;
            				for(i = 0, len = triggers.length; i < len; i++){
            						triggers[i].updateTransform();
            				}
            				var compounds = this._compounds;
            				for(i = 0, len = compounds.length; i < len; i++){
            						compounds[i]._updateCompound();
            				}
            				var kinematic = this._kinematic;
            				for(i = 0, len = kinematic.length; i < len; i++){
            						kinematic[i]._updateKinematic();
            				}
            				this.dynamicsWorld.stepSimulation(dt, this.maxSubSteps, this.fixedTimeStep);
            				var dynamic = this._dynamic;
            				for(i = 0, len = dynamic.length; i < len; i++){
            						dynamic[i]._updateDynamic();
            				}
            				if (!this.dynamicsWorld.setInternalTickCallback) {
            						this._checkForCollisions(Ammo.getPointer(this.dynamicsWorld), dt);
            				}
            		}
            		destroy() {
            				super.destroy();
            				this.app.systems.off('update', this.onUpdate, this);
            				if (typeof Ammo !== 'undefined') {
            						Ammo.destroy(this.dynamicsWorld);
            						Ammo.destroy(this.solver);
            						Ammo.destroy(this.overlappingPairCache);
            						Ammo.destroy(this.dispatcher);
            						Ammo.destroy(this.collisionConfiguration);
            						Ammo.destroy(ammoRayStart);
            						Ammo.destroy(ammoRayEnd);
            						this.dynamicsWorld = null;
            						this.solver = null;
            						this.overlappingPairCache = null;
            						this.dispatcher = null;
            						this.collisionConfiguration = null;
            						ammoRayStart = null;
            						ammoRayEnd = null;
            						RigidBodyComponent.onAppDestroy();
            				}
            		}
            		constructor(app){
            				super(app), this.maxSubSteps = 10, this.fixedTimeStep = 1 / 60, this.gravity = new Vec3(0, -9.81, 0), this._gravityFloat32 = new Float32Array(3), this._dynamic = [], this._kinematic = [], this._triggers = [], this._compounds = [];
            				this.id = 'rigidbody';
            				this._stats = app.stats.frame;
            				this.ComponentType = RigidBodyComponent;
            				this.DataType = RigidBodyComponentData;
            				this.contactPointPool = null;
            				this.contactResultPool = null;
            				this.singleContactResultPool = null;
            				this.schema = _schema$8;
            				this.collisions = {};
            				this.frameCollisions = {};
            				this.on('beforeremove', this.onBeforeRemove, this);
            		}
            }
            RigidBodyComponentSystem.EVENT_CONTACT = 'contact';
            Component._buildAccessors(RigidBodyComponent.prototype, _schema$8);
            
            var SCALEMODE_NONE = 'none';
            var SCALEMODE_BLEND = 'blend';
            
            var _transform = new Mat4();
            class ScreenComponent extends Component {
            		syncDrawOrder() {
            				this.system.queueDrawOrderSync(this.entity.getGuid(), this._processDrawOrderSync, this);
            		}
            		_recurseDrawOrderSync(e, i) {
            				if (!(e instanceof Entity)) {
            						return i;
            				}
            				if (e.element) {
            						var prevDrawOrder = e.element.drawOrder;
            						e.element.drawOrder = i++;
            						if (e.element._batchGroupId >= 0 && prevDrawOrder !== e.element.drawOrder) {
            								var _this_system_app_batcher;
            								(_this_system_app_batcher = this.system.app.batcher) == null ? void 0 : _this_system_app_batcher.markGroupDirty(e.element._batchGroupId);
            						}
            				}
            				if (e.particlesystem) {
            						e.particlesystem.drawOrder = i++;
            				}
            				var children = e.children;
            				for(var j = 0; j < children.length; j++){
            						i = this._recurseDrawOrderSync(children[j], i);
            				}
            				return i;
            		}
            		_processDrawOrderSync() {
            				var i = 1;
            				this._recurseDrawOrderSync(this.entity, i);
            				this.fire('syncdraworder');
            		}
            		_calcProjectionMatrix() {
            				var w = this._resolution.x / this.scale;
            				var h = this._resolution.y / this.scale;
            				var left = 0;
            				var right = w;
            				var bottom = -h;
            				var top = 0;
            				var near = 1;
            				var far = -1;
            				this._screenMatrix.setOrtho(left, right, bottom, top, near, far);
            				if (!this._screenSpace) {
            						_transform.setScale(0.5 * w, 0.5 * h, 1);
            						this._screenMatrix.mul2(_transform, this._screenMatrix);
            				}
            		}
            		_updateScale() {
            				this.scale = this._calcScale(this._resolution, this.referenceResolution);
            		}
            		_calcScale(resolution, referenceResolution) {
            				var lx = Math.log2((resolution.x || 1) / referenceResolution.x);
            				var ly = Math.log2((resolution.y || 1) / referenceResolution.y);
            				return Math.pow(2, lx * (1 - this._scaleBlend) + ly * this._scaleBlend);
            		}
            		_onResize(width, height) {
            				if (this._screenSpace) {
            						this._resolution.set(width, height);
            						this.resolution = this._resolution;
            				}
            		}
            		_bindElement(element) {
            				this._elements.add(element);
            		}
            		_unbindElement(element) {
            				this._elements.delete(element);
            		}
            		onRemove() {
            				this.system.app.graphicsDevice.off('resizecanvas', this._onResize, this);
            				this.fire('remove');
            				this._elements.forEach((element)=>element._onScreenRemove());
            				this._elements.clear();
            				this.off();
            		}
            		set resolution(value) {
            				if (!this._screenSpace) {
            						this._resolution.set(value.x, value.y);
            				} else {
            						this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);
            				}
            				this._updateScale();
            				this._calcProjectionMatrix();
            				if (!this.entity._dirtyLocal) {
            						this.entity._dirtifyLocal();
            				}
            				this.fire('set:resolution', this._resolution);
            				this._elements.forEach((element)=>element._onScreenResize(this._resolution));
            		}
            		get resolution() {
            				return this._resolution;
            		}
            		set referenceResolution(value) {
            				this._referenceResolution.set(value.x, value.y);
            				this._updateScale();
            				this._calcProjectionMatrix();
            				if (!this.entity._dirtyLocal) {
            						this.entity._dirtifyLocal();
            				}
            				this.fire('set:referenceresolution', this._resolution);
            				this._elements.forEach((element)=>element._onScreenResize(this._resolution));
            		}
            		get referenceResolution() {
            				if (this._scaleMode === SCALEMODE_NONE) {
            						return this._resolution;
            				}
            				return this._referenceResolution;
            		}
            		set screenSpace(value) {
            				this._screenSpace = value;
            				if (this._screenSpace) {
            						this._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);
            				}
            				this.resolution = this._resolution;
            				if (!this.entity._dirtyLocal) {
            						this.entity._dirtifyLocal();
            				}
            				this.fire('set:screenspace', this._screenSpace);
            				this._elements.forEach((element)=>element._onScreenSpaceChange());
            		}
            		get screenSpace() {
            				return this._screenSpace;
            		}
            		set scaleMode(value) {
            				if (value !== SCALEMODE_NONE && value !== SCALEMODE_BLEND) {
            						value = SCALEMODE_NONE;
            				}
            				if (!this._screenSpace && value !== SCALEMODE_NONE) {
            						value = SCALEMODE_NONE;
            				}
            				this._scaleMode = value;
            				this.resolution = this._resolution;
            				this.fire('set:scalemode', this._scaleMode);
            		}
            		get scaleMode() {
            				return this._scaleMode;
            		}
            		set scaleBlend(value) {
            				this._scaleBlend = value;
            				this._updateScale();
            				this._calcProjectionMatrix();
            				if (!this.entity._dirtyLocal) {
            						this.entity._dirtifyLocal();
            				}
            				this.fire('set:scaleblend', this._scaleBlend);
            				this._elements.forEach((element)=>element._onScreenResize(this._resolution));
            		}
            		get scaleBlend() {
            				return this._scaleBlend;
            		}
            		set priority(value) {
            				if (value > 0xFF) {
            						value = 0xFF;
            				}
            				if (this._priority === value) {
            						return;
            				}
            				this._priority = value;
            				this.syncDrawOrder();
            		}
            		get priority() {
            				return this._priority;
            		}
            		constructor(system, entity){
            				super(system, entity);
            				this._resolution = new Vec2(640, 320);
            				this._referenceResolution = new Vec2(640, 320);
            				this._scaleMode = SCALEMODE_NONE;
            				this.scale = 1;
            				this._scaleBlend = 0.5;
            				this._priority = 0;
            				this._screenSpace = false;
            				this.cull = this._screenSpace;
            				this._screenMatrix = new Mat4();
            				this._elements = new Set();
            				system.app.graphicsDevice.on('resizecanvas', this._onResize, this);
            		}
            }
            
            class ScreenComponentData {
            		constructor(){
            				this.enabled = true;
            		}
            }
            
            var _schema$7 = [
            		'enabled'
            ];
            class ScreenComponentSystem extends ComponentSystem {
            		initializeComponentData(component, data, properties) {
            				if (data.priority !== undefined) component.priority = data.priority;
            				if (data.screenSpace !== undefined) component.screenSpace = data.screenSpace;
            				component.cull = component.screenSpace;
            				if (data.scaleMode !== undefined) component.scaleMode = data.scaleMode;
            				if (data.scaleBlend !== undefined) component.scaleBlend = data.scaleBlend;
            				if (data.resolution !== undefined) {
            						if (data.resolution instanceof Vec2) {
            								component._resolution.copy(data.resolution);
            						} else {
            								component._resolution.set(data.resolution[0], data.resolution[1]);
            						}
            						component.resolution = component._resolution;
            				}
            				if (data.referenceResolution !== undefined) {
            						if (data.referenceResolution instanceof Vec2) {
            								component._referenceResolution.copy(data.referenceResolution);
            						} else {
            								component._referenceResolution.set(data.referenceResolution[0], data.referenceResolution[1]);
            						}
            						component.referenceResolution = component._referenceResolution;
            				}
            				component.syncDrawOrder();
            				super.initializeComponentData(component, data, _schema$7);
            		}
            		destroy() {
            				super.destroy();
            				this.app.graphicsDevice.off('resizecanvas', this._onResize, this);
            				this.app.systems.off('update', this._onUpdate, this);
            		}
            		_onUpdate(dt) {
            				var components = this.store;
            				for(var id in components){
            						if (components[id].entity.screen.update) components[id].entity.screen.update(dt);
            				}
            		}
            		_onResize(width, height) {
            				this.windowResolution.x = width;
            				this.windowResolution.y = height;
            		}
            		cloneComponent(entity, clone) {
            				var screen = entity.screen;
            				return this.addComponent(clone, {
            						enabled: screen.enabled,
            						screenSpace: screen.screenSpace,
            						scaleMode: screen.scaleMode,
            						resolution: screen.resolution.clone(),
            						referenceResolution: screen.referenceResolution.clone()
            				});
            		}
            		onRemoveComponent(entity, component) {
            				component.onRemove();
            		}
            		processDrawOrderSyncQueue() {
            				var list = this._drawOrderSyncQueue.list();
            				for(var i = 0; i < list.length; i++){
            						var item = list[i];
            						item.callback.call(item.scope);
            				}
            				this._drawOrderSyncQueue.clear();
            		}
            		queueDrawOrderSync(id, fn, scope) {
            				if (!this._drawOrderSyncQueue.list().length) {
            						this.app.once('prerender', this.processDrawOrderSyncQueue, this);
            				}
            				if (!this._drawOrderSyncQueue.has(id)) {
            						this._drawOrderSyncQueue.push(id, {
            								callback: fn,
            								scope: scope
            						});
            				}
            		}
            		constructor(app){
            				super(app);
            				this.id = 'screen';
            				this.ComponentType = ScreenComponent;
            				this.DataType = ScreenComponentData;
            				this.schema = _schema$7;
            				this.windowResolution = new Vec2();
            				this._drawOrderSyncQueue = new IndexedList();
            				this.app.graphicsDevice.on('resizecanvas', this._onResize, this);
            				this.app.systems.on('update', this._onUpdate, this);
            				this.on('beforeremove', this.onRemoveComponent, this);
            		}
            }
            Component._buildAccessors(ScreenComponent.prototype, _schema$7);
            
            var _inputScreenPosition = new Vec2();
            var _inputWorldPosition = new Vec3();
            var _ray = new Ray();
            var _plane = new Plane();
            var _normal = new Vec3();
            var _point = new Vec3();
            var _entityRotation = new Quat();
            var OPPOSITE_AXIS = {
            		x: 'y',
            		y: 'x'
            };
            class ElementDragHelper extends EventHandler {
            		_toggleLifecycleListeners(onOrOff) {
            				this._element[onOrOff]('mousedown', this._onMouseDownOrTouchStart, this);
            				this._element[onOrOff]('touchstart', this._onMouseDownOrTouchStart, this);
            				this._element[onOrOff]('selectstart', this._onMouseDownOrTouchStart, this);
            		}
            		_toggleDragListeners(onOrOff) {
            				var isOn = onOrOff === 'on';
            				if (this._hasDragListeners && isOn) {
            						return;
            				}
            				if (this._app.mouse) {
            						this._element[onOrOff]('mousemove', this._onMove, this);
            						this._element[onOrOff]('mouseup', this._onMouseUpOrTouchEnd, this);
            				}
            				if (platform.touch) {
            						this._element[onOrOff]('touchmove', this._onMove, this);
            						this._element[onOrOff]('touchend', this._onMouseUpOrTouchEnd, this);
            						this._element[onOrOff]('touchcancel', this._onMouseUpOrTouchEnd, this);
            				}
            				this._element[onOrOff]('selectmove', this._onMove, this);
            				this._element[onOrOff]('selectend', this._onMouseUpOrTouchEnd, this);
            				this._hasDragListeners = isOn;
            		}
            		_onMouseDownOrTouchStart(event) {
            				if (this._element && !this._isDragging && this.enabled) {
            						this._dragCamera = event.camera;
            						this._calculateDragScale();
            						var currentMousePosition = this._screenToLocal(event);
            						if (currentMousePosition) {
            								this._toggleDragListeners('on');
            								this._isDragging = true;
            								this._dragStartMousePosition.copy(currentMousePosition);
            								this._dragStartHandlePosition.copy(this._element.entity.getLocalPosition());
            								this.fire('drag:start');
            						}
            				}
            		}
            		_onMouseUpOrTouchEnd() {
            				if (this._isDragging) {
            						this._isDragging = false;
            						this._toggleDragListeners('off');
            						this.fire('drag:end');
            				}
            		}
            		_screenToLocal(event) {
            				if (event.inputSource) {
            						_ray.set(event.inputSource.getOrigin(), event.inputSource.getDirection());
            				} else {
            						this._determineInputPosition(event);
            						this._chooseRayOriginAndDirection();
            				}
            				_normal.copy(this._element.entity.forward).mulScalar(-1);
            				_plane.setFromPointNormal(this._element.entity.getPosition(), _normal);
            				if (_plane.intersectsRay(_ray, _point)) {
            						_entityRotation.copy(this._element.entity.getRotation()).invert().transformVector(_point, _point);
            						_point.mul(this._dragScale);
            						return _point;
            				}
            				return null;
            		}
            		_determineInputPosition(event) {
            				var devicePixelRatio = this._app.graphicsDevice.maxPixelRatio;
            				if (typeof event.x !== 'undefined' && typeof event.y !== 'undefined') {
            						_inputScreenPosition.x = event.x * devicePixelRatio;
            						_inputScreenPosition.y = event.y * devicePixelRatio;
            				} else if (event.changedTouches) {
            						_inputScreenPosition.x = event.changedTouches[0].x * devicePixelRatio;
            						_inputScreenPosition.y = event.changedTouches[0].y * devicePixelRatio;
            				} else {
            						console.warn('Could not determine position from input event');
            				}
            		}
            		_chooseRayOriginAndDirection() {
            				if (this._element.screen && this._element.screen.screen.screenSpace) {
            						_ray.origin.set(_inputScreenPosition.x, -_inputScreenPosition.y, 0);
            						_ray.direction.copy(Vec3.FORWARD);
            				} else {
            						_inputWorldPosition.copy(this._dragCamera.screenToWorld(_inputScreenPosition.x, _inputScreenPosition.y, 1));
            						_ray.origin.copy(this._dragCamera.entity.getPosition());
            						_ray.direction.copy(_inputWorldPosition).sub(_ray.origin).normalize();
            				}
            		}
            		_calculateDragScale() {
            				var current = this._element.entity.parent;
            				var screen = this._element.screen && this._element.screen.screen;
            				var isWithin2DScreen = screen && screen.screenSpace;
            				var screenScale = isWithin2DScreen ? screen.scale : 1;
            				var dragScale = this._dragScale;
            				dragScale.set(screenScale, screenScale, screenScale);
            				while(current){
            						dragScale.mul(current.getLocalScale());
            						current = current.parent;
            						if (isWithin2DScreen && current.screen) {
            								break;
            						}
            				}
            				dragScale.x = 1 / dragScale.x;
            				dragScale.y = 1 / dragScale.y;
            				dragScale.z = 0;
            		}
            		_onMove(event) {
            				var { _element: element, _deltaMousePosition: deltaMousePosition, _deltaHandlePosition: deltaHandlePosition, _axis: axis } = this;
            				if (element && this._isDragging && this.enabled && element.enabled && element.entity.enabled) {
            						var currentMousePosition = this._screenToLocal(event);
            						if (currentMousePosition) {
            								deltaMousePosition.sub2(currentMousePosition, this._dragStartMousePosition);
            								deltaHandlePosition.add2(this._dragStartHandlePosition, deltaMousePosition);
            								if (axis) {
            										var currentPosition = element.entity.getLocalPosition();
            										var constrainedAxis = OPPOSITE_AXIS[axis];
            										deltaHandlePosition[constrainedAxis] = currentPosition[constrainedAxis];
            								}
            								element.entity.setLocalPosition(deltaHandlePosition);
            								this.fire('drag:move', deltaHandlePosition);
            						}
            				}
            		}
            		destroy() {
            				this._toggleLifecycleListeners('off');
            				this._toggleDragListeners('off');
            		}
            		set enabled(value) {
            				this._enabled = value;
            		}
            		get enabled() {
            				return this._enabled;
            		}
            		get isDragging() {
            				return this._isDragging;
            		}
            		constructor(element, axis){
            				super();
            				if (!element || !(element instanceof ElementComponent)) {
            						throw new Error('Element was null or not an ElementComponent');
            				}
            				if (axis && axis !== 'x' && axis !== 'y') {
            						throw new Error("Unrecognized axis: " + axis);
            				}
            				this._element = element;
            				this._app = element.system.app;
            				this._axis = axis || null;
            				this._enabled = true;
            				this._dragScale = new Vec3();
            				this._dragStartMousePosition = new Vec3();
            				this._dragStartHandlePosition = new Vec3();
            				this._deltaMousePosition = new Vec3();
            				this._deltaHandlePosition = new Vec3();
            				this._isDragging = false;
            				this._toggleLifecycleListeners('on');
            		}
            }
            ElementDragHelper.EVENT_DRAGSTART = 'drag:start';
            ElementDragHelper.EVENT_DRAGEND = 'drag:end';
            ElementDragHelper.EVENT_DRAGMOVE = 'drag:move';
            
            var SCROLL_MODE_CLAMP = 0;
            var SCROLL_MODE_BOUNCE = 1;
            var SCROLL_MODE_INFINITE = 2;
            var SCROLLBAR_VISIBILITY_SHOW_ALWAYS = 0;
            var SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED = 1;
            
            var _tempScrollValue = new Vec2();
            class ScrollViewComponent extends Component {
            		get data() {
            				var record = this.system.store[this.entity.getGuid()];
            				return record ? record.data : null;
            		}
            		set enabled(arg) {
            				this._setValue('enabled', arg);
            		}
            		get enabled() {
            				return this.data.enabled;
            		}
            		set horizontal(arg) {
            				this._setValue('horizontal', arg);
            		}
            		get horizontal() {
            				return this.data.horizontal;
            		}
            		set vertical(arg) {
            				this._setValue('vertical', arg);
            		}
            		get vertical() {
            				return this.data.vertical;
            		}
            		set scrollMode(arg) {
            				this._setValue('scrollMode', arg);
            		}
            		get scrollMode() {
            				return this.data.scrollMode;
            		}
            		set bounceAmount(arg) {
            				this._setValue('bounceAmount', arg);
            		}
            		get bounceAmount() {
            				return this.data.bounceAmount;
            		}
            		set friction(arg) {
            				this._setValue('friction', arg);
            		}
            		get friction() {
            				return this.data.friction;
            		}
            		set dragThreshold(arg) {
            				this._setValue('dragThreshold', arg);
            		}
            		get dragThreshold() {
            				return this.data.dragThreshold;
            		}
            		set useMouseWheel(arg) {
            				this._setValue('useMouseWheel', arg);
            		}
            		get useMouseWheel() {
            				return this.data.useMouseWheel;
            		}
            		set mouseWheelSensitivity(arg) {
            				this._setValue('mouseWheelSensitivity', arg);
            		}
            		get mouseWheelSensitivity() {
            				return this.data.mouseWheelSensitivity;
            		}
            		set horizontalScrollbarVisibility(arg) {
            				this._setValue('horizontalScrollbarVisibility', arg);
            		}
            		get horizontalScrollbarVisibility() {
            				return this.data.horizontalScrollbarVisibility;
            		}
            		set verticalScrollbarVisibility(arg) {
            				this._setValue('verticalScrollbarVisibility', arg);
            		}
            		get verticalScrollbarVisibility() {
            				return this.data.verticalScrollbarVisibility;
            		}
            		set viewportEntity(arg) {
            				if (this._viewportEntity === arg) {
            						return;
            				}
            				var isString = typeof arg === 'string';
            				if (this._viewportEntity && isString && this._viewportEntity.getGuid() === arg) {
            						return;
            				}
            				if (this._viewportEntity) {
            						this._viewportEntityUnsubscribe();
            				}
            				if (arg instanceof GraphNode) {
            						this._viewportEntity = arg;
            				} else if (isString) {
            						this._viewportEntity = this.system.app.getEntityFromIndex(arg) || null;
            				} else {
            						this._viewportEntity = null;
            				}
            				if (this._viewportEntity) {
            						this._viewportEntitySubscribe();
            				}
            				if (this._viewportEntity) {
            						this.data.viewportEntity = this._viewportEntity.getGuid();
            				} else if (isString && arg) {
            						this.data.viewportEntity = arg;
            				}
            		}
            		get viewportEntity() {
            				return this._viewportEntity;
            		}
            		set contentEntity(arg) {
            				if (this._contentEntity === arg) {
            						return;
            				}
            				var isString = typeof arg === 'string';
            				if (this._contentEntity && isString && this._contentEntity.getGuid() === arg) {
            						return;
            				}
            				if (this._contentEntity) {
            						this._contentEntityUnsubscribe();
            				}
            				if (arg instanceof GraphNode) {
            						this._contentEntity = arg;
            				} else if (isString) {
            						this._contentEntity = this.system.app.getEntityFromIndex(arg) || null;
            				} else {
            						this._contentEntity = null;
            				}
            				if (this._contentEntity) {
            						this._contentEntitySubscribe();
            				}
            				if (this._contentEntity) {
            						this.data.contentEntity = this._contentEntity.getGuid();
            				} else if (isString && arg) {
            						this.data.contentEntity = arg;
            				}
            		}
            		get contentEntity() {
            				return this._contentEntity;
            		}
            		set horizontalScrollbarEntity(arg) {
            				if (this._horizontalScrollbarEntity === arg) {
            						return;
            				}
            				var isString = typeof arg === 'string';
            				if (this._horizontalScrollbarEntity && isString && this._horizontalScrollbarEntity.getGuid() === arg) {
            						return;
            				}
            				if (this._horizontalScrollbarEntity) {
            						this._horizontalScrollbarEntityUnsubscribe();
            				}
            				if (arg instanceof GraphNode) {
            						this._horizontalScrollbarEntity = arg;
            				} else if (isString) {
            						this._horizontalScrollbarEntity = this.system.app.getEntityFromIndex(arg) || null;
            				} else {
            						this._horizontalScrollbarEntity = null;
            				}
            				this._scrollbarEntities[ORIENTATION_HORIZONTAL] = this._horizontalScrollbarEntity;
            				if (this._horizontalScrollbarEntity) {
            						this._horizontalScrollbarEntitySubscribe();
            				}
            				if (this._horizontalScrollbarEntity) {
            						this.data.horizontalScrollbarEntity = this._horizontalScrollbarEntity.getGuid();
            				} else if (isString && arg) {
            						this.data.horizontalScrollbarEntity = arg;
            				}
            		}
            		get horizontalScrollbarEntity() {
            				return this._horizontalScrollbarEntity;
            		}
            		set verticalScrollbarEntity(arg) {
            				if (this._verticalScrollbarEntity === arg) {
            						return;
            				}
            				var isString = typeof arg === 'string';
            				if (this._verticalScrollbarEntity && isString && this._verticalScrollbarEntity.getGuid() === arg) {
            						return;
            				}
            				if (this._verticalScrollbarEntity) {
            						this._verticalScrollbarEntityUnsubscribe();
            				}
            				if (arg instanceof GraphNode) {
            						this._verticalScrollbarEntity = arg;
            				} else if (isString) {
            						this._verticalScrollbarEntity = this.system.app.getEntityFromIndex(arg) || null;
            				} else {
            						this._verticalScrollbarEntity = null;
            				}
            				this._scrollbarEntities[ORIENTATION_VERTICAL] = this._verticalScrollbarEntity;
            				if (this._verticalScrollbarEntity) {
            						this._verticalScrollbarEntitySubscribe();
            				}
            				if (this._verticalScrollbarEntity) {
            						this.data.verticalScrollbarEntity = this._verticalScrollbarEntity.getGuid();
            				} else if (isString && arg) {
            						this.data.verticalScrollbarEntity = arg;
            				}
            		}
            		get verticalScrollbarEntity() {
            				return this._verticalScrollbarEntity;
            		}
            		set scroll(value) {
            				this._onSetScroll(value.x, value.y);
            		}
            		get scroll() {
            				return this._scroll;
            		}
            		_setValue(name, value) {
            				var data = this.data;
            				var oldValue = data[name];
            				data[name] = value;
            				this.fire('set', name, oldValue, value);
            		}
            		_toggleLifecycleListeners(onOrOff) {
            				this[onOrOff]('set_horizontal', this._onSetHorizontalScrollingEnabled, this);
            				this[onOrOff]('set_vertical', this._onSetVerticalScrollingEnabled, this);
            				this.entity[onOrOff]('element:add', this._onElementComponentAdd, this);
            		}
            		_toggleElementListeners(onOrOff) {
            				if (this.entity.element) {
            						if (onOrOff === 'on' && this._hasElementListeners) {
            								return;
            						}
            						this.entity.element[onOrOff]('resize', this._syncAll, this);
            						this.entity.element[onOrOff]('mousewheel', this._onMouseWheel, this);
            						this._hasElementListeners = onOrOff === 'on';
            				}
            		}
            		_onElementComponentAdd(entity) {
            				this._evtElementRemove = this.entity.element.once('beforeremove', this._onElementComponentRemove, this);
            				this._toggleElementListeners('on');
            		}
            		_onElementComponentRemove(entity) {
            				var _this__evtElementRemove;
            				(_this__evtElementRemove = this._evtElementRemove) == null ? void 0 : _this__evtElementRemove.off();
            				this._evtElementRemove = null;
            				this._toggleElementListeners('off');
            		}
            		_viewportEntitySubscribe() {
            				this._evtViewportEntityElementAdd = this._viewportEntity.on('element:add', this._onViewportElementGain, this);
            				if (this._viewportEntity.element) {
            						this._onViewportElementGain();
            				}
            		}
            		_viewportEntityUnsubscribe() {
            				var _this__evtViewportEntityElementAdd, _this__viewportEntity;
            				(_this__evtViewportEntityElementAdd = this._evtViewportEntityElementAdd) == null ? void 0 : _this__evtViewportEntityElementAdd.off();
            				this._evtViewportEntityElementAdd = null;
            				if ((_this__viewportEntity = this._viewportEntity) == null ? void 0 : _this__viewportEntity.element) {
            						this._onViewportElementLose();
            				}
            		}
            		_viewportEntityElementSubscribe() {
            				var element = this._viewportEntity.element;
            				this._evtViewportElementRemove = element.once('beforeremove', this._onViewportElementLose, this);
            				this._evtViewportResize = element.on('resize', this._syncAll, this);
            		}
            		_viewportEntityElementUnsubscribe() {
            				var _this__evtViewportElementRemove, _this__evtViewportResize;
            				(_this__evtViewportElementRemove = this._evtViewportElementRemove) == null ? void 0 : _this__evtViewportElementRemove.off();
            				this._evtViewportElementRemove = null;
            				(_this__evtViewportResize = this._evtViewportResize) == null ? void 0 : _this__evtViewportResize.off();
            				this._evtViewportResize = null;
            		}
            		_onViewportElementGain() {
            				this._viewportEntityElementSubscribe();
            				this._syncAll();
            		}
            		_onViewportElementLose() {
            				this._viewportEntityElementUnsubscribe();
            		}
            		_contentEntitySubscribe() {
            				this._evtContentEntityElementAdd = this._contentEntity.on('element:add', this._onContentElementGain, this);
            				if (this._contentEntity.element) {
            						this._onContentElementGain();
            				}
            		}
            		_contentEntityUnsubscribe() {
            				var _this__evtContentEntityElementAdd, _this__contentEntity;
            				(_this__evtContentEntityElementAdd = this._evtContentEntityElementAdd) == null ? void 0 : _this__evtContentEntityElementAdd.off();
            				this._evtContentEntityElementAdd = null;
            				if ((_this__contentEntity = this._contentEntity) == null ? void 0 : _this__contentEntity.element) {
            						this._onContentElementLose();
            				}
            		}
            		_contentEntityElementSubscribe() {
            				var element = this._contentEntity.element;
            				this._evtContentElementRemove = element.once('beforeremove', this._onContentElementLose, this);
            				this._evtContentResize = element.on('resize', this._syncAll, this);
            		}
            		_contentEntityElementUnsubscribe() {
            				var _this__evtContentElementRemove, _this__evtContentResize;
            				(_this__evtContentElementRemove = this._evtContentElementRemove) == null ? void 0 : _this__evtContentElementRemove.off();
            				this._evtContentElementRemove = null;
            				(_this__evtContentResize = this._evtContentResize) == null ? void 0 : _this__evtContentResize.off();
            				this._evtContentResize = null;
            		}
            		_onContentElementGain() {
            				this._contentEntityElementSubscribe();
            				this._destroyDragHelper();
            				this._contentDragHelper = new ElementDragHelper(this._contentEntity.element);
            				this._contentDragHelper.on('drag:start', this._onContentDragStart, this);
            				this._contentDragHelper.on('drag:end', this._onContentDragEnd, this);
            				this._contentDragHelper.on('drag:move', this._onContentDragMove, this);
            				this._prevContentSizes[ORIENTATION_HORIZONTAL] = null;
            				this._prevContentSizes[ORIENTATION_VERTICAL] = null;
            				this._syncAll();
            		}
            		_onContentElementLose() {
            				this._contentEntityElementUnsubscribe();
            				this._destroyDragHelper();
            		}
            		_onContentDragStart() {
            				if (this._contentEntity && this.enabled && this.entity.enabled) {
            						this._dragStartPosition.copy(this._contentEntity.getLocalPosition());
            				}
            		}
            		_onContentDragEnd() {
            				this._prevContentDragPosition = null;
            				this._enableContentInput();
            		}
            		_onContentDragMove(position) {
            				if (this._contentEntity && this.enabled && this.entity.enabled) {
            						this._wasDragged = true;
            						this._setScrollFromContentPosition(position);
            						this._setVelocityFromContentPositionDelta(position);
            						if (!this._disabledContentInput) {
            								var dx = position.x - this._dragStartPosition.x;
            								var dy = position.y - this._dragStartPosition.y;
            								if (Math.abs(dx) > this.dragThreshold || Math.abs(dy) > this.dragThreshold) {
            										this._disableContentInput();
            								}
            						}
            				}
            		}
            		_horizontalScrollbarEntitySubscribe() {
            				this._evtHorizontalScrollbarAdd = this._horizontalScrollbarEntity.on('scrollbar:add', this._onHorizontalScrollbarGain, this);
            				if (this._horizontalScrollbarEntity.scrollbar) {
            						this._onHorizontalScrollbarGain();
            				}
            		}
            		_verticalScrollbarEntitySubscribe() {
            				this._evtVerticalScrollbarAdd = this._verticalScrollbarEntity.on('scrollbar:add', this._onVerticalScrollbarGain, this);
            				if (this._verticalScrollbarEntity.scrollbar) {
            						this._onVerticalScrollbarGain();
            				}
            		}
            		_horizontalScrollbarEntityUnsubscribe() {
            				var _this__evtHorizontalScrollbarAdd;
            				(_this__evtHorizontalScrollbarAdd = this._evtHorizontalScrollbarAdd) == null ? void 0 : _this__evtHorizontalScrollbarAdd.off();
            				this._evtHorizontalScrollbarAdd = null;
            				if (this._horizontalScrollbarEntity.scrollbar) {
            						this._onHorizontalScrollbarLose();
            				}
            		}
            		_verticalScrollbarEntityUnsubscribe() {
            				var _this__evtVerticalScrollbarAdd;
            				(_this__evtVerticalScrollbarAdd = this._evtVerticalScrollbarAdd) == null ? void 0 : _this__evtVerticalScrollbarAdd.off();
            				this._evtVerticalScrollbarAdd = null;
            				if (this._verticalScrollbarEntity.scrollbar) {
            						this._onVerticalScrollbarLose();
            				}
            		}
            		_onSetHorizontalScrollbarValue(scrollValueX) {
            				if (!this._scrollbarUpdateFlags[ORIENTATION_HORIZONTAL] && this.enabled && this.entity.enabled) {
            						this._onSetScroll(scrollValueX, null);
            				}
            		}
            		_onSetVerticalScrollbarValue(scrollValueY) {
            				if (!this._scrollbarUpdateFlags[ORIENTATION_VERTICAL] && this.enabled && this.entity.enabled) {
            						this._onSetScroll(null, scrollValueY);
            				}
            		}
            		_onHorizontalScrollbarGain() {
            				var _this__horizontalScrollbarEntity;
            				var scrollbar = (_this__horizontalScrollbarEntity = this._horizontalScrollbarEntity) == null ? void 0 : _this__horizontalScrollbarEntity.scrollbar;
            				this._evtHorizontalScrollbarRemove = scrollbar.on('beforeremove', this._onHorizontalScrollbarLose, this);
            				this._evtHorizontalScrollbarValue = scrollbar.on('set:value', this._onSetHorizontalScrollbarValue, this);
            				this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
            				this._syncScrollbarPosition(ORIENTATION_HORIZONTAL);
            		}
            		_onVerticalScrollbarGain() {
            				var _this__verticalScrollbarEntity;
            				var scrollbar = (_this__verticalScrollbarEntity = this._verticalScrollbarEntity) == null ? void 0 : _this__verticalScrollbarEntity.scrollbar;
            				this._evtVerticalScrollbarRemove = scrollbar.on('beforeremove', this._onVerticalScrollbarLose, this);
            				this._evtVerticalScrollbarValue = scrollbar.on('set:value', this._onSetVerticalScrollbarValue, this);
            				this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
            				this._syncScrollbarPosition(ORIENTATION_VERTICAL);
            		}
            		_onHorizontalScrollbarLose() {
            				var _this__evtHorizontalScrollbarRemove, _this__evtHorizontalScrollbarValue;
            				(_this__evtHorizontalScrollbarRemove = this._evtHorizontalScrollbarRemove) == null ? void 0 : _this__evtHorizontalScrollbarRemove.off();
            				this._evtHorizontalScrollbarRemove = null;
            				(_this__evtHorizontalScrollbarValue = this._evtHorizontalScrollbarValue) == null ? void 0 : _this__evtHorizontalScrollbarValue.off();
            				this._evtHorizontalScrollbarValue = null;
            		}
            		_onVerticalScrollbarLose() {
            				var _this__evtVerticalScrollbarRemove, _this__evtVerticalScrollbarValue;
            				(_this__evtVerticalScrollbarRemove = this._evtVerticalScrollbarRemove) == null ? void 0 : _this__evtVerticalScrollbarRemove.off();
            				this._evtVerticalScrollbarRemove = null;
            				(_this__evtVerticalScrollbarValue = this._evtVerticalScrollbarValue) == null ? void 0 : _this__evtVerticalScrollbarValue.off();
            				this._evtVerticalScrollbarValue = null;
            		}
            		_onSetHorizontalScrollingEnabled() {
            				this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
            		}
            		_onSetVerticalScrollingEnabled() {
            				this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
            		}
            		_onSetScroll(x, y, resetVelocity) {
            				if (resetVelocity !== false) {
            						this._velocity.set(0, 0, 0);
            				}
            				var xChanged = this._updateAxis(x, 'x', ORIENTATION_HORIZONTAL);
            				var yChanged = this._updateAxis(y, 'y', ORIENTATION_VERTICAL);
            				if (xChanged || yChanged) {
            						this.fire('set:scroll', this._scroll);
            				}
            		}
            		_updateAxis(scrollValue, axis, orientation) {
            				var hasChanged = scrollValue !== null && Math.abs(scrollValue - this._scroll[axis]) > 1e-5;
            				if (hasChanged || this._isDragging() || scrollValue === 0) {
            						this._scroll[axis] = this._determineNewScrollValue(scrollValue, axis, orientation);
            						this._syncContentPosition(orientation);
            						this._syncScrollbarPosition(orientation);
            				}
            				return hasChanged;
            		}
            		_determineNewScrollValue(scrollValue, axis, orientation) {
            				if (!this._getScrollingEnabled(orientation)) {
            						return this._scroll[axis];
            				}
            				switch(this.scrollMode){
            						case SCROLL_MODE_CLAMP:
            								return math.clamp(scrollValue, 0, this._getMaxScrollValue(orientation));
            						case SCROLL_MODE_BOUNCE:
            								this._setVelocityFromOvershoot(scrollValue, axis, orientation);
            								return scrollValue;
            						case SCROLL_MODE_INFINITE:
            								return scrollValue;
            						default:
            								console.warn("Unhandled scroll mode:" + this.scrollMode);
            								return scrollValue;
            				}
            		}
            		_syncAll() {
            				this._syncContentPosition(ORIENTATION_HORIZONTAL);
            				this._syncContentPosition(ORIENTATION_VERTICAL);
            				this._syncScrollbarPosition(ORIENTATION_HORIZONTAL);
            				this._syncScrollbarPosition(ORIENTATION_VERTICAL);
            				this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
            				this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
            		}
            		_syncContentPosition(orientation) {
            				if (!this._contentEntity) {
            						return;
            				}
            				var axis = this._getAxis(orientation);
            				var sign = this._getSign(orientation);
            				var prevContentSize = this._prevContentSizes[orientation];
            				var currContentSize = this._getContentSize(orientation);
            				if (prevContentSize !== null && Math.abs(prevContentSize - currContentSize) > 1e-4) {
            						var prevMaxOffset = this._getMaxOffset(orientation, prevContentSize);
            						var currMaxOffset = this._getMaxOffset(orientation, currContentSize);
            						if (currMaxOffset === 0) {
            								this._scroll[axis] = 1;
            						} else {
            								this._scroll[axis] = math.clamp(this._scroll[axis] * prevMaxOffset / currMaxOffset, 0, 1);
            						}
            				}
            				var offset = this._scroll[axis] * this._getMaxOffset(orientation);
            				var contentPosition = this._contentEntity.getLocalPosition();
            				contentPosition[axis] = offset * sign;
            				this._contentEntity.setLocalPosition(contentPosition);
            				this._prevContentSizes[orientation] = currContentSize;
            		}
            		_syncScrollbarPosition(orientation) {
            				var scrollbarEntity = this._scrollbarEntities[orientation];
            				if (!(scrollbarEntity == null ? void 0 : scrollbarEntity.scrollbar)) {
            						return;
            				}
            				var axis = this._getAxis(orientation);
            				this._scrollbarUpdateFlags[orientation] = true;
            				scrollbarEntity.scrollbar.value = this._scroll[axis];
            				scrollbarEntity.scrollbar.handleSize = this._getScrollbarHandleSize(axis, orientation);
            				this._scrollbarUpdateFlags[orientation] = false;
            		}
            		_syncScrollbarEnabledState(orientation) {
            				var entity = this._scrollbarEntities[orientation];
            				if (!entity) {
            						return;
            				}
            				var isScrollingEnabled = this._getScrollingEnabled(orientation);
            				var requestedVisibility = this._getScrollbarVisibility(orientation);
            				switch(requestedVisibility){
            						case SCROLLBAR_VISIBILITY_SHOW_ALWAYS:
            								entity.enabled = isScrollingEnabled;
            								return;
            						case SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED:
            								entity.enabled = isScrollingEnabled && this._contentIsLargerThanViewport(orientation);
            								return;
            						default:
            								console.warn("Unhandled scrollbar visibility:" + requestedVisibility);
            								entity.enabled = isScrollingEnabled;
            				}
            		}
            		_contentIsLargerThanViewport(orientation) {
            				return this._getContentSize(orientation) > this._getViewportSize(orientation);
            		}
            		_contentPositionToScrollValue(contentPosition) {
            				var maxOffsetH = this._getMaxOffset(ORIENTATION_HORIZONTAL);
            				var maxOffsetV = this._getMaxOffset(ORIENTATION_VERTICAL);
            				if (maxOffsetH === 0) {
            						_tempScrollValue.x = 0;
            				} else {
            						_tempScrollValue.x = contentPosition.x / maxOffsetH;
            				}
            				if (maxOffsetV === 0) {
            						_tempScrollValue.y = 0;
            				} else {
            						_tempScrollValue.y = contentPosition.y / -maxOffsetV;
            				}
            				return _tempScrollValue;
            		}
            		_getMaxOffset(orientation, contentSize) {
            				contentSize = contentSize === undefined ? this._getContentSize(orientation) : contentSize;
            				var viewportSize = this._getViewportSize(orientation);
            				if (contentSize < viewportSize) {
            						return -this._getViewportSize(orientation);
            				}
            				return viewportSize - contentSize;
            		}
            		_getMaxScrollValue(orientation) {
            				return this._contentIsLargerThanViewport(orientation) ? 1 : 0;
            		}
            		_getScrollbarHandleSize(axis, orientation) {
            				var viewportSize = this._getViewportSize(orientation);
            				var contentSize = this._getContentSize(orientation);
            				if (Math.abs(contentSize) < 0.001) {
            						return 1;
            				}
            				var handleSize = Math.min(viewportSize / contentSize, 1);
            				var overshoot = this._toOvershoot(this._scroll[axis], orientation);
            				if (overshoot === 0) {
            						return handleSize;
            				}
            				return handleSize / (1 + Math.abs(overshoot));
            		}
            		_getViewportSize(orientation) {
            				return this._getSize(orientation, this._viewportEntity);
            		}
            		_getContentSize(orientation) {
            				return this._getSize(orientation, this._contentEntity);
            		}
            		_getSize(orientation, entity) {
            				if (entity == null ? void 0 : entity.element) {
            						return entity.element[this._getCalculatedDimension(orientation)];
            				}
            				return 0;
            		}
            		_getScrollingEnabled(orientation) {
            				if (orientation === ORIENTATION_HORIZONTAL) {
            						return this.horizontal;
            				} else if (orientation === ORIENTATION_VERTICAL) {
            						return this.vertical;
            				}
            				return undefined;
            		}
            		_getScrollbarVisibility(orientation) {
            				if (orientation === ORIENTATION_HORIZONTAL) {
            						return this.horizontalScrollbarVisibility;
            				} else if (orientation === ORIENTATION_VERTICAL) {
            						return this.verticalScrollbarVisibility;
            				}
            				return undefined;
            		}
            		_getSign(orientation) {
            				return orientation === ORIENTATION_HORIZONTAL ? 1 : -1;
            		}
            		_getAxis(orientation) {
            				return orientation === ORIENTATION_HORIZONTAL ? 'x' : 'y';
            		}
            		_getCalculatedDimension(orientation) {
            				return orientation === ORIENTATION_HORIZONTAL ? 'calculatedWidth' : 'calculatedHeight';
            		}
            		_destroyDragHelper() {
            				if (this._contentDragHelper) {
            						this._contentDragHelper.destroy();
            				}
            		}
            		onUpdate() {
            				if (this._contentEntity) {
            						this._updateVelocity();
            						this._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);
            						this._syncScrollbarEnabledState(ORIENTATION_VERTICAL);
            				}
            		}
            		_updateVelocity() {
            				if (!this._isDragging()) {
            						if (this.scrollMode === SCROLL_MODE_BOUNCE) {
            								if (this._hasOvershoot('x', ORIENTATION_HORIZONTAL)) {
            										this._setVelocityFromOvershoot(this.scroll.x, 'x', ORIENTATION_HORIZONTAL);
            								}
            								if (this._hasOvershoot('y', ORIENTATION_VERTICAL)) {
            										this._setVelocityFromOvershoot(this.scroll.y, 'y', ORIENTATION_VERTICAL);
            								}
            						}
            						if (Math.abs(this._velocity.x) > 1e-4 || Math.abs(this._velocity.y) > 1e-4) {
            								var position = this._contentEntity.getLocalPosition();
            								position.x += this._velocity.x;
            								position.y += this._velocity.y;
            								this._contentEntity.setLocalPosition(position);
            								this._setScrollFromContentPosition(position);
            						}
            						this._velocity.x *= 1 - this.friction;
            						this._velocity.y *= 1 - this.friction;
            				}
            		}
            		_hasOvershoot(axis, orientation) {
            				return Math.abs(this._toOvershoot(this.scroll[axis], orientation)) > 0.001;
            		}
            		_toOvershoot(scrollValue, orientation) {
            				var maxScrollValue = this._getMaxScrollValue(orientation);
            				if (scrollValue < 0) {
            						return scrollValue;
            				} else if (scrollValue > maxScrollValue) {
            						return scrollValue - maxScrollValue;
            				}
            				return 0;
            		}
            		_setVelocityFromOvershoot(scrollValue, axis, orientation) {
            				var overshootValue = this._toOvershoot(scrollValue, orientation);
            				var overshootPixels = overshootValue * this._getMaxOffset(orientation) * this._getSign(orientation);
            				if (Math.abs(overshootPixels) > 0) {
            						this._velocity[axis] = -overshootPixels / (this.bounceAmount * 50 + 1);
            				}
            		}
            		_setVelocityFromContentPositionDelta(position) {
            				if (this._prevContentDragPosition) {
            						this._velocity.sub2(position, this._prevContentDragPosition);
            						this._prevContentDragPosition.copy(position);
            				} else {
            						this._velocity.set(0, 0, 0);
            						this._prevContentDragPosition = position.clone();
            				}
            		}
            		_setScrollFromContentPosition(position) {
            				var scrollValue = this._contentPositionToScrollValue(position);
            				if (this._isDragging()) {
            						scrollValue = this._applyScrollValueTension(scrollValue);
            				}
            				this._onSetScroll(scrollValue.x, scrollValue.y, false);
            		}
            		_applyScrollValueTension(scrollValue) {
            				var factor = 1;
            				var max = this._getMaxScrollValue(ORIENTATION_HORIZONTAL);
            				var overshoot = this._toOvershoot(scrollValue.x, ORIENTATION_HORIZONTAL);
            				if (overshoot > 0) {
            						scrollValue.x = max + factor * Math.log10(1 + overshoot);
            				} else if (overshoot < 0) {
            						scrollValue.x = -1 * Math.log10(1 - overshoot);
            				}
            				max = this._getMaxScrollValue(ORIENTATION_VERTICAL);
            				overshoot = this._toOvershoot(scrollValue.y, ORIENTATION_VERTICAL);
            				if (overshoot > 0) {
            						scrollValue.y = max + factor * Math.log10(1 + overshoot);
            				} else if (overshoot < 0) {
            						scrollValue.y = -1 * Math.log10(1 - overshoot);
            				}
            				return scrollValue;
            		}
            		_isDragging() {
            				return this._contentDragHelper && this._contentDragHelper.isDragging;
            		}
            		_setScrollbarComponentsEnabled(enabled) {
            				var _this__horizontalScrollbarEntity, _this__verticalScrollbarEntity;
            				if ((_this__horizontalScrollbarEntity = this._horizontalScrollbarEntity) == null ? void 0 : _this__horizontalScrollbarEntity.scrollbar) {
            						this._horizontalScrollbarEntity.scrollbar.enabled = enabled;
            				}
            				if ((_this__verticalScrollbarEntity = this._verticalScrollbarEntity) == null ? void 0 : _this__verticalScrollbarEntity.scrollbar) {
            						this._verticalScrollbarEntity.scrollbar.enabled = enabled;
            				}
            		}
            		_setContentDraggingEnabled(enabled) {
            				if (this._contentDragHelper) {
            						this._contentDragHelper.enabled = enabled;
            				}
            		}
            		_onMouseWheel(event) {
            				var _this__contentEntity;
            				if (!this.useMouseWheel || !((_this__contentEntity = this._contentEntity) == null ? void 0 : _this__contentEntity.element)) {
            						return;
            				}
            				var wheelEvent = event.event;
            				var normalizedDeltaX = wheelEvent.deltaX / this._contentEntity.element.calculatedWidth * this.mouseWheelSensitivity.x;
            				var normalizedDeltaY = wheelEvent.deltaY / this._contentEntity.element.calculatedHeight * this.mouseWheelSensitivity.y;
            				var scrollX = math.clamp(this._scroll.x + normalizedDeltaX, 0, this._getMaxScrollValue(ORIENTATION_HORIZONTAL));
            				var scrollY = math.clamp(this._scroll.y + normalizedDeltaY, 0, this._getMaxScrollValue(ORIENTATION_VERTICAL));
            				this.scroll = new Vec2(scrollX, scrollY);
            		}
            		_enableContentInput() {
            				while(this._disabledContentInputEntities.length){
            						var e = this._disabledContentInputEntities.pop();
            						if (e.element) {
            								e.element.useInput = true;
            						}
            				}
            				this._disabledContentInput = false;
            		}
            		_disableContentInput() {
            				var _disableInput = (e)=>{
            						if (e.element && e.element.useInput) {
            								this._disabledContentInputEntities.push(e);
            								e.element.useInput = false;
            						}
            						var children = e.children;
            						for(var i = 0, l = children.length; i < l; i++){
            								_disableInput(children[i]);
            						}
            				};
            				if (this._contentEntity) {
            						var children = this._contentEntity.children;
            						for(var i = 0, l = children.length; i < l; i++){
            								_disableInput(children[i]);
            						}
            				}
            				this._disabledContentInput = true;
            		}
            		onEnable() {
            				this._setScrollbarComponentsEnabled(true);
            				this._setContentDraggingEnabled(true);
            				this._syncAll();
            		}
            		onDisable() {
            				this._setScrollbarComponentsEnabled(false);
            				this._setContentDraggingEnabled(false);
            		}
            		onRemove() {
            				this._toggleLifecycleListeners('off');
            				this._toggleElementListeners('off');
            				this._destroyDragHelper();
            		}
            		resolveDuplicatedEntityReferenceProperties(oldScrollView, duplicatedIdsMap) {
            				if (oldScrollView.viewportEntity) {
            						this.viewportEntity = duplicatedIdsMap[oldScrollView.viewportEntity.getGuid()];
            				}
            				if (oldScrollView.contentEntity) {
            						this.contentEntity = duplicatedIdsMap[oldScrollView.contentEntity.getGuid()];
            				}
            				if (oldScrollView.horizontalScrollbarEntity) {
            						this.horizontalScrollbarEntity = duplicatedIdsMap[oldScrollView.horizontalScrollbarEntity.getGuid()];
            				}
            				if (oldScrollView.verticalScrollbarEntity) {
            						this.verticalScrollbarEntity = duplicatedIdsMap[oldScrollView.verticalScrollbarEntity.getGuid()];
            				}
            		}
            		constructor(system, entity){
            				super(system, entity), this._viewportEntity = null, this._contentEntity = null, this._horizontalScrollbarEntity = null, this._verticalScrollbarEntity = null, this._evtElementRemove = null, this._evtViewportElementRemove = null, this._evtViewportResize = null, this._evtContentEntityElementAdd = null, this._evtContentElementRemove = null, this._evtContentResize = null, this._evtHorizontalScrollbarAdd = null, this._evtHorizontalScrollbarRemove = null, this._evtHorizontalScrollbarValue = null, this._evtVerticalScrollbarAdd = null, this._evtVerticalScrollbarRemove = null, this._evtVerticalScrollbarValue = null;
            				this._scrollbarUpdateFlags = {};
            				this._scrollbarEntities = {};
            				this._prevContentSizes = {};
            				this._prevContentSizes[ORIENTATION_HORIZONTAL] = null;
            				this._prevContentSizes[ORIENTATION_VERTICAL] = null;
            				this._scroll = new Vec2();
            				this._velocity = new Vec3();
            				this._dragStartPosition = new Vec3();
            				this._disabledContentInput = false;
            				this._disabledContentInputEntities = [];
            				this._toggleLifecycleListeners('on');
            				this._toggleElementListeners('on');
            		}
            }
            ScrollViewComponent.EVENT_SETSCROLL = 'set:scroll';
            
            var DEFAULT_DRAG_THRESHOLD$1 = 10;
            class ScrollViewComponentData {
            		constructor(){
            				this.enabled = true;
            				this.dragThreshold = DEFAULT_DRAG_THRESHOLD$1;
            				this.useMouseWheel = true;
            				this.mouseWheelSensitivity = new Vec2(1, 1);
            				this.horizontalScrollbarVisibility = 0;
            				this.verticalScrollbarVisibility = 0;
            				this.viewportEntity = null;
            				this.contentEntity = null;
            				this.horizontalScrollbarEntity = null;
            				this.verticalScrollbarEntity = null;
            		}
            }
            
            var _schema$6 = [
            		{
            				name: 'enabled',
            				type: 'boolean'
            		},
            		{
            				name: 'horizontal',
            				type: 'boolean'
            		},
            		{
            				name: 'vertical',
            				type: 'boolean'
            		},
            		{
            				name: 'scrollMode',
            				type: 'number'
            		},
            		{
            				name: 'bounceAmount',
            				type: 'number'
            		},
            		{
            				name: 'friction',
            				type: 'number'
            		},
            		{
            				name: 'dragThreshold',
            				type: 'number'
            		},
            		{
            				name: 'useMouseWheel',
            				type: 'boolean'
            		},
            		{
            				name: 'mouseWheelSensitivity',
            				type: 'vec2'
            		},
            		{
            				name: 'horizontalScrollbarVisibility',
            				type: 'number'
            		},
            		{
            				name: 'verticalScrollbarVisibility',
            				type: 'number'
            		}
            ];
            var DEFAULT_DRAG_THRESHOLD = 10;
            class ScrollViewComponentSystem extends ComponentSystem {
            		initializeComponentData(component, data, properties) {
            				if (data.dragThreshold === undefined) {
            						data.dragThreshold = DEFAULT_DRAG_THRESHOLD;
            				}
            				if (data.useMouseWheel === undefined) {
            						data.useMouseWheel = true;
            				}
            				if (data.mouseWheelSensitivity === undefined) {
            						data.mouseWheelSensitivity = new Vec2(1, 1);
            				}
            				super.initializeComponentData(component, data, _schema$6);
            				component.viewportEntity = data.viewportEntity;
            				component.contentEntity = data.contentEntity;
            				component.horizontalScrollbarEntity = data.horizontalScrollbarEntity;
            				component.verticalScrollbarEntity = data.verticalScrollbarEntity;
            		}
            		onUpdate(dt) {
            				var components = this.store;
            				for(var id in components){
            						var entity = components[id].entity;
            						var component = entity.scrollview;
            						if (component.enabled && entity.enabled) {
            								component.onUpdate();
            						}
            				}
            		}
            		_onRemoveComponent(entity, component) {
            				component.onRemove();
            		}
            		destroy() {
            				super.destroy();
            				this.app.systems.off('update', this.onUpdate, this);
            		}
            		constructor(app){
            				super(app);
            				this.id = 'scrollview';
            				this.ComponentType = ScrollViewComponent;
            				this.DataType = ScrollViewComponentData;
            				this.schema = _schema$6;
            				this.on('beforeremove', this._onRemoveComponent, this);
            				this.app.systems.on('update', this.onUpdate, this);
            		}
            }
            
            class ScrollbarComponent extends Component {
            		get data() {
            				var record = this.system.store[this.entity.getGuid()];
            				return record ? record.data : null;
            		}
            		set enabled(arg) {
            				this._setValue('enabled', arg);
            		}
            		get enabled() {
            				return this.data.enabled;
            		}
            		set orientation(arg) {
            				this._setValue('orientation', arg);
            		}
            		get orientation() {
            				return this.data.orientation;
            		}
            		set value(arg) {
            				this._setValue('value', arg);
            		}
            		get value() {
            				return this.data.value;
            		}
            		set handleSize(arg) {
            				this._setValue('handleSize', arg);
            		}
            		get handleSize() {
            				return this.data.handleSize;
            		}
            		set handleEntity(arg) {
            				if (this._handleEntity === arg) {
            						return;
            				}
            				var isString = typeof arg === 'string';
            				if (this._handleEntity && isString && this._handleEntity.getGuid() === arg) {
            						return;
            				}
            				if (this._handleEntity) {
            						this._handleEntityUnsubscribe();
            				}
            				if (arg instanceof GraphNode) {
            						this._handleEntity = arg;
            				} else if (isString) {
            						this._handleEntity = this.system.app.getEntityFromIndex(arg) || null;
            				} else {
            						this._handleEntity = null;
            				}
            				if (this._handleEntity) {
            						this._handleEntitySubscribe();
            				}
            				if (this._handleEntity) {
            						this.data.handleEntity = this._handleEntity.getGuid();
            				} else if (isString && arg) {
            						this.data.handleEntity = arg;
            				}
            		}
            		get handleEntity() {
            				return this._handleEntity;
            		}
            		_setValue(name, value) {
            				var data = this.data;
            				var oldValue = data[name];
            				data[name] = value;
            				this.fire('set', name, oldValue, value);
            		}
            		_toggleLifecycleListeners(onOrOff) {
            				this[onOrOff]('set_value', this._onSetValue, this);
            				this[onOrOff]('set_handleSize', this._onSetHandleSize, this);
            				this[onOrOff]('set_orientation', this._onSetOrientation, this);
            		}
            		_handleEntitySubscribe() {
            				this._evtHandleEntityElementAdd = this._handleEntity.on('element:add', this._onHandleElementGain, this);
            				if (this._handleEntity.element) {
            						this._onHandleElementGain();
            				}
            		}
            		_handleEntityUnsubscribe() {
            				var _this__evtHandleEntityElementAdd, _this__handleEntity;
            				(_this__evtHandleEntityElementAdd = this._evtHandleEntityElementAdd) == null ? void 0 : _this__evtHandleEntityElementAdd.off();
            				this._evtHandleEntityElementAdd = null;
            				if ((_this__handleEntity = this._handleEntity) == null ? void 0 : _this__handleEntity.element) {
            						this._onHandleElementLose();
            				}
            		}
            		_handleEntityElementSubscribe() {
            				var element = this._handleEntity.element;
            				var handles = this._evtHandleEntityChanges;
            				handles.push(element.once('beforeremove', this._onHandleElementLose, this));
            				handles.push(element.on('set:anchor', this._onSetHandleAlignment, this));
            				handles.push(element.on('set:margin', this._onSetHandleAlignment, this));
            				handles.push(element.on('set:pivot', this._onSetHandleAlignment, this));
            		}
            		_handleEntityElementUnsubscribe() {
            				for(var i = 0; i < this._evtHandleEntityChanges.length; i++){
            						this._evtHandleEntityChanges[i].off();
            				}
            				this._evtHandleEntityChanges.length = 0;
            		}
            		_onHandleElementGain() {
            				this._handleEntityElementSubscribe();
            				this._destroyDragHelper();
            				this._handleDragHelper = new ElementDragHelper(this._handleEntity.element, this._getAxis());
            				this._handleDragHelper.on('drag:move', this._onHandleDrag, this);
            				this._updateHandlePositionAndSize();
            		}
            		_onHandleElementLose() {
            				this._handleEntityElementUnsubscribe();
            				this._destroyDragHelper();
            		}
            		_onHandleDrag(position) {
            				if (this._handleEntity && this.enabled && this.entity.enabled) {
            						this.value = this._handlePositionToScrollValue(position[this._getAxis()]);
            				}
            		}
            		_onSetValue(name, oldValue, newValue) {
            				if (Math.abs(newValue - oldValue) > 1e-5) {
            						this.data.value = math.clamp(newValue, 0, 1);
            						this._updateHandlePositionAndSize();
            						this.fire('set:value', this.data.value);
            				}
            		}
            		_onSetHandleSize(name, oldValue, newValue) {
            				if (Math.abs(newValue - oldValue) > 1e-5) {
            						this.data.handleSize = math.clamp(newValue, 0, 1);
            						this._updateHandlePositionAndSize();
            				}
            		}
            		_onSetHandleAlignment() {
            				this._updateHandlePositionAndSize();
            		}
            		_onSetOrientation(name, oldValue, newValue) {
            				var _this__handleEntity;
            				if (newValue !== oldValue && ((_this__handleEntity = this._handleEntity) == null ? void 0 : _this__handleEntity.element)) {
            						this._handleEntity.element[this._getOppositeDimension()] = 0;
            				}
            		}
            		_updateHandlePositionAndSize() {
            				var handleEntity = this._handleEntity;
            				var handleElement = handleEntity == null ? void 0 : handleEntity.element;
            				if (handleEntity) {
            						var position = handleEntity.getLocalPosition();
            						position[this._getAxis()] = this._getHandlePosition();
            						handleEntity.setLocalPosition(position);
            				}
            				if (handleElement) {
            						handleElement[this._getDimension()] = this._getHandleLength();
            				}
            		}
            		_handlePositionToScrollValue(handlePosition) {
            				return handlePosition * this._getSign() / this._getUsableTrackLength();
            		}
            		_scrollValueToHandlePosition(value) {
            				return value * this._getSign() * this._getUsableTrackLength();
            		}
            		_getUsableTrackLength() {
            				return Math.max(this._getTrackLength() - this._getHandleLength(), 0.001);
            		}
            		_getTrackLength() {
            				if (this.entity.element) {
            						return this.orientation === ORIENTATION_HORIZONTAL ? this.entity.element.calculatedWidth : this.entity.element.calculatedHeight;
            				}
            				return 0;
            		}
            		_getHandleLength() {
            				return this._getTrackLength() * this.handleSize;
            		}
            		_getHandlePosition() {
            				return this._scrollValueToHandlePosition(this.value);
            		}
            		_getSign() {
            				return this.orientation === ORIENTATION_HORIZONTAL ? 1 : -1;
            		}
            		_getAxis() {
            				return this.orientation === ORIENTATION_HORIZONTAL ? 'x' : 'y';
            		}
            		_getDimension() {
            				return this.orientation === ORIENTATION_HORIZONTAL ? 'width' : 'height';
            		}
            		_getOppositeDimension() {
            				return this.orientation === ORIENTATION_HORIZONTAL ? 'height' : 'width';
            		}
            		_destroyDragHelper() {
            				if (this._handleDragHelper) {
            						this._handleDragHelper.destroy();
            				}
            		}
            		_setHandleDraggingEnabled(enabled) {
            				if (this._handleDragHelper) {
            						this._handleDragHelper.enabled = enabled;
            				}
            		}
            		onEnable() {
            				this._setHandleDraggingEnabled(true);
            		}
            		onDisable() {
            				this._setHandleDraggingEnabled(false);
            		}
            		onRemove() {
            				this._destroyDragHelper();
            				this._toggleLifecycleListeners('off');
            		}
            		resolveDuplicatedEntityReferenceProperties(oldScrollbar, duplicatedIdsMap) {
            				if (oldScrollbar.handleEntity) {
            						this.handleEntity = duplicatedIdsMap[oldScrollbar.handleEntity.getGuid()];
            				}
            		}
            		constructor(system, entity){
            				super(system, entity), this._handleEntity = null, this._evtHandleEntityElementAdd = null, this._evtHandleEntityChanges = [];
            				this._toggleLifecycleListeners('on');
            		}
            }
            ScrollbarComponent.EVENT_SETVALUE = 'set:value';
            
            class ScrollbarComponentData {
            		constructor(){
            				this.enabled = true;
            				this.orientation = ORIENTATION_HORIZONTAL;
            				this.value = 0;
            				this.handleSize = 0;
            				this.handleEntity = null;
            		}
            }
            
            var _schema$5 = [
            		{
            				name: 'enabled',
            				type: 'boolean'
            		},
            		{
            				name: 'orientation',
            				type: 'number'
            		},
            		{
            				name: 'value',
            				type: 'number'
            		},
            		{
            				name: 'handleSize',
            				type: 'number'
            		}
            ];
            class ScrollbarComponentSystem extends ComponentSystem {
            		initializeComponentData(component, data, properties) {
            				super.initializeComponentData(component, data, _schema$5);
            				component.handleEntity = data.handleEntity;
            		}
            		_onAddComponent(entity) {
            				entity.fire('scrollbar:add');
            		}
            		_onRemoveComponent(entity, component) {
            				component.onRemove();
            		}
            		constructor(app){
            				super(app);
            				this.id = 'scrollbar';
            				this.ComponentType = ScrollbarComponent;
            				this.DataType = ScrollbarComponentData;
            				this.schema = _schema$5;
            				this.on('add', this._onAddComponent, this);
            				this.on('beforeremove', this._onRemoveComponent, this);
            		}
            }
            
            var instanceOptions = {
            		volume: 0,
            		pitch: 0,
            		loop: false,
            		startTime: 0,
            		duration: 0,
            		position: new Vec3(),
            		maxDistance: 0,
            		refDistance: 0,
            		rollOffFactor: 0,
            		distanceModel: 0,
            		onPlay: null,
            		onPause: null,
            		onResume: null,
            		onStop: null,
            		onEnd: null
            };
            class SoundSlot extends EventHandler {
            		play() {
            				if (!this.overlap) {
            						this.stop();
            				}
            				if (!this.isLoaded && !this._hasAsset()) {
            						return undefined;
            				}
            				var instance = this._createInstance();
            				this.instances.push(instance);
            				if (!this.isLoaded) {
            						var onLoad = function onLoad(sound) {
            								var playWhenLoaded = instance._playWhenLoaded;
            								instance.sound = sound;
            								if (playWhenLoaded) {
            										instance.play();
            								}
            						};
            						this.off('load', onLoad);
            						this.once('load', onLoad);
            						this.load();
            				} else {
            						instance.play();
            				}
            				return instance;
            		}
            		pause() {
            				var paused = false;
            				var instances = this.instances;
            				for(var i = 0, len = instances.length; i < len; i++){
            						if (instances[i].pause()) {
            								paused = true;
            						}
            				}
            				return paused;
            		}
            		resume() {
            				var resumed = false;
            				var instances = this.instances;
            				for(var i = 0, len = instances.length; i < len; i++){
            						if (instances[i].resume()) {
            								resumed = true;
            						}
            				}
            				return resumed;
            		}
            		stop() {
            				var stopped = false;
            				var instances = this.instances;
            				var i = instances.length;
            				while(i--){
            						instances[i].stop();
            						stopped = true;
            				}
            				instances.length = 0;
            				return stopped;
            		}
            		load() {
            				if (!this._hasAsset()) {
            						return;
            				}
            				var asset = this._assets.get(this._asset);
            				if (!asset) {
            						this._assets.off("add:" + this._asset, this._onAssetAdd, this);
            						this._assets.once("add:" + this._asset, this._onAssetAdd, this);
            						return;
            				}
            				asset.off('remove', this._onAssetRemoved, this);
            				asset.on('remove', this._onAssetRemoved, this);
            				if (!asset.resource) {
            						asset.off('load', this._onAssetLoad, this);
            						asset.once('load', this._onAssetLoad, this);
            						this._assets.load(asset);
            						return;
            				}
            				this.fire('load', asset.resource);
            		}
            		setExternalNodes(firstNode, lastNode) {
            				if (!firstNode) {
            						console.error('The firstNode must have a valid AudioNode');
            						return;
            				}
            				if (!lastNode) {
            						lastNode = firstNode;
            				}
            				this._firstNode = firstNode;
            				this._lastNode = lastNode;
            				if (!this._overlap) {
            						var instances = this.instances;
            						for(var i = 0, len = instances.length; i < len; i++){
            								instances[i].setExternalNodes(firstNode, lastNode);
            						}
            				}
            		}
            		clearExternalNodes() {
            				this._firstNode = null;
            				this._lastNode = null;
            				if (!this._overlap) {
            						var instances = this.instances;
            						for(var i = 0, len = instances.length; i < len; i++){
            								instances[i].clearExternalNodes();
            						}
            				}
            		}
            		getExternalNodes() {
            				return [
            						this._firstNode,
            						this._lastNode
            				];
            		}
            		_hasAsset() {
            				return this._asset != null;
            		}
            		_createInstance() {
            				var instance = null;
            				var component = this._component;
            				var sound = null;
            				if (this._hasAsset()) {
            						var asset = this._assets.get(this._asset);
            						if (asset) {
            								sound = asset.resource;
            						}
            				}
            				var data = instanceOptions;
            				data.volume = this._volume * component.volume;
            				data.pitch = this._pitch * component.pitch;
            				data.loop = this._loop;
            				data.startTime = this._startTime;
            				data.duration = this._duration;
            				data.onPlay = this._onInstancePlayHandler;
            				data.onPause = this._onInstancePauseHandler;
            				data.onResume = this._onInstanceResumeHandler;
            				data.onStop = this._onInstanceStopHandler;
            				data.onEnd = this._onInstanceEndHandler;
            				if (component.positional) {
            						data.position.copy(component.entity.getPosition());
            						data.maxDistance = component.maxDistance;
            						data.refDistance = component.refDistance;
            						data.rollOffFactor = component.rollOffFactor;
            						data.distanceModel = component.distanceModel;
            						instance = new SoundInstance3d(this._manager, sound, data);
            				} else {
            						instance = new SoundInstance(this._manager, sound, data);
            				}
            				if (this._firstNode) {
            						instance.setExternalNodes(this._firstNode, this._lastNode);
            				}
            				return instance;
            		}
            		_onInstancePlay(instance) {
            				this.fire('play', instance);
            				this._component.fire('play', this, instance);
            		}
            		_onInstancePause(instance) {
            				this.fire('pause', instance);
            				this._component.fire('pause', this, instance);
            		}
            		_onInstanceResume(instance) {
            				this.fire('resume', instance);
            				this._component.fire('resume', this, instance);
            		}
            		_onInstanceStop(instance) {
            				var idx = this.instances.indexOf(instance);
            				if (idx !== -1) {
            						this.instances.splice(idx, 1);
            				}
            				this.fire('stop', instance);
            				this._component.fire('stop', this, instance);
            		}
            		_onInstanceEnd(instance) {
            				var idx = this.instances.indexOf(instance);
            				if (idx !== -1) {
            						this.instances.splice(idx, 1);
            				}
            				this.fire('end', instance);
            				this._component.fire('end', this, instance);
            		}
            		_onAssetAdd(asset) {
            				this.load();
            		}
            		_onAssetLoad(asset) {
            				this.load();
            		}
            		_onAssetRemoved(asset) {
            				asset.off('remove', this._onAssetRemoved, this);
            				this._assets.off("add:" + asset.id, this._onAssetAdd, this);
            				this.stop();
            		}
            		updatePosition(position) {
            				var instances = this.instances;
            				for(var i = 0, len = instances.length; i < len; i++){
            						instances[i].position = position;
            				}
            		}
            		set asset(value) {
            				var old = this._asset;
            				if (old) {
            						this._assets.off("add:" + old, this._onAssetAdd, this);
            						var oldAsset = this._assets.get(old);
            						if (oldAsset) {
            								oldAsset.off('remove', this._onAssetRemoved, this);
            						}
            				}
            				this._asset = value;
            				if (this._asset instanceof Asset) {
            						this._asset = this._asset.id;
            				}
            				if (this._hasAsset() && this._component.enabled && this._component.entity.enabled) {
            						this.load();
            				}
            		}
            		get asset() {
            				return this._asset;
            		}
            		set autoPlay(value) {
            				this._autoPlay = !!value;
            		}
            		get autoPlay() {
            				return this._autoPlay;
            		}
            		set duration(value) {
            				this._duration = Math.max(0, Number(value) || 0) || null;
            				if (!this._overlap) {
            						var instances = this.instances;
            						for(var i = 0, len = instances.length; i < len; i++){
            								instances[i].duration = this._duration;
            						}
            				}
            		}
            		get duration() {
            				var assetDuration = 0;
            				if (this._hasAsset()) {
            						var asset = this._assets.get(this._asset);
            						assetDuration = (asset == null ? void 0 : asset.resource) ? asset.resource.duration : 0;
            				}
            				if (this._duration != null) {
            						return this._duration % (assetDuration || 1);
            				}
            				return assetDuration;
            		}
            		get isLoaded() {
            				if (this._hasAsset()) {
            						var asset = this._assets.get(this._asset);
            						if (asset) {
            								return !!asset.resource;
            						}
            				}
            				return false;
            		}
            		get isPaused() {
            				var instances = this.instances;
            				var len = instances.length;
            				if (len === 0) {
            						return false;
            				}
            				for(var i = 0; i < len; i++){
            						if (!instances[i].isPaused) {
            								return false;
            						}
            				}
            				return true;
            		}
            		get isPlaying() {
            				var instances = this.instances;
            				for(var i = 0, len = instances.length; i < len; i++){
            						if (instances[i].isPlaying) {
            								return true;
            						}
            				}
            				return false;
            		}
            		get isStopped() {
            				var instances = this.instances;
            				for(var i = 0, len = instances.length; i < len; i++){
            						if (!instances[i].isStopped) {
            								return false;
            						}
            				}
            				return true;
            		}
            		set loop(value) {
            				this._loop = !!value;
            				var instances = this.instances;
            				for(var i = 0, len = instances.length; i < len; i++){
            						instances[i].loop = this._loop;
            				}
            		}
            		get loop() {
            				return this._loop;
            		}
            		set overlap(value) {
            				this._overlap = !!value;
            		}
            		get overlap() {
            				return this._overlap;
            		}
            		set pitch(value) {
            				this._pitch = Math.max(Number(value) || 0, 0.01);
            				if (!this._overlap) {
            						var instances = this.instances;
            						for(var i = 0, len = instances.length; i < len; i++){
            								instances[i].pitch = this.pitch * this._component.pitch;
            						}
            				}
            		}
            		get pitch() {
            				return this._pitch;
            		}
            		set startTime(value) {
            				this._startTime = Math.max(0, Number(value) || 0);
            				if (!this._overlap) {
            						var instances = this.instances;
            						for(var i = 0, len = instances.length; i < len; i++){
            								instances[i].startTime = this._startTime;
            						}
            				}
            		}
            		get startTime() {
            				return this._startTime;
            		}
            		set volume(value) {
            				this._volume = math.clamp(Number(value) || 0, 0, 1);
            				if (!this._overlap) {
            						var instances = this.instances;
            						for(var i = 0, len = instances.length; i < len; i++){
            								instances[i].volume = this._volume * this._component.volume;
            						}
            				}
            		}
            		get volume() {
            				return this._volume;
            		}
            		constructor(component, name = 'Untitled', options = {}){
            				super(), this.instances = [];
            				this._component = component;
            				this._assets = component.system.app.assets;
            				this._manager = component.system.manager;
            				this.name = name;
            				this._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;
            				this._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;
            				this._loop = !!(options.loop !== undefined ? options.loop : false);
            				this._duration = options.duration > 0 ? options.duration : null;
            				this._startTime = Math.max(0, Number(options.startTime) || 0);
            				this._overlap = !!options.overlap;
            				this._autoPlay = !!options.autoPlay;
            				this._firstNode = null;
            				this._lastNode = null;
            				this._asset = options.asset;
            				if (this._asset instanceof Asset) {
            						this._asset = this._asset.id;
            				}
            				this._onInstancePlayHandler = this._onInstancePlay.bind(this);
            				this._onInstancePauseHandler = this._onInstancePause.bind(this);
            				this._onInstanceResumeHandler = this._onInstanceResume.bind(this);
            				this._onInstanceStopHandler = this._onInstanceStop.bind(this);
            				this._onInstanceEndHandler = this._onInstanceEnd.bind(this);
            		}
            }
            SoundSlot.EVENT_PLAY = 'play';
            SoundSlot.EVENT_PAUSE = 'pause';
            SoundSlot.EVENT_RESUME = 'resume';
            SoundSlot.EVENT_STOP = 'stop';
            SoundSlot.EVENT_LOAD = 'load';
            
            class SoundComponent extends Component {
            		_updateSoundInstances(property, value, isFactor) {
            				var slots = this._slots;
            				for(var key in slots){
            						var slot = slots[key];
            						if (!slot.overlap) {
            								var instances = slot.instances;
            								for(var i = 0, len = instances.length; i < len; i++){
            										instances[i][property] = isFactor ? slot[property] * value : value;
            								}
            						}
            				}
            		}
            		set distanceModel(value) {
            				this._distanceModel = value;
            				this._updateSoundInstances('distanceModel', value, false);
            		}
            		get distanceModel() {
            				return this._distanceModel;
            		}
            		set maxDistance(value) {
            				this._maxDistance = value;
            				this._updateSoundInstances('maxDistance', value, false);
            		}
            		get maxDistance() {
            				return this._maxDistance;
            		}
            		set refDistance(value) {
            				this._refDistance = value;
            				this._updateSoundInstances('refDistance', value, false);
            		}
            		get refDistance() {
            				return this._refDistance;
            		}
            		set rollOffFactor(value) {
            				this._rollOffFactor = value;
            				this._updateSoundInstances('rollOffFactor', value, false);
            		}
            		get rollOffFactor() {
            				return this._rollOffFactor;
            		}
            		set pitch(value) {
            				this._pitch = value;
            				this._updateSoundInstances('pitch', value, true);
            		}
            		get pitch() {
            				return this._pitch;
            		}
            		set volume(value) {
            				this._volume = value;
            				this._updateSoundInstances('volume', value, true);
            		}
            		get volume() {
            				return this._volume;
            		}
            		set positional(newValue) {
            				this._positional = newValue;
            				var slots = this._slots;
            				for(var key in slots){
            						var slot = slots[key];
            						if (!slot.overlap) {
            								var instances = slot.instances;
            								var oldLength = instances.length;
            								for(var i = oldLength - 1; i >= 0; i--){
            										var isPlaying = instances[i].isPlaying || instances[i].isSuspended;
            										var currentTime = instances[i].currentTime;
            										if (isPlaying) {
            												instances[i].stop();
            										}
            										var instance = slot._createInstance();
            										if (isPlaying) {
            												instance.play();
            												instance.currentTime = currentTime;
            										}
            										instances.push(instance);
            								}
            						}
            				}
            		}
            		get positional() {
            				return this._positional;
            		}
            		set slots(newValue) {
            				var oldValue = this._slots;
            				if (oldValue) {
            						for(var key in oldValue){
            								oldValue[key].stop();
            						}
            				}
            				var slots = {};
            				for(var key1 in newValue){
            						if (!(newValue[key1] instanceof SoundSlot)) {
            								if (newValue[key1].name) {
            										slots[newValue[key1].name] = new SoundSlot(this, newValue[key1].name, newValue[key1]);
            								}
            						} else {
            								slots[newValue[key1].name] = newValue[key1];
            						}
            				}
            				this._slots = slots;
            				if (this.enabled && this.entity.enabled) {
            						this.onEnable();
            				}
            		}
            		get slots() {
            				return this._slots;
            		}
            		onEnable() {
            				if (this.system._inTools) {
            						return;
            				}
            				var slots = this._slots;
            				var playingBeforeDisable = this._playingBeforeDisable;
            				for(var key in slots){
            						var slot = slots[key];
            						if (slot.autoPlay && slot.isStopped) {
            								slot.play();
            						} else if (playingBeforeDisable[key]) {
            								slot.resume();
            						} else if (!slot.isLoaded) {
            								slot.load();
            						}
            				}
            		}
            		onDisable() {
            				var slots = this._slots;
            				var playingBeforeDisable = {};
            				for(var key in slots){
            						if (!slots[key].overlap) {
            								if (slots[key].isPlaying) {
            										slots[key].pause();
            										playingBeforeDisable[key] = true;
            								}
            						}
            				}
            				this._playingBeforeDisable = playingBeforeDisable;
            		}
            		onRemove() {
            				this.off();
            		}
            		addSlot(name, options) {
            				var slots = this._slots;
            				if (slots[name]) {
            						return null;
            				}
            				var slot = new SoundSlot(this, name, options);
            				slots[name] = slot;
            				if (slot.autoPlay && this.enabled && this.entity.enabled) {
            						slot.play();
            				}
            				return slot;
            		}
            		removeSlot(name) {
            				var slots = this._slots;
            				if (slots[name]) {
            						slots[name].stop();
            						delete slots[name];
            				}
            		}
            		slot(name) {
            				return this._slots[name];
            		}
            		_getSlotProperty(name, property) {
            				if (!this.enabled || !this.entity.enabled) {
            						return undefined;
            				}
            				var slot = this._slots[name];
            				if (!slot) {
            						return undefined;
            				}
            				return slot[property];
            		}
            		isPlaying(name) {
            				return this._getSlotProperty(name, 'isPlaying') || false;
            		}
            		isLoaded(name) {
            				return this._getSlotProperty(name, 'isLoaded') || false;
            		}
            		isPaused(name) {
            				return this._getSlotProperty(name, 'isPaused') || false;
            		}
            		isStopped(name) {
            				return this._getSlotProperty(name, 'isStopped') || false;
            		}
            		play(name) {
            				if (!this.enabled || !this.entity.enabled) {
            						return null;
            				}
            				var slot = this._slots[name];
            				if (!slot) {
            						return null;
            				}
            				return slot.play();
            		}
            		pause(name) {
            				var slots = this._slots;
            				if (name) {
            						var slot = slots[name];
            						if (!slot) {
            								return;
            						}
            						slot.pause();
            				} else {
            						for(var key in slots){
            								slots[key].pause();
            						}
            				}
            		}
            		resume(name) {
            				var slots = this._slots;
            				if (name) {
            						var slot = slots[name];
            						if (!slot) {
            								return;
            						}
            						if (slot.isPaused) {
            								slot.resume();
            						}
            				} else {
            						for(var key in slots){
            								slots[key].resume();
            						}
            				}
            		}
            		stop(name) {
            				var slots = this._slots;
            				if (name) {
            						var slot = slots[name];
            						if (!slot) {
            								return;
            						}
            						slot.stop();
            				} else {
            						for(var key in slots){
            								slots[key].stop();
            						}
            				}
            		}
            		constructor(...args){
            				super(...args), this._volume = 1, this._pitch = 1, this._positional = true, this._refDistance = 1, this._maxDistance = 10000, this._rollOffFactor = 1, this._distanceModel = DISTANCE_LINEAR, this._slots = {}, this._playingBeforeDisable = {};
            		}
            }
            SoundComponent.EVENT_PLAY = 'play';
            SoundComponent.EVENT_PAUSE = 'pause';
            SoundComponent.EVENT_RESUME = 'resume';
            SoundComponent.EVENT_STOP = 'stop';
            SoundComponent.EVENT_END = 'end';
            
            class SoundComponentData {
            		constructor(){
            				this.enabled = true;
            		}
            }
            
            var _schema$4 = [
            		'enabled'
            ];
            class SoundComponentSystem extends ComponentSystem {
            		set volume(volume) {
            				this.manager.volume = volume;
            		}
            		get volume() {
            				return this.manager.volume;
            		}
            		get context() {
            				if (!hasAudioContext()) {
            						return null;
            				}
            				return this.manager.context;
            		}
            		initializeComponentData(component, data, properties) {
            				properties = [
            						'volume',
            						'pitch',
            						'positional',
            						'refDistance',
            						'maxDistance',
            						'rollOffFactor',
            						'distanceModel',
            						'slots'
            				];
            				for(var i = 0; i < properties.length; i++){
            						if (data.hasOwnProperty(properties[i])) {
            								component[properties[i]] = data[properties[i]];
            						}
            				}
            				super.initializeComponentData(component, data, [
            						'enabled'
            				]);
            		}
            		cloneComponent(entity, clone) {
            				var srcComponent = entity.sound;
            				var srcSlots = srcComponent.slots;
            				var slots = {};
            				for(var key in srcSlots){
            						var srcSlot = srcSlots[key];
            						slots[key] = {
            								name: srcSlot.name,
            								volume: srcSlot.volume,
            								pitch: srcSlot.pitch,
            								loop: srcSlot.loop,
            								duration: srcSlot.duration,
            								startTime: srcSlot.startTime,
            								overlap: srcSlot.overlap,
            								autoPlay: srcSlot.autoPlay,
            								asset: srcSlot.asset
            						};
            				}
            				var cloneData = {
            						distanceModel: srcComponent.distanceModel,
            						enabled: srcComponent.enabled,
            						maxDistance: srcComponent.maxDistance,
            						pitch: srcComponent.pitch,
            						positional: srcComponent.positional,
            						refDistance: srcComponent.refDistance,
            						rollOffFactor: srcComponent.rollOffFactor,
            						slots: slots,
            						volume: srcComponent.volume
            				};
            				return this.addComponent(clone, cloneData);
            		}
            		onUpdate(dt) {
            				var store = this.store;
            				for(var id in store){
            						if (store.hasOwnProperty(id)) {
            								var item = store[id];
            								var entity = item.entity;
            								if (entity.enabled) {
            										var component = entity.sound;
            										if (component.enabled && component.positional) {
            												var position = entity.getPosition();
            												var slots = component.slots;
            												for(var key in slots){
            														slots[key].updatePosition(position);
            												}
            										}
            								}
            						}
            				}
            		}
            		onBeforeRemove(entity, component) {
            				var slots = component.slots;
            				for(var key in slots){
            						if (!slots[key].overlap) {
            								slots[key].stop();
            						}
            				}
            				component.onRemove();
            		}
            		destroy() {
            				super.destroy();
            				this.app.systems.off('update', this.onUpdate, this);
            		}
            		constructor(app){
            				super(app);
            				this.id = 'sound';
            				this.ComponentType = SoundComponent;
            				this.DataType = SoundComponentData;
            				this.schema = _schema$4;
            				this.manager = app.soundManager;
            				this.app.systems.on('update', this.onUpdate, this);
            				this.on('beforeremove', this.onBeforeRemove, this);
            		}
            }
            Component._buildAccessors(SoundComponent.prototype, _schema$4);
            
            var SPRITETYPE_SIMPLE = 'simple';
            var SPRITETYPE_ANIMATED = 'animated';
            
            class SpriteAnimationClip extends EventHandler {
            		get duration() {
            				if (this._sprite) {
            						var fps = this.fps || Number.MIN_VALUE;
            						return this._sprite.frameKeys.length / Math.abs(fps);
            				}
            				return 0;
            		}
            		set frame(value) {
            				this._setFrame(value);
            				var fps = this.fps || Number.MIN_VALUE;
            				this._setTime(this._frame / fps);
            		}
            		get frame() {
            				return this._frame;
            		}
            		get isPaused() {
            				return this._paused;
            		}
            		get isPlaying() {
            				return this._playing;
            		}
            		set sprite(value) {
            				if (this._sprite) {
            						var _this__evtSetMeshes;
            						(_this__evtSetMeshes = this._evtSetMeshes) == null ? void 0 : _this__evtSetMeshes.off();
            						this._evtSetMeshes = null;
            						this._sprite.off('set:pixelsPerUnit', this._onSpritePpuChanged, this);
            						this._sprite.off('set:atlas', this._onSpriteMeshesChange, this);
            						if (this._sprite.atlas) {
            								this._sprite.atlas.off('set:texture', this._onSpriteMeshesChange, this);
            						}
            				}
            				this._sprite = value;
            				if (this._sprite) {
            						this._evtSetMeshes = this._sprite.on('set:meshes', this._onSpriteMeshesChange, this);
            						this._sprite.on('set:pixelsPerUnit', this._onSpritePpuChanged, this);
            						this._sprite.on('set:atlas', this._onSpriteMeshesChange, this);
            						if (this._sprite.atlas) {
            								this._sprite.atlas.on('set:texture', this._onSpriteMeshesChange, this);
            						}
            				}
            				if (this._component.currentClip === this) {
            						var mi;
            						if (!value || !value.atlas) {
            								mi = this._component._meshInstance;
            								if (mi) {
            										mi.deleteParameter('texture_emissiveMap');
            										mi.deleteParameter('texture_opacityMap');
            								}
            								this._component._hideModel();
            						} else {
            								if (value.atlas.texture) {
            										mi = this._component._meshInstance;
            										if (mi) {
            												mi.setParameter('texture_emissiveMap', value.atlas.texture);
            												mi.setParameter('texture_opacityMap', value.atlas.texture);
            										}
            										if (this._component.enabled && this._component.entity.enabled) {
            												this._component._showModel();
            										}
            								}
            								if (this.time && this.fps) {
            										this.time = this.time;
            								} else {
            										this.frame = this.frame;
            								}
            						}
            				}
            		}
            		get sprite() {
            				return this._sprite;
            		}
            		set spriteAsset(value) {
            				var assets = this._component.system.app.assets;
            				var id = value;
            				if (value instanceof Asset) {
            						id = value.id;
            				}
            				if (this._spriteAsset !== id) {
            						if (this._spriteAsset) {
            								var prev = assets.get(this._spriteAsset);
            								if (prev) {
            										this._unbindSpriteAsset(prev);
            								}
            						}
            						this._spriteAsset = id;
            						if (this._spriteAsset) {
            								var asset = assets.get(this._spriteAsset);
            								if (!asset) {
            										this.sprite = null;
            										assets.on("add:" + this._spriteAsset, this._onSpriteAssetAdded, this);
            								} else {
            										this._bindSpriteAsset(asset);
            								}
            						} else {
            								this.sprite = null;
            						}
            				}
            		}
            		get spriteAsset() {
            				return this._spriteAsset;
            		}
            		set time(value) {
            				this._setTime(value);
            				if (this._sprite) {
            						this.frame = Math.min(this._sprite.frameKeys.length - 1, Math.floor(this._time * Math.abs(this.fps)));
            				} else {
            						this.frame = 0;
            				}
            		}
            		get time() {
            				return this._time;
            		}
            		_onSpriteAssetAdded(asset) {
            				this._component.system.app.assets.off("add:" + asset.id, this._onSpriteAssetAdded, this);
            				if (this._spriteAsset === asset.id) {
            						this._bindSpriteAsset(asset);
            				}
            		}
            		_bindSpriteAsset(asset) {
            				asset.on('load', this._onSpriteAssetLoad, this);
            				asset.on('remove', this._onSpriteAssetRemove, this);
            				if (asset.resource) {
            						this._onSpriteAssetLoad(asset);
            				} else {
            						this._component.system.app.assets.load(asset);
            				}
            		}
            		_unbindSpriteAsset(asset) {
            				if (!asset) {
            						return;
            				}
            				asset.off('load', this._onSpriteAssetLoad, this);
            				asset.off('remove', this._onSpriteAssetRemove, this);
            				if (asset.resource && !asset.resource.atlas) {
            						this._component.system.app.assets.off("load:" + asset.data.textureAtlasAsset, this._onTextureAtlasLoad, this);
            				}
            		}
            		_onSpriteAssetLoad(asset) {
            				if (!asset.resource) {
            						this.sprite = null;
            				} else {
            						if (!asset.resource.atlas) {
            								var atlasAssetId = asset.data.textureAtlasAsset;
            								var assets = this._component.system.app.assets;
            								assets.off("load:" + atlasAssetId, this._onTextureAtlasLoad, this);
            								assets.once("load:" + atlasAssetId, this._onTextureAtlasLoad, this);
            						} else {
            								this.sprite = asset.resource;
            						}
            				}
            		}
            		_onTextureAtlasLoad(atlasAsset) {
            				var spriteAsset = this._spriteAsset;
            				if (spriteAsset instanceof Asset) {
            						this._onSpriteAssetLoad(spriteAsset);
            				} else {
            						this._onSpriteAssetLoad(this._component.system.app.assets.get(spriteAsset));
            				}
            		}
            		_onSpriteAssetRemove(asset) {
            				this.sprite = null;
            		}
            		_onSpriteMeshesChange() {
            				if (this._component.currentClip === this) {
            						this._component._showFrame(this.frame);
            				}
            		}
            		_onSpritePpuChanged() {
            				if (this._component.currentClip === this) {
            						if (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE) {
            								this._component._showFrame(this.frame);
            						}
            				}
            		}
            		_update(dt) {
            				if (this.fps === 0) return;
            				if (!this._playing || this._paused || !this._sprite) return;
            				var dir = this.fps < 0 ? -1 : 1;
            				var time = this._time + dt * this._component.speed * dir;
            				var duration = this.duration;
            				var end = time > duration || time < 0;
            				this._setTime(time);
            				var frame = this.frame;
            				if (this._sprite) {
            						frame = Math.floor(this._sprite.frameKeys.length * this._time / duration);
            				} else {
            						frame = 0;
            				}
            				if (frame !== this._frame) {
            						this._setFrame(frame);
            				}
            				if (end) {
            						if (this.loop) {
            								this.fire('loop');
            								this._component.fire('loop', this);
            						} else {
            								this._playing = false;
            								this._paused = false;
            								this.fire('end');
            								this._component.fire('end', this);
            						}
            				}
            		}
            		_setTime(value) {
            				this._time = value;
            				var duration = this.duration;
            				if (this._time < 0) {
            						if (this.loop) {
            								this._time = this._time % duration + duration;
            						} else {
            								this._time = 0;
            						}
            				} else if (this._time > duration) {
            						if (this.loop) {
            								this._time %= duration;
            						} else {
            								this._time = duration;
            						}
            				}
            		}
            		_setFrame(value) {
            				if (this._sprite) {
            						this._frame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);
            				} else {
            						this._frame = value;
            				}
            				if (this._component.currentClip === this) {
            						this._component._showFrame(this._frame);
            				}
            		}
            		_destroy() {
            				if (this._spriteAsset) {
            						var assets = this._component.system.app.assets;
            						this._unbindSpriteAsset(assets.get(this._spriteAsset));
            				}
            				if (this._sprite) {
            						this.sprite = null;
            				}
            				if (this._spriteAsset) {
            						this.spriteAsset = null;
            				}
            		}
            		play() {
            				if (this._playing) {
            						return;
            				}
            				this._playing = true;
            				this._paused = false;
            				this.frame = 0;
            				this.fire('play');
            				this._component.fire('play', this);
            		}
            		pause() {
            				if (!this._playing || this._paused) {
            						return;
            				}
            				this._paused = true;
            				this.fire('pause');
            				this._component.fire('pause', this);
            		}
            		resume() {
            				if (!this._paused) return;
            				this._paused = false;
            				this.fire('resume');
            				this._component.fire('resume', this);
            		}
            		stop() {
            				if (!this._playing) return;
            				this._playing = false;
            				this._paused = false;
            				this._time = 0;
            				this.frame = 0;
            				this.fire('stop');
            				this._component.fire('stop', this);
            		}
            		constructor(component, data){
            				super(), this._evtSetMeshes = null;
            				this._component = component;
            				this._frame = 0;
            				this._sprite = null;
            				this._spriteAsset = null;
            				this.spriteAsset = data.spriteAsset;
            				this.name = data.name;
            				this.fps = data.fps || 0;
            				this.loop = data.loop || false;
            				this._playing = false;
            				this._paused = false;
            				this._time = 0;
            		}
            }
            SpriteAnimationClip.EVENT_PLAY = 'play';
            SpriteAnimationClip.EVENT_PAUSE = 'pause';
            SpriteAnimationClip.EVENT_RESUME = 'resume';
            SpriteAnimationClip.EVENT_STOP = 'stop';
            SpriteAnimationClip.EVENT_END = 'end';
            SpriteAnimationClip.EVENT_LOOP = 'loop';
            
            var PARAM_EMISSIVE_MAP = 'texture_emissiveMap';
            var PARAM_OPACITY_MAP = 'texture_opacityMap';
            var PARAM_EMISSIVE = 'material_emissive';
            var PARAM_OPACITY = 'material_opacity';
            var PARAM_INNER_OFFSET = 'innerOffset';
            var PARAM_OUTER_SCALE = 'outerScale';
            var PARAM_ATLAS_RECT = 'atlasRect';
            class SpriteComponent extends Component {
            		set type(value) {
            				if (this._type === value) {
            						return;
            				}
            				this._type = value;
            				if (this._type === SPRITETYPE_SIMPLE) {
            						this.stop();
            						this._currentClip = this._defaultClip;
            						if (this.enabled && this.entity.enabled) {
            								this._currentClip.frame = this.frame;
            								if (this._currentClip.sprite) {
            										this._showModel();
            								} else {
            										this._hideModel();
            								}
            						}
            				} else if (this._type === SPRITETYPE_ANIMATED) {
            						this.stop();
            						if (this._autoPlayClip) {
            								this._tryAutoPlay();
            						}
            						if (this._currentClip && this._currentClip.isPlaying && this.enabled && this.entity.enabled) {
            								this._showModel();
            						} else {
            								this._hideModel();
            						}
            				}
            		}
            		get type() {
            				return this._type;
            		}
            		set frame(value) {
            				this._currentClip.frame = value;
            		}
            		get frame() {
            				return this._currentClip.frame;
            		}
            		set spriteAsset(value) {
            				this._defaultClip.spriteAsset = value;
            		}
            		get spriteAsset() {
            				return this._defaultClip._spriteAsset;
            		}
            		set sprite(value) {
            				this._currentClip.sprite = value;
            		}
            		get sprite() {
            				return this._currentClip.sprite;
            		}
            		set material(value) {
            				this._material = value;
            				if (this._meshInstance) {
            						this._meshInstance.material = value;
            				}
            		}
            		get material() {
            				return this._material;
            		}
            		set color(value) {
            				this._color.r = value.r;
            				this._color.g = value.g;
            				this._color.b = value.b;
            				if (this._meshInstance) {
            						this._colorUniform[0] = this._color.r;
            						this._colorUniform[1] = this._color.g;
            						this._colorUniform[2] = this._color.b;
            						this._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);
            				}
            		}
            		get color() {
            				return this._color;
            		}
            		set opacity(value) {
            				this._color.a = value;
            				if (this._meshInstance) {
            						this._meshInstance.setParameter(PARAM_OPACITY, value);
            				}
            		}
            		get opacity() {
            				return this._color.a;
            		}
            		set clips(value) {
            				if (!value) {
            						for(var name in this._clips){
            								this.removeClip(name);
            						}
            						return;
            				}
            				for(var name1 in this._clips){
            						var found = false;
            						for(var key in value){
            								if (value[key].name === name1) {
            										found = true;
            										this._clips[name1].fps = value[key].fps;
            										this._clips[name1].loop = value[key].loop;
            										if (value[key].hasOwnProperty('sprite')) {
            												this._clips[name1].sprite = value[key].sprite;
            										} else if (value[key].hasOwnProperty('spriteAsset')) {
            												this._clips[name1].spriteAsset = value[key].spriteAsset;
            										}
            										break;
            								}
            						}
            						if (!found) {
            								this.removeClip(name1);
            						}
            				}
            				for(var key1 in value){
            						if (this._clips[value[key1].name]) continue;
            						this.addClip(value[key1]);
            				}
            				if (this._autoPlayClip) {
            						this._tryAutoPlay();
            				}
            				if (!this._currentClip || !this._currentClip.sprite) {
            						this._hideModel();
            				}
            		}
            		get clips() {
            				return this._clips;
            		}
            		get currentClip() {
            				return this._currentClip;
            		}
            		set speed(value) {
            				this._speed = value;
            		}
            		get speed() {
            				return this._speed;
            		}
            		set flipX(value) {
            				if (this._flipX === value) return;
            				this._flipX = value;
            				this._updateTransform();
            		}
            		get flipX() {
            				return this._flipX;
            		}
            		set flipY(value) {
            				if (this._flipY === value) return;
            				this._flipY = value;
            				this._updateTransform();
            		}
            		get flipY() {
            				return this._flipY;
            		}
            		set width(value) {
            				if (value === this._width) return;
            				this._width = value;
            				this._outerScale.x = this._width;
            				if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {
            						this._updateTransform();
            				}
            		}
            		get width() {
            				return this._width;
            		}
            		set height(value) {
            				if (value === this._height) return;
            				this._height = value;
            				this._outerScale.y = this.height;
            				if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {
            						this._updateTransform();
            				}
            		}
            		get height() {
            				return this._height;
            		}
            		set batchGroupId(value) {
            				if (this._batchGroupId === value) {
            						return;
            				}
            				var prev = this._batchGroupId;
            				this._batchGroupId = value;
            				if (this.entity.enabled && prev >= 0) {
            						var _this_system_app_batcher;
            						(_this_system_app_batcher = this.system.app.batcher) == null ? void 0 : _this_system_app_batcher.remove(BatchGroup.SPRITE, prev, this.entity);
            				}
            				if (this.entity.enabled && value >= 0) {
            						var _this_system_app_batcher1;
            						(_this_system_app_batcher1 = this.system.app.batcher) == null ? void 0 : _this_system_app_batcher1.insert(BatchGroup.SPRITE, value, this.entity);
            				} else {
            						if (prev >= 0) {
            								if (this._currentClip && this._currentClip.sprite && this.enabled && this.entity.enabled) {
            										this._showModel();
            								}
            						}
            				}
            		}
            		get batchGroupId() {
            				return this._batchGroupId;
            		}
            		set autoPlayClip(value) {
            				this._autoPlayClip = value instanceof SpriteAnimationClip ? value.name : value;
            				this._tryAutoPlay();
            		}
            		get autoPlayClip() {
            				return this._autoPlayClip;
            		}
            		set drawOrder(value) {
            				this._drawOrder = value;
            				if (this._meshInstance) {
            						this._meshInstance.drawOrder = value;
            				}
            		}
            		get drawOrder() {
            				return this._drawOrder;
            		}
            		set layers(value) {
            				if (this._addedModel) {
            						this._hideModel();
            				}
            				this._layers = value;
            				if (!this._meshInstance) {
            						return;
            				}
            				if (this.enabled && this.entity.enabled) {
            						this._showModel();
            				}
            		}
            		get layers() {
            				return this._layers;
            		}
            		get aabb() {
            				if (this._meshInstance) {
            						return this._meshInstance.aabb;
            				}
            				return null;
            		}
            		onEnable() {
            				var app = this.system.app;
            				var scene = app.scene;
            				var layers = scene.layers;
            				this._evtLayersChanged = scene.on('set:layers', this._onLayersChanged, this);
            				if (layers) {
            						this._evtLayerAdded = layers.on('add', this._onLayerAdded, this);
            						this._evtLayerRemoved = layers.on('remove', this._onLayerRemoved, this);
            				}
            				this._showModel();
            				if (this._autoPlayClip) {
            						this._tryAutoPlay();
            				}
            				if (this._batchGroupId >= 0) {
            						var _app_batcher;
            						(_app_batcher = app.batcher) == null ? void 0 : _app_batcher.insert(BatchGroup.SPRITE, this._batchGroupId, this.entity);
            				}
            		}
            		onDisable() {
            				var _this__evtLayersChanged;
            				var app = this.system.app;
            				var scene = app.scene;
            				var layers = scene.layers;
            				(_this__evtLayersChanged = this._evtLayersChanged) == null ? void 0 : _this__evtLayersChanged.off();
            				this._evtLayersChanged = null;
            				if (layers) {
            						var _this__evtLayerAdded, _this__evtLayerRemoved;
            						(_this__evtLayerAdded = this._evtLayerAdded) == null ? void 0 : _this__evtLayerAdded.off();
            						this._evtLayerAdded = null;
            						(_this__evtLayerRemoved = this._evtLayerRemoved) == null ? void 0 : _this__evtLayerRemoved.off();
            						this._evtLayerRemoved = null;
            				}
            				this.stop();
            				this._hideModel();
            				if (this._batchGroupId >= 0) {
            						var _app_batcher;
            						(_app_batcher = app.batcher) == null ? void 0 : _app_batcher.remove(BatchGroup.SPRITE, this._batchGroupId, this.entity);
            				}
            		}
            		onDestroy() {
            				var _this__node;
            				this._currentClip = null;
            				if (this._defaultClip) {
            						this._defaultClip._destroy();
            						this._defaultClip = null;
            				}
            				for(var key in this._clips){
            						this._clips[key]._destroy();
            				}
            				this._clips = null;
            				this._hideModel();
            				this._model = null;
            				(_this__node = this._node) == null ? void 0 : _this__node.remove();
            				this._node = null;
            				if (this._meshInstance) {
            						this._meshInstance.material = null;
            						this._meshInstance.mesh = null;
            						this._meshInstance = null;
            				}
            		}
            		_showModel() {
            				if (this._addedModel) return;
            				if (!this._meshInstance) return;
            				var meshInstances = [
            						this._meshInstance
            				];
            				for(var i = 0, len = this._layers.length; i < len; i++){
            						var layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
            						if (layer) {
            								layer.addMeshInstances(meshInstances);
            						}
            				}
            				this._addedModel = true;
            		}
            		_hideModel() {
            				if (!this._addedModel || !this._meshInstance) return;
            				var meshInstances = [
            						this._meshInstance
            				];
            				for(var i = 0, len = this._layers.length; i < len; i++){
            						var layer = this.system.app.scene.layers.getLayerById(this._layers[i]);
            						if (layer) {
            								layer.removeMeshInstances(meshInstances);
            						}
            				}
            				this._addedModel = false;
            		}
            		_showFrame(frame) {
            				if (!this.sprite) return;
            				var mesh = this.sprite.meshes[frame];
            				if (!mesh) {
            						if (this._meshInstance) {
            								this._meshInstance.mesh = null;
            								this._meshInstance.visible = false;
            						}
            						return;
            				}
            				var material;
            				if (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED) {
            						material = this.system.default9SlicedMaterialSlicedMode;
            				} else if (this.sprite.renderMode === SPRITE_RENDERMODE_TILED) {
            						material = this.system.default9SlicedMaterialTiledMode;
            				} else {
            						material = this.system.defaultMaterial;
            				}
            				if (!this._meshInstance) {
            						this._meshInstance = new MeshInstance(mesh, this._material, this._node);
            						this._meshInstance.castShadow = false;
            						this._meshInstance.receiveShadow = false;
            						this._meshInstance.drawOrder = this._drawOrder;
            						this._model.meshInstances.push(this._meshInstance);
            						this._colorUniform[0] = this._color.r;
            						this._colorUniform[1] = this._color.g;
            						this._colorUniform[2] = this._color.b;
            						this._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);
            						this._meshInstance.setParameter(PARAM_OPACITY, this._color.a);
            						if (this.enabled && this.entity.enabled) {
            								this._showModel();
            						}
            				}
            				if (this._meshInstance.material !== material) {
            						this._meshInstance.material = material;
            				}
            				if (this._meshInstance.mesh !== mesh) {
            						this._meshInstance.mesh = mesh;
            						this._meshInstance.visible = true;
            						this._meshInstance._aabbVer = -1;
            				}
            				if (this.sprite.atlas && this.sprite.atlas.texture) {
            						this._meshInstance.setParameter(PARAM_EMISSIVE_MAP, this.sprite.atlas.texture);
            						this._meshInstance.setParameter(PARAM_OPACITY_MAP, this.sprite.atlas.texture);
            				} else {
            						this._meshInstance.deleteParameter(PARAM_EMISSIVE_MAP);
            						this._meshInstance.deleteParameter(PARAM_OPACITY_MAP);
            				}
            				if (this.sprite.atlas && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
            						this._meshInstance._updateAabbFunc = this._updateAabbFunc;
            						var frameData = this.sprite.atlas.frames[this.sprite.frameKeys[frame]];
            						if (frameData) {
            								var borderWidthScale = 2 / frameData.rect.z;
            								var borderHeightScale = 2 / frameData.rect.w;
            								this._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);
            								var tex = this.sprite.atlas.texture;
            								this._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);
            						} else {
            								this._innerOffset.set(0, 0, 0, 0);
            						}
            						this._innerOffsetUniform[0] = this._innerOffset.x;
            						this._innerOffsetUniform[1] = this._innerOffset.y;
            						this._innerOffsetUniform[2] = this._innerOffset.z;
            						this._innerOffsetUniform[3] = this._innerOffset.w;
            						this._meshInstance.setParameter(PARAM_INNER_OFFSET, this._innerOffsetUniform);
            						this._atlasRectUniform[0] = this._atlasRect.x;
            						this._atlasRectUniform[1] = this._atlasRect.y;
            						this._atlasRectUniform[2] = this._atlasRect.z;
            						this._atlasRectUniform[3] = this._atlasRect.w;
            						this._meshInstance.setParameter(PARAM_ATLAS_RECT, this._atlasRectUniform);
            				} else {
            						this._meshInstance._updateAabbFunc = null;
            				}
            				this._updateTransform();
            		}
            		_updateTransform() {
            				var scaleX = this.flipX ? -1 : 1;
            				var scaleY = this.flipY ? -1 : 1;
            				var posX = 0;
            				var posY = 0;
            				if (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {
            						var w = 1;
            						var h = 1;
            						if (this.sprite.atlas) {
            								var frameData = this.sprite.atlas.frames[this.sprite.frameKeys[this.frame]];
            								if (frameData) {
            										w = frameData.rect.z;
            										h = frameData.rect.w;
            										posX = (0.5 - frameData.pivot.x) * this._width;
            										posY = (0.5 - frameData.pivot.y) * this._height;
            								}
            						}
            						var scaleMulX = w / this.sprite.pixelsPerUnit;
            						var scaleMulY = h / this.sprite.pixelsPerUnit;
            						this._outerScale.set(Math.max(this._width, this._innerOffset.x * scaleMulX), Math.max(this._height, this._innerOffset.y * scaleMulY));
            						scaleX *= scaleMulX;
            						scaleY *= scaleMulY;
            						this._outerScale.x /= scaleMulX;
            						this._outerScale.y /= scaleMulY;
            						scaleX *= math.clamp(this._width / (this._innerOffset.x * scaleMulX), 0.0001, 1);
            						scaleY *= math.clamp(this._height / (this._innerOffset.y * scaleMulY), 0.0001, 1);
            						if (this._meshInstance) {
            								this._outerScaleUniform[0] = this._outerScale.x;
            								this._outerScaleUniform[1] = this._outerScale.y;
            								this._meshInstance.setParameter(PARAM_OUTER_SCALE, this._outerScaleUniform);
            						}
            				}
            				this._node.setLocalScale(scaleX, scaleY, 1);
            				this._node.setLocalPosition(posX, posY, 0);
            		}
            		_updateAabb(aabb) {
            				aabb.center.set(0, 0, 0);
            				aabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);
            				aabb.setFromTransformedAabb(aabb, this._node.getWorldTransform());
            				return aabb;
            		}
            		_tryAutoPlay() {
            				if (!this._autoPlayClip) return;
            				if (this.type !== SPRITETYPE_ANIMATED) return;
            				var clip = this._clips[this._autoPlayClip];
            				if (clip && !clip.isPlaying && (!this._currentClip || !this._currentClip.isPlaying)) {
            						if (this.enabled && this.entity.enabled) {
            								this.play(clip.name);
            						}
            				}
            		}
            		_onLayersChanged(oldComp, newComp) {
            				oldComp.off('add', this.onLayerAdded, this);
            				oldComp.off('remove', this.onLayerRemoved, this);
            				newComp.on('add', this.onLayerAdded, this);
            				newComp.on('remove', this.onLayerRemoved, this);
            				if (this.enabled && this.entity.enabled) {
            						this._showModel();
            				}
            		}
            		_onLayerAdded(layer) {
            				var index = this.layers.indexOf(layer.id);
            				if (index < 0) return;
            				if (this._addedModel && this.enabled && this.entity.enabled && this._meshInstance) {
            						layer.addMeshInstances([
            								this._meshInstance
            						]);
            				}
            		}
            		_onLayerRemoved(layer) {
            				if (!this._meshInstance) return;
            				var index = this.layers.indexOf(layer.id);
            				if (index < 0) return;
            				layer.removeMeshInstances([
            						this._meshInstance
            				]);
            		}
            		removeModelFromLayers() {
            				for(var i = 0; i < this.layers.length; i++){
            						var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
            						if (!layer) continue;
            						layer.removeMeshInstances([
            								this._meshInstance
            						]);
            				}
            		}
            		addClip(data) {
            				var clip = new SpriteAnimationClip(this, {
            						name: data.name,
            						fps: data.fps,
            						loop: data.loop,
            						spriteAsset: data.spriteAsset
            				});
            				this._clips[data.name] = clip;
            				if (clip.name && clip.name === this._autoPlayClip) {
            						this._tryAutoPlay();
            				}
            				return clip;
            		}
            		removeClip(name) {
            				delete this._clips[name];
            		}
            		clip(name) {
            				return this._clips[name];
            		}
            		play(name) {
            				var clip = this._clips[name];
            				var current = this._currentClip;
            				if (current && current !== clip) {
            						current._playing = false;
            				}
            				this._currentClip = clip;
            				if (this._currentClip) {
            						this._currentClip = clip;
            						this._currentClip.play();
            				}
            				return clip;
            		}
            		pause() {
            				if (this._currentClip === this._defaultClip) return;
            				if (this._currentClip.isPlaying) {
            						this._currentClip.pause();
            				}
            		}
            		resume() {
            				if (this._currentClip === this._defaultClip) return;
            				if (this._currentClip.isPaused) {
            						this._currentClip.resume();
            				}
            		}
            		stop() {
            				if (this._currentClip === this._defaultClip) return;
            				this._currentClip.stop();
            		}
            		constructor(system, entity){
            				super(system, entity), this._evtLayersChanged = null, this._evtLayerAdded = null, this._evtLayerRemoved = null;
            				this._type = SPRITETYPE_SIMPLE;
            				this._material = system.defaultMaterial;
            				this._color = new Color(1, 1, 1, 1);
            				this._colorUniform = new Float32Array(3);
            				this._speed = 1;
            				this._flipX = false;
            				this._flipY = false;
            				this._width = 1;
            				this._height = 1;
            				this._drawOrder = 0;
            				this._layers = [
            						LAYERID_WORLD
            				];
            				this._outerScale = new Vec2(1, 1);
            				this._outerScaleUniform = new Float32Array(2);
            				this._innerOffset = new Vec4();
            				this._innerOffsetUniform = new Float32Array(4);
            				this._atlasRect = new Vec4();
            				this._atlasRectUniform = new Float32Array(4);
            				this._batchGroupId = -1;
            				this._batchGroup = null;
            				this._node = new GraphNode();
            				this._model = new Model();
            				this._model.graph = this._node;
            				this._meshInstance = null;
            				entity.addChild(this._model.graph);
            				this._model._entity = entity;
            				this._updateAabbFunc = this._updateAabb.bind(this);
            				this._addedModel = false;
            				this._autoPlayClip = null;
            				this._clips = {};
            				this._defaultClip = new SpriteAnimationClip(this, {
            						name: this.entity.name,
            						fps: 0,
            						loop: false,
            						spriteAsset: null
            				});
            				this._currentClip = this._defaultClip;
            		}
            }
            SpriteComponent.EVENT_PLAY = 'play';
            SpriteComponent.EVENT_PAUSE = 'pause';
            SpriteComponent.EVENT_RESUME = 'resume';
            SpriteComponent.EVENT_STOP = 'stop';
            SpriteComponent.EVENT_END = 'end';
            SpriteComponent.EVENT_LOOP = 'loop';
            
            class SpriteComponentData {
            		constructor(){
            				this.enabled = true;
            		}
            }
            
            var _schema$3 = [
            		'enabled'
            ];
            class SpriteComponentSystem extends ComponentSystem {
            		set defaultMaterial(material) {
            				this._defaultMaterial = material;
            		}
            		get defaultMaterial() {
            				if (!this._defaultMaterial) {
            						var texture = new Texture(this.app.graphicsDevice, {
            								width: 1,
            								height: 1,
            								format: PIXELFORMAT_SRGBA8,
            								name: 'sprite'
            						});
            						var pixels = new Uint8Array(texture.lock());
            						pixels[0] = pixels[1] = pixels[2] = pixels[3] = 255;
            						texture.unlock();
            						var material = new StandardMaterial();
            						material.diffuse.set(0, 0, 0);
            						material.emissive.set(1, 1, 1);
            						material.emissiveMap = texture;
            						material.opacityMap = texture;
            						material.opacityMapChannel = 'a';
            						material.useLighting = false;
            						material.useTonemap = false;
            						material.useFog = false;
            						material.useSkybox = false;
            						material.blendType = BLEND_PREMULTIPLIED;
            						material.depthWrite = false;
            						material.pixelSnap = false;
            						material.cull = CULLFACE_NONE;
            						material.update();
            						this._defaultTexture = texture;
            						this._defaultMaterial = material;
            				}
            				return this._defaultMaterial;
            		}
            		set default9SlicedMaterialSlicedMode(material) {
            				this._default9SlicedMaterialSlicedMode = material;
            		}
            		get default9SlicedMaterialSlicedMode() {
            				if (!this._default9SlicedMaterialSlicedMode) {
            						var material = this.defaultMaterial.clone();
            						material.nineSlicedMode = SPRITE_RENDERMODE_SLICED;
            						material.update();
            						this._default9SlicedMaterialSlicedMode = material;
            				}
            				return this._default9SlicedMaterialSlicedMode;
            		}
            		set default9SlicedMaterialTiledMode(material) {
            				this._default9SlicedMaterialTiledMode = material;
            		}
            		get default9SlicedMaterialTiledMode() {
            				if (!this._default9SlicedMaterialTiledMode) {
            						var material = this.defaultMaterial.clone();
            						material.nineSlicedMode = SPRITE_RENDERMODE_TILED;
            						material.update();
            						this._default9SlicedMaterialTiledMode = material;
            				}
            				return this._default9SlicedMaterialTiledMode;
            		}
            		destroy() {
            				super.destroy();
            				this.app.systems.off('update', this.onUpdate, this);
            				if (this._defaultTexture) {
            						this._defaultTexture.destroy();
            						this._defaultTexture = null;
            				}
            		}
            		initializeComponentData(component, data, properties) {
            				if (data.enabled !== undefined) {
            						component.enabled = data.enabled;
            				}
            				component.type = data.type;
            				if (data.layers && Array.isArray(data.layers)) {
            						component.layers = data.layers.slice(0);
            				}
            				if (data.drawOrder !== undefined) {
            						component.drawOrder = data.drawOrder;
            				}
            				if (data.color !== undefined) {
            						if (data.color instanceof Color) {
            								var _data_opacity;
            								component.color.set(data.color.r, data.color.g, data.color.b, (_data_opacity = data.opacity) != null ? _data_opacity : 1);
            						} else {
            								var _data_opacity1;
            								component.color.set(data.color[0], data.color[1], data.color[2], (_data_opacity1 = data.opacity) != null ? _data_opacity1 : 1);
            						}
            						component.color = component.color;
            				}
            				if (data.opacity !== undefined) {
            						component.opacity = data.opacity;
            				}
            				if (data.flipX !== undefined) {
            						component.flipX = data.flipX;
            				}
            				if (data.flipY !== undefined) {
            						component.flipY = data.flipY;
            				}
            				if (data.width !== undefined) {
            						component.width = data.width;
            				}
            				if (data.height !== undefined) {
            						component.height = data.height;
            				}
            				if (data.spriteAsset !== undefined) {
            						component.spriteAsset = data.spriteAsset;
            				}
            				if (data.sprite) {
            						component.sprite = data.sprite;
            				}
            				if (data.frame !== undefined) {
            						component.frame = data.frame;
            				}
            				if (data.clips) {
            						for(var name in data.clips){
            								component.addClip(data.clips[name]);
            						}
            				}
            				if (data.speed !== undefined) {
            						component.speed = data.speed;
            				}
            				if (data.autoPlayClip) {
            						component.autoPlayClip = data.autoPlayClip;
            				}
            				component.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;
            				super.initializeComponentData(component, data, properties);
            		}
            		cloneComponent(entity, clone) {
            				var source = entity.sprite;
            				return this.addComponent(clone, {
            						enabled: source.enabled,
            						type: source.type,
            						spriteAsset: source.spriteAsset,
            						sprite: source.sprite,
            						width: source.width,
            						height: source.height,
            						frame: source.frame,
            						color: source.color.clone(),
            						opacity: source.opacity,
            						flipX: source.flipX,
            						flipY: source.flipY,
            						speed: source.speed,
            						clips: source.clips,
            						autoPlayClip: source.autoPlayClip,
            						batchGroupId: source.batchGroupId,
            						drawOrder: source.drawOrder,
            						layers: source.layers.slice(0)
            				});
            		}
            		onUpdate(dt) {
            				var components = this.store;
            				for(var id in components){
            						if (components.hasOwnProperty(id)) {
            								var component = components[id];
            								if (component.data.enabled && component.entity.enabled) {
            										var sprite = component.entity.sprite;
            										if (sprite._currentClip) {
            												sprite._currentClip._update(dt);
            										}
            								}
            						}
            				}
            		}
            		onBeforeRemove(entity, component) {
            				component.onDestroy();
            		}
            		constructor(app){
            				super(app);
            				this.id = 'sprite';
            				this.ComponentType = SpriteComponent;
            				this.DataType = SpriteComponentData;
            				this.schema = _schema$3;
            				this._defaultTexture = null;
            				this._defaultMaterial = null;
            				this._default9SlicedMaterialSlicedMode = null;
            				this._default9SlicedMaterialTiledMode = null;
            				this.app.systems.on('update', this.onUpdate, this);
            				this.on('beforeremove', this.onBeforeRemove, this);
            		}
            }
            Component._buildAccessors(SpriteComponent.prototype, _schema$3);
            
            class ZoneComponent extends Component {
            		set size(data) {
            				if (data instanceof Vec3) {
            						this._size.copy(data);
            				} else if (data instanceof Array && data.length >= 3) {
            						this.size.set(data[0], data[1], data[2]);
            				}
            		}
            		get size() {
            				return this._size;
            		}
            		onEnable() {
            				this._checkState();
            		}
            		onDisable() {
            				this._checkState();
            		}
            		_onSetEnabled(prop, old, value) {
            				this._checkState();
            		}
            		_checkState() {
            				var state = this.enabled && this.entity.enabled;
            				if (state === this._oldState) {
            						return;
            				}
            				this._oldState = state;
            				this.fire('enable');
            				this.fire('state', this.enabled);
            		}
            		_onBeforeRemove() {
            				this.fire('remove');
            		}
            		constructor(system, entity){
            				super(system, entity);
            				this._oldState = true;
            				this._size = new Vec3();
            				this.on('set_enabled', this._onSetEnabled, this);
            		}
            }
            ZoneComponent.EVENT_ENABLE = 'enable';
            ZoneComponent.EVENT_DISABLE = 'disable';
            ZoneComponent.EVENT_STATE = 'state';
            ZoneComponent.EVENT_REMOVE = 'remove';
            
            class ZoneComponentData {
            		constructor(){
            				this.enabled = true;
            		}
            }
            
            var _schema$2 = [
            		'enabled'
            ];
            class ZoneComponentSystem extends ComponentSystem {
            		initializeComponentData(component, data, properties) {
            				component.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;
            				if (data.size) {
            						if (data.size instanceof Vec3) {
            								component.size.copy(data.size);
            						} else if (data.size instanceof Array && data.size.length >= 3) {
            								component.size.set(data.size[0], data.size[1], data.size[2]);
            						}
            				}
            		}
            		cloneComponent(entity, clone) {
            				var data = {
            						enabled: entity.zone.enabled,
            						size: entity.zone.size
            				};
            				return this.addComponent(clone, data);
            		}
            		_onBeforeRemove(entity, component) {
            				component._onBeforeRemove();
            		}
            		constructor(app){
            				super(app);
            				this.id = 'zone';
            				this.ComponentType = ZoneComponent;
            				this.DataType = ZoneComponentData;
            				this.schema = _schema$2;
            				this.on('beforeremove', this._onBeforeRemove, this);
            		}
            }
            Component._buildAccessors(ZoneComponent.prototype, _schema$2);
            
            class PostEffectEntry {
            		constructor(effect, inputTarget){
            				this.effect = effect;
            				this.inputTarget = inputTarget;
            				this.outputTarget = null;
            				this.name = effect.constructor.name;
            		}
            }
            class PostEffectQueue {
            		_allocateColorBuffer(format, name) {
            				var rect = this.camera.rect;
            				var renderTarget = this.destinationRenderTarget;
            				var device = this.app.graphicsDevice;
            				var _renderTarget_width;
            				var width = Math.floor(rect.z * ((_renderTarget_width = renderTarget == null ? void 0 : renderTarget.width) != null ? _renderTarget_width : device.width));
            				var _renderTarget_height;
            				var height = Math.floor(rect.w * ((_renderTarget_height = renderTarget == null ? void 0 : renderTarget.height) != null ? _renderTarget_height : device.height));
            				var colorBuffer = new Texture(device, {
            						name: name,
            						format: format,
            						width: width,
            						height: height,
            						mipmaps: false,
            						minFilter: FILTER_NEAREST,
            						magFilter: FILTER_NEAREST,
            						addressU: ADDRESS_CLAMP_TO_EDGE,
            						addressV: ADDRESS_CLAMP_TO_EDGE
            				});
            				return colorBuffer;
            		}
            		_createOffscreenTarget(useDepth, hdr) {
            				var device = this.app.graphicsDevice;
            				var _this_destinationRenderTarget;
            				var outputRt = (_this_destinationRenderTarget = this.destinationRenderTarget) != null ? _this_destinationRenderTarget : device.backBuffer;
            				var srgb = outputRt.isColorBufferSrgb(0);
            				var _ref;
            				var format = (_ref = hdr && device.getRenderableHdrFormat([
            						PIXELFORMAT_RGBA16F,
            						PIXELFORMAT_RGBA32F
            				], true)) != null ? _ref : srgb ? PIXELFORMAT_SRGBA8 : PIXELFORMAT_RGBA8;
            				var name = this.camera.entity.name + "-posteffect-" + this.effects.length;
            				var colorBuffer = this._allocateColorBuffer(format, name);
            				return new RenderTarget({
            						colorBuffer: colorBuffer,
            						depth: useDepth,
            						stencil: useDepth && this.app.graphicsDevice.supportsStencil,
            						samples: useDepth ? device.samples : 1
            				});
            		}
            		_resizeOffscreenTarget(rt) {
            				var format = rt.colorBuffer.format;
            				var name = rt.colorBuffer.name;
            				rt.destroyFrameBuffers();
            				rt.destroyTextureBuffers();
            				rt._colorBuffer = this._allocateColorBuffer(format, name);
            				rt._colorBuffers = [
            						rt._colorBuffer
            				];
            		}
            		_destroyOffscreenTarget(rt) {
            				rt.destroyTextureBuffers();
            				rt.destroy();
            		}
            		addEffect(effect) {
            				var effects = this.effects;
            				var isFirstEffect = effects.length === 0;
            				var inputTarget = this._createOffscreenTarget(isFirstEffect, effect.hdr);
            				var newEntry = new PostEffectEntry(effect, inputTarget);
            				effects.push(newEntry);
            				this._sourceTarget = newEntry.inputTarget;
            				if (effects.length > 1) {
            						effects[effects.length - 2].outputTarget = newEntry.inputTarget;
            				}
            				this._newPostEffect = effect;
            				if (effect.needsDepthBuffer) {
            						this._requestDepthMap();
            				}
            				this.enable();
            				this._newPostEffect = undefined;
            		}
            		removeEffect(effect) {
            				var index = -1;
            				for(var i = 0, len = this.effects.length; i < len; i++){
            						if (this.effects[i].effect === effect) {
            								index = i;
            								break;
            						}
            				}
            				if (index >= 0) {
            						if (index > 0) {
            								this.effects[index - 1].outputTarget = index + 1 < this.effects.length ? this.effects[index + 1].inputTarget : null;
            						} else {
            								if (this.effects.length > 1) {
            										if (!this.effects[1].inputTarget._depth) {
            												this._destroyOffscreenTarget(this.effects[1].inputTarget);
            												this.effects[1].inputTarget = this._createOffscreenTarget(true, this.effects[1].hdr);
            												this._sourceTarget = this.effects[1].inputTarget;
            										}
            										this.camera.renderTarget = this.effects[1].inputTarget;
            								}
            						}
            						this._destroyOffscreenTarget(this.effects[index].inputTarget);
            						this.effects.splice(index, 1);
            				}
            				if (this.enabled) {
            						if (effect.needsDepthBuffer) {
            								this._releaseDepthMap();
            						}
            				}
            				if (this.effects.length === 0) {
            						this.disable();
            				}
            		}
            		_requestDepthMaps() {
            				for(var i = 0, len = this.effects.length; i < len; i++){
            						var effect = this.effects[i].effect;
            						if (this._newPostEffect === effect) {
            								continue;
            						}
            						if (effect.needsDepthBuffer) {
            								this._requestDepthMap();
            						}
            				}
            		}
            		_releaseDepthMaps() {
            				for(var i = 0, len = this.effects.length; i < len; i++){
            						var effect = this.effects[i].effect;
            						if (effect.needsDepthBuffer) {
            								this._releaseDepthMap();
            						}
            				}
            		}
            		_requestDepthMap() {
            				var depthLayer = this.app.scene.layers.getLayerById(LAYERID_DEPTH);
            				if (depthLayer) {
            						depthLayer.incrementCounter();
            						this.camera.requestSceneDepthMap(true);
            				}
            		}
            		_releaseDepthMap() {
            				var depthLayer = this.app.scene.layers.getLayerById(LAYERID_DEPTH);
            				if (depthLayer) {
            						depthLayer.decrementCounter();
            						this.camera.requestSceneDepthMap(false);
            				}
            		}
            		destroy() {
            				for(var i = 0, len = this.effects.length; i < len; i++){
            						this.effects[i].inputTarget.destroy();
            				}
            				this.effects.length = 0;
            				this.disable();
            		}
            		enable() {
            				if (!this.enabled && this.effects.length) {
            						this.enabled = true;
            						this._requestDepthMaps();
            						this.app.graphicsDevice.on('resizecanvas', this._onCanvasResized, this);
            						this.destinationRenderTarget = this.camera.renderTarget;
            						this.camera.renderTarget = this.effects[0].inputTarget;
            						this.camera.onPostprocessing = ()=>{
            								if (this.enabled) {
            										var rect = null;
            										var len = this.effects.length;
            										if (len) {
            												for(var i = 0; i < len; i++){
            														var fx = this.effects[i];
            														var destTarget = fx.outputTarget;
            														if (i === len - 1) {
            																rect = this.camera.rect;
            																if (this.destinationRenderTarget) {
            																		destTarget = this.destinationRenderTarget;
            																}
            														}
            														fx.effect.render(fx.inputTarget, destTarget, rect);
            												}
            										}
            								}
            						};
            				}
            		}
            		disable() {
            				if (this.enabled) {
            						this.enabled = false;
            						this.app.graphicsDevice.off('resizecanvas', this._onCanvasResized, this);
            						this._releaseDepthMaps();
            						this._destroyOffscreenTarget(this._sourceTarget);
            						this.camera.renderTarget = this.destinationRenderTarget;
            						this.camera.onPostprocessing = null;
            				}
            		}
            		_onCanvasResized(width, height) {
            				var rect = this.camera.rect;
            				var renderTarget = this.destinationRenderTarget;
            				var _renderTarget_width;
            				width = (_renderTarget_width = renderTarget == null ? void 0 : renderTarget.width) != null ? _renderTarget_width : width;
            				var _renderTarget_height;
            				height = (_renderTarget_height = renderTarget == null ? void 0 : renderTarget.height) != null ? _renderTarget_height : height;
            				this.camera.camera.aspectRatio = width * rect.z / (height * rect.w);
            				this.resizeRenderTargets();
            		}
            		resizeRenderTargets() {
            				var device = this.app.graphicsDevice;
            				var renderTarget = this.destinationRenderTarget;
            				var _renderTarget_width;
            				var width = (_renderTarget_width = renderTarget == null ? void 0 : renderTarget.width) != null ? _renderTarget_width : device.width;
            				var _renderTarget_height;
            				var height = (_renderTarget_height = renderTarget == null ? void 0 : renderTarget.height) != null ? _renderTarget_height : device.height;
            				var rect = this.camera.rect;
            				var desiredWidth = Math.floor(rect.z * width);
            				var desiredHeight = Math.floor(rect.w * height);
            				var effects = this.effects;
            				for(var i = 0, len = effects.length; i < len; i++){
            						var fx = effects[i];
            						if (fx.inputTarget.width !== desiredWidth || fx.inputTarget.height !== desiredHeight) {
            								this._resizeOffscreenTarget(fx.inputTarget);
            						}
            				}
            		}
            		onCameraRectChanged(name, oldValue, newValue) {
            				if (this.enabled) {
            						this.resizeRenderTargets();
            				}
            		}
            		constructor(app, camera){
            				this.app = app;
            				this.camera = camera;
            				this.destinationRenderTarget = null;
            				this.effects = [];
            				this.enabled = false;
            				this.depthTarget = null;
            				camera.on('set:rect', this.onCameraRectChanged, this);
            		}
            }
            
            class CameraComponent extends Component {
            		setShaderPass(name) {
            				var shaderPass = ShaderPass.get(this.system.app.graphicsDevice);
            				var shaderPassInfo = name ? shaderPass.allocate(name, {
            						isForward: true
            				}) : null;
            				this._camera.shaderPassInfo = shaderPassInfo;
            				return shaderPassInfo.index;
            		}
            		getShaderPass() {
            				var _this__camera_shaderPassInfo;
            				return (_this__camera_shaderPassInfo = this._camera.shaderPassInfo) == null ? void 0 : _this__camera_shaderPassInfo.name;
            		}
            		set renderPasses(passes) {
            				this._camera.renderPasses = passes || [];
            				this.dirtyLayerCompositionCameras();
            				this.system.app.scene.updateShaders = true;
            		}
            		get renderPasses() {
            				return this._camera.renderPasses;
            		}
            		get shaderParams() {
            				return this._camera.shaderParams;
            		}
            		set gammaCorrection(value) {
            				this.camera.shaderParams.gammaCorrection = value;
            		}
            		get gammaCorrection() {
            				return this.camera.shaderParams.gammaCorrection;
            		}
            		set toneMapping(value) {
            				this.camera.shaderParams.toneMapping = value;
            		}
            		get toneMapping() {
            				return this.camera.shaderParams.toneMapping;
            		}
            		set fog(value) {
            				this._camera.fogParams = value;
            		}
            		get fog() {
            				return this._camera.fogParams;
            		}
            		set aperture(value) {
            				this._camera.aperture = value;
            		}
            		get aperture() {
            				return this._camera.aperture;
            		}
            		set aspectRatio(value) {
            				this._camera.aspectRatio = value;
            		}
            		get aspectRatio() {
            				return this._camera.aspectRatio;
            		}
            		set aspectRatioMode(value) {
            				this._camera.aspectRatioMode = value;
            		}
            		get aspectRatioMode() {
            				return this._camera.aspectRatioMode;
            		}
            		set calculateProjection(value) {
            				this._camera.calculateProjection = value;
            		}
            		get calculateProjection() {
            				return this._camera.calculateProjection;
            		}
            		set calculateTransform(value) {
            				this._camera.calculateTransform = value;
            		}
            		get calculateTransform() {
            				return this._camera.calculateTransform;
            		}
            		get camera() {
            				return this._camera;
            		}
            		set clearColor(value) {
            				this._camera.clearColor = value;
            		}
            		get clearColor() {
            				return this._camera.clearColor;
            		}
            		set clearColorBuffer(value) {
            				this._camera.clearColorBuffer = value;
            				this.dirtyLayerCompositionCameras();
            		}
            		get clearColorBuffer() {
            				return this._camera.clearColorBuffer;
            		}
            		set clearDepthBuffer(value) {
            				this._camera.clearDepthBuffer = value;
            				this.dirtyLayerCompositionCameras();
            		}
            		get clearDepthBuffer() {
            				return this._camera.clearDepthBuffer;
            		}
            		set clearStencilBuffer(value) {
            				this._camera.clearStencilBuffer = value;
            				this.dirtyLayerCompositionCameras();
            		}
            		get clearStencilBuffer() {
            				return this._camera.clearStencilBuffer;
            		}
            		set cullFaces(value) {
            				this._camera.cullFaces = value;
            		}
            		get cullFaces() {
            				return this._camera.cullFaces;
            		}
            		set disablePostEffectsLayer(layer) {
            				this._disablePostEffectsLayer = layer;
            				this.dirtyLayerCompositionCameras();
            		}
            		get disablePostEffectsLayer() {
            				return this._disablePostEffectsLayer;
            		}
            		set farClip(value) {
            				this._camera.farClip = value;
            		}
            		get farClip() {
            				return this._camera.farClip;
            		}
            		set flipFaces(value) {
            				this._camera.flipFaces = value;
            		}
            		get flipFaces() {
            				return this._camera.flipFaces;
            		}
            		set fov(value) {
            				this._camera.fov = value;
            		}
            		get fov() {
            				return this._camera.fov;
            		}
            		get frustum() {
            				return this._camera.frustum;
            		}
            		set frustumCulling(value) {
            				this._camera.frustumCulling = value;
            		}
            		get frustumCulling() {
            				return this._camera.frustumCulling;
            		}
            		set horizontalFov(value) {
            				this._camera.horizontalFov = value;
            		}
            		get horizontalFov() {
            				return this._camera.horizontalFov;
            		}
            		set layers(newValue) {
            				var oldLayers = this._camera.layers;
            				var scene = this.system.app.scene;
            				oldLayers.forEach((layerId)=>{
            						var layer = scene.layers.getLayerById(layerId);
            						layer == null ? void 0 : layer.removeCamera(this);
            				});
            				this._camera.layers = newValue;
            				if (this.enabled && this.entity.enabled) {
            						newValue.forEach((layerId)=>{
            								var layer = scene.layers.getLayerById(layerId);
            								layer == null ? void 0 : layer.addCamera(this);
            						});
            				}
            		}
            		get layers() {
            				return this._camera.layers;
            		}
            		get layersSet() {
            				return this._camera.layersSet;
            		}
            		set jitter(value) {
            				this._camera.jitter = value;
            		}
            		get jitter() {
            				return this._camera.jitter;
            		}
            		set nearClip(value) {
            				this._camera.nearClip = value;
            		}
            		get nearClip() {
            				return this._camera.nearClip;
            		}
            		set orthoHeight(value) {
            				this._camera.orthoHeight = value;
            		}
            		get orthoHeight() {
            				return this._camera.orthoHeight;
            		}
            		get postEffects() {
            				return this._postEffects;
            		}
            		get postEffectsEnabled() {
            				return this._postEffects.enabled;
            		}
            		set priority(newValue) {
            				this._priority = newValue;
            				this.dirtyLayerCompositionCameras();
            		}
            		get priority() {
            				return this._priority;
            		}
            		set projection(value) {
            				this._camera.projection = value;
            		}
            		get projection() {
            				return this._camera.projection;
            		}
            		get projectionMatrix() {
            				return this._camera.projectionMatrix;
            		}
            		set rect(value) {
            				this._camera.rect = value;
            				this.fire('set:rect', this._camera.rect);
            		}
            		get rect() {
            				return this._camera.rect;
            		}
            		set renderSceneColorMap(value) {
            				if (value && !this._sceneColorMapRequested) {
            						this.requestSceneColorMap(true);
            						this._sceneColorMapRequested = true;
            				} else if (this._sceneColorMapRequested) {
            						this.requestSceneColorMap(false);
            						this._sceneColorMapRequested = false;
            				}
            		}
            		get renderSceneColorMap() {
            				return this._renderSceneColorMap > 0;
            		}
            		set renderSceneDepthMap(value) {
            				if (value && !this._sceneDepthMapRequested) {
            						this.requestSceneDepthMap(true);
            						this._sceneDepthMapRequested = true;
            				} else if (this._sceneDepthMapRequested) {
            						this.requestSceneDepthMap(false);
            						this._sceneDepthMapRequested = false;
            				}
            		}
            		get renderSceneDepthMap() {
            				return this._renderSceneDepthMap > 0;
            		}
            		set renderTarget(value) {
            				this._camera.renderTarget = value;
            				this.dirtyLayerCompositionCameras();
            		}
            		get renderTarget() {
            				return this._camera.renderTarget;
            		}
            		set scissorRect(value) {
            				this._camera.scissorRect = value;
            		}
            		get scissorRect() {
            				return this._camera.scissorRect;
            		}
            		set sensitivity(value) {
            				this._camera.sensitivity = value;
            		}
            		get sensitivity() {
            				return this._camera.sensitivity;
            		}
            		set shutter(value) {
            				this._camera.shutter = value;
            		}
            		get shutter() {
            				return this._camera.shutter;
            		}
            		get viewMatrix() {
            				return this._camera.viewMatrix;
            		}
            		_enableDepthLayer(value) {
            				var hasDepthLayer = this.layers.find((layerId)=>layerId === LAYERID_DEPTH);
            				if (hasDepthLayer) {
            						var depthLayer = this.system.app.scene.layers.getLayerById(LAYERID_DEPTH);
            						if (value) {
            								depthLayer == null ? void 0 : depthLayer.incrementCounter();
            						} else {
            								depthLayer == null ? void 0 : depthLayer.decrementCounter();
            						}
            				} else if (value) {
            						return false;
            				}
            				return true;
            		}
            		requestSceneColorMap(enabled) {
            				this._renderSceneColorMap += enabled ? 1 : -1;
            				this._enableDepthLayer(enabled);
            				this.camera._enableRenderPassColorGrab(this.system.app.graphicsDevice, this.renderSceneColorMap);
            				this.system.app.scene.layers.markDirty();
            		}
            		requestSceneDepthMap(enabled) {
            				this._renderSceneDepthMap += enabled ? 1 : -1;
            				this._enableDepthLayer(enabled);
            				this.camera._enableRenderPassDepthGrab(this.system.app.graphicsDevice, this.system.app.renderer, this.renderSceneDepthMap);
            				this.system.app.scene.layers.markDirty();
            		}
            		dirtyLayerCompositionCameras() {
            				var layerComp = this.system.app.scene.layers;
            				layerComp._dirty = true;
            		}
            		screenToWorld(screenx, screeny, cameraz, worldCoord) {
            				var device = this.system.app.graphicsDevice;
            				var { width, height } = device.clientRect;
            				return this._camera.screenToWorld(screenx, screeny, cameraz, width, height, worldCoord);
            		}
            		worldToScreen(worldCoord, screenCoord) {
            				var device = this.system.app.graphicsDevice;
            				var { width, height } = device.clientRect;
            				return this._camera.worldToScreen(worldCoord, width, height, screenCoord);
            		}
            		onAppPrerender() {
            				this._camera._viewMatDirty = true;
            				this._camera._viewProjMatDirty = true;
            		}
            		addCameraToLayers() {
            				var layers = this.layers;
            				for(var i = 0; i < layers.length; i++){
            						var layer = this.system.app.scene.layers.getLayerById(layers[i]);
            						if (layer) {
            								layer.addCamera(this);
            						}
            				}
            		}
            		removeCameraFromLayers() {
            				var layers = this.layers;
            				for(var i = 0; i < layers.length; i++){
            						var layer = this.system.app.scene.layers.getLayerById(layers[i]);
            						if (layer) {
            								layer.removeCamera(this);
            						}
            				}
            		}
            		onLayersChanged(oldComp, newComp) {
            				this.addCameraToLayers();
            				oldComp.off('add', this.onLayerAdded, this);
            				oldComp.off('remove', this.onLayerRemoved, this);
            				newComp.on('add', this.onLayerAdded, this);
            				newComp.on('remove', this.onLayerRemoved, this);
            		}
            		onLayerAdded(layer) {
            				var index = this.layers.indexOf(layer.id);
            				if (index < 0) return;
            				layer.addCamera(this);
            		}
            		onLayerRemoved(layer) {
            				var index = this.layers.indexOf(layer.id);
            				if (index < 0) return;
            				layer.removeCamera(this);
            		}
            		onEnable() {
            				var _this__evtLayersChanged;
            				var scene = this.system.app.scene;
            				var layers = scene.layers;
            				this.system.addCamera(this);
            				(_this__evtLayersChanged = this._evtLayersChanged) == null ? void 0 : _this__evtLayersChanged.off();
            				this._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);
            				if (layers) {
            						var _this__evtLayerAdded, _this__evtLayerRemoved;
            						(_this__evtLayerAdded = this._evtLayerAdded) == null ? void 0 : _this__evtLayerAdded.off();
            						this._evtLayerAdded = layers.on('add', this.onLayerAdded, this);
            						(_this__evtLayerRemoved = this._evtLayerRemoved) == null ? void 0 : _this__evtLayerRemoved.off();
            						this._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);
            				}
            				if (this.enabled && this.entity.enabled) {
            						this.addCameraToLayers();
            				}
            				this.postEffects.enable();
            		}
            		onDisable() {
            				var _this__evtLayersChanged;
            				var scene = this.system.app.scene;
            				var layers = scene.layers;
            				this.postEffects.disable();
            				this.removeCameraFromLayers();
            				(_this__evtLayersChanged = this._evtLayersChanged) == null ? void 0 : _this__evtLayersChanged.off();
            				this._evtLayersChanged = null;
            				if (layers) {
            						var _this__evtLayerAdded, _this__evtLayerRemoved;
            						(_this__evtLayerAdded = this._evtLayerAdded) == null ? void 0 : _this__evtLayerAdded.off();
            						this._evtLayerAdded = null;
            						(_this__evtLayerRemoved = this._evtLayerRemoved) == null ? void 0 : _this__evtLayerRemoved.off();
            						this._evtLayerRemoved = null;
            				}
            				this.system.removeCamera(this);
            		}
            		onRemove() {
            				this.onDisable();
            				this.off();
            				this.camera.destroy();
            		}
            		calculateAspectRatio(rt) {
            				var device = this.system.app.graphicsDevice;
            				var width = rt ? rt.width : device.width;
            				var height = rt ? rt.height : device.height;
            				return width * this.rect.z / (height * this.rect.w);
            		}
            		frameUpdate(rt) {
            				if (this.aspectRatioMode === ASPECT_AUTO) {
            						this.aspectRatio = this.calculateAspectRatio(rt);
            				}
            		}
            		startXr(type, spaceType, options) {
            				this.system.app.xr.start(this, type, spaceType, options);
            		}
            		endXr(callback) {
            				if (!this._camera.xr) {
            						if (callback) callback(new Error('Camera is not in XR'));
            						return;
            				}
            				this._camera.xr.end(callback);
            		}
            		copy(source) {
            				this.aperture = source.aperture;
            				this.aspectRatio = source.aspectRatio;
            				this.aspectRatioMode = source.aspectRatioMode;
            				this.calculateProjection = source.calculateProjection;
            				this.calculateTransform = source.calculateTransform;
            				this.clearColor = source.clearColor;
            				this.clearColorBuffer = source.clearColorBuffer;
            				this.clearDepthBuffer = source.clearDepthBuffer;
            				this.clearStencilBuffer = source.clearStencilBuffer;
            				this.cullFaces = source.cullFaces;
            				this.disablePostEffectsLayer = source.disablePostEffectsLayer;
            				this.farClip = source.farClip;
            				this.flipFaces = source.flipFaces;
            				this.fov = source.fov;
            				this.frustumCulling = source.frustumCulling;
            				this.horizontalFov = source.horizontalFov;
            				this.layers = source.layers;
            				this.nearClip = source.nearClip;
            				this.orthoHeight = source.orthoHeight;
            				this.priority = source.priority;
            				this.projection = source.projection;
            				this.rect = source.rect;
            				this.renderTarget = source.renderTarget;
            				this.scissorRect = source.scissorRect;
            				this.sensitivity = source.sensitivity;
            				this.shutter = source.shutter;
            		}
            		constructor(system, entity){
            				super(system, entity), this.onPostprocessing = null, this._renderSceneDepthMap = 0, this._renderSceneColorMap = 0, this._sceneDepthMapRequested = false, this._sceneColorMapRequested = false, this._priority = 0, this._disablePostEffectsLayer = LAYERID_UI, this._camera = new Camera(), this._evtLayersChanged = null, this._evtLayerAdded = null, this._evtLayerRemoved = null;
            				this._camera.node = entity;
            				this._postEffects = new PostEffectQueue(system.app, this);
            		}
            }
            
            class CameraComponentData {
            		constructor(){
            				this.enabled = true;
            		}
            }
            
            var _schema$1 = [
            		'enabled'
            ];
            class CameraComponentSystem extends ComponentSystem {
            		initializeComponentData(component, data, properties) {
            				properties = [
            						'aspectRatio',
            						'aspectRatioMode',
            						'calculateProjection',
            						'calculateTransform',
            						'clearColor',
            						'clearColorBuffer',
            						'clearDepthBuffer',
            						'clearStencilBuffer',
            						'renderSceneColorMap',
            						'renderSceneDepthMap',
            						'cullFaces',
            						'farClip',
            						'flipFaces',
            						'fog',
            						'fov',
            						'frustumCulling',
            						'horizontalFov',
            						'layers',
            						'renderTarget',
            						'nearClip',
            						'orthoHeight',
            						'projection',
            						'priority',
            						'rect',
            						'scissorRect',
            						'aperture',
            						'shutter',
            						'sensitivity',
            						'gammaCorrection',
            						'toneMapping'
            				];
            				for(var i = 0; i < properties.length; i++){
            						var property = properties[i];
            						if (data.hasOwnProperty(property)) {
            								var value = data[property];
            								switch(property){
            										case 'rect':
            										case 'scissorRect':
            												if (Array.isArray(value)) {
            														component[property] = new Vec4(value[0], value[1], value[2], value[3]);
            												} else {
            														component[property] = value;
            												}
            												break;
            										case 'clearColor':
            												if (Array.isArray(value)) {
            														component[property] = new Color(value[0], value[1], value[2], value[3]);
            												} else {
            														component[property] = value;
            												}
            												break;
            										default:
            												component[property] = value;
            												break;
            								}
            						}
            				}
            				super.initializeComponentData(component, data, [
            						'enabled'
            				]);
            		}
            		cloneComponent(entity, clone) {
            				var c = entity.camera;
            				return this.addComponent(clone, {
            						aspectRatio: c.aspectRatio,
            						aspectRatioMode: c.aspectRatioMode,
            						calculateProjection: c.calculateProjection,
            						calculateTransform: c.calculateTransform,
            						clearColor: c.clearColor,
            						clearColorBuffer: c.clearColorBuffer,
            						clearDepthBuffer: c.clearDepthBuffer,
            						clearStencilBuffer: c.clearStencilBuffer,
            						renderSceneDepthMap: c.renderSceneDepthMap,
            						renderSceneColorMap: c.renderSceneColorMap,
            						cullFaces: c.cullFaces,
            						enabled: c.enabled,
            						farClip: c.farClip,
            						flipFaces: c.flipFaces,
            						fov: c.fov,
            						frustumCulling: c.frustumCulling,
            						horizontalFov: c.horizontalFov,
            						layers: c.layers,
            						renderTarget: c.renderTarget,
            						nearClip: c.nearClip,
            						orthoHeight: c.orthoHeight,
            						projection: c.projection,
            						priority: c.priority,
            						rect: c.rect,
            						scissorRect: c.scissorRect,
            						aperture: c.aperture,
            						sensitivity: c.sensitivity,
            						shutter: c.shutter,
            						gammaCorrection: c.gammaCorrection,
            						toneMapping: c.toneMapping
            				});
            		}
            		onBeforeRemove(entity, component) {
            				this.removeCamera(component);
            				component.onRemove();
            		}
            		onAppPrerender() {
            				for(var i = 0, len = this.cameras.length; i < len; i++){
            						this.cameras[i].onAppPrerender();
            				}
            		}
            		addCamera(camera) {
            				this.cameras.push(camera);
            				sortPriority(this.cameras);
            		}
            		removeCamera(camera) {
            				var index = this.cameras.indexOf(camera);
            				if (index >= 0) {
            						this.cameras.splice(index, 1);
            						sortPriority(this.cameras);
            				}
            		}
            		destroy() {
            				this.app.off('prerender', this.onAppPrerender, this);
            				super.destroy();
            		}
            		constructor(app){
            				super(app), this.cameras = [];
            				this.id = 'camera';
            				this.ComponentType = CameraComponent;
            				this.DataType = CameraComponentData;
            				this.schema = _schema$1;
            				this.on('beforeremove', this.onBeforeRemove, this);
            				this.app.on('prerender', this.onAppPrerender, this);
            		}
            }
            Component._buildAccessors(CameraComponent.prototype, _schema$1);
            
            class LightComponentData {
            		constructor(){
            				this.enabled = true;
            				this.type = 'directional';
            				this.color = new Color(1, 1, 1);
            				this.intensity = 1;
            				this.luminance = 0;
            				this.shape = LIGHTSHAPE_PUNCTUAL;
            				this.affectSpecularity = true;
            				this.castShadows = false;
            				this.shadowDistance = 40;
            				this.shadowIntensity = 1;
            				this.shadowResolution = 1024;
            				this.shadowBias = 0.05;
            				this.numCascades = 1;
            				this.cascadeBlend = 0;
            				this.bakeNumSamples = 1;
            				this.bakeArea = 0;
            				this.cascadeDistribution = 0.5;
            				this.normalOffsetBias = 0;
            				this.range = 10;
            				this.innerConeAngle = 40;
            				this.outerConeAngle = 45;
            				this.falloffMode = LIGHTFALLOFF_LINEAR;
            				this.shadowType = SHADOW_PCF3_32F;
            				this.vsmBlurSize = 11;
            				this.vsmBlurMode = BLUR_GAUSSIAN;
            				this.vsmBias = 0.01 * 0.25;
            				this.cookieAsset = null;
            				this.cookie = null;
            				this.cookieIntensity = 1;
            				this.cookieFalloff = true;
            				this.cookieChannel = 'rgb';
            				this.cookieAngle = 0;
            				this.cookieScale = null;
            				this.cookieOffset = null;
            				this.shadowUpdateMode = SHADOWUPDATE_REALTIME;
            				this.mask = 1;
            				this.affectDynamic = true;
            				this.affectLightmapped = false;
            				this.bake = false;
            				this.bakeDir = true;
            				this.isStatic = false;
            				this.layers = [
            						LAYERID_WORLD
            				];
            				this.penumbraSize = 1;
            				this.penumbraFalloff = 1;
            				this.shadowSamples = 16;
            				this.shadowBlockerSamples = 16;
            		}
            }
            var properties = Object.keys(new LightComponentData());
            
            class LightComponent extends Component {
            		get data() {
            				var record = this.system.store[this.entity.getGuid()];
            				return record ? record.data : null;
            		}
            		set enabled(arg) {
            				this._setValue('enabled', arg, function(newValue, oldValue) {
            						this.onSetEnabled(null, oldValue, newValue);
            				});
            		}
            		get enabled() {
            				return this.data.enabled;
            		}
            		set light(arg) {
            				this._setValue('light', arg);
            		}
            		get light() {
            				return this.data.light;
            		}
            		set type(arg) {
            				this._setValue('type', arg, function(newValue, oldValue) {
            						this.system.changeType(this, oldValue, newValue);
            						this.refreshProperties();
            				});
            		}
            		get type() {
            				return this.data.type;
            		}
            		set color(arg) {
            				this._setValue('color', arg, function(newValue, oldValue) {
            						this.light.setColor(newValue);
            				}, true);
            		}
            		get color() {
            				return this.data.color;
            		}
            		set intensity(arg) {
            				this._setValue('intensity', arg, function(newValue, oldValue) {
            						this.light.intensity = newValue;
            				});
            		}
            		get intensity() {
            				return this.data.intensity;
            		}
            		set luminance(arg) {
            				this._setValue('luminance', arg, function(newValue, oldValue) {
            						this.light.luminance = newValue;
            				});
            		}
            		get luminance() {
            				return this.data.luminance;
            		}
            		set shape(arg) {
            				this._setValue('shape', arg, function(newValue, oldValue) {
            						this.light.shape = newValue;
            				});
            		}
            		get shape() {
            				return this.data.shape;
            		}
            		set affectSpecularity(arg) {
            				this._setValue('affectSpecularity', arg, function(newValue, oldValue) {
            						this.light.affectSpecularity = newValue;
            				});
            		}
            		get affectSpecularity() {
            				return this.data.affectSpecularity;
            		}
            		set castShadows(arg) {
            				this._setValue('castShadows', arg, function(newValue, oldValue) {
            						this.light.castShadows = newValue;
            				});
            		}
            		get castShadows() {
            				return this.data.castShadows;
            		}
            		set shadowDistance(arg) {
            				this._setValue('shadowDistance', arg, function(newValue, oldValue) {
            						this.light.shadowDistance = newValue;
            				});
            		}
            		get shadowDistance() {
            				return this.data.shadowDistance;
            		}
            		set shadowIntensity(arg) {
            				this._setValue('shadowIntensity', arg, function(newValue, oldValue) {
            						this.light.shadowIntensity = newValue;
            				});
            		}
            		get shadowIntensity() {
            				return this.data.shadowIntensity;
            		}
            		set shadowResolution(arg) {
            				this._setValue('shadowResolution', arg, function(newValue, oldValue) {
            						this.light.shadowResolution = newValue;
            				});
            		}
            		get shadowResolution() {
            				return this.data.shadowResolution;
            		}
            		set shadowBias(arg) {
            				this._setValue('shadowBias', arg, function(newValue, oldValue) {
            						this.light.shadowBias = -0.01 * math.clamp(newValue, 0, 1);
            				});
            		}
            		get shadowBias() {
            				return this.data.shadowBias;
            		}
            		set numCascades(arg) {
            				this._setValue('numCascades', arg, function(newValue, oldValue) {
            						this.light.numCascades = math.clamp(Math.floor(newValue), 1, 4);
            				});
            		}
            		get numCascades() {
            				return this.data.numCascades;
            		}
            		set cascadeBlend(value) {
            				this._setValue('cascadeBlend', value, function(newValue, oldValue) {
            						this.light.cascadeBlend = math.clamp(newValue, 0, 1);
            				});
            		}
            		get cascadeBlend() {
            				return this.data.cascadeBlend;
            		}
            		set bakeNumSamples(arg) {
            				this._setValue('bakeNumSamples', arg, function(newValue, oldValue) {
            						this.light.bakeNumSamples = math.clamp(Math.floor(newValue), 1, 255);
            				});
            		}
            		get bakeNumSamples() {
            				return this.data.bakeNumSamples;
            		}
            		set bakeArea(arg) {
            				this._setValue('bakeArea', arg, function(newValue, oldValue) {
            						this.light.bakeArea = math.clamp(newValue, 0, 180);
            				});
            		}
            		get bakeArea() {
            				return this.data.bakeArea;
            		}
            		set cascadeDistribution(arg) {
            				this._setValue('cascadeDistribution', arg, function(newValue, oldValue) {
            						this.light.cascadeDistribution = math.clamp(newValue, 0, 1);
            				});
            		}
            		get cascadeDistribution() {
            				return this.data.cascadeDistribution;
            		}
            		set normalOffsetBias(arg) {
            				this._setValue('normalOffsetBias', arg, function(newValue, oldValue) {
            						this.light.normalOffsetBias = math.clamp(newValue, 0, 1);
            				});
            		}
            		get normalOffsetBias() {
            				return this.data.normalOffsetBias;
            		}
            		set range(arg) {
            				this._setValue('range', arg, function(newValue, oldValue) {
            						this.light.attenuationEnd = newValue;
            				});
            		}
            		get range() {
            				return this.data.range;
            		}
            		set innerConeAngle(arg) {
            				this._setValue('innerConeAngle', arg, function(newValue, oldValue) {
            						this.light.innerConeAngle = newValue;
            				});
            		}
            		get innerConeAngle() {
            				return this.data.innerConeAngle;
            		}
            		set outerConeAngle(arg) {
            				this._setValue('outerConeAngle', arg, function(newValue, oldValue) {
            						this.light.outerConeAngle = newValue;
            				});
            		}
            		get outerConeAngle() {
            				return this.data.outerConeAngle;
            		}
            		set falloffMode(arg) {
            				this._setValue('falloffMode', arg, function(newValue, oldValue) {
            						this.light.falloffMode = newValue;
            				});
            		}
            		get falloffMode() {
            				return this.data.falloffMode;
            		}
            		set shadowType(arg) {
            				this._setValue('shadowType', arg, function(newValue, oldValue) {
            						this.light.shadowType = newValue;
            				});
            		}
            		get shadowType() {
            				return this.data.shadowType;
            		}
            		set vsmBlurSize(arg) {
            				this._setValue('vsmBlurSize', arg, function(newValue, oldValue) {
            						this.light.vsmBlurSize = newValue;
            				});
            		}
            		get vsmBlurSize() {
            				return this.data.vsmBlurSize;
            		}
            		set vsmBlurMode(arg) {
            				this._setValue('vsmBlurMode', arg, function(newValue, oldValue) {
            						this.light.vsmBlurMode = newValue;
            				});
            		}
            		get vsmBlurMode() {
            				return this.data.vsmBlurMode;
            		}
            		set vsmBias(arg) {
            				this._setValue('vsmBias', arg, function(newValue, oldValue) {
            						this.light.vsmBias = math.clamp(newValue, 0, 1);
            				});
            		}
            		get vsmBias() {
            				return this.data.vsmBias;
            		}
            		set cookieAsset(arg) {
            				this._setValue('cookieAsset', arg, function(newValue, oldValue) {
            						if (this._cookieAssetId && (newValue instanceof Asset && newValue.id === this._cookieAssetId || newValue === this._cookieAssetId)) {
            								return;
            						}
            						this.onCookieAssetRemove();
            						this._cookieAssetId = null;
            						if (newValue instanceof Asset) {
            								this.data.cookieAsset = newValue.id;
            								this._cookieAssetId = newValue.id;
            								this.onCookieAssetAdd(newValue);
            						} else if (typeof newValue === 'number') {
            								this._cookieAssetId = newValue;
            								var asset = this.system.app.assets.get(newValue);
            								if (asset) {
            										this.onCookieAssetAdd(asset);
            								} else {
            										this._cookieAssetAdd = true;
            										this.system.app.assets.on("add:" + this._cookieAssetId, this.onCookieAssetAdd, this);
            								}
            						}
            				});
            		}
            		get cookieAsset() {
            				return this.data.cookieAsset;
            		}
            		set cookie(arg) {
            				this._setValue('cookie', arg, function(newValue, oldValue) {
            						this.light.cookie = newValue;
            				});
            		}
            		get cookie() {
            				return this.data.cookie;
            		}
            		set cookieIntensity(arg) {
            				this._setValue('cookieIntensity', arg, function(newValue, oldValue) {
            						this.light.cookieIntensity = math.clamp(newValue, 0, 1);
            				});
            		}
            		get cookieIntensity() {
            				return this.data.cookieIntensity;
            		}
            		set cookieFalloff(arg) {
            				this._setValue('cookieFalloff', arg, function(newValue, oldValue) {
            						this.light.cookieFalloff = newValue;
            				});
            		}
            		get cookieFalloff() {
            				return this.data.cookieFalloff;
            		}
            		set cookieChannel(arg) {
            				this._setValue('cookieChannel', arg, function(newValue, oldValue) {
            						this.light.cookieChannel = newValue;
            				});
            		}
            		get cookieChannel() {
            				return this.data.cookieChannel;
            		}
            		set cookieAngle(arg) {
            				this._setValue('cookieAngle', arg, function(newValue, oldValue) {
            						if (newValue !== 0 || this.cookieScale !== null) {
            								if (!this._cookieMatrix) this._cookieMatrix = new Vec4();
            								var scx = 1;
            								var scy = 1;
            								if (this.cookieScale) {
            										scx = this.cookieScale.x;
            										scy = this.cookieScale.y;
            								}
            								var c = Math.cos(newValue * math.DEG_TO_RAD);
            								var s = Math.sin(newValue * math.DEG_TO_RAD);
            								this._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);
            								this.light.cookieTransform = this._cookieMatrix;
            						} else {
            								this.light.cookieTransform = null;
            						}
            				});
            		}
            		get cookieAngle() {
            				return this.data.cookieAngle;
            		}
            		set cookieScale(arg) {
            				this._setValue('cookieScale', arg, function(newValue, oldValue) {
            						if (newValue !== null || this.cookieAngle !== 0) {
            								if (!this._cookieMatrix) this._cookieMatrix = new Vec4();
            								var scx = newValue.x;
            								var scy = newValue.y;
            								var c = Math.cos(this.cookieAngle * math.DEG_TO_RAD);
            								var s = Math.sin(this.cookieAngle * math.DEG_TO_RAD);
            								this._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);
            								this.light.cookieTransform = this._cookieMatrix;
            						} else {
            								this.light.cookieTransform = null;
            						}
            				}, true);
            		}
            		get cookieScale() {
            				return this.data.cookieScale;
            		}
            		set cookieOffset(arg) {
            				this._setValue('cookieOffset', arg, function(newValue, oldValue) {
            						this.light.cookieOffset = newValue;
            				}, true);
            		}
            		get cookieOffset() {
            				return this.data.cookieOffset;
            		}
            		set shadowUpdateMode(arg) {
            				this._setValue('shadowUpdateMode', arg, function(newValue, oldValue) {
            						this.light.shadowUpdateMode = newValue;
            				}, true);
            		}
            		get shadowUpdateMode() {
            				return this.data.shadowUpdateMode;
            		}
            		set mask(arg) {
            				this._setValue('mask', arg, function(newValue, oldValue) {
            						this.light.mask = newValue;
            				});
            		}
            		get mask() {
            				return this.data.mask;
            		}
            		set affectDynamic(arg) {
            				this._setValue('affectDynamic', arg, function(newValue, oldValue) {
            						if (newValue) {
            								this.light.mask |= MASK_AFFECT_DYNAMIC;
            						} else {
            								this.light.mask &= -2;
            						}
            						this.light.layersDirty();
            				});
            		}
            		get affectDynamic() {
            				return this.data.affectDynamic;
            		}
            		set affectLightmapped(arg) {
            				this._setValue('affectLightmapped', arg, function(newValue, oldValue) {
            						if (newValue) {
            								this.light.mask |= MASK_AFFECT_LIGHTMAPPED;
            								if (this.bake) this.light.mask &= -5;
            						} else {
            								this.light.mask &= -3;
            								if (this.bake) this.light.mask |= MASK_BAKE;
            						}
            				});
            		}
            		get affectLightmapped() {
            				return this.data.affectLightmapped;
            		}
            		set bake(arg) {
            				this._setValue('bake', arg, function(newValue, oldValue) {
            						if (newValue) {
            								this.light.mask |= MASK_BAKE;
            								if (this.affectLightmapped) this.light.mask &= -3;
            						} else {
            								this.light.mask &= -5;
            								if (this.affectLightmapped) this.light.mask |= MASK_AFFECT_LIGHTMAPPED;
            						}
            						this.light.layersDirty();
            				});
            		}
            		get bake() {
            				return this.data.bake;
            		}
            		set bakeDir(arg) {
            				this._setValue('bakeDir', arg, function(newValue, oldValue) {
            						this.light.bakeDir = newValue;
            				});
            		}
            		get bakeDir() {
            				return this.data.bakeDir;
            		}
            		set isStatic(arg) {
            				this._setValue('isStatic', arg, function(newValue, oldValue) {
            						this.light.isStatic = newValue;
            				});
            		}
            		get isStatic() {
            				return this.data.isStatic;
            		}
            		set layers(arg) {
            				this._setValue('layers', arg, function(newValue, oldValue) {
            						for(var i = 0; i < oldValue.length; i++){
            								var layer = this.system.app.scene.layers.getLayerById(oldValue[i]);
            								if (!layer) continue;
            								layer.removeLight(this);
            								this.light.removeLayer(layer);
            						}
            						for(var i1 = 0; i1 < newValue.length; i1++){
            								var layer1 = this.system.app.scene.layers.getLayerById(newValue[i1]);
            								if (!layer1) continue;
            								if (this.enabled && this.entity.enabled) {
            										layer1.addLight(this);
            										this.light.addLayer(layer1);
            								}
            						}
            				});
            		}
            		get layers() {
            				return this.data.layers;
            		}
            		set shadowUpdateOverrides(values) {
            				this.light.shadowUpdateOverrides = values;
            		}
            		get shadowUpdateOverrides() {
            				return this.light.shadowUpdateOverrides;
            		}
            		set shadowSamples(value) {
            				this.light.shadowSamples = value;
            		}
            		get shadowSamples() {
            				return this.light.shadowSamples;
            		}
            		set shadowBlockerSamples(value) {
            				this.light.shadowBlockerSamples = value;
            		}
            		get shadowBlockerSamples() {
            				return this.light.shadowBlockerSamples;
            		}
            		set penumbraSize(value) {
            				this.light.penumbraSize = value;
            		}
            		get penumbraSize() {
            				return this.light.penumbraSize;
            		}
            		set penumbraFalloff(value) {
            				this.light.penumbraFalloff = value;
            		}
            		get penumbraFalloff() {
            				return this.light.penumbraFalloff;
            		}
            		_setValue(name, value, setFunc, skipEqualsCheck) {
            				var data = this.data;
            				var oldValue = data[name];
            				if (!skipEqualsCheck && oldValue === value) return;
            				data[name] = value;
            				if (setFunc) setFunc.call(this, value, oldValue);
            		}
            		addLightToLayers() {
            				for(var i = 0; i < this.layers.length; i++){
            						var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
            						if (layer) {
            								layer.addLight(this);
            								this.light.addLayer(layer);
            						}
            				}
            		}
            		removeLightFromLayers() {
            				for(var i = 0; i < this.layers.length; i++){
            						var layer = this.system.app.scene.layers.getLayerById(this.layers[i]);
            						if (layer) {
            								layer.removeLight(this);
            								this.light.removeLayer(layer);
            						}
            				}
            		}
            		onLayersChanged(oldComp, newComp) {
            				if (this.enabled && this.entity.enabled) {
            						this.addLightToLayers();
            				}
            				oldComp.off('add', this.onLayerAdded, this);
            				oldComp.off('remove', this.onLayerRemoved, this);
            				newComp.on('add', this.onLayerAdded, this);
            				newComp.on('remove', this.onLayerRemoved, this);
            		}
            		onLayerAdded(layer) {
            				var index = this.layers.indexOf(layer.id);
            				if (index >= 0 && this.enabled && this.entity.enabled) {
            						layer.addLight(this);
            						this.light.addLayer(layer);
            				}
            		}
            		onLayerRemoved(layer) {
            				var index = this.layers.indexOf(layer.id);
            				if (index >= 0) {
            						layer.removeLight(this);
            						this.light.removeLayer(layer);
            				}
            		}
            		refreshProperties() {
            				for(var i = 0; i < properties.length; i++){
            						var name = properties[i];
            						this[name] = this[name];
            				}
            				if (this.enabled && this.entity.enabled) {
            						this.onEnable();
            				}
            		}
            		onCookieAssetSet() {
            				var forceLoad = false;
            				if (this._cookieAsset.type === 'cubemap' && !this._cookieAsset.loadFaces) {
            						this._cookieAsset.loadFaces = true;
            						forceLoad = true;
            				}
            				if (!this._cookieAsset.resource || forceLoad) this.system.app.assets.load(this._cookieAsset);
            				if (this._cookieAsset.resource) {
            						this.onCookieAssetLoad();
            				}
            		}
            		onCookieAssetAdd(asset) {
            				if (this._cookieAssetId !== asset.id) return;
            				this._cookieAsset = asset;
            				if (this.light.enabled) {
            						this.onCookieAssetSet();
            				}
            				this._cookieAsset.on('load', this.onCookieAssetLoad, this);
            				this._cookieAsset.on('remove', this.onCookieAssetRemove, this);
            		}
            		onCookieAssetLoad() {
            				if (!this._cookieAsset || !this._cookieAsset.resource) {
            						return;
            				}
            				this.cookie = this._cookieAsset.resource;
            		}
            		onCookieAssetRemove() {
            				if (!this._cookieAssetId) {
            						return;
            				}
            				if (this._cookieAssetAdd) {
            						this.system.app.assets.off("add:" + this._cookieAssetId, this.onCookieAssetAdd, this);
            						this._cookieAssetAdd = false;
            				}
            				if (this._cookieAsset) {
            						this._cookieAsset.off('load', this.onCookieAssetLoad, this);
            						this._cookieAsset.off('remove', this.onCookieAssetRemove, this);
            						this._cookieAsset = null;
            				}
            				this.cookie = null;
            		}
            		onEnable() {
            				var scene = this.system.app.scene;
            				var layers = scene.layers;
            				this.light.enabled = true;
            				this._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);
            				if (layers) {
            						this._evtLayerAdded = layers.on('add', this.onLayerAdded, this);
            						this._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);
            				}
            				if (this.enabled && this.entity.enabled) {
            						this.addLightToLayers();
            				}
            				if (this._cookieAsset && !this.cookie) {
            						this.onCookieAssetSet();
            				}
            		}
            		onDisable() {
            				var _this__evtLayersChanged;
            				var scene = this.system.app.scene;
            				var layers = scene.layers;
            				this.light.enabled = false;
            				(_this__evtLayersChanged = this._evtLayersChanged) == null ? void 0 : _this__evtLayersChanged.off();
            				this._evtLayersChanged = null;
            				if (layers) {
            						var _this__evtLayerAdded, _this__evtLayerRemoved;
            						(_this__evtLayerAdded = this._evtLayerAdded) == null ? void 0 : _this__evtLayerAdded.off();
            						this._evtLayerAdded = null;
            						(_this__evtLayerRemoved = this._evtLayerRemoved) == null ? void 0 : _this__evtLayerRemoved.off();
            						this._evtLayerRemoved = null;
            				}
            				this.removeLightFromLayers();
            		}
            		onRemove() {
            				this.onDisable();
            				this.light.destroy();
            				this.cookieAsset = null;
            		}
            		constructor(...args){
            				super(...args), this._evtLayersChanged = null, this._evtLayerAdded = null, this._evtLayerRemoved = null, this._cookieAsset = null, this._cookieAssetId = null, this._cookieAssetAdd = false, this._cookieMatrix = null;
            		}
            }
            
            function _extends$8() {
            		_extends$8 = Object.assign || function(target) {
            				for(var i = 1; i < arguments.length; i++){
            						var source = arguments[i];
            						for(var key in source){
            								if (Object.prototype.hasOwnProperty.call(source, key)) {
            										target[key] = source[key];
            								}
            						}
            				}
            				return target;
            		};
            		return _extends$8.apply(this, arguments);
            }
            class LightComponentSystem extends ComponentSystem {
            		initializeComponentData(component, _data) {
            				var data = _extends$8({}, _data);
            				if (!data.type) {
            						data.type = component.data.type;
            				}
            				component.data.type = data.type;
            				if (data.layers && Array.isArray(data.layers)) {
            						data.layers = data.layers.slice(0);
            				}
            				if (data.color && Array.isArray(data.color)) {
            						data.color = new Color(data.color[0], data.color[1], data.color[2]);
            				}
            				if (data.cookieOffset && data.cookieOffset instanceof Array) {
            						data.cookieOffset = new Vec2(data.cookieOffset[0], data.cookieOffset[1]);
            				}
            				if (data.cookieScale && data.cookieScale instanceof Array) {
            						data.cookieScale = new Vec2(data.cookieScale[0], data.cookieScale[1]);
            				}
            				if (data.enable) {
            						console.warn('WARNING: enable: Property is deprecated. Set enabled property instead.');
            						data.enabled = data.enable;
            				}
            				if (!data.shape) {
            						data.shape = LIGHTSHAPE_PUNCTUAL;
            				}
            				var light = new Light(this.app.graphicsDevice, this.app.scene.clusteredLightingEnabled);
            				light.type = lightTypes[data.type];
            				light._node = component.entity;
            				component.data.light = light;
            				super.initializeComponentData(component, data, properties);
            		}
            		_onRemoveComponent(entity, component) {
            				component.onRemove();
            		}
            		cloneComponent(entity, clone) {
            				var light = entity.light;
            				var data = [];
            				var name;
            				for(var i = 0; i < properties.length; i++){
            						name = properties[i];
            						if (name === 'light') {
            								continue;
            						}
            						if (light[name] && light[name].clone) {
            								data[name] = light[name].clone();
            						} else {
            								data[name] = light[name];
            						}
            				}
            				return this.addComponent(clone, data);
            		}
            		changeType(component, oldValue, newValue) {
            				if (oldValue !== newValue) {
            						component.light.type = lightTypes[newValue];
            				}
            		}
            		constructor(app){
            				super(app);
            				this.id = 'light';
            				this.ComponentType = LightComponent;
            				this.DataType = LightComponentData;
            				this.on('beforeremove', this._onRemoveComponent, this);
            		}
            }
            
            var components = [
            		'x',
            		'y',
            		'z',
            		'w'
            ];
            var vecLookup = [
            		undefined,
            		undefined,
            		Vec2,
            		Vec3,
            		Vec4
            ];
            function rawToValue(app, args, value, old) {
            		switch(args.type){
            				case 'boolean':
            						return !!value;
            				case 'number':
            						if (typeof value === 'number') {
            								return value;
            						} else if (typeof value === 'string') {
            								var v = parseInt(value, 10);
            								if (isNaN(v)) return null;
            								return v;
            						} else if (typeof value === 'boolean') {
            								return 0 + value;
            						}
            						return null;
            				case 'json':
            						{
            								var result = {};
            								if (Array.isArray(args.schema)) {
            										if (!value || typeof value !== 'object') {
            												value = {};
            										}
            										for(var i = 0; i < args.schema.length; i++){
            												var field = args.schema[i];
            												if (!field.name) continue;
            												if (field.array) {
            														result[field.name] = [];
            														var arr = Array.isArray(value[field.name]) ? value[field.name] : [];
            														for(var j = 0; j < arr.length; j++){
            																result[field.name].push(rawToValue(app, field, arr[j]));
            														}
            												} else {
            														var val = value.hasOwnProperty(field.name) ? value[field.name] : field.default;
            														result[field.name] = rawToValue(app, field, val);
            												}
            										}
            								}
            								return result;
            						}
            				case 'asset':
            						if (value instanceof Asset) {
            								return value;
            						} else if (typeof value === 'number') {
            								return app.assets.get(value) || null;
            						} else if (typeof value === 'string') {
            								return app.assets.get(parseInt(value, 10)) || null;
            						}
            						return null;
            				case 'entity':
            						if (value instanceof GraphNode) {
            								return value;
            						} else if (typeof value === 'string') {
            								return app.getEntityFromIndex(value);
            						}
            						return null;
            				case 'rgb':
            				case 'rgba':
            						if (value instanceof Color) {
            								if (old instanceof Color) {
            										old.copy(value);
            										return old;
            								}
            								return value.clone();
            						} else if (value instanceof Array && value.length >= 3 && value.length <= 4) {
            								for(var i1 = 0; i1 < value.length; i1++){
            										if (typeof value[i1] !== 'number') {
            												return null;
            										}
            								}
            								if (!old) old = new Color();
            								old.r = value[0];
            								old.g = value[1];
            								old.b = value[2];
            								old.a = value.length === 3 ? 1 : value[3];
            								return old;
            						} else if (typeof value === 'string' && /#(?:[0-9a-f]{2}){3,4}/i.test(value)) {
            								if (!old) {
            										old = new Color();
            								}
            								old.fromString(value);
            								return old;
            						}
            						return null;
            				case 'vec2':
            				case 'vec3':
            				case 'vec4':
            						{
            								var len = parseInt(args.type.slice(3), 10);
            								var vecType = vecLookup[len];
            								if (value instanceof vecType) {
            										if (old instanceof vecType) {
            												old.copy(value);
            												return old;
            										}
            										return value.clone();
            								} else if (value instanceof Array && value.length === len) {
            										for(var i2 = 0; i2 < value.length; i2++){
            												if (typeof value[i2] !== 'number') {
            														return null;
            												}
            										}
            										if (!old) old = new vecType();
            										for(var i3 = 0; i3 < len; i3++){
            												old[components[i3]] = value[i3];
            										}
            										return old;
            								}
            								return null;
            						}
            				case 'curve':
            						if (value) {
            								var curve;
            								if (value instanceof Curve || value instanceof CurveSet) {
            										curve = value.clone();
            								} else {
            										var CurveType = value.keys[0] instanceof Array ? CurveSet : Curve;
            										curve = new CurveType(value.keys);
            										curve.type = value.type;
            								}
            								return curve;
            						}
            						break;
            		}
            		return value;
            }
            function attributeToValue(app, schema, value, current) {
            		if (schema.array) {
            				return value.map((item, index)=>rawToValue(app, schema, item, current ? current[index] : null));
            		}
            		return rawToValue(app, schema, value, current);
            }
            function assignAttributesToScript(app, attributeSchemaMap, data, script) {
            		if (!data) return;
            		for(var attributeName in attributeSchemaMap){
            				var attributeSchema = attributeSchemaMap[attributeName];
            				var dataToAssign = data[attributeName];
            				if (dataToAssign === undefined) continue;
            				script[attributeName] = attributeToValue(app, attributeSchema, dataToAssign, script[attributeName]);
            		}
            }
            class ScriptAttributes {
            		add(name, args) {
            				if (this.index[name]) {
            						return;
            				} else if (ScriptAttributes.reservedNames.has(name)) {
            						return;
            				}
            				this.index[name] = args;
            				Object.defineProperty(this.scriptType.prototype, name, {
            						get: function get() {
            								return this.__attributes[name];
            						},
            						set: function set(raw) {
            								var evt = 'attr';
            								var evtName = "attr:" + name;
            								var old = this.__attributes[name];
            								var oldCopy = old;
            								if (old && args.type !== 'json' && args.type !== 'entity' && old.clone) {
            										if (this.hasEvent(evt) || this.hasEvent(evtName)) {
            												oldCopy = old.clone();
            										}
            								}
            								if (args.array) {
            										this.__attributes[name] = [];
            										if (raw) {
            												for(var i = 0, len = raw.length; i < len; i++){
            														this.__attributes[name].push(rawToValue(this.app, args, raw[i], old ? old[i] : null));
            												}
            										}
            								} else {
            										this.__attributes[name] = rawToValue(this.app, args, raw, old);
            								}
            								this.fire(evt, name, this.__attributes[name], oldCopy);
            								this.fire(evtName, this.__attributes[name], oldCopy);
            						}
            				});
            		}
            		remove(name) {
            				if (!this.index[name]) {
            						return false;
            				}
            				delete this.index[name];
            				delete this.scriptType.prototype[name];
            				return true;
            		}
            		has(name) {
            				return !!this.index[name];
            		}
            		get(name) {
            				return this.index[name] || null;
            		}
            		constructor(scriptType){
            				this.scriptType = scriptType;
            				this.index = {};
            		}
            }
            ScriptAttributes.assignAttributesToScript = assignAttributesToScript;
            ScriptAttributes.attributeToValue = attributeToValue;
            ScriptAttributes.reservedNames = new Set([
            		'app',
            		'entity',
            		'enabled',
            		'_enabled',
            		'_enabledOld',
            		'_destroyed',
            		'__attributes',
            		'__attributesRaw',
            		"__scriptType",
            		'__executionOrder',
            		'_callbacks',
            		'_callbackActive',
            		'has',
            		'get',
            		'on',
            		'off',
            		'fire',
            		'once',
            		'hasEvent'
            ]);
            
            var SCRIPT_INITIALIZE = 'initialize';
            var SCRIPT_POST_INITIALIZE = 'postInitialize';
            var SCRIPT_UPDATE = 'update';
            var SCRIPT_POST_UPDATE = 'postUpdate';
            var SCRIPT_SWAP = 'swap';
            
            class Script extends EventHandler {
            		set enabled(value) {
            				this._enabled = !!value;
            				if (this.enabled === this._enabledOld) return;
            				this._enabledOld = this.enabled;
            				this.fire(this.enabled ? 'enable' : 'disable');
            				this.fire('state', this.enabled);
            				if (!this._initialized && this.enabled) {
            						this._initialized = true;
            						this.fire('preInitialize');
            						if (this.initialize) {
            								this.entity.script._scriptMethod(this, SCRIPT_INITIALIZE);
            						}
            				}
            				if (this._initialized && !this._postInitialized && this.enabled && !this.entity.script._beingEnabled) {
            						this._postInitialized = true;
            						if (this.postInitialize) {
            								this.entity.script._scriptMethod(this, SCRIPT_POST_INITIALIZE);
            						}
            				}
            		}
            		get enabled() {
            				return this._enabled && !this._destroyed && this.entity.script.enabled && this.entity.enabled;
            		}
            		initScript(args) {
            				var script = this.constructor;
            				this.app = args.app;
            				this.entity = args.entity;
            				this._enabled = typeof args.enabled === 'boolean' ? args.enabled : true;
            				this._enabledOld = this.enabled;
            				this.__destroyed = false;
            				this.__scriptType = script;
            				this.__executionOrder = -1;
            		}
            		static get scriptName() {
            				return this.__name;
            		}
            		constructor(args){
            				super();
            				this.initScript(args);
            		}
            }
            Script.EVENT_ENABLE = 'enable';
            Script.EVENT_DISABLE = 'disable';
            Script.EVENT_STATE = 'state';
            Script.EVENT_DESTROY = 'destroy';
            Script.EVENT_ATTR = 'attr';
            Script.EVENT_ERROR = 'error';
            Script.__name = null;
            Script.__getScriptName = getScriptName;
            var funcNameRegex = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s\/]*)\s*/;
            function getScriptName(constructorFn) {
            		if (typeof constructorFn !== 'function') return undefined;
            		if ('name' in Function.prototype) return constructorFn.name;
            		if (constructorFn === Function || constructorFn === Function.prototype.constructor) return 'Function';
            		var match = ("" + constructorFn).match(funcNameRegex);
            		return match ? match[1] : undefined;
            }
            
            class ScriptType extends Script {
            		static get attributes() {
            				if (!this.hasOwnProperty('__attributes')) this.__attributes = new ScriptAttributes(this);
            				return this.__attributes;
            		}
            		initScript(args) {
            				Script.prototype.initScript.call(this, args);
            				this.__attributes = {};
            				this.__attributesRaw = args.attributes || {};
            		}
            		initScriptType(args) {
            				this.initScript(args);
            		}
            		__initializeAttributes(force) {
            				if (!force && !this.__attributesRaw) {
            						return;
            				}
            				for(var key in this.__scriptType.attributes.index){
            						if (this.__attributesRaw && this.__attributesRaw.hasOwnProperty(key)) {
            								this[key] = this.__attributesRaw[key];
            						} else if (!this.__attributes.hasOwnProperty(key)) {
            								if (this.__scriptType.attributes.index[key].hasOwnProperty('default')) {
            										this[key] = this.__scriptType.attributes.index[key].default;
            								} else {
            										this[key] = null;
            								}
            						}
            				}
            				this.__attributesRaw = null;
            		}
            		static extend(methods) {
            				for(var key in methods){
            						if (!methods.hasOwnProperty(key)) {
            								continue;
            						}
            						this.prototype[key] = methods[key];
            				}
            		}
            		constructor(args){
            				super(args);
            				this.initScriptType(args);
            		}
            }
            
            var toLowerCamelCase$1 = (str)=>str[0].toLowerCase() + str.substring(1);
            class ScriptComponent extends Component {
            		set scripts(value) {
            				var _this, _loop = function(key) {
            						if (!value.hasOwnProperty(key)) {
            								return "continue";
            						}
            						var script = _this._scriptsIndex[key];
            						if (script) {
            								if (typeof value[key].enabled === 'boolean') {
            										script.once('preInitialize', ()=>{
            												_this.initializeAttributes(script);
            										});
            										script.enabled = !!value[key].enabled;
            								}
            								if (typeof value[key].attributes === 'object') {
            										for(var attr in value[key].attributes){
            												if (ScriptAttributes.reservedNames.has(attr)) {
            														continue;
            												}
            												if (!script.__attributes.hasOwnProperty(attr)) {
            														var scriptType = _this.system.app.scripts.get(key);
            														if (scriptType) {
            																scriptType.attributes.add(attr, {});
            														}
            												}
            												script[attr] = value[key].attributes[attr];
            										}
            								}
            						} else {
            								console.log(_this.order);
            						}
            				};
            				this._scriptsData = value;
            				for(var key in value)_this = this, _loop(key);
            		}
            		get scripts() {
            				return this._scripts;
            		}
            		set enabled(value) {
            				var oldValue = this._enabled;
            				this._enabled = value;
            				this.fire('set', 'enabled', oldValue, value);
            		}
            		get enabled() {
            				return this._enabled;
            		}
            		onEnable() {
            				this._beingEnabled = true;
            				this._checkState();
            				if (!this.entity._beingEnabled) {
            						this.onPostStateChange();
            				}
            				this._beingEnabled = false;
            		}
            		onDisable() {
            				this._checkState();
            		}
            		onPostStateChange() {
            				var wasLooping = this._beginLooping();
            				for(var i = 0, len = this.scripts.length; i < len; i++){
            						var script = this.scripts[i];
            						if (script._initialized && !script._postInitialized && script.enabled) {
            								script._postInitialized = true;
            								if (script.postInitialize) {
            										this._scriptMethod(script, SCRIPT_POST_INITIALIZE);
            								}
            						}
            				}
            				this._endLooping(wasLooping);
            		}
            		_beginLooping() {
            				var looping = this._isLoopingThroughScripts;
            				this._isLoopingThroughScripts = true;
            				return looping;
            		}
            		_endLooping(wasLoopingBefore) {
            				this._isLoopingThroughScripts = wasLoopingBefore;
            				if (!this._isLoopingThroughScripts) {
            						this._removeDestroyedScripts();
            				}
            		}
            		_onSetEnabled(prop, old, value) {
            				this._beingEnabled = true;
            				this._checkState();
            				this._beingEnabled = false;
            		}
            		_checkState() {
            				var _this, _loop = function(i, len) {
            						var script = _this.scripts[i];
            						script.once('preInitialize', ()=>{
            								_this.initializeAttributes(script);
            						});
            						script.enabled = script._enabled;
            				};
            				var state = this.enabled && this.entity.enabled;
            				if (state === this._oldState) {
            						return;
            				}
            				this._oldState = state;
            				this.fire(state ? 'enable' : 'disable');
            				this.fire('state', state);
            				if (state) {
            						this.system._addComponentToEnabled(this);
            				} else {
            						this.system._removeComponentFromEnabled(this);
            				}
            				var wasLooping = this._beginLooping();
            				for(var i = 0, len = this.scripts.length; i < len; i++)_this = this, _loop(i);
            				this._endLooping(wasLooping);
            		}
            		_onBeforeRemove() {
            				this.fire('remove');
            				var wasLooping = this._beginLooping();
            				for(var i = 0; i < this.scripts.length; i++){
            						var script = this.scripts[i];
            						if (!script) continue;
            						this.destroy(script.__scriptType.__name);
            				}
            				this._endLooping(wasLooping);
            		}
            		_removeDestroyedScripts() {
            				var len = this._destroyedScripts.length;
            				if (!len) return;
            				for(var i = 0; i < len; i++){
            						var script = this._destroyedScripts[i];
            						this._removeScriptInstance(script);
            				}
            				this._destroyedScripts.length = 0;
            				this._resetExecutionOrder(0, this._scripts.length);
            		}
            		_onInitializeAttributes() {
            				for(var i = 0, len = this.scripts.length; i < len; i++){
            						var script = this.scripts[i];
            						this.initializeAttributes(script);
            				}
            		}
            		initializeAttributes(script) {
            				if (script instanceof ScriptType) {
            						script.__initializeAttributes();
            				} else {
            						var _this_system_app_scripts;
            						var name = script.__scriptType.__name;
            						var data = this._attributeDataMap.get(name);
            						if (!data) {
            								return;
            						}
            						var schema = (_this_system_app_scripts = this.system.app.scripts) == null ? void 0 : _this_system_app_scripts.getSchema(name);
            						assignAttributesToScript(this.system.app, schema.attributes, data, script);
            				}
            		}
            		_scriptMethod(script, method, arg) {
            				script[method](arg);
            		}
            		_onInitialize() {
            				var scripts = this._scripts;
            				var wasLooping = this._beginLooping();
            				for(var i = 0, len = scripts.length; i < len; i++){
            						var script = scripts[i];
            						if (!script._initialized && script.enabled) {
            								script._initialized = true;
            								if (script.initialize) {
            										this._scriptMethod(script, SCRIPT_INITIALIZE);
            								}
            						}
            				}
            				this._endLooping(wasLooping);
            		}
            		_onPostInitialize() {
            				this.onPostStateChange();
            		}
            		_onUpdate(dt) {
            				var list = this._updateList;
            				if (!list.length) return;
            				var wasLooping = this._beginLooping();
            				for(list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++){
            						var script = list.items[list.loopIndex];
            						if (script.enabled) {
            								this._scriptMethod(script, SCRIPT_UPDATE, dt);
            						}
            				}
            				this._endLooping(wasLooping);
            		}
            		_onPostUpdate(dt) {
            				var list = this._postUpdateList;
            				if (!list.length) return;
            				var wasLooping = this._beginLooping();
            				for(list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++){
            						var script = list.items[list.loopIndex];
            						if (script.enabled) {
            								this._scriptMethod(script, SCRIPT_POST_UPDATE, dt);
            						}
            				}
            				this._endLooping(wasLooping);
            		}
            		_insertScriptInstance(scriptInstance, index, scriptsLength) {
            				if (index === -1) {
            						this._scripts.push(scriptInstance);
            						scriptInstance.__executionOrder = scriptsLength;
            						if (scriptInstance.update) {
            								this._updateList.append(scriptInstance);
            						}
            						if (scriptInstance.postUpdate) {
            								this._postUpdateList.append(scriptInstance);
            						}
            				} else {
            						this._scripts.splice(index, 0, scriptInstance);
            						scriptInstance.__executionOrder = index;
            						this._resetExecutionOrder(index + 1, scriptsLength + 1);
            						if (scriptInstance.update) {
            								this._updateList.insert(scriptInstance);
            						}
            						if (scriptInstance.postUpdate) {
            								this._postUpdateList.insert(scriptInstance);
            						}
            				}
            		}
            		_removeScriptInstance(scriptInstance) {
            				var idx = this._scripts.indexOf(scriptInstance);
            				if (idx === -1) return idx;
            				this._scripts.splice(idx, 1);
            				if (scriptInstance.update) {
            						this._updateList.remove(scriptInstance);
            				}
            				if (scriptInstance.postUpdate) {
            						this._postUpdateList.remove(scriptInstance);
            				}
            				return idx;
            		}
            		_resetExecutionOrder(startIndex, scriptsLength) {
            				for(var i = startIndex; i < scriptsLength; i++){
            						this._scripts[i].__executionOrder = i;
            				}
            		}
            		_resolveEntityScriptAttribute(attribute, attributeName, oldValue, useGuid, newAttributes, duplicatedIdsMap) {
            				if (attribute.array) {
            						var len = oldValue.length;
            						if (!len) {
            								return;
            						}
            						var newGuidArray = oldValue.slice();
            						for(var i = 0; i < len; i++){
            								var guid = newGuidArray[i] instanceof Entity ? newGuidArray[i].getGuid() : newGuidArray[i];
            								if (duplicatedIdsMap[guid]) {
            										newGuidArray[i] = useGuid ? duplicatedIdsMap[guid].getGuid() : duplicatedIdsMap[guid];
            								}
            						}
            						newAttributes[attributeName] = newGuidArray;
            				} else {
            						if (oldValue instanceof Entity) {
            								oldValue = oldValue.getGuid();
            						} else if (typeof oldValue !== 'string') {
            								return;
            						}
            						if (duplicatedIdsMap[oldValue]) {
            								newAttributes[attributeName] = duplicatedIdsMap[oldValue];
            						}
            				}
            		}
            		has(nameOrType) {
            				if (typeof nameOrType === 'string') {
            						return !!this._scriptsIndex[nameOrType];
            				}
            				if (!nameOrType) return false;
            				var scriptType = nameOrType;
            				var scriptName = scriptType.__name;
            				var scriptData = this._scriptsIndex[scriptName];
            				var scriptInstance = scriptData && scriptData.instance;
            				return scriptInstance instanceof scriptType;
            		}
            		get(nameOrType) {
            				if (typeof nameOrType === 'string') {
            						var data = this._scriptsIndex[nameOrType];
            						return data ? data.instance : null;
            				}
            				if (!nameOrType) return null;
            				var scriptType = nameOrType;
            				var scriptName = scriptType.__name;
            				var scriptData = this._scriptsIndex[scriptName];
            				var scriptInstance = scriptData && scriptData.instance;
            				return scriptInstance instanceof scriptType ? scriptInstance : null;
            		}
            		create(nameOrType, args) {
            				if (args === void 0) args = {};
            				var self = this;
            				var scriptType = nameOrType;
            				var scriptName = nameOrType;
            				if (typeof scriptType === 'string') {
            						scriptType = this.system.app.scripts.get(scriptType);
            				} else if (scriptType) {
            						var _scriptType;
            						var ___name;
            						scriptName = (___name = (_scriptType = scriptType).__name) != null ? ___name : _scriptType.__name = toLowerCamelCase$1(getScriptName(scriptType));
            				}
            				if (scriptType) {
            						if (!this._scriptsIndex[scriptName] || !this._scriptsIndex[scriptName].instance) {
            								var scriptInstance = new scriptType({
            										app: this.system.app,
            										entity: this.entity,
            										enabled: args.hasOwnProperty('enabled') ? args.enabled : true,
            										attributes: args.attributes || {}
            								});
            								if (args.properties && typeof args.properties === 'object') {
            										Object.assign(scriptInstance, args.properties);
            								}
            								if (!(scriptInstance instanceof ScriptType)) {
            										this._attributeDataMap.set(scriptName, args.attributes);
            								}
            								var len = this._scripts.length;
            								var ind = -1;
            								if (typeof args.ind === 'number' && args.ind !== -1 && len > args.ind) {
            										ind = args.ind;
            								}
            								this._insertScriptInstance(scriptInstance, ind, len);
            								this._scriptsIndex[scriptName] = {
            										instance: scriptInstance,
            										onSwap: function onSwap() {
            												self.swap(scriptName);
            										}
            								};
            								this[scriptName] = scriptInstance;
            								if (!args.preloading) {
            										this.initializeAttributes(scriptInstance);
            								}
            								this.fire('create', scriptName, scriptInstance);
            								this.fire("create:" + scriptName, scriptInstance);
            								this.system.app.scripts.on("swap:" + scriptName, this._scriptsIndex[scriptName].onSwap);
            								if (!args.preloading) {
            										if (scriptInstance.enabled && !scriptInstance._initialized) {
            												scriptInstance._initialized = true;
            												if (scriptInstance.initialize) {
            														this._scriptMethod(scriptInstance, SCRIPT_INITIALIZE);
            												}
            										}
            										if (scriptInstance.enabled && !scriptInstance._postInitialized) {
            												scriptInstance._postInitialized = true;
            												if (scriptInstance.postInitialize) {
            														this._scriptMethod(scriptInstance, SCRIPT_POST_INITIALIZE);
            												}
            										}
            								}
            								return scriptInstance;
            						}
            				} else {
            						this._scriptsIndex[scriptName] = {
            								awaiting: true,
            								ind: this._scripts.length
            						};
            				}
            				return null;
            		}
            		destroy(nameOrType) {
            				var scriptName = nameOrType;
            				var scriptType = nameOrType;
            				if (typeof scriptType === 'string') {
            						scriptType = this.system.app.scripts.get(scriptType);
            				} else if (scriptType) {
            						scriptName = scriptType.__name;
            				}
            				var scriptData = this._scriptsIndex[scriptName];
            				delete this._scriptsIndex[scriptName];
            				if (!scriptData) return false;
            				this._attributeDataMap.delete(scriptName);
            				var scriptInstance = scriptData.instance;
            				if (scriptInstance && !scriptInstance._destroyed) {
            						scriptInstance.enabled = false;
            						scriptInstance._destroyed = true;
            						if (!this._isLoopingThroughScripts) {
            								var ind = this._removeScriptInstance(scriptInstance);
            								if (ind >= 0) {
            										this._resetExecutionOrder(ind, this._scripts.length);
            								}
            						} else {
            								this._destroyedScripts.push(scriptInstance);
            						}
            				}
            				this.system.app.scripts.off("swap:" + scriptName, scriptData.onSwap);
            				delete this[scriptName];
            				this.fire('destroy', scriptName, scriptInstance || null);
            				this.fire("destroy:" + scriptName, scriptInstance || null);
            				if (scriptInstance) {
            						scriptInstance.fire('destroy');
            				}
            				return true;
            		}
            		swap(nameOrType) {
            				var scriptName = nameOrType;
            				var scriptType = nameOrType;
            				if (typeof scriptType === 'string') {
            						scriptType = this.system.app.scripts.get(scriptType);
            				} else if (scriptType) {
            						scriptName = scriptType.__name;
            				}
            				var old = this._scriptsIndex[scriptName];
            				if (!old || !old.instance) return false;
            				var scriptInstanceOld = old.instance;
            				var ind = this._scripts.indexOf(scriptInstanceOld);
            				var scriptInstance = new scriptType({
            						app: this.system.app,
            						entity: this.entity,
            						enabled: scriptInstanceOld.enabled,
            						attributes: scriptInstanceOld.__attributes
            				});
            				if (!scriptInstance.swap) {
            						return false;
            				}
            				this.initializeAttributes(scriptInstance);
            				this._scripts[ind] = scriptInstance;
            				this._scriptsIndex[scriptName].instance = scriptInstance;
            				this[scriptName] = scriptInstance;
            				scriptInstance.__executionOrder = ind;
            				if (scriptInstanceOld.update) {
            						this._updateList.remove(scriptInstanceOld);
            				}
            				if (scriptInstanceOld.postUpdate) {
            						this._postUpdateList.remove(scriptInstanceOld);
            				}
            				if (scriptInstance.update) {
            						this._updateList.insert(scriptInstance);
            				}
            				if (scriptInstance.postUpdate) {
            						this._postUpdateList.insert(scriptInstance);
            				}
            				this._scriptMethod(scriptInstance, SCRIPT_SWAP, scriptInstanceOld);
            				this.fire('swap', scriptName, scriptInstance);
            				this.fire("swap:" + scriptName, scriptInstance);
            				return true;
            		}
            		resolveDuplicatedEntityReferenceProperties(oldScriptComponent, duplicatedIdsMap) {
            				var newScriptComponent = this.entity.script;
            				for(var scriptName in oldScriptComponent._scriptsIndex){
            						var scriptType = this.system.app.scripts.get(scriptName);
            						if (!scriptType) {
            								continue;
            						}
            						var script = oldScriptComponent._scriptsIndex[scriptName];
            						if (!script || !script.instance) {
            								continue;
            						}
            						var newAttributesRaw = newScriptComponent[scriptName].__attributesRaw;
            						var newAttributes = newScriptComponent[scriptName].__attributes;
            						if (!newAttributesRaw && !newAttributes) {
            								continue;
            						}
            						var useGuid = !!newAttributesRaw;
            						var oldAttributes = script.instance.__attributes;
            						for(var attributeName in oldAttributes){
            								if (!oldAttributes[attributeName]) {
            										continue;
            								}
            								var attribute = scriptType.attributes.get(attributeName);
            								if (!attribute) {
            										continue;
            								}
            								if (attribute.type === 'entity') {
            										this._resolveEntityScriptAttribute(attribute, attributeName, oldAttributes[attributeName], useGuid, newAttributesRaw || newAttributes, duplicatedIdsMap);
            								} else if (attribute.type === 'json' && Array.isArray(attribute.schema)) {
            										var oldValue = oldAttributes[attributeName];
            										var newJsonValue = newAttributesRaw ? newAttributesRaw[attributeName] : newAttributes[attributeName];
            										for(var i = 0; i < attribute.schema.length; i++){
            												var field = attribute.schema[i];
            												if (field.type !== 'entity') {
            														continue;
            												}
            												if (attribute.array) {
            														for(var j = 0; j < oldValue.length; j++){
            																this._resolveEntityScriptAttribute(field, field.name, oldValue[j][field.name], useGuid, newJsonValue[j], duplicatedIdsMap);
            														}
            												} else {
            														this._resolveEntityScriptAttribute(field, field.name, oldValue[field.name], useGuid, newJsonValue, duplicatedIdsMap);
            												}
            										}
            								}
            						}
            				}
            		}
            		move(nameOrType, ind) {
            				var len = this._scripts.length;
            				if (ind >= len || ind < 0) {
            						return false;
            				}
            				var scriptType = nameOrType;
            				var scriptName = nameOrType;
            				if (typeof scriptName !== 'string') {
            						scriptName = nameOrType.__name;
            				} else {
            						scriptType = null;
            				}
            				var scriptData = this._scriptsIndex[scriptName];
            				if (!scriptData || !scriptData.instance) {
            						return false;
            				}
            				var scriptInstance = scriptData.instance;
            				if (scriptType && !(scriptInstance instanceof scriptType)) {
            						return false;
            				}
            				var indOld = this._scripts.indexOf(scriptInstance);
            				if (indOld === -1 || indOld === ind) {
            						return false;
            				}
            				this._scripts.splice(ind, 0, this._scripts.splice(indOld, 1)[0]);
            				this._resetExecutionOrder(0, len);
            				this._updateList.sort();
            				this._postUpdateList.sort();
            				this.fire('move', scriptName, scriptInstance, ind, indOld);
            				this.fire("move:" + scriptName, scriptInstance, ind, indOld);
            				return true;
            		}
            		constructor(system, entity){
            				super(system, entity), this._attributeDataMap = new Map();
            				this._scripts = [];
            				this._updateList = new SortedLoopArray({
            						sortBy: '__executionOrder'
            				});
            				this._postUpdateList = new SortedLoopArray({
            						sortBy: '__executionOrder'
            				});
            				this._scriptsIndex = {};
            				this._destroyedScripts = [];
            				this._destroyed = false;
            				this._scriptsData = null;
            				this._oldState = true;
            				this._enabled = true;
            				this._beingEnabled = false;
            				this._isLoopingThroughScripts = false;
            				this._executionOrder = -1;
            				this.on('set_enabled', this._onSetEnabled, this);
            		}
            }
            ScriptComponent.EVENT_CREATE = 'create';
            ScriptComponent.EVENT_DESTROY = 'destroy';
            ScriptComponent.EVENT_ENABLE = 'enable';
            ScriptComponent.EVENT_DISABLE = 'disable';
            ScriptComponent.EVENT_REMOVE = 'remove';
            ScriptComponent.EVENT_STATE = 'state';
            ScriptComponent.EVENT_MOVE = 'move';
            ScriptComponent.EVENT_ERROR = 'error';
            
            class ScriptComponentData {
            		constructor(){
            				this.enabled = true;
            		}
            }
            
            var METHOD_INITIALIZE_ATTRIBUTES = '_onInitializeAttributes';
            var METHOD_INITIALIZE = '_onInitialize';
            var METHOD_POST_INITIALIZE = '_onPostInitialize';
            var METHOD_UPDATE = '_onUpdate';
            var METHOD_POST_UPDATE = '_onPostUpdate';
            var executionOrderCounter = 0;
            class ScriptComponentSystem extends ComponentSystem {
            		initializeComponentData(component, data) {
            				component._executionOrder = executionOrderCounter++;
            				this._components.append(component);
            				if (executionOrderCounter > Number.MAX_SAFE_INTEGER) {
            						this._resetExecutionOrder();
            				}
            				component.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;
            				if (component.enabled && component.entity.enabled) {
            						this._enabledComponents.append(component);
            				}
            				if (data.hasOwnProperty('order') && data.hasOwnProperty("scripts")) {
            						component._scriptsData = data.scripts;
            						for(var i = 0; i < data.order.length; i++){
            								component.create(data.order[i], {
            										enabled: data.scripts[data.order[i]].enabled,
            										attributes: data.scripts[data.order[i]].attributes,
            										preloading: this.preloading
            								});
            						}
            				}
            		}
            		cloneComponent(entity, clone) {
            				var order = [];
            				var scripts = {};
            				for(var i = 0; i < entity.script._scripts.length; i++){
            						var _entity_script__attributeDataMap;
            						var scriptInstance = entity.script._scripts[i];
            						var scriptName = scriptInstance.__scriptType.__name;
            						order.push(scriptName);
            						var attributes = ((_entity_script__attributeDataMap = entity.script._attributeDataMap) == null ? void 0 : _entity_script__attributeDataMap.get(scriptName)) || {};
            						for(var key in scriptInstance.__attributes){
            								attributes[key] = scriptInstance.__attributes[key];
            						}
            						scripts[scriptName] = {
            								enabled: scriptInstance._enabled,
            								attributes: attributes
            						};
            				}
            				for(var key1 in entity.script._scriptsIndex){
            						if (key1.awaiting) {
            								order.splice(key1.ind, 0, key1);
            						}
            				}
            				var data = {
            						enabled: entity.script.enabled,
            						order: order,
            						scripts: scripts
            				};
            				return this.addComponent(clone, data);
            		}
            		_resetExecutionOrder() {
            				executionOrderCounter = 0;
            				for(var i = 0, len = this._components.length; i < len; i++){
            						this._components.items[i]._executionOrder = executionOrderCounter++;
            				}
            		}
            		_callComponentMethod(components, name, dt) {
            				for(components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++){
            						components.items[components.loopIndex][name](dt);
            				}
            		}
            		_onInitialize() {
            				this.preloading = false;
            				this._callComponentMethod(this._components, METHOD_INITIALIZE_ATTRIBUTES);
            				this._callComponentMethod(this._enabledComponents, METHOD_INITIALIZE);
            		}
            		_onPostInitialize() {
            				this._callComponentMethod(this._enabledComponents, METHOD_POST_INITIALIZE);
            		}
            		_onUpdate(dt) {
            				this._callComponentMethod(this._enabledComponents, METHOD_UPDATE, dt);
            		}
            		_onPostUpdate(dt) {
            				this._callComponentMethod(this._enabledComponents, METHOD_POST_UPDATE, dt);
            		}
            		_addComponentToEnabled(component) {
            				this._enabledComponents.insert(component);
            		}
            		_removeComponentFromEnabled(component) {
            				this._enabledComponents.remove(component);
            		}
            		_onBeforeRemove(entity, component) {
            				var ind = this._components.items.indexOf(component);
            				if (ind >= 0) {
            						component._onBeforeRemove();
            				}
            				this._removeComponentFromEnabled(component);
            				this._components.remove(component);
            		}
            		destroy() {
            				super.destroy();
            				this.app.systems.off('initialize', this._onInitialize, this);
            				this.app.systems.off('postInitialize', this._onPostInitialize, this);
            				this.app.systems.off('update', this._onUpdate, this);
            				this.app.systems.off('postUpdate', this._onPostUpdate, this);
            		}
            		constructor(app){
            				super(app);
            				this.id = "script";
            				this.ComponentType = ScriptComponent;
            				this.DataType = ScriptComponentData;
            				this._components = new SortedLoopArray({
            						sortBy: '_executionOrder'
            				});
            				this._enabledComponents = new SortedLoopArray({
            						sortBy: '_executionOrder'
            				});
            				this.preloading = true;
            				this.on('beforeremove', this._onBeforeRemove, this);
            				this.app.systems.on('initialize', this._onInitialize, this);
            				this.app.systems.on('postInitialize', this._onPostInitialize, this);
            				this.app.systems.on('update', this._onUpdate, this);
            				this.app.systems.on('postUpdate', this._onPostUpdate, this);
            		}
            }
            
            class GSplatComponent extends Component {
            		set customAabb(value) {
            				var _this__instance_meshInstance, _this__instance;
            				this._customAabb = value;
            				(_this__instance = this._instance) == null ? void 0 : (_this__instance_meshInstance = _this__instance.meshInstance) == null ? void 0 : _this__instance_meshInstance.setCustomAabb(this._customAabb);
            		}
            		get customAabb() {
            				return this._customAabb;
            		}
            		set instance(value) {
            				var _this__instance;
            				this.destroyInstance();
            				this._instance = value;
            				if ((_this__instance = this._instance) == null ? void 0 : _this__instance.meshInstance) {
            						var mi = this._instance.meshInstance;
            						if (!mi.node) {
            								mi.node = this.entity;
            						}
            						mi.castShadow = this._castShadows;
            						mi.setCustomAabb(this._customAabb);
            						if (this._materialOptions) {
            								this._instance.createMaterial(this._materialOptions);
            						}
            						if (this.enabled && this.entity.enabled) {
            								this.addToLayers();
            						}
            				}
            		}
            		get instance() {
            				return this._instance;
            		}
            		set materialOptions(value) {
            				this._materialOptions = Object.assign({}, value);
            				if (this._instance) {
            						this._instance.createMaterial(this._materialOptions);
            				}
            		}
            		get materialOptions() {
            				return this._materialOptions;
            		}
            		get material() {
            				var _this__instance;
            				return (_this__instance = this._instance) == null ? void 0 : _this__instance.material;
            		}
            		set castShadows(value) {
            				if (this._castShadows !== value) {
            						var _this_instance;
            						var mi = (_this_instance = this.instance) == null ? void 0 : _this_instance.meshInstance;
            						if (mi) {
            								var layers = this.layers;
            								var scene = this.system.app.scene;
            								if (this._castShadows && !value) {
            										for(var i = 0; i < layers.length; i++){
            												var layer = scene.layers.getLayerById(this.layers[i]);
            												if (layer) {
            														layer.removeShadowCasters([
            																mi
            														]);
            												}
            										}
            								}
            								mi.castShadow = value;
            								if (!this._castShadows && value) {
            										for(var i1 = 0; i1 < layers.length; i1++){
            												var layer1 = scene.layers.getLayerById(layers[i1]);
            												if (layer1) {
            														layer1.addShadowCasters([
            																mi
            														]);
            												}
            										}
            								}
            						}
            						this._castShadows = value;
            				}
            		}
            		get castShadows() {
            				return this._castShadows;
            		}
            		set layers(value) {
            				this.removeFromLayers();
            				this._layers.length = 0;
            				for(var i = 0; i < value.length; i++){
            						this._layers[i] = value[i];
            				}
            				if (!this.enabled || !this.entity.enabled) {
            						return;
            				}
            				this.addToLayers();
            		}
            		get layers() {
            				return this._layers;
            		}
            		set asset(value) {
            				var id = value instanceof Asset ? value.id : value;
            				if (this._assetReference.id === id) return;
            				if (this._assetReference.asset && this._assetReference.asset.resource) {
            						this._onGSplatAssetRemove();
            				}
            				this._assetReference.id = id;
            				if (this._assetReference.asset) {
            						this._onGSplatAssetAdded();
            				}
            		}
            		get asset() {
            				return this._assetReference.id;
            		}
            		assignAsset(asset) {
            				var id = asset instanceof Asset ? asset.id : asset;
            				this._assetReference.id = id;
            		}
            		destroyInstance() {
            				if (this._instance) {
            						var _this__instance;
            						this.removeFromLayers();
            						(_this__instance = this._instance) == null ? void 0 : _this__instance.destroy();
            						this._instance = null;
            				}
            		}
            		addToLayers() {
            				var _this_instance;
            				var meshInstance = (_this_instance = this.instance) == null ? void 0 : _this_instance.meshInstance;
            				if (meshInstance) {
            						var layers = this.system.app.scene.layers;
            						for(var i = 0; i < this._layers.length; i++){
            								var _layers_getLayerById;
            								(_layers_getLayerById = layers.getLayerById(this._layers[i])) == null ? void 0 : _layers_getLayerById.addMeshInstances([
            										meshInstance
            								]);
            						}
            				}
            		}
            		removeFromLayers() {
            				var _this_instance;
            				var meshInstance = (_this_instance = this.instance) == null ? void 0 : _this_instance.meshInstance;
            				if (meshInstance) {
            						var layers = this.system.app.scene.layers;
            						for(var i = 0; i < this._layers.length; i++){
            								var _layers_getLayerById;
            								(_layers_getLayerById = layers.getLayerById(this._layers[i])) == null ? void 0 : _layers_getLayerById.removeMeshInstances([
            										meshInstance
            								]);
            						}
            				}
            		}
            		onRemoveChild() {
            				this.removeFromLayers();
            		}
            		onInsertChild() {
            				if (this._instance && this.enabled && this.entity.enabled) {
            						this.addToLayers();
            				}
            		}
            		onRemove() {
            				this.destroyInstance();
            				this.asset = null;
            				this._assetReference.id = null;
            				this.entity.off('remove', this.onRemoveChild, this);
            				this.entity.off('insert', this.onInsertChild, this);
            		}
            		onLayersChanged(oldComp, newComp) {
            				this.addToLayers();
            				oldComp.off('add', this.onLayerAdded, this);
            				oldComp.off('remove', this.onLayerRemoved, this);
            				newComp.on('add', this.onLayerAdded, this);
            				newComp.on('remove', this.onLayerRemoved, this);
            		}
            		onLayerAdded(layer) {
            				var index = this.layers.indexOf(layer.id);
            				if (index < 0) return;
            				if (this._instance) {
            						layer.addMeshInstances(this._instance.meshInstance);
            				}
            		}
            		onLayerRemoved(layer) {
            				var index = this.layers.indexOf(layer.id);
            				if (index < 0) return;
            				if (this._instance) {
            						layer.removeMeshInstances(this._instance.meshInstance);
            				}
            		}
            		onEnable() {
            				var scene = this.system.app.scene;
            				var layers = scene.layers;
            				this._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);
            				if (layers) {
            						this._evtLayerAdded = layers.on('add', this.onLayerAdded, this);
            						this._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);
            				}
            				if (this._instance) {
            						this.addToLayers();
            				} else if (this.asset) {
            						this._onGSplatAssetAdded();
            				}
            		}
            		onDisable() {
            				var _this__evtLayersChanged;
            				var scene = this.system.app.scene;
            				var layers = scene.layers;
            				(_this__evtLayersChanged = this._evtLayersChanged) == null ? void 0 : _this__evtLayersChanged.off();
            				this._evtLayersChanged = null;
            				if (layers) {
            						var _this__evtLayerAdded, _this__evtLayerRemoved;
            						(_this__evtLayerAdded = this._evtLayerAdded) == null ? void 0 : _this__evtLayerAdded.off();
            						this._evtLayerAdded = null;
            						(_this__evtLayerRemoved = this._evtLayerRemoved) == null ? void 0 : _this__evtLayerRemoved.off();
            						this._evtLayerRemoved = null;
            				}
            				this.removeFromLayers();
            		}
            		hide() {
            				if (this._instance) {
            						this._instance.meshInstance.visible = false;
            				}
            		}
            		show() {
            				if (this._instance) {
            						this._instance.meshInstance.visible = true;
            				}
            		}
            		_onGSplatAssetAdded() {
            				if (!this._assetReference.asset) {
            						return;
            				}
            				if (this._assetReference.asset.resource) {
            						this._onGSplatAssetLoad();
            				} else if (this.enabled && this.entity.enabled) {
            						this.system.app.assets.load(this._assetReference.asset);
            				}
            		}
            		_onGSplatAssetLoad() {
            				this.destroyInstance();
            				var asset = this._assetReference.asset;
            				if (asset) {
            						this.instance = asset.resource.createInstance();
            				}
            		}
            		_onGSplatAssetUnload() {
            				this.destroyInstance();
            		}
            		_onGSplatAssetRemove() {
            				this._onGSplatAssetUnload();
            		}
            		constructor(system, entity){
            				super(system, entity), this._layers = [
            						LAYERID_WORLD
            				], this._instance = null, this._customAabb = null, this._materialOptions = null, this._evtLayersChanged = null, this._evtLayerAdded = null, this._evtLayerRemoved = null, this._castShadows = false;
            				this._assetReference = new AssetReference('asset', this, system.app.assets, {
            						add: this._onGSplatAssetAdded,
            						load: this._onGSplatAssetLoad,
            						remove: this._onGSplatAssetRemove,
            						unload: this._onGSplatAssetUnload
            				}, this);
            				entity.on('remove', this.onRemoveChild, this);
            				entity.on('removehierarchy', this.onRemoveChild, this);
            				entity.on('insert', this.onInsertChild, this);
            				entity.on('inserthierarchy', this.onInsertChild, this);
            		}
            }
            
            class GSplatComponentData {
            		constructor(){
            				this.enabled = true;
            		}
            }
            
            var _schema = [
            		'enabled'
            ];
            var _properties = [
            		'castShadows',
            		'instance',
            		'asset',
            		'layers'
            ];
            class GSplatComponentSystem extends ComponentSystem {
            		initializeComponentData(component, _data, properties) {
            				if (_data.layers && _data.layers.length) {
            						_data.layers = _data.layers.slice(0);
            				}
            				for(var i = 0; i < _properties.length; i++){
            						if (_data.hasOwnProperty(_properties[i])) {
            								component[_properties[i]] = _data[_properties[i]];
            						}
            				}
            				if (_data.aabbCenter && _data.aabbHalfExtents) {
            						component.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));
            				}
            				super.initializeComponentData(component, _data, _schema);
            		}
            		cloneComponent(entity, clone) {
            				var gSplatComponent = entity.gsplat;
            				var data = {};
            				for(var i = 0; i < _properties.length; i++){
            						data[_properties[i]] = gSplatComponent[_properties[i]];
            				}
            				data.enabled = gSplatComponent.enabled;
            				delete data.instance;
            				var component = this.addComponent(clone, data);
            				if (gSplatComponent.instance) {
            						component.instance = gSplatComponent.instance.clone();
            				}
            				if (gSplatComponent.customAabb) {
            						component.customAabb = gSplatComponent.customAabb.clone();
            				}
            				return component;
            		}
            		onRemove(entity, component) {
            				component.onRemove();
            		}
            		constructor(app){
            				super(app);
            				this.id = 'gsplat';
            				this.ComponentType = GSplatComponent;
            				this.DataType = GSplatComponentData;
            				this.schema = _schema;
            				this.on('beforeremove', this.onRemove, this);
            		}
            }
            Component._buildAccessors(GSplatComponent.prototype, _schema);
            
            class Render extends EventHandler {
            		set meshes(value) {
            				this.decRefMeshes();
            				this._meshes = value;
            				this.incRefMeshes();
            				this.fire('set:meshes', value);
            		}
            		get meshes() {
            				return this._meshes;
            		}
            		destroy() {
            				this.meshes = null;
            		}
            		decRefMeshes() {
            				var _this__meshes;
            				(_this__meshes = this._meshes) == null ? void 0 : _this__meshes.forEach((mesh, index)=>{
            						if (mesh) {
            								mesh.decRefCount();
            								if (mesh.refCount < 1) {
            										mesh.destroy();
            										this._meshes[index] = null;
            								}
            						}
            				});
            		}
            		incRefMeshes() {
            				var _this__meshes;
            				(_this__meshes = this._meshes) == null ? void 0 : _this__meshes.forEach((mesh)=>{
            						mesh == null ? void 0 : mesh.incRefCount();
            				});
            		}
            		constructor(...args){
            				super(...args), this._meshes = null;
            		}
            }
            Render.EVENT_SETMESHES = 'set:meshes';
            
            function onContainerAssetLoaded(containerAsset) {
            		var renderAsset = this;
            		if (!renderAsset.resource) return;
            		var containerResource = containerAsset.resource;
            		var render = containerResource.renders && containerResource.renders[renderAsset.data.renderIndex];
            		if (render) {
            				renderAsset.resource.meshes = render.resource.meshes;
            		}
            }
            function onContainerAssetAdded(containerAsset) {
            		var renderAsset = this;
            		renderAsset.registry.off("load:" + containerAsset.id, onContainerAssetLoaded, renderAsset);
            		renderAsset.registry.on("load:" + containerAsset.id, onContainerAssetLoaded, renderAsset);
            		renderAsset.registry.off("remove:" + containerAsset.id, onContainerAssetRemoved, renderAsset);
            		renderAsset.registry.once("remove:" + containerAsset.id, onContainerAssetRemoved, renderAsset);
            		if (!containerAsset.resource) {
            				renderAsset.registry.load(containerAsset);
            		} else {
            				onContainerAssetLoaded.call(renderAsset, containerAsset);
            		}
            }
            function onContainerAssetRemoved(containerAsset) {
            		var renderAsset = this;
            		renderAsset.registry.off("load:" + containerAsset.id, onContainerAssetLoaded, renderAsset);
            		if (renderAsset.resource) {
            				renderAsset.resource.destroy();
            		}
            }
            class RenderHandler extends ResourceHandler {
            		open(url, data) {
            				return new Render();
            		}
            		patch(asset, registry) {
            				if (!asset.data.containerAsset) {
            						return;
            				}
            				var containerAsset = registry.get(asset.data.containerAsset);
            				if (!containerAsset) {
            						registry.once("add:" + asset.data.containerAsset, onContainerAssetAdded, asset);
            						return;
            				}
            				onContainerAssetAdded.call(asset, containerAsset);
            		}
            		constructor(app){
            				super(app, 'render');
            				this._registry = app.assets;
            		}
            }
            
            class AnimCurve {
            		get paths() {
            				return this._paths;
            		}
            		get input() {
            				return this._input;
            		}
            		get output() {
            				return this._output;
            		}
            		get interpolation() {
            				return this._interpolation;
            		}
            		constructor(paths, input, output, interpolation){
            				this._paths = paths;
            				this._input = input;
            				this._output = output;
            				this._interpolation = interpolation;
            		}
            }
            
            class AnimData {
            		get components() {
            				return this._components;
            		}
            		get data() {
            				return this._data;
            		}
            		constructor(components, data){
            				this._components = components;
            				this._data = data;
            		}
            }
            
            function DracoWorker(jsUrl, wasmUrl) {
            		var draco;
            		var POSITION_ATTRIBUTE = 0;
            		var NORMAL_ATTRIBUTE = 1;
            		var wrap = (typedArray, dataType)=>{
            				switch(dataType){
            						case draco.DT_INT8:
            								return new Int8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
            						case draco.DT_INT16:
            								return new Int16Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 2);
            						case draco.DT_INT32:
            								return new Int32Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 4);
            						case draco.DT_UINT8:
            								return new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
            						case draco.DT_UINT16:
            								return new Uint16Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 2);
            						case draco.DT_UINT32:
            								return new Uint32Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 4);
            						case draco.DT_FLOAT32:
            								return new Float32Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 4);
            				}
            				return null;
            		};
            		var componentSizeInBytes = (dataType)=>{
            				switch(dataType){
            						case draco.DT_INT8:
            								return 1;
            						case draco.DT_INT16:
            								return 2;
            						case draco.DT_INT32:
            								return 4;
            						case draco.DT_UINT8:
            								return 1;
            						case draco.DT_UINT16:
            								return 2;
            						case draco.DT_UINT32:
            								return 4;
            						case draco.DT_FLOAT32:
            								return 4;
            				}
            				return 1;
            		};
            		var attributeSizeInBytes = (attribute)=>{
            				return attribute.num_components() * componentSizeInBytes(attribute.data_type());
            		};
            		var attributeOrder = {
            				0: 0,
            				1: 1,
            				5: 2,
            				2: 3,
            				7: 4,
            				8: 5,
            				4: 6,
            				3: 7
            		};
            		var generateNormals = (vertices, indices)=>{
            				var subtract = (dst, a, b)=>{
            						dst[0] = a[0] - b[0];
            						dst[1] = a[1] - b[1];
            						dst[2] = a[2] - b[2];
            				};
            				var cross = (dst, a, b)=>{
            						dst[0] = a[1] * b[2] - b[1] * a[2];
            						dst[1] = a[2] * b[0] - b[2] * a[0];
            						dst[2] = a[0] * b[1] - b[0] * a[1];
            				};
            				var normalize = (dst, offset)=>{
            						var a = dst[offset + 0];
            						var b = dst[offset + 1];
            						var c = dst[offset + 2];
            						var l = 1.0 / Math.sqrt(a * a + b * b + c * c);
            						dst[offset + 0] *= l;
            						dst[offset + 1] *= l;
            						dst[offset + 2] *= l;
            				};
            				var copy = (dst, src, srcOffset)=>{
            						for(var i = 0; i < 3; ++i){
            								dst[i] = src[srcOffset + i];
            						}
            				};
            				var numTriangles = indices.length / 3;
            				var numVertices = vertices.length / 3;
            				var result = new Float32Array(vertices.length);
            				var a = [
            						0,
            						0,
            						0
            				], b = [
            						0,
            						0,
            						0
            				], c = [
            						0,
            						0,
            						0
            				], t1 = [
            						0,
            						0,
            						0
            				], t2 = [
            						0,
            						0,
            						0
            				], n = [
            						0,
            						0,
            						0
            				];
            				for(var i = 0; i < numTriangles; ++i){
            						var v0 = indices[i * 3 + 0] * 3;
            						var v1 = indices[i * 3 + 1] * 3;
            						var v2 = indices[i * 3 + 2] * 3;
            						copy(a, vertices, v0);
            						copy(b, vertices, v1);
            						copy(c, vertices, v2);
            						subtract(t1, b, a);
            						subtract(t2, c, a);
            						cross(n, t1, t2);
            						normalize(n, 0);
            						for(var j = 0; j < 3; ++j){
            								result[v0 + j] += n[j];
            								result[v1 + j] += n[j];
            								result[v2 + j] += n[j];
            						}
            				}
            				for(var i1 = 0; i1 < numVertices; ++i1){
            						normalize(result, i1 * 3);
            				}
            				return new Uint8Array(result.buffer);
            		};
            		var decodeMesh = (inputBuffer)=>{
            				var result = {};
            				var buffer = new draco.DecoderBuffer();
            				buffer.Init(inputBuffer, inputBuffer.length);
            				var decoder = new draco.Decoder();
            				if (decoder.GetEncodedGeometryType(buffer) !== draco.TRIANGULAR_MESH) {
            						result.error = 'Failed to decode draco mesh: not a mesh';
            						return result;
            				}
            				var mesh = new draco.Mesh();
            				var status = decoder.DecodeBufferToMesh(buffer, mesh);
            				if (!status || !status.ok() || draco.getPointer(mesh) === 0) {
            						result.error = 'Failed to decode draco asset';
            						return result;
            				}
            				var numIndices = mesh.num_faces() * 3;
            				var shortIndices = mesh.num_points() <= 65535;
            				var indicesSize = numIndices * (shortIndices ? 2 : 4);
            				var indicesPtr = draco._malloc(indicesSize);
            				if (shortIndices) {
            						decoder.GetTrianglesUInt16Array(mesh, indicesSize, indicesPtr);
            						result.indices = new Uint16Array(draco.HEAPU16.buffer, indicesPtr, numIndices).slice().buffer;
            				} else {
            						decoder.GetTrianglesUInt32Array(mesh, indicesSize, indicesPtr);
            						result.indices = new Uint32Array(draco.HEAPU32.buffer, indicesPtr, numIndices).slice().buffer;
            				}
            				draco._free(indicesPtr);
            				var attributes = [];
            				for(var i = 0; i < mesh.num_attributes(); ++i){
            						attributes.push(decoder.GetAttribute(mesh, i));
            				}
            				attributes.sort((a, b)=>{
            						var _attributeOrder_a_attribute_type, _attributeOrder_b_attribute_type;
            						return ((_attributeOrder_a_attribute_type = attributeOrder[a.attribute_type()]) != null ? _attributeOrder_a_attribute_type : attributeOrder.length) - ((_attributeOrder_b_attribute_type = attributeOrder[b.attribute_type()]) != null ? _attributeOrder_b_attribute_type : attributeOrder.length);
            				});
            				result.attributes = attributes.map((a)=>a.unique_id());
            				var totalVertexSize = 0;
            				var offsets = attributes.map((a)=>{
            						var offset = totalVertexSize;
            						totalVertexSize += Math.ceil(attributeSizeInBytes(a) / 4) * 4;
            						return offset;
            				});
            				var hasNormals = attributes.some((a)=>a.attribute_type() === NORMAL_ATTRIBUTE);
            				var normalOffset = offsets[1];
            				if (!hasNormals) {
            						for(var i1 = 1; i1 < offsets.length; ++i1){
            								offsets[i1] += 12;
            						}
            						totalVertexSize += 12;
            				}
            				result.vertices = new ArrayBuffer(mesh.num_points() * totalVertexSize);
            				var dst = new Uint8Array(result.vertices);
            				for(var i2 = 0; i2 < mesh.num_attributes(); ++i2){
            						var attribute = attributes[i2];
            						var sizeInBytes = attributeSizeInBytes(attribute);
            						var ptrSize = mesh.num_points() * sizeInBytes;
            						var ptr = draco._malloc(ptrSize);
            						decoder.GetAttributeDataArrayForAllPoints(mesh, attribute, attribute.data_type(), ptrSize, ptr);
            						var src = new Uint8Array(draco.HEAPU8.buffer, ptr, ptrSize);
            						for(var j = 0; j < mesh.num_points(); ++j){
            								for(var c = 0; c < sizeInBytes; ++c){
            										dst[j * totalVertexSize + offsets[i2] + c] = src[j * sizeInBytes + c];
            								}
            						}
            						if (!hasNormals && attribute.attribute_type() === POSITION_ATTRIBUTE) {
            								var normals = generateNormals(wrap(src, attribute.data_type()), shortIndices ? new Uint16Array(result.indices) : new Uint32Array(result.indices));
            								for(var j1 = 0; j1 < mesh.num_points(); ++j1){
            										for(var c1 = 0; c1 < 12; ++c1){
            												dst[j1 * totalVertexSize + normalOffset + c1] = normals[j1 * 12 + c1];
            										}
            								}
            						}
            						draco._free(ptr);
            				}
            				draco.destroy(mesh);
            				draco.destroy(decoder);
            				draco.destroy(buffer);
            				return result;
            		};
            		var decode = (data)=>{
            				var result = decodeMesh(new Uint8Array(data.buffer));
            				self.postMessage({
            						jobId: data.jobId,
            						error: result.error,
            						indices: result.indices,
            						vertices: result.vertices,
            						attributes: result.attributes
            				}, [
            						result.indices,
            						result.vertices
            				].filter((t)=>t != null));
            		};
            		var workQueue = [];
            		self.onmessage = (message)=>{
            				var data = message.data;
            				switch(data.type){
            						case 'init':
            								self.DracoDecoderModule({
            										instantiateWasm: (imports, successCallback)=>{
            												WebAssembly.instantiate(data.module, imports).then((result)=>successCallback(result)).catch((reason)=>console.error("instantiate failed + " + reason));
            												return {};
            										}
            								}).then((instance)=>{
            										draco = instance;
            										workQueue.forEach((data)=>decode(data));
            								});
            								break;
            						case 'decodeMesh':
            								if (draco) {
            										decode(data);
            								} else {
            										workQueue.push(data);
            								}
            								break;
            				}
            		};
            }
            
            var downloadMaxRetries = 3;
            class JobQueue {
            		init(workers) {
            				workers.forEach((worker)=>{
            						worker.addEventListener('message', (message)=>{
            								var data = message.data;
            								var callback = this.jobCallbacks.get(data.jobId);
            								if (callback) {
            										callback(data.error, {
            												indices: data.indices,
            												vertices: data.vertices,
            												attributes: data.attributes
            										});
            								}
            								this.jobCallbacks.delete(data.jobId);
            								if (this.jobQueue.length > 0) {
            										var job = this.jobQueue.shift();
            										this.run(worker, job);
            								} else {
            										var index2 = this.workers[2].indexOf(worker);
            										if (index2 !== -1) {
            												this.workers[2].splice(index2, 1);
            												this.workers[1].push(worker);
            										} else {
            												var index1 = this.workers[1].indexOf(worker);
            												if (index1 !== -1) {
            														this.workers[1].splice(index1, 1);
            														this.workers[0].push(worker);
            												}
            										}
            								}
            						});
            				});
            				this.workers[0] = workers;
            				while(this.jobQueue.length && (this.workers[0].length || this.workers[1].length)){
            						var job = this.jobQueue.shift();
            						if (this.workers[0].length > 0) {
            								var worker = this.workers[0].shift();
            								this.workers[1].push(worker);
            								this.run(worker, job);
            						} else {
            								var worker1 = this.workers[1].shift();
            								this.workers[2].push(worker1);
            								this.run(worker1, job);
            						}
            				}
            		}
            		enqueueJob(buffer, callback) {
            				var job = {
            						jobId: this.jobId++,
            						buffer: buffer
            				};
            				this.jobCallbacks.set(job.jobId, callback);
            				if (this.workers[0].length > 0) {
            						var worker = this.workers[0].shift();
            						this.workers[1].push(worker);
            						this.run(worker, job);
            				} else if (this.workers[1].length > 0) {
            						var worker1 = this.workers[1].shift();
            						this.workers[2].push(worker1);
            						this.run(worker1, job);
            				} else {
            						this.jobQueue.push(job);
            				}
            		}
            		constructor(){
            				this.workers = [
            						[],
            						[],
            						[]
            				];
            				this.jobId = 0;
            				this.jobQueue = [];
            				this.jobCallbacks = new Map();
            				this.run = (worker, job)=>{
            						worker.postMessage({
            								type: 'decodeMesh',
            								jobId: job.jobId,
            								buffer: job.buffer
            						}, [
            								job.buffer
            						]);
            				};
            		}
            }
            var downloadScript = (url)=>{
            		return new Promise((resolve, reject)=>{
            				var options = {
            						cache: true,
            						responseType: 'text',
            						retry: downloadMaxRetries > 0,
            						maxRetries: downloadMaxRetries
            				};
            				http.get(url, options, (err, response)=>{
            						if (err) {
            								reject(err);
            						} else {
            								resolve(response);
            						}
            				});
            		});
            };
            var compileModule = (url)=>{
            		var compileManual = ()=>{
            				return fetch(url).then((result)=>result.arrayBuffer()).then((buffer)=>WebAssembly.compile(buffer));
            		};
            		var compileStreaming = ()=>{
            				return WebAssembly.compileStreaming(fetch(url)).catch((err)=>{
            						return compileManual();
            				});
            		};
            		return WebAssembly.compileStreaming ? compileStreaming() : compileManual();
            };
            var defaultNumWorkers$1 = 1;
            var jobQueue;
            var initializeWorkers = (config)=>{
            		if (jobQueue) {
            				return true;
            		}
            		if (!config) {
            				{
            						var moduleConfig = WasmModule.getConfig('DracoDecoderModule');
            						if (moduleConfig) {
            								config = {
            										jsUrl: moduleConfig.glueUrl,
            										wasmUrl: moduleConfig.wasmUrl,
            										numWorkers: moduleConfig.numWorkers
            								};
            						} else {
            								config = {
            										jsUrl: 'draco.wasm.js',
            										wasmUrl: 'draco.wasm.wasm',
            										numWorkers: defaultNumWorkers$1
            								};
            						}
            				}
            		}
            		if (!config.jsUrl || !config.wasmUrl) {
            				return false;
            		}
            		jobQueue = new JobQueue();
            		Promise.all([
            				downloadScript(config.jsUrl),
            				compileModule(config.wasmUrl)
            		]).then((param)=>{
            				var [dracoSource, dracoModule] = param;
            				var code = [
            						'/* draco */',
            						dracoSource,
            						'/* worker */',
            						"(\n" + DracoWorker.toString() + "\n)()\n\n"
            				].join('\n');
            				var blob = new Blob([
            						code
            				], {
            						type: "application/javascript"
            				});
            				var workerUrl = URL.createObjectURL(blob);
            				var numWorkers = Math.max(1, Math.min(16, config.numWorkers || defaultNumWorkers$1));
            				var workers = [];
            				for(var i = 0; i < numWorkers; ++i){
            						var worker = new Worker(workerUrl);
            						worker.postMessage({
            								type: 'init',
            								module: dracoModule
            						});
            						workers.push(worker);
            				}
            				jobQueue.init(workers);
            		});
            		return true;
            };
            var dracoDecode = (buffer, callback)=>{
            		if (!initializeWorkers()) {
            				return false;
            		}
            		jobQueue.enqueueJob(buffer, callback);
            		return true;
            };
            
            function asyncGeneratorStep$2(gen, resolve, reject, _next, _throw, key, arg) {
            		try {
            				var info = gen[key](arg);
            				var value = info.value;
            		} catch (error) {
            				reject(error);
            				return;
            		}
            		if (info.done) {
            				resolve(value);
            		} else {
            				Promise.resolve(value).then(_next, _throw);
            		}
            }
            function _async_to_generator$2(fn) {
            		return function() {
            				var self = this, args = arguments;
            				return new Promise(function(resolve, reject) {
            						var gen = fn.apply(self, args);
            						function _next(value) {
            								asyncGeneratorStep$2(gen, resolve, reject, _next, _throw, "next", value);
            						}
            						function _throw(err) {
            								asyncGeneratorStep$2(gen, resolve, reject, _next, _throw, "throw", err);
            						}
            						_next(undefined);
            				});
            		};
            }
            class GlbResources {
            		destroy() {
            				if (this.renders) {
            						this.renders.forEach((render)=>{
            								render.meshes = null;
            						});
            				}
            		}
            }
            var isDataURI = (uri)=>{
            		return /^data:[^\n\r,\u2028\u2029]*,.*$/i.test(uri);
            };
            var getDataURIMimeType = (uri)=>{
            		return uri.substring(uri.indexOf(':') + 1, uri.indexOf(';'));
            };
            var getNumComponents = (accessorType)=>{
            		switch(accessorType){
            				case 'SCALAR':
            						return 1;
            				case 'VEC2':
            						return 2;
            				case 'VEC3':
            						return 3;
            				case 'VEC4':
            						return 4;
            				case 'MAT2':
            						return 4;
            				case 'MAT3':
            						return 9;
            				case 'MAT4':
            						return 16;
            				default:
            						return 3;
            		}
            };
            var getComponentType = (componentType)=>{
            		switch(componentType){
            				case 5120:
            						return TYPE_INT8;
            				case 5121:
            						return TYPE_UINT8;
            				case 5122:
            						return TYPE_INT16;
            				case 5123:
            						return TYPE_UINT16;
            				case 5124:
            						return TYPE_INT32;
            				case 5125:
            						return TYPE_UINT32;
            				case 5126:
            						return TYPE_FLOAT32;
            				default:
            						return 0;
            		}
            };
            var getComponentSizeInBytes = (componentType)=>{
            		switch(componentType){
            				case 5120:
            						return 1;
            				case 5121:
            						return 1;
            				case 5122:
            						return 2;
            				case 5123:
            						return 2;
            				case 5124:
            						return 4;
            				case 5125:
            						return 4;
            				case 5126:
            						return 4;
            				default:
            						return 0;
            		}
            };
            var getComponentDataType = (componentType)=>{
            		switch(componentType){
            				case 5120:
            						return Int8Array;
            				case 5121:
            						return Uint8Array;
            				case 5122:
            						return Int16Array;
            				case 5123:
            						return Uint16Array;
            				case 5124:
            						return Int32Array;
            				case 5125:
            						return Uint32Array;
            				case 5126:
            						return Float32Array;
            				default:
            						return null;
            		}
            };
            var gltfToEngineSemanticMap = {
            		'POSITION': SEMANTIC_POSITION,
            		'NORMAL': SEMANTIC_NORMAL,
            		'TANGENT': SEMANTIC_TANGENT,
            		'COLOR_0': SEMANTIC_COLOR,
            		'JOINTS_0': SEMANTIC_BLENDINDICES,
            		'WEIGHTS_0': SEMANTIC_BLENDWEIGHT,
            		'TEXCOORD_0': SEMANTIC_TEXCOORD0,
            		'TEXCOORD_1': SEMANTIC_TEXCOORD1,
            		'TEXCOORD_2': SEMANTIC_TEXCOORD2,
            		'TEXCOORD_3': SEMANTIC_TEXCOORD3,
            		'TEXCOORD_4': SEMANTIC_TEXCOORD4,
            		'TEXCOORD_5': SEMANTIC_TEXCOORD5,
            		'TEXCOORD_6': SEMANTIC_TEXCOORD6,
            		'TEXCOORD_7': SEMANTIC_TEXCOORD7
            };
            var attributeOrder = {
            		[SEMANTIC_POSITION]: 0,
            		[SEMANTIC_NORMAL]: 1,
            		[SEMANTIC_TANGENT]: 2,
            		[SEMANTIC_COLOR]: 3,
            		[SEMANTIC_BLENDINDICES]: 4,
            		[SEMANTIC_BLENDWEIGHT]: 5,
            		[SEMANTIC_TEXCOORD0]: 6,
            		[SEMANTIC_TEXCOORD1]: 7,
            		[SEMANTIC_TEXCOORD2]: 8,
            		[SEMANTIC_TEXCOORD3]: 9,
            		[SEMANTIC_TEXCOORD4]: 10,
            		[SEMANTIC_TEXCOORD5]: 11,
            		[SEMANTIC_TEXCOORD6]: 12,
            		[SEMANTIC_TEXCOORD7]: 13
            };
            var getDequantizeFunc = (srcType)=>{
            		switch(srcType){
            				case TYPE_INT8:
            						return (x)=>Math.max(x / 127.0, -1);
            				case TYPE_UINT8:
            						return (x)=>x / 255.0;
            				case TYPE_INT16:
            						return (x)=>Math.max(x / 32767.0, -1);
            				case TYPE_UINT16:
            						return (x)=>x / 65535.0;
            				default:
            						return (x)=>x;
            		}
            };
            var dequantizeArray = (dstArray, srcArray, srcType)=>{
            		var convFunc = getDequantizeFunc(srcType);
            		var len = srcArray.length;
            		for(var i = 0; i < len; ++i){
            				dstArray[i] = convFunc(srcArray[i]);
            		}
            		return dstArray;
            };
            var getAccessorData = (gltfAccessor, bufferViews, flatten)=>{
            		if (flatten === void 0) flatten = false;
            		var numComponents = getNumComponents(gltfAccessor.type);
            		var dataType = getComponentDataType(gltfAccessor.componentType);
            		if (!dataType) {
            				return null;
            		}
            		var result;
            		if (gltfAccessor.sparse) {
            				var sparse = gltfAccessor.sparse;
            				var indicesAccessor = {
            						count: sparse.count,
            						type: 'SCALAR'
            				};
            				var indices = getAccessorData(Object.assign(indicesAccessor, sparse.indices), bufferViews, true);
            				var valuesAccessor = {
            						count: sparse.count,
            						type: gltfAccessor.type,
            						componentType: gltfAccessor.componentType
            				};
            				var values = getAccessorData(Object.assign(valuesAccessor, sparse.values), bufferViews, true);
            				if (gltfAccessor.hasOwnProperty('bufferView')) {
            						var baseAccessor = {
            								bufferView: gltfAccessor.bufferView,
            								byteOffset: gltfAccessor.byteOffset,
            								componentType: gltfAccessor.componentType,
            								count: gltfAccessor.count,
            								type: gltfAccessor.type
            						};
            						result = getAccessorData(baseAccessor, bufferViews, true).slice();
            				} else {
            						result = new dataType(gltfAccessor.count * numComponents);
            				}
            				for(var i = 0; i < sparse.count; ++i){
            						var targetIndex = indices[i];
            						for(var j = 0; j < numComponents; ++j){
            								result[targetIndex * numComponents + j] = values[i * numComponents + j];
            						}
            				}
            		} else {
            				if (gltfAccessor.hasOwnProperty('bufferView')) {
            						var bufferView = bufferViews[gltfAccessor.bufferView];
            						if (flatten && bufferView.hasOwnProperty('byteStride')) {
            								var bytesPerElement = numComponents * dataType.BYTES_PER_ELEMENT;
            								var storage = new ArrayBuffer(gltfAccessor.count * bytesPerElement);
            								var tmpArray = new Uint8Array(storage);
            								var dstOffset = 0;
            								for(var i1 = 0; i1 < gltfAccessor.count; ++i1){
            										var srcOffset = (gltfAccessor.byteOffset || 0) + i1 * bufferView.byteStride;
            										for(var b = 0; b < bytesPerElement; ++b){
            												tmpArray[dstOffset++] = bufferView[srcOffset++];
            										}
            								}
            								result = new dataType(storage);
            						} else {
            								result = new dataType(bufferView.buffer, bufferView.byteOffset + (gltfAccessor.byteOffset || 0), gltfAccessor.count * numComponents);
            						}
            				} else {
            						result = new dataType(gltfAccessor.count * numComponents);
            				}
            		}
            		return result;
            };
            var getAccessorDataFloat32 = (gltfAccessor, bufferViews)=>{
            		var data = getAccessorData(gltfAccessor, bufferViews, true);
            		if (data instanceof Float32Array || !gltfAccessor.normalized) {
            				return data;
            		}
            		var float32Data = new Float32Array(data.length);
            		dequantizeArray(float32Data, data, getComponentType(gltfAccessor.componentType));
            		return float32Data;
            };
            var getAccessorBoundingBox = (gltfAccessor)=>{
            		var min = gltfAccessor.min;
            		var max = gltfAccessor.max;
            		if (!min || !max) {
            				return null;
            		}
            		if (gltfAccessor.normalized) {
            				var ctype = getComponentType(gltfAccessor.componentType);
            				min = dequantizeArray([], min, ctype);
            				max = dequantizeArray([], max, ctype);
            		}
            		return new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
            };
            var getPrimitiveType = (primitive)=>{
            		if (!primitive.hasOwnProperty('mode')) {
            				return PRIMITIVE_TRIANGLES;
            		}
            		switch(primitive.mode){
            				case 0:
            						return PRIMITIVE_POINTS;
            				case 1:
            						return PRIMITIVE_LINES;
            				case 2:
            						return PRIMITIVE_LINELOOP;
            				case 3:
            						return PRIMITIVE_LINESTRIP;
            				case 4:
            						return PRIMITIVE_TRIANGLES;
            				case 5:
            						return PRIMITIVE_TRISTRIP;
            				case 6:
            						return PRIMITIVE_TRIFAN;
            				default:
            						return PRIMITIVE_TRIANGLES;
            		}
            };
            var generateIndices = (numVertices)=>{
            		var dummyIndices = new Uint16Array(numVertices);
            		for(var i = 0; i < numVertices; i++){
            				dummyIndices[i] = i;
            		}
            		return dummyIndices;
            };
            var generateNormals = (sourceDesc, indices)=>{
            		var p = sourceDesc[SEMANTIC_POSITION];
            		if (!p || p.components !== 3) {
            				return;
            		}
            		var positions;
            		if (p.size !== p.stride) {
            				var srcStride = p.stride / typedArrayTypesByteSize[p.type];
            				var src = new typedArrayTypes[p.type](p.buffer, p.offset, p.count * srcStride);
            				positions = new typedArrayTypes[p.type](p.count * 3);
            				for(var i = 0; i < p.count; ++i){
            						positions[i * 3 + 0] = src[i * srcStride + 0];
            						positions[i * 3 + 1] = src[i * srcStride + 1];
            						positions[i * 3 + 2] = src[i * srcStride + 2];
            				}
            		} else {
            				positions = new typedArrayTypes[p.type](p.buffer, p.offset, p.count * 3);
            		}
            		var numVertices = p.count;
            		if (!indices) {
            				indices = generateIndices(numVertices);
            		}
            		var normalsTemp = calculateNormals(positions, indices);
            		var normals = new Float32Array(normalsTemp.length);
            		normals.set(normalsTemp);
            		sourceDesc[SEMANTIC_NORMAL] = {
            				buffer: normals.buffer,
            				size: 12,
            				offset: 0,
            				stride: 12,
            				count: numVertices,
            				components: 3,
            				type: TYPE_FLOAT32
            		};
            };
            var cloneTexture = (texture)=>{
            		var shallowCopyLevels = (texture)=>{
            				var result = [];
            				for(var mip = 0; mip < texture._levels.length; ++mip){
            						var level = [];
            						if (texture.cubemap) {
            								for(var face = 0; face < 6; ++face){
            										level.push(texture._levels[mip][face]);
            								}
            						} else {
            								level = texture._levels[mip];
            						}
            						result.push(level);
            				}
            				return result;
            		};
            		var result = new Texture(texture.device, texture);
            		result._levels = shallowCopyLevels(texture);
            		return result;
            };
            var cloneTextureAsset = (src)=>{
            		var result = new Asset("" + src.name + "_clone", src.type, src.file, src.data, src.options);
            		result.loaded = true;
            		result.resource = cloneTexture(src.resource);
            		src.registry.add(result);
            		return result;
            };
            var createVertexBufferInternal = (device, sourceDesc)=>{
            		var positionDesc = sourceDesc[SEMANTIC_POSITION];
            		if (!positionDesc) {
            				return null;
            		}
            		var numVertices = positionDesc.count;
            		var vertexDesc = [];
            		for(var semantic in sourceDesc){
            				if (sourceDesc.hasOwnProperty(semantic)) {
            						var element = {
            								semantic: semantic,
            								components: sourceDesc[semantic].components,
            								type: sourceDesc[semantic].type,
            								normalize: !!sourceDesc[semantic].normalize
            						};
            						if (!VertexFormat.isElementValid(device, element)) {
            								element.components++;
            						}
            						vertexDesc.push(element);
            				}
            		}
            		vertexDesc.sort((lhs, rhs)=>{
            				return attributeOrder[lhs.semantic] - attributeOrder[rhs.semantic];
            		});
            		var i, j, k;
            		var source, target, sourceOffset;
            		var vertexFormat = new VertexFormat(device, vertexDesc);
            		var isCorrectlyInterleaved = true;
            		for(i = 0; i < vertexFormat.elements.length; ++i){
            				target = vertexFormat.elements[i];
            				source = sourceDesc[target.name];
            				sourceOffset = source.offset - positionDesc.offset;
            				if (source.buffer !== positionDesc.buffer || source.stride !== target.stride || source.size !== target.size || sourceOffset !== target.offset) {
            						isCorrectlyInterleaved = false;
            						break;
            				}
            		}
            		var vertexBuffer = new VertexBuffer(device, vertexFormat, numVertices);
            		var vertexData = vertexBuffer.lock();
            		var targetArray = new Uint32Array(vertexData);
            		var sourceArray;
            		if (isCorrectlyInterleaved) {
            				sourceArray = new Uint32Array(positionDesc.buffer, positionDesc.offset, numVertices * vertexBuffer.format.size / 4);
            				targetArray.set(sourceArray);
            		} else {
            				var targetStride, sourceStride;
            				for(i = 0; i < vertexBuffer.format.elements.length; ++i){
            						target = vertexBuffer.format.elements[i];
            						targetStride = target.stride / 4;
            						source = sourceDesc[target.name];
            						sourceStride = source.stride / 4;
            						sourceArray = new Uint32Array(source.buffer, source.offset, (source.count - 1) * sourceStride + (source.size + 3) / 4);
            						var src = 0;
            						var dst = target.offset / 4;
            						var kend = Math.floor((source.size + 3) / 4);
            						for(j = 0; j < numVertices; ++j){
            								for(k = 0; k < kend; ++k){
            										targetArray[dst + k] = sourceArray[src + k];
            								}
            								src += sourceStride;
            								dst += targetStride;
            						}
            				}
            		}
            		vertexBuffer.unlock();
            		return vertexBuffer;
            };
            var createVertexBuffer = (device, attributes, indices, accessors, bufferViews, vertexBufferDict)=>{
            		var useAttributes = {};
            		var attribIds = [];
            		for(var attrib in attributes){
            				if (attributes.hasOwnProperty(attrib) && gltfToEngineSemanticMap.hasOwnProperty(attrib)) {
            						useAttributes[attrib] = attributes[attrib];
            						attribIds.push(attrib + ":" + attributes[attrib]);
            				}
            		}
            		attribIds.sort();
            		var vbKey = attribIds.join();
            		var vb = vertexBufferDict[vbKey];
            		if (!vb) {
            				var sourceDesc = {};
            				for(var attrib1 in useAttributes){
            						var accessor = accessors[attributes[attrib1]];
            						var accessorData = getAccessorData(accessor, bufferViews);
            						var bufferView = bufferViews[accessor.bufferView];
            						var semantic = gltfToEngineSemanticMap[attrib1];
            						var size = getNumComponents(accessor.type) * getComponentSizeInBytes(accessor.componentType);
            						var stride = bufferView && bufferView.hasOwnProperty('byteStride') ? bufferView.byteStride : size;
            						sourceDesc[semantic] = {
            								buffer: accessorData.buffer,
            								size: size,
            								offset: accessorData.byteOffset,
            								stride: stride,
            								count: accessor.count,
            								components: getNumComponents(accessor.type),
            								type: getComponentType(accessor.componentType),
            								normalize: accessor.normalized
            						};
            				}
            				if (!sourceDesc.hasOwnProperty(SEMANTIC_NORMAL)) {
            						generateNormals(sourceDesc, indices);
            				}
            				vb = createVertexBufferInternal(device, sourceDesc);
            				vertexBufferDict[vbKey] = vb;
            		}
            		return vb;
            };
            var createSkin = (device, gltfSkin, accessors, bufferViews, nodes, glbSkins)=>{
            		var i, j, bindMatrix;
            		var joints = gltfSkin.joints;
            		var numJoints = joints.length;
            		var ibp = [];
            		if (gltfSkin.hasOwnProperty('inverseBindMatrices')) {
            				var inverseBindMatrices = gltfSkin.inverseBindMatrices;
            				var ibmData = getAccessorData(accessors[inverseBindMatrices], bufferViews, true);
            				var ibmValues = [];
            				for(i = 0; i < numJoints; i++){
            						for(j = 0; j < 16; j++){
            								ibmValues[j] = ibmData[i * 16 + j];
            						}
            						bindMatrix = new Mat4();
            						bindMatrix.set(ibmValues);
            						ibp.push(bindMatrix);
            				}
            		} else {
            				for(i = 0; i < numJoints; i++){
            						bindMatrix = new Mat4();
            						ibp.push(bindMatrix);
            				}
            		}
            		var boneNames = [];
            		for(i = 0; i < numJoints; i++){
            				boneNames[i] = nodes[joints[i]].name;
            		}
            		var key = boneNames.join('#');
            		var skin = glbSkins.get(key);
            		if (!skin) {
            				skin = new Skin(device, ibp, boneNames);
            				glbSkins.set(key, skin);
            		}
            		return skin;
            };
            var createDracoMesh = (device, primitive, accessors, bufferViews, meshVariants, meshDefaultMaterials, promises)=>{
            		var _primitive_extensions;
            		var result = new Mesh(device);
            		result.aabb = getAccessorBoundingBox(accessors[primitive.attributes.POSITION]);
            		var vertexDesc = [];
            		for (var [name, index] of Object.entries(primitive.attributes)){
            				var accessor = accessors[index];
            				var semantic = gltfToEngineSemanticMap[name];
            				var componentType = getComponentType(accessor.componentType);
            				var _accessor_normalized;
            				vertexDesc.push({
            						semantic: semantic,
            						components: getNumComponents(accessor.type),
            						type: componentType,
            						normalize: (_accessor_normalized = accessor.normalized) != null ? _accessor_normalized : semantic === SEMANTIC_COLOR && (componentType === TYPE_UINT8 || componentType === TYPE_UINT16)
            				});
            		}
            		promises.push(new Promise((resolve, reject)=>{
            				var dracoExt = primitive.extensions.KHR_draco_mesh_compression;
            				dracoDecode(bufferViews[dracoExt.bufferView].slice().buffer, (err, decompressedData)=>{
            						if (err) {
            								console.log(err);
            								reject(err);
            						} else {
            								var _primitive_attributes;
            								var order = {};
            								for (var [name, index] of Object.entries(dracoExt.attributes)){
            										order[gltfToEngineSemanticMap[name]] = decompressedData.attributes.indexOf(index);
            								}
            								vertexDesc.sort((a, b)=>{
            										return order[a.semantic] - order[b.semantic];
            								});
            								if (!((_primitive_attributes = primitive.attributes) == null ? void 0 : _primitive_attributes.NORMAL)) {
            										vertexDesc.splice(1, 0, {
            												semantic: 'NORMAL',
            												components: 3,
            												type: TYPE_FLOAT32
            										});
            								}
            								var vertexFormat = new VertexFormat(device, vertexDesc);
            								var numVertices = decompressedData.vertices.byteLength / vertexFormat.size;
            								var indexFormat = numVertices <= 65535 ? INDEXFORMAT_UINT16 : INDEXFORMAT_UINT32;
            								var numIndices = decompressedData.indices.byteLength / (numVertices <= 65535 ? 2 : 4);
            								var vertexBuffer = new VertexBuffer(device, vertexFormat, numVertices, {
            										data: decompressedData.vertices
            								});
            								var indexBuffer = new IndexBuffer(device, indexFormat, numIndices, BUFFER_STATIC, decompressedData.indices);
            								result.vertexBuffer = vertexBuffer;
            								result.indexBuffer[0] = indexBuffer;
            								result.primitive[0].type = getPrimitiveType(primitive);
            								result.primitive[0].base = 0;
            								result.primitive[0].count = indexBuffer ? numIndices : numVertices;
            								result.primitive[0].indexed = !!indexBuffer;
            								resolve();
            						}
            				});
            		}));
            		if (primitive == null ? void 0 : (_primitive_extensions = primitive.extensions) == null ? void 0 : _primitive_extensions.KHR_materials_variants) {
            				var variants = primitive.extensions.KHR_materials_variants;
            				var tempMapping = {};
            				variants.mappings.forEach((mapping)=>{
            						mapping.variants.forEach((variant)=>{
            								tempMapping[variant] = mapping.material;
            						});
            				});
            				meshVariants[result.id] = tempMapping;
            		}
            		meshDefaultMaterials[result.id] = primitive.material;
            		return result;
            };
            var createMesh = (device, gltfMesh, accessors, bufferViews, vertexBufferDict, meshVariants, meshDefaultMaterials, assetOptions, promises)=>{
            		var meshes = [];
            		gltfMesh.primitives.forEach((primitive)=>{
            				var _primitive_extensions;
            				if ((_primitive_extensions = primitive.extensions) == null ? void 0 : _primitive_extensions.KHR_draco_mesh_compression) {
            						meshes.push(createDracoMesh(device, primitive, accessors, bufferViews, meshVariants, meshDefaultMaterials, promises));
            				} else {
            						var indices = primitive.hasOwnProperty('indices') ? getAccessorData(accessors[primitive.indices], bufferViews, true) : null;
            						var vertexBuffer = createVertexBuffer(device, primitive.attributes, indices, accessors, bufferViews, vertexBufferDict);
            						var primitiveType = getPrimitiveType(primitive);
            						var mesh = new Mesh(device);
            						mesh.vertexBuffer = vertexBuffer;
            						mesh.primitive[0].type = primitiveType;
            						mesh.primitive[0].base = 0;
            						mesh.primitive[0].indexed = indices !== null;
            						if (indices !== null) {
            								var indexFormat;
            								if (indices instanceof Uint8Array) {
            										indexFormat = INDEXFORMAT_UINT8;
            								} else if (indices instanceof Uint16Array) {
            										indexFormat = INDEXFORMAT_UINT16;
            								} else {
            										indexFormat = INDEXFORMAT_UINT32;
            								}
            								if (indexFormat === INDEXFORMAT_UINT8 && device.isWebGPU) {
            										indexFormat = INDEXFORMAT_UINT16;
            										indices = new Uint16Array(indices);
            								}
            								var indexBuffer = new IndexBuffer(device, indexFormat, indices.length, BUFFER_STATIC, indices);
            								mesh.indexBuffer[0] = indexBuffer;
            								mesh.primitive[0].count = indices.length;
            						} else {
            								mesh.primitive[0].count = vertexBuffer.numVertices;
            						}
            						if (primitive.hasOwnProperty('extensions') && primitive.extensions.hasOwnProperty('KHR_materials_variants')) {
            								var variants = primitive.extensions.KHR_materials_variants;
            								var tempMapping = {};
            								variants.mappings.forEach((mapping)=>{
            										mapping.variants.forEach((variant)=>{
            												tempMapping[variant] = mapping.material;
            										});
            								});
            								meshVariants[mesh.id] = tempMapping;
            						}
            						meshDefaultMaterials[mesh.id] = primitive.material;
            						var accessor = accessors[primitive.attributes.POSITION];
            						mesh.aabb = getAccessorBoundingBox(accessor);
            						if (primitive.hasOwnProperty('targets')) {
            								var targets = [];
            								primitive.targets.forEach((target, index)=>{
            										var options = {};
            										if (target.hasOwnProperty('POSITION')) {
            												accessor = accessors[target.POSITION];
            												options.deltaPositions = getAccessorDataFloat32(accessor, bufferViews);
            												options.aabb = getAccessorBoundingBox(accessor);
            										}
            										if (target.hasOwnProperty('NORMAL')) {
            												accessor = accessors[target.NORMAL];
            												options.deltaNormals = getAccessorDataFloat32(accessor, bufferViews);
            										}
            										if (gltfMesh.hasOwnProperty('extras') && gltfMesh.extras.hasOwnProperty('targetNames')) {
            												options.name = gltfMesh.extras.targetNames[index];
            										} else {
            												options.name = index.toString(10);
            										}
            										if (gltfMesh.hasOwnProperty('weights')) {
            												options.defaultWeight = gltfMesh.weights[index];
            										}
            										options.preserveData = assetOptions.morphPreserveData;
            										targets.push(new MorphTarget(options));
            								});
            								mesh.morph = new Morph(targets, device, {
            										preferHighPrecision: assetOptions.morphPreferHighPrecision
            								});
            						}
            						meshes.push(mesh);
            				}
            		});
            		return meshes;
            };
            var extractTextureTransform = (source, material, maps)=>{
            		var _source_extensions;
            		var map;
            		var texCoord = source.texCoord;
            		if (texCoord) {
            				for(map = 0; map < maps.length; ++map){
            						material["" + maps[map] + "MapUv"] = texCoord;
            				}
            		}
            		var zeros = [
            				0,
            				0
            		];
            		var ones = [
            				1,
            				1
            		];
            		var textureTransform = (_source_extensions = source.extensions) == null ? void 0 : _source_extensions.KHR_texture_transform;
            		if (textureTransform) {
            				var offset = textureTransform.offset || zeros;
            				var scale = textureTransform.scale || ones;
            				var rotation = textureTransform.rotation ? -textureTransform.rotation * math.RAD_TO_DEG : 0;
            				var tilingVec = new Vec2(scale[0], scale[1]);
            				var offsetVec = new Vec2(offset[0], 1.0 - scale[1] - offset[1]);
            				for(map = 0; map < maps.length; ++map){
            						material["" + maps[map] + "MapTiling"] = tilingVec;
            						material["" + maps[map] + "MapOffset"] = offsetVec;
            						material["" + maps[map] + "MapRotation"] = rotation;
            				}
            		}
            };
            var extensionPbrSpecGlossiness = (data, material, textures)=>{
            		var color, texture;
            		if (data.hasOwnProperty('diffuseFactor')) {
            				color = data.diffuseFactor;
            				material.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
            				material.opacity = color[3];
            		} else {
            				material.diffuse.set(1, 1, 1);
            				material.opacity = 1;
            		}
            		if (data.hasOwnProperty('diffuseTexture')) {
            				var diffuseTexture = data.diffuseTexture;
            				texture = textures[diffuseTexture.index];
            				material.diffuseMap = texture;
            				material.diffuseMapChannel = 'rgb';
            				material.opacityMap = texture;
            				material.opacityMapChannel = 'a';
            				extractTextureTransform(diffuseTexture, material, [
            						'diffuse',
            						'opacity'
            				]);
            		}
            		material.useMetalness = false;
            		if (data.hasOwnProperty('specularFactor')) {
            				color = data.specularFactor;
            				material.specular.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
            		} else {
            				material.specular.set(1, 1, 1);
            		}
            		if (data.hasOwnProperty('glossinessFactor')) {
            				material.gloss = data.glossinessFactor;
            		} else {
            				material.gloss = 1.0;
            		}
            		if (data.hasOwnProperty('specularGlossinessTexture')) {
            				var specularGlossinessTexture = data.specularGlossinessTexture;
            				material.specularMap = material.glossMap = textures[specularGlossinessTexture.index];
            				material.specularMapChannel = 'rgb';
            				material.glossMapChannel = 'a';
            				extractTextureTransform(specularGlossinessTexture, material, [
            						'gloss',
            						'metalness'
            				]);
            		}
            };
            var extensionClearCoat = (data, material, textures)=>{
            		if (data.hasOwnProperty('clearcoatFactor')) {
            				material.clearCoat = data.clearcoatFactor * 0.25;
            		} else {
            				material.clearCoat = 0;
            		}
            		if (data.hasOwnProperty('clearcoatTexture')) {
            				var clearcoatTexture = data.clearcoatTexture;
            				material.clearCoatMap = textures[clearcoatTexture.index];
            				material.clearCoatMapChannel = 'r';
            				extractTextureTransform(clearcoatTexture, material, [
            						'clearCoat'
            				]);
            		}
            		if (data.hasOwnProperty('clearcoatRoughnessFactor')) {
            				material.clearCoatGloss = data.clearcoatRoughnessFactor;
            		} else {
            				material.clearCoatGloss = 0;
            		}
            		if (data.hasOwnProperty('clearcoatRoughnessTexture')) {
            				var clearcoatRoughnessTexture = data.clearcoatRoughnessTexture;
            				material.clearCoatGlossMap = textures[clearcoatRoughnessTexture.index];
            				material.clearCoatGlossMapChannel = 'g';
            				extractTextureTransform(clearcoatRoughnessTexture, material, [
            						'clearCoatGloss'
            				]);
            		}
            		if (data.hasOwnProperty('clearcoatNormalTexture')) {
            				var clearcoatNormalTexture = data.clearcoatNormalTexture;
            				material.clearCoatNormalMap = textures[clearcoatNormalTexture.index];
            				extractTextureTransform(clearcoatNormalTexture, material, [
            						'clearCoatNormal'
            				]);
            				if (clearcoatNormalTexture.hasOwnProperty('scale')) {
            						material.clearCoatBumpiness = clearcoatNormalTexture.scale;
            				} else {
            						material.clearCoatBumpiness = 1;
            				}
            		}
            		material.clearCoatGlossInvert = true;
            };
            var extensionUnlit = (data, material, textures)=>{
            		material.useLighting = false;
            		material.emissive.copy(material.diffuse);
            		material.emissiveMap = material.diffuseMap;
            		material.emissiveMapUv = material.diffuseMapUv;
            		material.emissiveMapTiling.copy(material.diffuseMapTiling);
            		material.emissiveMapOffset.copy(material.diffuseMapOffset);
            		material.emissiveMapRotation = material.diffuseMapRotation;
            		material.emissiveMapChannel = material.diffuseMapChannel;
            		material.emissiveVertexColor = material.diffuseVertexColor;
            		material.emissiveVertexColorChannel = material.diffuseVertexColorChannel;
            		material.useLighting = false;
            		material.useSkybox = false;
            		material.diffuse.set(1, 1, 1);
            		material.diffuseMap = null;
            		material.diffuseVertexColor = false;
            };
            var extensionSpecular = (data, material, textures)=>{
            		material.useMetalnessSpecularColor = true;
            		if (data.hasOwnProperty('specularColorTexture')) {
            				material.specularMap = textures[data.specularColorTexture.index];
            				material.specularMapChannel = 'rgb';
            				extractTextureTransform(data.specularColorTexture, material, [
            						'specular'
            				]);
            		}
            		if (data.hasOwnProperty('specularColorFactor')) {
            				var color = data.specularColorFactor;
            				material.specular.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
            		} else {
            				material.specular.set(1, 1, 1);
            		}
            		if (data.hasOwnProperty('specularFactor')) {
            				material.specularityFactor = data.specularFactor;
            		} else {
            				material.specularityFactor = 1;
            		}
            		if (data.hasOwnProperty('specularTexture')) {
            				material.specularityFactorMapChannel = 'a';
            				material.specularityFactorMap = textures[data.specularTexture.index];
            				extractTextureTransform(data.specularTexture, material, [
            						'specularityFactor'
            				]);
            		}
            };
            var extensionIor = (data, material, textures)=>{
            		if (data.hasOwnProperty('ior')) {
            				material.refractionIndex = 1.0 / data.ior;
            		}
            };
            var extensionDispersion = (data, material, textures)=>{
            		if (data.hasOwnProperty('dispersion')) {
            				material.dispersion = data.dispersion;
            		}
            };
            var extensionTransmission = (data, material, textures)=>{
            		material.blendType = BLEND_NORMAL;
            		material.useDynamicRefraction = true;
            		if (data.hasOwnProperty('transmissionFactor')) {
            				material.refraction = data.transmissionFactor;
            		}
            		if (data.hasOwnProperty('transmissionTexture')) {
            				material.refractionMapChannel = 'r';
            				material.refractionMap = textures[data.transmissionTexture.index];
            				extractTextureTransform(data.transmissionTexture, material, [
            						'refraction'
            				]);
            		}
            };
            var extensionSheen = (data, material, textures)=>{
            		material.useSheen = true;
            		if (data.hasOwnProperty('sheenColorFactor')) {
            				var color = data.sheenColorFactor;
            				material.sheen.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
            		} else {
            				material.sheen.set(1, 1, 1);
            		}
            		if (data.hasOwnProperty('sheenColorTexture')) {
            				material.sheenMap = textures[data.sheenColorTexture.index];
            				extractTextureTransform(data.sheenColorTexture, material, [
            						'sheen'
            				]);
            		}
            		material.sheenGloss = data.hasOwnProperty('sheenRoughnessFactor') ? data.sheenRoughnessFactor : 0.0;
            		if (data.hasOwnProperty('sheenRoughnessTexture')) {
            				material.sheenGlossMap = textures[data.sheenRoughnessTexture.index];
            				material.sheenGlossMapChannel = 'a';
            				extractTextureTransform(data.sheenRoughnessTexture, material, [
            						'sheenGloss'
            				]);
            		}
            		material.sheenGlossInvert = true;
            };
            var extensionVolume = (data, material, textures)=>{
            		material.blendType = BLEND_NORMAL;
            		material.useDynamicRefraction = true;
            		if (data.hasOwnProperty('thicknessFactor')) {
            				material.thickness = data.thicknessFactor;
            		}
            		if (data.hasOwnProperty('thicknessTexture')) {
            				material.thicknessMap = textures[data.thicknessTexture.index];
            				material.thicknessMapChannel = 'g';
            				extractTextureTransform(data.thicknessTexture, material, [
            						'thickness'
            				]);
            		}
            		if (data.hasOwnProperty('attenuationDistance')) {
            				material.attenuationDistance = data.attenuationDistance;
            		}
            		if (data.hasOwnProperty('attenuationColor')) {
            				var color = data.attenuationColor;
            				material.attenuation.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
            		}
            };
            var extensionEmissiveStrength = (data, material, textures)=>{
            		if (data.hasOwnProperty('emissiveStrength')) {
            				material.emissiveIntensity = data.emissiveStrength;
            		}
            };
            var extensionIridescence = (data, material, textures)=>{
            		material.useIridescence = true;
            		if (data.hasOwnProperty('iridescenceFactor')) {
            				material.iridescence = data.iridescenceFactor;
            		}
            		if (data.hasOwnProperty('iridescenceTexture')) {
            				material.iridescenceMapChannel = 'r';
            				material.iridescenceMap = textures[data.iridescenceTexture.index];
            				extractTextureTransform(data.iridescenceTexture, material, [
            						'iridescence'
            				]);
            		}
            		if (data.hasOwnProperty('iridescenceIor')) {
            				material.iridescenceRefractionIndex = data.iridescenceIor;
            		}
            		if (data.hasOwnProperty('iridescenceThicknessMinimum')) {
            				material.iridescenceThicknessMin = data.iridescenceThicknessMinimum;
            		}
            		if (data.hasOwnProperty('iridescenceThicknessMaximum')) {
            				material.iridescenceThicknessMax = data.iridescenceThicknessMaximum;
            		}
            		if (data.hasOwnProperty('iridescenceThicknessTexture')) {
            				material.iridescenceThicknessMapChannel = 'g';
            				material.iridescenceThicknessMap = textures[data.iridescenceThicknessTexture.index];
            				extractTextureTransform(data.iridescenceThicknessTexture, material, [
            						'iridescenceThickness'
            				]);
            		}
            };
            var createMaterial = (gltfMaterial, textures)=>{
            		var material = new StandardMaterial();
            		if (gltfMaterial.hasOwnProperty('name')) {
            				material.name = gltfMaterial.name;
            		}
            		material.occludeSpecular = SPECOCC_AO;
            		material.diffuseVertexColor = true;
            		material.specularTint = true;
            		material.specularVertexColor = true;
            		material.specular.set(1, 1, 1);
            		material.gloss = 1;
            		material.glossInvert = true;
            		material.useMetalness = true;
            		var color, texture;
            		if (gltfMaterial.hasOwnProperty('pbrMetallicRoughness')) {
            				var pbrData = gltfMaterial.pbrMetallicRoughness;
            				if (pbrData.hasOwnProperty('baseColorFactor')) {
            						color = pbrData.baseColorFactor;
            						material.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
            						material.opacity = color[3];
            				}
            				if (pbrData.hasOwnProperty('baseColorTexture')) {
            						var baseColorTexture = pbrData.baseColorTexture;
            						texture = textures[baseColorTexture.index];
            						material.diffuseMap = texture;
            						material.diffuseMapChannel = 'rgb';
            						material.opacityMap = texture;
            						material.opacityMapChannel = 'a';
            						extractTextureTransform(baseColorTexture, material, [
            								'diffuse',
            								'opacity'
            						]);
            				}
            				if (pbrData.hasOwnProperty('metallicFactor')) {
            						material.metalness = pbrData.metallicFactor;
            				}
            				if (pbrData.hasOwnProperty('roughnessFactor')) {
            						material.gloss = pbrData.roughnessFactor;
            				}
            				if (pbrData.hasOwnProperty('metallicRoughnessTexture')) {
            						var metallicRoughnessTexture = pbrData.metallicRoughnessTexture;
            						material.metalnessMap = material.glossMap = textures[metallicRoughnessTexture.index];
            						material.metalnessMapChannel = 'b';
            						material.glossMapChannel = 'g';
            						extractTextureTransform(metallicRoughnessTexture, material, [
            								'gloss',
            								'metalness'
            						]);
            				}
            		}
            		if (gltfMaterial.hasOwnProperty('normalTexture')) {
            				var normalTexture = gltfMaterial.normalTexture;
            				material.normalMap = textures[normalTexture.index];
            				extractTextureTransform(normalTexture, material, [
            						'normal'
            				]);
            				if (normalTexture.hasOwnProperty('scale')) {
            						material.bumpiness = normalTexture.scale;
            				}
            		}
            		if (gltfMaterial.hasOwnProperty('occlusionTexture')) {
            				var occlusionTexture = gltfMaterial.occlusionTexture;
            				material.aoMap = textures[occlusionTexture.index];
            				material.aoMapChannel = 'r';
            				extractTextureTransform(occlusionTexture, material, [
            						'ao'
            				]);
            		}
            		if (gltfMaterial.hasOwnProperty('emissiveFactor')) {
            				color = gltfMaterial.emissiveFactor;
            				material.emissive.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));
            		}
            		if (gltfMaterial.hasOwnProperty('emissiveTexture')) {
            				var emissiveTexture = gltfMaterial.emissiveTexture;
            				material.emissiveMap = textures[emissiveTexture.index];
            				extractTextureTransform(emissiveTexture, material, [
            						'emissive'
            				]);
            		}
            		if (gltfMaterial.hasOwnProperty('alphaMode')) {
            				switch(gltfMaterial.alphaMode){
            						case 'MASK':
            								material.blendType = BLEND_NONE;
            								if (gltfMaterial.hasOwnProperty('alphaCutoff')) {
            										material.alphaTest = gltfMaterial.alphaCutoff;
            								} else {
            										material.alphaTest = 0.5;
            								}
            								break;
            						case 'BLEND':
            								material.blendType = BLEND_NORMAL;
            								material.depthWrite = false;
            								break;
            						default:
            						case 'OPAQUE':
            								material.blendType = BLEND_NONE;
            								break;
            				}
            		} else {
            				material.blendType = BLEND_NONE;
            		}
            		if (gltfMaterial.hasOwnProperty('doubleSided')) {
            				material.twoSidedLighting = gltfMaterial.doubleSided;
            				material.cull = gltfMaterial.doubleSided ? CULLFACE_NONE : CULLFACE_BACK;
            		} else {
            				material.twoSidedLighting = false;
            				material.cull = CULLFACE_BACK;
            		}
            		var extensions = {
            				'KHR_materials_clearcoat': extensionClearCoat,
            				'KHR_materials_emissive_strength': extensionEmissiveStrength,
            				'KHR_materials_ior': extensionIor,
            				'KHR_materials_dispersion': extensionDispersion,
            				'KHR_materials_iridescence': extensionIridescence,
            				'KHR_materials_pbrSpecularGlossiness': extensionPbrSpecGlossiness,
            				'KHR_materials_sheen': extensionSheen,
            				'KHR_materials_specular': extensionSpecular,
            				'KHR_materials_transmission': extensionTransmission,
            				'KHR_materials_unlit': extensionUnlit,
            				'KHR_materials_volume': extensionVolume
            		};
            		if (gltfMaterial.hasOwnProperty('extensions')) {
            				for(var key in gltfMaterial.extensions){
            						var extensionFunc = extensions[key];
            						if (extensionFunc !== undefined) {
            								extensionFunc(gltfMaterial.extensions[key], material, textures);
            						}
            				}
            		}
            		material.update();
            		return material;
            };
            var createAnimation = (gltfAnimation, animationIndex, gltfAccessors, bufferViews, nodes, meshes, gltfNodes)=>{
            		var createAnimData = (gltfAccessor)=>{
            				return new AnimData(getNumComponents(gltfAccessor.type), getAccessorDataFloat32(gltfAccessor, bufferViews));
            		};
            		var interpMap = {
            				'STEP': INTERPOLATION_STEP,
            				'LINEAR': INTERPOLATION_LINEAR,
            				'CUBICSPLINE': INTERPOLATION_CUBIC
            		};
            		var inputMap = {};
            		var outputMap = {};
            		var curveMap = {};
            		var outputCounter = 1;
            		var i;
            		for(i = 0; i < gltfAnimation.samplers.length; ++i){
            				var sampler = gltfAnimation.samplers[i];
            				if (!inputMap.hasOwnProperty(sampler.input)) {
            						inputMap[sampler.input] = createAnimData(gltfAccessors[sampler.input]);
            				}
            				if (!outputMap.hasOwnProperty(sampler.output)) {
            						outputMap[sampler.output] = createAnimData(gltfAccessors[sampler.output]);
            				}
            				var interpolation = sampler.hasOwnProperty('interpolation') && interpMap.hasOwnProperty(sampler.interpolation) ? interpMap[sampler.interpolation] : INTERPOLATION_LINEAR;
            				var curve = {
            						paths: [],
            						input: sampler.input,
            						output: sampler.output,
            						interpolation: interpolation
            				};
            				curveMap[i] = curve;
            		}
            		var quatArrays = [];
            		var transformSchema = {
            				'translation': 'localPosition',
            				'rotation': 'localRotation',
            				'scale': 'localScale'
            		};
            		var constructNodePath = (node)=>{
            				var path = [];
            				while(node){
            						path.unshift(node.name);
            						node = node.parent;
            				}
            				return path;
            		};
            		var createMorphTargetCurves = (curve, gltfNode, entityPath)=>{
            				var out = outputMap[curve.output];
            				if (!out) {
            						return;
            				}
            				var targetNames;
            				if (meshes && meshes[gltfNode.mesh]) {
            						var mesh = meshes[gltfNode.mesh];
            						if (mesh.hasOwnProperty('extras') && mesh.extras.hasOwnProperty('targetNames')) {
            								targetNames = mesh.extras.targetNames;
            						}
            				}
            				var outData = out.data;
            				var morphTargetCount = outData.length / inputMap[curve.input].data.length;
            				var keyframeCount = outData.length / morphTargetCount;
            				var singleBufferSize = keyframeCount * 4;
            				var buffer = new ArrayBuffer(singleBufferSize * morphTargetCount);
            				for(var j = 0; j < morphTargetCount; j++){
            						var morphTargetOutput = new Float32Array(buffer, singleBufferSize * j, keyframeCount);
            						for(var k = 0; k < keyframeCount; k++){
            								morphTargetOutput[k] = outData[k * morphTargetCount + j];
            						}
            						var output = new AnimData(1, morphTargetOutput);
            						var weightName = (targetNames == null ? void 0 : targetNames[j]) ? "name." + targetNames[j] : j;
            						outputMap[-outputCounter] = output;
            						var morphCurve = {
            								paths: [
            										{
            												entityPath: entityPath,
            												component: 'graph',
            												propertyPath: [
            														"weight." + weightName
            												]
            										}
            								],
            								input: curve.input,
            								output: -outputCounter,
            								interpolation: curve.interpolation
            						};
            						outputCounter++;
            						curveMap["morphCurve-" + i + "-" + j] = morphCurve;
            				}
            		};
            		for(i = 0; i < gltfAnimation.channels.length; ++i){
            				var channel = gltfAnimation.channels[i];
            				var target = channel.target;
            				var curve1 = curveMap[channel.sampler];
            				var node = nodes[target.node];
            				var gltfNode = gltfNodes[target.node];
            				var entityPath = constructNodePath(node);
            				if (target.path.startsWith('weights')) {
            						createMorphTargetCurves(curve1, gltfNode, entityPath);
            						curveMap[channel.sampler].morphCurve = true;
            				} else {
            						curve1.paths.push({
            								entityPath: entityPath,
            								component: 'graph',
            								propertyPath: [
            										transformSchema[target.path]
            								]
            						});
            				}
            		}
            		var inputs = [];
            		var outputs = [];
            		var curves = [];
            		for(var inputKey in inputMap){
            				inputs.push(inputMap[inputKey]);
            				inputMap[inputKey] = inputs.length - 1;
            		}
            		for(var outputKey in outputMap){
            				outputs.push(outputMap[outputKey]);
            				outputMap[outputKey] = outputs.length - 1;
            		}
            		for(var curveKey in curveMap){
            				var curveData = curveMap[curveKey];
            				if (curveData.morphCurve) {
            						continue;
            				}
            				curves.push(new AnimCurve(curveData.paths, inputMap[curveData.input], outputMap[curveData.output], curveData.interpolation));
            				if (curveData.paths.length > 0 && curveData.paths[0].propertyPath[0] === 'localRotation' && curveData.interpolation !== INTERPOLATION_CUBIC) {
            						quatArrays.push(curves[curves.length - 1].output);
            				}
            		}
            		quatArrays.sort();
            		var prevIndex = null;
            		var data;
            		for(i = 0; i < quatArrays.length; ++i){
            				var index = quatArrays[i];
            				if (i === 0 || index !== prevIndex) {
            						data = outputs[index];
            						if (data.components === 4) {
            								var d = data.data;
            								var len = d.length - 4;
            								for(var j = 0; j < len; j += 4){
            										var dp = d[j + 0] * d[j + 4] + d[j + 1] * d[j + 5] + d[j + 2] * d[j + 6] + d[j + 3] * d[j + 7];
            										if (dp < 0) {
            												d[j + 4] *= -1;
            												d[j + 5] *= -1;
            												d[j + 6] *= -1;
            												d[j + 7] *= -1;
            										}
            								}
            						}
            						prevIndex = index;
            				}
            		}
            		var duration = 0;
            		for(i = 0; i < inputs.length; i++){
            				data = inputs[i]._data;
            				duration = Math.max(duration, data.length === 0 ? 0 : data[data.length - 1]);
            		}
            		return new AnimTrack(gltfAnimation.hasOwnProperty('name') ? gltfAnimation.name : "animation_" + animationIndex, duration, inputs, outputs, curves);
            };
            var tempMat = new Mat4();
            var tempVec = new Vec3();
            var createNode = (gltfNode, nodeIndex, nodeInstancingMap)=>{
            		var entity = new GraphNode();
            		if (gltfNode.hasOwnProperty('name') && gltfNode.name.length > 0) {
            				entity.name = gltfNode.name;
            		} else {
            				entity.name = "node_" + nodeIndex;
            		}
            		if (gltfNode.hasOwnProperty('matrix')) {
            				tempMat.data.set(gltfNode.matrix);
            				tempMat.getTranslation(tempVec);
            				entity.setLocalPosition(tempVec);
            				tempMat.getEulerAngles(tempVec);
            				entity.setLocalEulerAngles(tempVec);
            				tempMat.getScale(tempVec);
            				entity.setLocalScale(tempVec);
            		}
            		if (gltfNode.hasOwnProperty('rotation')) {
            				var r = gltfNode.rotation;
            				entity.setLocalRotation(r[0], r[1], r[2], r[3]);
            		}
            		if (gltfNode.hasOwnProperty('translation')) {
            				var t = gltfNode.translation;
            				entity.setLocalPosition(t[0], t[1], t[2]);
            		}
            		if (gltfNode.hasOwnProperty('scale')) {
            				var s = gltfNode.scale;
            				entity.setLocalScale(s[0], s[1], s[2]);
            		}
            		if (gltfNode.hasOwnProperty('extensions') && gltfNode.extensions.EXT_mesh_gpu_instancing) {
            				nodeInstancingMap.set(gltfNode, {
            						ext: gltfNode.extensions.EXT_mesh_gpu_instancing
            				});
            		}
            		return entity;
            };
            var createCamera = (gltfCamera, node)=>{
            		var projection = gltfCamera.type === 'orthographic' ? PROJECTION_ORTHOGRAPHIC : PROJECTION_PERSPECTIVE;
            		var gltfProperties = projection === PROJECTION_ORTHOGRAPHIC ? gltfCamera.orthographic : gltfCamera.perspective;
            		var componentData = {
            				enabled: false,
            				projection: projection,
            				nearClip: gltfProperties.znear,
            				aspectRatioMode: ASPECT_AUTO
            		};
            		if (gltfProperties.zfar) {
            				componentData.farClip = gltfProperties.zfar;
            		}
            		if (projection === PROJECTION_ORTHOGRAPHIC) {
            				componentData.orthoHeight = 0.5 * gltfProperties.ymag;
            				if (gltfProperties.ymag) {
            						componentData.aspectRatioMode = ASPECT_MANUAL;
            						componentData.aspectRatio = gltfProperties.xmag / gltfProperties.ymag;
            				}
            		} else {
            				componentData.fov = gltfProperties.yfov * math.RAD_TO_DEG;
            				if (gltfProperties.aspectRatio) {
            						componentData.aspectRatioMode = ASPECT_MANUAL;
            						componentData.aspectRatio = gltfProperties.aspectRatio;
            				}
            		}
            		var cameraEntity = new Entity(gltfCamera.name);
            		cameraEntity.addComponent('camera', componentData);
            		return cameraEntity;
            };
            var createLight = (gltfLight, node)=>{
            		var lightProps = {
            				enabled: false,
            				type: gltfLight.type === 'point' ? 'omni' : gltfLight.type,
            				color: gltfLight.hasOwnProperty('color') ? new Color(gltfLight.color) : Color.WHITE,
            				range: gltfLight.hasOwnProperty('range') ? gltfLight.range : 9999,
            				falloffMode: LIGHTFALLOFF_INVERSESQUARED,
            				intensity: gltfLight.hasOwnProperty('intensity') ? math.clamp(gltfLight.intensity, 0, 2) : 1
            		};
            		if (gltfLight.hasOwnProperty('spot')) {
            				lightProps.innerConeAngle = gltfLight.spot.hasOwnProperty('innerConeAngle') ? gltfLight.spot.innerConeAngle * math.RAD_TO_DEG : 0;
            				lightProps.outerConeAngle = gltfLight.spot.hasOwnProperty('outerConeAngle') ? gltfLight.spot.outerConeAngle * math.RAD_TO_DEG : Math.PI / 4;
            		}
            		if (gltfLight.hasOwnProperty('intensity')) {
            				lightProps.luminance = gltfLight.intensity * Light.getLightUnitConversion(lightTypes[lightProps.type], lightProps.outerConeAngle, lightProps.innerConeAngle);
            		}
            		var lightEntity = new Entity(node.name);
            		lightEntity.rotateLocal(90, 0, 0);
            		lightEntity.addComponent('light', lightProps);
            		return lightEntity;
            };
            var createSkins = (device, gltf, nodes, bufferViews)=>{
            		if (!gltf.hasOwnProperty('skins') || gltf.skins.length === 0) {
            				return [];
            		}
            		var glbSkins = new Map();
            		return gltf.skins.map((gltfSkin)=>{
            				return createSkin(device, gltfSkin, gltf.accessors, bufferViews, nodes, glbSkins);
            		});
            };
            var createMeshes = (device, gltf, bufferViews, options)=>{
            		var _gltf_meshes, _gltf_accessors, _gltf_bufferViews;
            		var vertexBufferDict = {};
            		var meshVariants = {};
            		var meshDefaultMaterials = {};
            		var promises = [];
            		var valid = !options.skipMeshes && (gltf == null ? void 0 : (_gltf_meshes = gltf.meshes) == null ? void 0 : _gltf_meshes.length) && (gltf == null ? void 0 : (_gltf_accessors = gltf.accessors) == null ? void 0 : _gltf_accessors.length) && (gltf == null ? void 0 : (_gltf_bufferViews = gltf.bufferViews) == null ? void 0 : _gltf_bufferViews.length);
            		var meshes = valid ? gltf.meshes.map((gltfMesh)=>{
            				return createMesh(device, gltfMesh, gltf.accessors, bufferViews, vertexBufferDict, meshVariants, meshDefaultMaterials, options, promises);
            		}) : [];
            		return {
            				meshes,
            				meshVariants,
            				meshDefaultMaterials,
            				promises
            		};
            };
            var createMaterials = (gltf, textures, options)=>{
            		var _options_material, _options_material1, _options_material2;
            		if (!gltf.hasOwnProperty('materials') || gltf.materials.length === 0) {
            				return [];
            		}
            		var preprocess = options == null ? void 0 : (_options_material = options.material) == null ? void 0 : _options_material.preprocess;
            		var _options_material_process;
            		var process = (_options_material_process = options == null ? void 0 : (_options_material1 = options.material) == null ? void 0 : _options_material1.process) != null ? _options_material_process : createMaterial;
            		var postprocess = options == null ? void 0 : (_options_material2 = options.material) == null ? void 0 : _options_material2.postprocess;
            		return gltf.materials.map((gltfMaterial)=>{
            				if (preprocess) {
            						preprocess(gltfMaterial);
            				}
            				var material = process(gltfMaterial, textures);
            				if (postprocess) {
            						postprocess(gltfMaterial, material);
            				}
            				return material;
            		});
            };
            var createVariants = (gltf)=>{
            		if (!gltf.hasOwnProperty('extensions') || !gltf.extensions.hasOwnProperty('KHR_materials_variants')) {
            				return null;
            		}
            		var data = gltf.extensions.KHR_materials_variants.variants;
            		var variants = {};
            		for(var i = 0; i < data.length; i++){
            				variants[data[i].name] = i;
            		}
            		return variants;
            };
            var createAnimations = (gltf, nodes, bufferViews, options)=>{
            		var _options_animation, _options_animation1;
            		if (!gltf.hasOwnProperty('animations') || gltf.animations.length === 0) {
            				return [];
            		}
            		var preprocess = options == null ? void 0 : (_options_animation = options.animation) == null ? void 0 : _options_animation.preprocess;
            		var postprocess = options == null ? void 0 : (_options_animation1 = options.animation) == null ? void 0 : _options_animation1.postprocess;
            		return gltf.animations.map((gltfAnimation, index)=>{
            				if (preprocess) {
            						preprocess(gltfAnimation);
            				}
            				var animation = createAnimation(gltfAnimation, index, gltf.accessors, bufferViews, nodes, gltf.meshes, gltf.nodes);
            				if (postprocess) {
            						postprocess(gltfAnimation, animation);
            				}
            				return animation;
            		});
            };
            var createInstancing = (device, gltf, nodeInstancingMap, bufferViews)=>{
            		var accessors = gltf.accessors;
            		nodeInstancingMap.forEach((data, entity)=>{
            				var attributes = data.ext.attributes;
            				var translations;
            				if (attributes.hasOwnProperty('TRANSLATION')) {
            						var accessor = accessors[attributes.TRANSLATION];
            						translations = getAccessorDataFloat32(accessor, bufferViews);
            				}
            				var rotations;
            				if (attributes.hasOwnProperty('ROTATION')) {
            						var accessor1 = accessors[attributes.ROTATION];
            						rotations = getAccessorDataFloat32(accessor1, bufferViews);
            				}
            				var scales;
            				if (attributes.hasOwnProperty('SCALE')) {
            						var accessor2 = accessors[attributes.SCALE];
            						scales = getAccessorDataFloat32(accessor2, bufferViews);
            				}
            				var instanceCount = (translations ? translations.length / 3 : 0) || (rotations ? rotations.length / 4 : 0) || (scales ? scales.length / 3 : 0);
            				if (instanceCount) {
            						var matrices = new Float32Array(instanceCount * 16);
            						var pos = new Vec3();
            						var rot = new Quat();
            						var scl = new Vec3(1, 1, 1);
            						var matrix = new Mat4();
            						var matrixIndex = 0;
            						for(var i = 0; i < instanceCount; i++){
            								var i3 = i * 3;
            								if (translations) {
            										pos.set(translations[i3], translations[i3 + 1], translations[i3 + 2]);
            								}
            								if (rotations) {
            										var i4 = i * 4;
            										rot.set(rotations[i4], rotations[i4 + 1], rotations[i4 + 2], rotations[i4 + 3]);
            								}
            								if (scales) {
            										scl.set(scales[i3], scales[i3 + 1], scales[i3 + 2]);
            								}
            								matrix.setTRS(pos, rot, scl);
            								for(var m = 0; m < 16; m++){
            										matrices[matrixIndex++] = matrix.data[m];
            								}
            						}
            						data.matrices = matrices;
            				}
            		});
            };
            var createNodes = (gltf, options, nodeInstancingMap)=>{
            		var _options_node, _options_node1, _options_node2;
            		if (!gltf.hasOwnProperty('nodes') || gltf.nodes.length === 0) {
            				return [];
            		}
            		var preprocess = options == null ? void 0 : (_options_node = options.node) == null ? void 0 : _options_node.preprocess;
            		var _options_node_process;
            		var process = (_options_node_process = options == null ? void 0 : (_options_node1 = options.node) == null ? void 0 : _options_node1.process) != null ? _options_node_process : createNode;
            		var postprocess = options == null ? void 0 : (_options_node2 = options.node) == null ? void 0 : _options_node2.postprocess;
            		var nodes = gltf.nodes.map((gltfNode, index)=>{
            				if (preprocess) {
            						preprocess(gltfNode);
            				}
            				var node = process(gltfNode, index, nodeInstancingMap);
            				if (postprocess) {
            						postprocess(gltfNode, node);
            				}
            				return node;
            		});
            		for(var i = 0; i < gltf.nodes.length; ++i){
            				var gltfNode = gltf.nodes[i];
            				if (gltfNode.hasOwnProperty('children')) {
            						var parent = nodes[i];
            						var uniqueNames = {};
            						for(var j = 0; j < gltfNode.children.length; ++j){
            								var child = nodes[gltfNode.children[j]];
            								if (!child.parent) {
            										if (uniqueNames.hasOwnProperty(child.name)) {
            												child.name += uniqueNames[child.name]++;
            										} else {
            												uniqueNames[child.name] = 1;
            										}
            										parent.addChild(child);
            								}
            						}
            				}
            		}
            		return nodes;
            };
            var createScenes = (gltf, nodes)=>{
            		var _gltf_scenes__nodes;
            		var scenes = [];
            		var count = gltf.scenes.length;
            		if (count === 1 && ((_gltf_scenes__nodes = gltf.scenes[0].nodes) == null ? void 0 : _gltf_scenes__nodes.length) === 1) {
            				var nodeIndex = gltf.scenes[0].nodes[0];
            				scenes.push(nodes[nodeIndex]);
            		} else {
            				for(var i = 0; i < count; i++){
            						var scene = gltf.scenes[i];
            						if (scene.nodes) {
            								var sceneRoot = new GraphNode(scene.name);
            								for(var n = 0; n < scene.nodes.length; n++){
            										var childNode = nodes[scene.nodes[n]];
            										sceneRoot.addChild(childNode);
            								}
            								scenes.push(sceneRoot);
            						}
            				}
            		}
            		return scenes;
            };
            var createCameras = (gltf, nodes, options)=>{
            		var cameras = null;
            		if (gltf.hasOwnProperty('nodes') && gltf.hasOwnProperty('cameras') && gltf.cameras.length > 0) {
            				var _options_camera, _options_camera1, _options_camera2;
            				var preprocess = options == null ? void 0 : (_options_camera = options.camera) == null ? void 0 : _options_camera.preprocess;
            				var _options_camera_process;
            				var process = (_options_camera_process = options == null ? void 0 : (_options_camera1 = options.camera) == null ? void 0 : _options_camera1.process) != null ? _options_camera_process : createCamera;
            				var postprocess = options == null ? void 0 : (_options_camera2 = options.camera) == null ? void 0 : _options_camera2.postprocess;
            				gltf.nodes.forEach((gltfNode, nodeIndex)=>{
            						if (gltfNode.hasOwnProperty('camera')) {
            								var gltfCamera = gltf.cameras[gltfNode.camera];
            								if (gltfCamera) {
            										if (preprocess) {
            												preprocess(gltfCamera);
            										}
            										var camera = process(gltfCamera, nodes[nodeIndex]);
            										if (postprocess) {
            												postprocess(gltfCamera, camera);
            										}
            										if (camera) {
            												if (!cameras) cameras = new Map();
            												cameras.set(gltfNode, camera);
            										}
            								}
            						}
            				});
            		}
            		return cameras;
            };
            var createLights = (gltf, nodes, options)=>{
            		var lights = null;
            		if (gltf.hasOwnProperty('nodes') && gltf.hasOwnProperty('extensions') && gltf.extensions.hasOwnProperty('KHR_lights_punctual') && gltf.extensions.KHR_lights_punctual.hasOwnProperty('lights')) {
            				var gltfLights = gltf.extensions.KHR_lights_punctual.lights;
            				if (gltfLights.length) {
            						var _options_light, _options_light1, _options_light2;
            						var preprocess = options == null ? void 0 : (_options_light = options.light) == null ? void 0 : _options_light.preprocess;
            						var _options_light_process;
            						var process = (_options_light_process = options == null ? void 0 : (_options_light1 = options.light) == null ? void 0 : _options_light1.process) != null ? _options_light_process : createLight;
            						var postprocess = options == null ? void 0 : (_options_light2 = options.light) == null ? void 0 : _options_light2.postprocess;
            						gltf.nodes.forEach((gltfNode, nodeIndex)=>{
            								if (gltfNode.hasOwnProperty('extensions') && gltfNode.extensions.hasOwnProperty('KHR_lights_punctual') && gltfNode.extensions.KHR_lights_punctual.hasOwnProperty('light')) {
            										var lightIndex = gltfNode.extensions.KHR_lights_punctual.light;
            										var gltfLight = gltfLights[lightIndex];
            										if (gltfLight) {
            												if (preprocess) {
            														preprocess(gltfLight);
            												}
            												var light = process(gltfLight, nodes[nodeIndex]);
            												if (postprocess) {
            														postprocess(gltfLight, light);
            												}
            												if (light) {
            														if (!lights) lights = new Map();
            														lights.set(gltfNode, light);
            												}
            										}
            								}
            						});
            				}
            		}
            		return lights;
            };
            var linkSkins = (gltf, renders, skins)=>{
            		gltf.nodes.forEach((gltfNode)=>{
            				if (gltfNode.hasOwnProperty('mesh') && gltfNode.hasOwnProperty('skin')) {
            						var meshGroup = renders[gltfNode.mesh].meshes;
            						meshGroup.forEach((mesh)=>{
            								mesh.skin = skins[gltfNode.skin];
            						});
            				}
            		});
            };
            var createResources = /*#__PURE__*/ _async_to_generator$2(function*(device, gltf, bufferViews, textures, options) {
            		var _options_global, _options_global1;
            		var preprocess = options == null ? void 0 : (_options_global = options.global) == null ? void 0 : _options_global.preprocess;
            		var postprocess = options == null ? void 0 : (_options_global1 = options.global) == null ? void 0 : _options_global1.postprocess;
            		if (preprocess) {
            				preprocess(gltf);
            		}
            		if (gltf.asset && gltf.asset.generator === 'PlayCanvas') ;
            		var nodeInstancingMap = new Map();
            		var nodes = createNodes(gltf, options, nodeInstancingMap);
            		var scenes = createScenes(gltf, nodes);
            		var lights = createLights(gltf, nodes, options);
            		var cameras = createCameras(gltf, nodes, options);
            		var variants = createVariants(gltf);
            		var bufferViewData = yield Promise.all(bufferViews);
            		var { meshes, meshVariants, meshDefaultMaterials, promises } = createMeshes(device, gltf, bufferViewData, options);
            		var animations = createAnimations(gltf, nodes, bufferViewData, options);
            		createInstancing(device, gltf, nodeInstancingMap, bufferViewData);
            		var textureAssets = yield Promise.all(textures);
            		var textureInstances = textureAssets.map((t)=>t.resource);
            		var materials = createMaterials(gltf, textureInstances, options);
            		var skins = createSkins(device, gltf, nodes, bufferViewData);
            		var renders = [];
            		for(var i = 0; i < meshes.length; i++){
            				renders[i] = new Render();
            				renders[i].meshes = meshes[i];
            		}
            		linkSkins(gltf, renders, skins);
            		var result = new GlbResources();
            		result.gltf = gltf;
            		result.nodes = nodes;
            		result.scenes = scenes;
            		result.animations = animations;
            		result.textures = textureAssets;
            		result.materials = materials;
            		result.variants = variants;
            		result.meshVariants = meshVariants;
            		result.meshDefaultMaterials = meshDefaultMaterials;
            		result.renders = renders;
            		result.skins = skins;
            		result.lights = lights;
            		result.cameras = cameras;
            		result.nodeInstancingMap = nodeInstancingMap;
            		if (postprocess) {
            				postprocess(gltf, result);
            		}
            		yield Promise.all(promises);
            		return result;
            });
            var applySampler = (texture, gltfSampler)=>{
            		var getFilter = (filter, defaultValue)=>{
            				switch(filter){
            						case 9728:
            								return FILTER_NEAREST;
            						case 9729:
            								return FILTER_LINEAR;
            						case 9984:
            								return FILTER_NEAREST_MIPMAP_NEAREST;
            						case 9985:
            								return FILTER_LINEAR_MIPMAP_NEAREST;
            						case 9986:
            								return FILTER_NEAREST_MIPMAP_LINEAR;
            						case 9987:
            								return FILTER_LINEAR_MIPMAP_LINEAR;
            						default:
            								return defaultValue;
            				}
            		};
            		var getWrap = (wrap, defaultValue)=>{
            				switch(wrap){
            						case 33071:
            								return ADDRESS_CLAMP_TO_EDGE;
            						case 33648:
            								return ADDRESS_MIRRORED_REPEAT;
            						case 10497:
            								return ADDRESS_REPEAT;
            						default:
            								return defaultValue;
            				}
            		};
            		if (texture) {
            				gltfSampler = gltfSampler != null ? gltfSampler : {};
            				texture.minFilter = getFilter(gltfSampler.minFilter, FILTER_LINEAR_MIPMAP_LINEAR);
            				texture.magFilter = getFilter(gltfSampler.magFilter, FILTER_LINEAR);
            				texture.addressU = getWrap(gltfSampler.wrapS, ADDRESS_REPEAT);
            				texture.addressV = getWrap(gltfSampler.wrapT, ADDRESS_REPEAT);
            		}
            };
            var gltfTextureUniqueId = 0;
            var getTextureSource = (gltfTexture)=>{
            		var _gltfTexture_extensions_KHR_texture_basisu, _gltfTexture_extensions, _gltfTexture_extensions_EXT_texture_webp, _gltfTexture_extensions1;
            		var _gltfTexture_extensions_KHR_texture_basisu_source, _ref;
            		return (_ref = (_gltfTexture_extensions_KHR_texture_basisu_source = (_gltfTexture_extensions = gltfTexture.extensions) == null ? void 0 : (_gltfTexture_extensions_KHR_texture_basisu = _gltfTexture_extensions.KHR_texture_basisu) == null ? void 0 : _gltfTexture_extensions_KHR_texture_basisu.source) != null ? _gltfTexture_extensions_KHR_texture_basisu_source : (_gltfTexture_extensions1 = gltfTexture.extensions) == null ? void 0 : (_gltfTexture_extensions_EXT_texture_webp = _gltfTexture_extensions1.EXT_texture_webp) == null ? void 0 : _gltfTexture_extensions_EXT_texture_webp.source) != null ? _ref : gltfTexture.source;
            };
            var createImages = (gltf, bufferViews, urlBase, registry, options)=>{
            		var _options_image, _options_image1, _options_image2;
            		if (!gltf.images || gltf.images.length === 0) {
            				return [];
            		}
            		var preprocess = options == null ? void 0 : (_options_image = options.image) == null ? void 0 : _options_image.preprocess;
            		var processAsync = options == null ? void 0 : (_options_image1 = options.image) == null ? void 0 : _options_image1.processAsync;
            		var postprocess = options == null ? void 0 : (_options_image2 = options.image) == null ? void 0 : _options_image2.postprocess;
            		var mimeTypeFileExtensions = {
            				'image/png': 'png',
            				'image/jpeg': 'jpg',
            				'image/basis': 'basis',
            				'image/ktx': 'ktx',
            				'image/ktx2': 'ktx2',
            				'image/vnd-ms.dds': 'dds'
            		};
            		var getGammaTextures = (gltf)=>{
            				var set = new Set();
            				if (gltf.hasOwnProperty('materials')) {
            						gltf.materials.forEach((gltfMaterial)=>{
            								if (gltfMaterial.hasOwnProperty('pbrMetallicRoughness')) {
            										var pbrData = gltfMaterial.pbrMetallicRoughness;
            										if (pbrData.hasOwnProperty('baseColorTexture')) {
            												var gltfTexture = gltf.textures[pbrData.baseColorTexture.index];
            												set.add(getTextureSource(gltfTexture));
            										}
            								}
            								if (gltfMaterial.hasOwnProperty('emissiveTexture')) {
            										var gltfTexture1 = gltf.textures[gltfMaterial.emissiveTexture.index];
            										set.add(getTextureSource(gltfTexture1));
            								}
            								if (gltfMaterial.hasOwnProperty('extensions')) {
            										var sheen = gltfMaterial.extensions.KHR_materials_sheen;
            										if (sheen) {
            												if (sheen.hasOwnProperty('sheenColorTexture')) {
            														var gltfTexture2 = gltf.textures[sheen.sheenColorTexture.index];
            														set.add(getTextureSource(gltfTexture2));
            												}
            										}
            										var specularGlossiness = gltfMaterial.extensions.KHR_materials_pbrSpecularGlossiness;
            										if (specularGlossiness) {
            												if (specularGlossiness.hasOwnProperty('specularGlossinessTexture')) {
            														var gltfTexture3 = gltf.textures[specularGlossiness.specularGlossinessTexture.index];
            														set.add(getTextureSource(gltfTexture3));
            												}
            										}
            										var specular = gltfMaterial.extensions.KHR_materials_specular;
            										if (specular) {
            												if (specular.hasOwnProperty('specularColorTexture')) {
            														var gltfTexture4 = gltf.textures[specular.specularColorTexture.index];
            														set.add(getTextureSource(gltfTexture4));
            												}
            										}
            								}
            						});
            				}
            				return set;
            		};
            		var loadTexture = (gltfImage, url, bufferView, mimeType, options, srgb)=>{
            				return new Promise((resolve, reject)=>{
            						var continuation = (bufferViewData)=>{
            								var name = (gltfImage.name || 'gltf-texture') + "-" + gltfTextureUniqueId++;
            								var file = {
            										url: url || name
            								};
            								if (bufferViewData) {
            										file.contents = bufferViewData.slice(0).buffer;
            								}
            								if (mimeType) {
            										var extension = mimeTypeFileExtensions[mimeType];
            										if (extension) {
            												file.filename = file.url + "." + extension;
            										}
            								}
            								var data = {
            										srgb
            								};
            								var asset = new Asset(name, 'texture', file, data, options);
            								asset.on('load', (asset)=>resolve(asset));
            								asset.on('error', (err)=>reject(err));
            								registry.add(asset);
            								registry.load(asset);
            						};
            						if (bufferView) {
            								bufferView.then((bufferViewData)=>continuation(bufferViewData));
            						} else {
            								continuation(null);
            						}
            				});
            		};
            		var gammaTextures = getGammaTextures(gltf);
            		return gltf.images.map((gltfImage, i)=>{
            				if (preprocess) {
            						preprocess(gltfImage);
            				}
            				var promise;
            				if (processAsync) {
            						promise = new Promise((resolve, reject)=>{
            								processAsync(gltfImage, (err, textureAsset)=>{
            										if (err) {
            												reject(err);
            										} else {
            												resolve(textureAsset);
            										}
            								});
            						});
            				} else {
            						promise = new Promise((resolve)=>{
            								resolve(null);
            						});
            				}
            				promise = promise.then((textureAsset)=>{
            						var srgb = gammaTextures.has(i);
            						if (textureAsset) {
            								return textureAsset;
            						} else if (gltfImage.hasOwnProperty('uri')) {
            								if (isDataURI(gltfImage.uri)) {
            										return loadTexture(gltfImage, gltfImage.uri, null, getDataURIMimeType(gltfImage.uri), null, srgb);
            								}
            								return loadTexture(gltfImage, ABSOLUTE_URL.test(gltfImage.uri) ? gltfImage.uri : path.join(urlBase, gltfImage.uri), null, null, {
            										crossOrigin: 'anonymous'
            								}, srgb);
            						} else if (gltfImage.hasOwnProperty('bufferView') && gltfImage.hasOwnProperty('mimeType')) {
            								return loadTexture(gltfImage, null, bufferViews[gltfImage.bufferView], gltfImage.mimeType, null, srgb);
            						}
            						return Promise.reject(new Error("Invalid image found in gltf (neither uri or bufferView found). index=" + i));
            				});
            				if (postprocess) {
            						promise = promise.then((textureAsset)=>{
            								postprocess(gltfImage, textureAsset);
            								return textureAsset;
            						});
            				}
            				return promise;
            		});
            };
            var createTextures = (gltf, images, options)=>{
            		var _gltf_images, _gltf_textures, _options_texture, _options_texture1, _options_texture2;
            		if (!(gltf == null ? void 0 : (_gltf_images = gltf.images) == null ? void 0 : _gltf_images.length) || !(gltf == null ? void 0 : (_gltf_textures = gltf.textures) == null ? void 0 : _gltf_textures.length)) {
            				return [];
            		}
            		var preprocess = options == null ? void 0 : (_options_texture = options.texture) == null ? void 0 : _options_texture.preprocess;
            		var processAsync = options == null ? void 0 : (_options_texture1 = options.texture) == null ? void 0 : _options_texture1.processAsync;
            		var postprocess = options == null ? void 0 : (_options_texture2 = options.texture) == null ? void 0 : _options_texture2.postprocess;
            		var seenImages = new Set();
            		return gltf.textures.map((gltfTexture)=>{
            				if (preprocess) {
            						preprocess(gltfTexture);
            				}
            				var promise;
            				if (processAsync) {
            						promise = new Promise((resolve, reject)=>{
            								processAsync(gltfTexture, gltf.images, (err, gltfImageIndex)=>{
            										if (err) {
            												reject(err);
            										} else {
            												resolve(gltfImageIndex);
            										}
            								});
            						});
            				} else {
            						promise = new Promise((resolve)=>{
            								resolve(null);
            						});
            				}
            				promise = promise.then((gltfImageIndex)=>{
            						gltfImageIndex = gltfImageIndex != null ? gltfImageIndex : getTextureSource(gltfTexture);
            						var cloneAsset = seenImages.has(gltfImageIndex);
            						seenImages.add(gltfImageIndex);
            						return images[gltfImageIndex].then((imageAsset)=>{
            								var asset = cloneAsset ? cloneTextureAsset(imageAsset) : imageAsset;
            								var _gltf_samplers;
            								applySampler(asset.resource, ((_gltf_samplers = gltf.samplers) != null ? _gltf_samplers : [])[gltfTexture.sampler]);
            								return asset;
            						});
            				});
            				if (postprocess) {
            						promise = promise.then((textureAsset)=>{
            								postprocess(gltfTexture, textureAsset);
            								return textureAsset;
            						});
            				}
            				return promise;
            		});
            };
            var loadBuffers = (gltf, binaryChunk, urlBase, options)=>{
            		var _options_buffer, _options_buffer1, _options_buffer2;
            		if (!gltf.buffers || gltf.buffers.length === 0) {
            				return [];
            		}
            		var preprocess = options == null ? void 0 : (_options_buffer = options.buffer) == null ? void 0 : _options_buffer.preprocess;
            		var processAsync = options == null ? void 0 : (_options_buffer1 = options.buffer) == null ? void 0 : _options_buffer1.processAsync;
            		var postprocess = options == null ? void 0 : (_options_buffer2 = options.buffer) == null ? void 0 : _options_buffer2.postprocess;
            		return gltf.buffers.map((gltfBuffer, i)=>{
            				if (preprocess) {
            						preprocess(gltfBuffer);
            				}
            				var promise;
            				if (processAsync) {
            						promise = new Promise((resolve, reject)=>{
            								processAsync(gltfBuffer, (err, arrayBuffer)=>{
            										if (err) {
            												reject(err);
            										} else {
            												resolve(arrayBuffer);
            										}
            								});
            						});
            				} else {
            						promise = new Promise((resolve)=>{
            								resolve(null);
            						});
            				}
            				promise = promise.then((arrayBuffer)=>{
            						if (arrayBuffer) {
            								return arrayBuffer;
            						} else if (gltfBuffer.hasOwnProperty('uri')) {
            								if (isDataURI(gltfBuffer.uri)) {
            										var byteString = atob(gltfBuffer.uri.split(',')[1]);
            										var binaryArray = new Uint8Array(byteString.length);
            										for(var j = 0; j < byteString.length; j++){
            												binaryArray[j] = byteString.charCodeAt(j);
            										}
            										return binaryArray;
            								}
            								return new Promise((resolve, reject)=>{
            										http.get(ABSOLUTE_URL.test(gltfBuffer.uri) ? gltfBuffer.uri : path.join(urlBase, gltfBuffer.uri), {
            												cache: true,
            												responseType: 'arraybuffer',
            												retry: false
            										}, (err, result)=>{
            												if (err) {
            														reject(err);
            												} else {
            														resolve(new Uint8Array(result));
            												}
            										});
            								});
            						}
            						return binaryChunk;
            				});
            				if (postprocess) {
            						promise = promise.then((buffer)=>{
            								postprocess(gltf.buffers[i], buffer);
            								return buffer;
            						});
            				}
            				return promise;
            		});
            };
            var parseGltf = (gltfChunk, callback)=>{
            		var decodeBinaryUtf8 = (array)=>{
            				if (typeof TextDecoder !== 'undefined') {
            						return new TextDecoder().decode(array);
            				}
            				var str = '';
            				for(var i = 0; i < array.length; i++){
            						str += String.fromCharCode(array[i]);
            				}
            				return decodeURIComponent(escape(str));
            		};
            		var gltf = JSON.parse(decodeBinaryUtf8(gltfChunk));
            		if (gltf.asset && gltf.asset.version && parseFloat(gltf.asset.version) < 2) {
            				callback("Invalid gltf version. Expected version 2.0 or above but found version '" + gltf.asset.version + "'.");
            				return;
            		}
            		callback(null, gltf);
            };
            var parseGlb = (glbData, callback)=>{
            		var data = glbData instanceof ArrayBuffer ? new DataView(glbData) : new DataView(glbData.buffer, glbData.byteOffset, glbData.byteLength);
            		var magic = data.getUint32(0, true);
            		var version = data.getUint32(4, true);
            		var length = data.getUint32(8, true);
            		if (magic !== 0x46546C67) {
            				callback("Invalid magic number found in glb header. Expected 0x46546C67, found 0x" + magic.toString(16));
            				return;
            		}
            		if (version !== 2) {
            				callback("Invalid version number found in glb header. Expected 2, found " + version);
            				return;
            		}
            		if (length <= 0 || length > data.byteLength) {
            				callback("Invalid length found in glb header. Found " + length);
            				return;
            		}
            		var chunks = [];
            		var offset = 12;
            		while(offset < length){
            				var chunkLength = data.getUint32(offset, true);
            				if (offset + chunkLength + 8 > data.byteLength) {
            						callback("Invalid chunk length found in glb. Found " + chunkLength);
            				}
            				var chunkType = data.getUint32(offset + 4, true);
            				var chunkData = new Uint8Array(data.buffer, data.byteOffset + offset + 8, chunkLength);
            				chunks.push({
            						length: chunkLength,
            						type: chunkType,
            						data: chunkData
            				});
            				offset += chunkLength + 8;
            		}
            		if (chunks.length !== 1 && chunks.length !== 2) {
            				callback('Invalid number of chunks found in glb file.');
            				return;
            		}
            		if (chunks[0].type !== 0x4E4F534A) {
            				callback("Invalid chunk type found in glb file. Expected 0x4E4F534A, found 0x" + chunks[0].type.toString(16));
            				return;
            		}
            		if (chunks.length > 1 && chunks[1].type !== 0x004E4942) {
            				callback("Invalid chunk type found in glb file. Expected 0x004E4942, found 0x" + chunks[1].type.toString(16));
            				return;
            		}
            		callback(null, {
            				gltfChunk: chunks[0].data,
            				binaryChunk: chunks.length === 2 ? chunks[1].data : null
            		});
            };
            var parseChunk = (filename, data, callback)=>{
            		var hasGlbHeader = ()=>{
            				var u8 = new Uint8Array(data);
            				return u8[0] === 103 && u8[1] === 108 && u8[2] === 84 && u8[3] === 70;
            		};
            		if (filename && filename.toLowerCase().endsWith('.glb') || hasGlbHeader()) {
            				parseGlb(data, callback);
            		} else {
            				callback(null, {
            						gltfChunk: data,
            						binaryChunk: null
            				});
            		}
            };
            var createBufferViews = (gltf, buffers, options)=>{
            		var _loop = function(i) {
            				var gltfBufferView = gltf.bufferViews[i];
            				if (preprocess) {
            						preprocess(gltfBufferView);
            				}
            				var promise = void 0;
            				if (processAsync) {
            						promise = new Promise((resolve, reject)=>{
            								processAsync(gltfBufferView, buffers, (err, result)=>{
            										if (err) {
            												reject(err);
            										} else {
            												resolve(result);
            										}
            								});
            						});
            				} else {
            						promise = new Promise((resolve)=>{
            								resolve(null);
            						});
            				}
            				promise = promise.then((buffer)=>{
            						if (buffer) {
            								return buffer;
            						}
            						return buffers[gltfBufferView.buffer].then((buffer)=>{
            								return new Uint8Array(buffer.buffer, buffer.byteOffset + (gltfBufferView.byteOffset || 0), gltfBufferView.byteLength);
            						});
            				});
            				if (gltfBufferView.hasOwnProperty('byteStride')) {
            						promise = promise.then((typedArray)=>{
            								typedArray.byteStride = gltfBufferView.byteStride;
            								return typedArray;
            						});
            				}
            				if (postprocess) {
            						promise = promise.then((typedArray)=>{
            								postprocess(gltfBufferView, typedArray);
            								return typedArray;
            						});
            				}
            				result.push(promise);
            		};
            		var _options_bufferView, _options_bufferView1, _options_bufferView2, _gltf_bufferViews;
            		var result = [];
            		var preprocess = options == null ? void 0 : (_options_bufferView = options.bufferView) == null ? void 0 : _options_bufferView.preprocess;
            		var processAsync = options == null ? void 0 : (_options_bufferView1 = options.bufferView) == null ? void 0 : _options_bufferView1.processAsync;
            		var postprocess = options == null ? void 0 : (_options_bufferView2 = options.bufferView) == null ? void 0 : _options_bufferView2.postprocess;
            		if (!((_gltf_bufferViews = gltf.bufferViews) == null ? void 0 : _gltf_bufferViews.length)) {
            				return result;
            		}
            		for(var i = 0; i < gltf.bufferViews.length; ++i)_loop(i);
            		return result;
            };
            class GlbParser {
            		static parse(filename, urlBase, data, device, registry, options, callback) {
            				parseChunk(filename, data, (err, chunks)=>{
            						if (err) {
            								callback(err);
            								return;
            						}
            						parseGltf(chunks.gltfChunk, (err, gltf)=>{
            								if (err) {
            										callback(err);
            										return;
            								}
            								var buffers = loadBuffers(gltf, chunks.binaryChunk, urlBase, options);
            								var bufferViews = createBufferViews(gltf, buffers, options);
            								var images = createImages(gltf, bufferViews, urlBase, registry, options);
            								var textures = createTextures(gltf, images, options);
            								createResources(device, gltf, bufferViews, textures, options).then((result)=>callback(null, result)).catch((err)=>callback(err));
            						});
            				});
            		}
            		static createDefaultMaterial() {
            				return createMaterial({
            						name: 'defaultGlbMaterial'
            				}, []);
            		}
            }
            
            class AnimationHandler extends ResourceHandler {
            		load(url, callback, asset) {
            				if (typeof url === 'string') {
            						url = {
            								load: url,
            								original: url
            						};
            				}
            				var options = {
            						retry: this.maxRetries > 0,
            						maxRetries: this.maxRetries
            				};
            				if (url.load.startsWith('blob:') || url.load.startsWith('data:')) {
            						if (path.getExtension(url.original).toLowerCase() === '.glb') {
            								options.responseType = Http.ResponseType.ARRAY_BUFFER;
            						} else {
            								options.responseType = Http.ResponseType.JSON;
            						}
            				}
            				http.get(url.load, options, (err, response)=>{
            						if (err) {
            								callback("Error loading animation resource: " + url.original + " [" + err + "]");
            						} else {
            								if (path.getExtension(url.original).toLowerCase() === '.glb') {
            										var _asset_options;
            										GlbParser.parse('filename.glb', '', response, this.device, this.assets, (_asset_options = asset == null ? void 0 : asset.options) != null ? _asset_options : {}, (err, parseResult)=>{
            												if (err) {
            														callback(err);
            												} else {
            														var _asset_data;
            														var animations = parseResult.animations;
            														if (asset == null ? void 0 : (_asset_data = asset.data) == null ? void 0 : _asset_data.events) {
            																for(var i = 0; i < animations.length; i++){
            																		animations[i].events = new AnimEvents(Object.values(asset.data.events));
            																}
            														}
            														parseResult.destroy();
            														callback(null, animations);
            												}
            										});
            								} else {
            										callback(null, this["_parseAnimationV" + response.animation.version](response));
            								}
            						}
            				});
            		}
            		open(url, data, asset) {
            				return data;
            		}
            		_parseAnimationV3(data) {
            				var animData = data.animation;
            				var anim = new Animation();
            				anim.name = animData.name;
            				anim.duration = animData.duration;
            				for(var i = 0; i < animData.nodes.length; i++){
            						var node = new Node();
            						var n = animData.nodes[i];
            						node._name = n.name;
            						for(var j = 0; j < n.keys.length; j++){
            								var k = n.keys[j];
            								var t = k.time;
            								var p = k.pos;
            								var r = k.rot;
            								var s = k.scale;
            								var pos = new Vec3(p[0], p[1], p[2]);
            								var rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);
            								var scl = new Vec3(s[0], s[1], s[2]);
            								var key = new Key(t, pos, rot, scl);
            								node._keys.push(key);
            						}
            						anim.addNode(node);
            				}
            				return anim;
            		}
            		_parseAnimationV4(data) {
            				var animData = data.animation;
            				var anim = new Animation();
            				anim.name = animData.name;
            				anim.duration = animData.duration;
            				for(var i = 0; i < animData.nodes.length; i++){
            						var node = new Node();
            						var n = animData.nodes[i];
            						node._name = n.name;
            						var defPos = n.defaults.p;
            						var defRot = n.defaults.r;
            						var defScl = n.defaults.s;
            						for(var j = 0; j < n.keys.length; j++){
            								var k = n.keys[j];
            								var t = k.t;
            								var p = defPos ? defPos : k.p;
            								var r = defRot ? defRot : k.r;
            								var s = defScl ? defScl : k.s;
            								var pos = new Vec3(p[0], p[1], p[2]);
            								var rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);
            								var scl = new Vec3(s[0], s[1], s[2]);
            								var key = new Key(t, pos, rot, scl);
            								node._keys.push(key);
            						}
            						anim.addNode(node);
            				}
            				return anim;
            		}
            		constructor(app){
            				super(app, 'animation');
            				this.device = app.graphicsDevice;
            				this.assets = app.assets;
            		}
            }
            
            class AnimClipHandler extends ResourceHandler {
            		load(url, callback) {
            				if (typeof url === 'string') {
            						url = {
            								load: url,
            								original: url
            						};
            				}
            				var options = {
            						retry: this.maxRetries > 0,
            						maxRetries: this.maxRetries
            				};
            				if (url.load.startsWith('blob:')) {
            						options.responseType = Http.ResponseType.JSON;
            				}
            				http.get(url.load, options, (err, response)=>{
            						if (err) {
            								callback("Error loading animation clip resource: " + url.original + " [" + err + "]");
            						} else {
            								callback(null, response);
            						}
            				});
            		}
            		open(url, data) {
            				var name = data.name;
            				var duration = data.duration;
            				var inputs = data.inputs.map((input)=>{
            						return new AnimData(1, input);
            				});
            				var outputs = data.outputs.map((output)=>{
            						return new AnimData(output.components, output.data);
            				});
            				var curves = data.curves.map((curve)=>{
            						return new AnimCurve([
            								curve.path
            						], curve.inputIndex, curve.outputIndex, curve.interpolation);
            				});
            				return new AnimTrack(name, duration, inputs, outputs, curves);
            		}
            		constructor(app){
            				super(app, 'animclip');
            		}
            }
            
            class AnimStateGraphHandler extends ResourceHandler {
            		load(url, callback) {
            				if (typeof url === 'string') {
            						url = {
            								load: url,
            								original: url
            						};
            				}
            				var options = {
            						retry: this.maxRetries > 0,
            						maxRetries: this.maxRetries
            				};
            				if (url.load.startsWith('blob:')) {
            						options.responseType = Http.ResponseType.JSON;
            				}
            				http.get(url.load, options, (err, response)=>{
            						if (err) {
            								callback("Error loading animation state graph resource: " + url.original + " [" + err + "]");
            						} else {
            								callback(null, response);
            						}
            				});
            		}
            		open(url, data) {
            				return new AnimStateGraph(data);
            		}
            		constructor(app){
            				super(app, 'animstategraph');
            		}
            }
            
            var ie = function() {
            		if (typeof window === 'undefined') {
            				return false;
            		}
            		var ua = window.navigator.userAgent;
            		var msie = ua.indexOf('MSIE ');
            		if (msie > 0) {
            				return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
            		}
            		var trident = ua.indexOf('Trident/');
            		if (trident > 0) {
            				var rv = ua.indexOf('rv:');
            				return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
            		}
            		return false;
            }();
            var supportedExtensions = [
            		'.ogg',
            		'.mp3',
            		'.wav',
            		'.mp4a',
            		'.m4a',
            		'.mp4',
            		'.aac',
            		'.opus'
            ];
            class AudioHandler extends ResourceHandler {
            		_isSupported(url) {
            				var ext = path.getExtension(url);
            				return supportedExtensions.indexOf(ext) > -1;
            		}
            		load(url, callback) {
            				if (typeof url === 'string') {
            						url = {
            								load: url,
            								original: url
            						};
            				}
            				var success = function success(resource) {
            						callback(null, new Sound(resource));
            				};
            				var error = function error(err) {
            						var msg = "Error loading audio url: " + url.original;
            						if (err) {
            								msg += ": " + (err.message || err);
            						}
            						console.warn(msg);
            						callback(msg);
            				};
            				if (this._createSound) {
            						if (!this._isSupported(url.original)) {
            								error("Audio format for " + url.original + " not supported");
            								return;
            						}
            						this._createSound(url.load, success, error);
            				} else {
            						error(null);
            				}
            		}
            		_createSound(url, success, error) {
            				if (hasAudioContext()) {
            						var manager = this.manager;
            						if (!manager.context) {
            								error('Audio manager has no audio context');
            								return;
            						}
            						var options = {
            								retry: this.maxRetries > 0,
            								maxRetries: this.maxRetries
            						};
            						if (url.startsWith('blob:') || url.startsWith('data:')) {
            								options.responseType = Http.ResponseType.ARRAY_BUFFER;
            						}
            						http.get(url, options, (err, response)=>{
            								if (err) {
            										error(err);
            										return;
            								}
            								manager.context.decodeAudioData(response, success, error);
            						});
            				} else {
            						var audio = null;
            						try {
            								audio = new Audio();
            						} catch (e) {
            								error('No support for Audio element');
            								return;
            						}
            						if (ie) {
            								document.body.appendChild(audio);
            						}
            						var onReady = function onReady1() {
            								audio.removeEventListener('canplaythrough', onReady);
            								if (ie) {
            										document.body.removeChild(audio);
            								}
            								success(audio);
            						};
            						audio.onerror = function() {
            								audio.onerror = null;
            								if (ie) {
            										document.body.removeChild(audio);
            								}
            								error();
            						};
            						audio.addEventListener('canplaythrough', onReady);
            						audio.src = url;
            				}
            		}
            		constructor(app){
            				super(app, 'audio');
            				this.manager = app.soundManager;
            		}
            }
            
            class BinaryHandler extends ResourceHandler {
            		load(url, callback) {
            				if (typeof url === 'string') {
            						url = {
            								load: url,
            								original: url
            						};
            				}
            				http.get(url.load, {
            						responseType: Http.ResponseType.ARRAY_BUFFER,
            						retry: this.maxRetries > 0,
            						maxRetries: this.maxRetries
            				}, (err, response)=>{
            						if (!err) {
            								callback(null, response);
            						} else {
            								callback("Error loading binary resource: " + url.original + " [" + err + "]");
            						}
            				});
            		}
            		openBinary(data) {
            				return data.buffer;
            		}
            		constructor(app){
            				super(app, 'binary');
            		}
            }
            
            class GlbContainerResource {
            		get model() {
            				if (!this._model) {
            						var model = GlbContainerResource.createModel(this.data, this._defaultMaterial);
            						var modelAsset = GlbContainerResource.createAsset(this._assetName, 'model', model, 0);
            						this._assets.add(modelAsset);
            						this._model = modelAsset;
            				}
            				return this._model;
            		}
            		static createAsset(assetName, type, resource, index) {
            				var subAsset = new Asset(assetName + "/" + type + "/" + index, type, {
            						url: ''
            				});
            				subAsset.resource = resource;
            				subAsset.loaded = true;
            				return subAsset;
            		}
            		instantiateModelEntity(options) {
            				var entity = new Entity(undefined, this._assets._loader._app);
            				entity.addComponent('model', Object.assign({
            						type: 'asset',
            						asset: this.model
            				}, options));
            				return entity;
            		}
            		instantiateRenderEntity(options) {
            				var defaultMaterial = this._defaultMaterial;
            				var skinnedMeshInstances = [];
            				var createMeshInstance = function createMeshInstance(root, entity, mesh, materials, meshDefaultMaterials, skins, gltfNode, nodeInstancingMap) {
            						var materialIndex = meshDefaultMaterials[mesh.id];
            						var material = materialIndex === undefined ? defaultMaterial : materials[materialIndex];
            						var meshInstance = new MeshInstance(mesh, material);
            						if (mesh.morph) {
            								meshInstance.morphInstance = new MorphInstance(mesh.morph);
            						}
            						if (gltfNode.hasOwnProperty('skin')) {
            								skinnedMeshInstances.push({
            										meshInstance: meshInstance,
            										rootBone: root,
            										entity: entity
            								});
            						}
            						var instData = nodeInstancingMap.get(gltfNode);
            						if (instData) {
            								var matrices = instData.matrices;
            								var vbFormat = VertexFormat.getDefaultInstancingFormat(mesh.device);
            								var vb = new VertexBuffer(mesh.device, vbFormat, matrices.length / 16, {
            										data: matrices
            								});
            								meshInstance.setInstancing(vb);
            								meshInstance.instancingData._destroyVertexBuffer = true;
            						}
            						return meshInstance;
            				};
            				var cloneHierarchy = (root, node, glb)=>{
            						var entity = new Entity(undefined, this._assets._loader._app);
            						node._cloneInternal(entity);
            						if (!root) root = entity;
            						var attachedMi = null;
            						var renderAsset = null;
            						for(var i = 0; i < glb.nodes.length; i++){
            								var glbNode = glb.nodes[i];
            								if (glbNode === node) {
            										var gltfNode = glb.gltf.nodes[i];
            										if (gltfNode.hasOwnProperty('mesh')) {
            												var meshGroup = glb.renders[gltfNode.mesh].meshes;
            												renderAsset = this.renders[gltfNode.mesh];
            												for(var mi = 0; mi < meshGroup.length; mi++){
            														var mesh = meshGroup[mi];
            														if (mesh) {
            																var cloneMi = createMeshInstance(root, entity, mesh, glb.materials, glb.meshDefaultMaterials, glb.skins, gltfNode, glb.nodeInstancingMap);
            																if (!attachedMi) {
            																		attachedMi = [];
            																}
            																attachedMi.push(cloneMi);
            														}
            												}
            										}
            										if (glb.lights) {
            												var lightEntity = glb.lights.get(gltfNode);
            												if (lightEntity) {
            														entity.addChild(lightEntity.clone());
            												}
            										}
            										if (glb.cameras) {
            												var cameraEntity = glb.cameras.get(gltfNode);
            												if (cameraEntity) {
            														cameraEntity.camera.system.cloneComponent(cameraEntity, entity);
            												}
            										}
            								}
            						}
            						if (attachedMi) {
            								entity.addComponent('render', Object.assign({
            										type: 'asset',
            										meshInstances: attachedMi
            								}, options));
            								entity.render.assignAsset(renderAsset);
            						}
            						var children = node.children;
            						for(var i1 = 0; i1 < children.length; i1++){
            								var childClone = cloneHierarchy(root, children[i1], glb);
            								entity.addChild(childClone);
            						}
            						return entity;
            				};
            				var sceneClones = [];
            				for (var scene of this.data.scenes){
            						sceneClones.push(cloneHierarchy(null, scene, this.data));
            				}
            				skinnedMeshInstances.forEach((data)=>{
            						data.meshInstance.skinInstance = SkinInstanceCache.createCachedSkinInstance(data.meshInstance.mesh.skin, data.rootBone, data.entity);
            						data.meshInstance.node.render.rootBone = data.rootBone;
            				});
            				return GlbContainerResource.createSceneHierarchy(sceneClones, Entity);
            		}
            		getMaterialVariants() {
            				return this.data.variants ? Object.keys(this.data.variants) : [];
            		}
            		applyMaterialVariant(entity, name) {
            				var variant = name ? this.data.variants[name] : null;
            				if (variant === undefined) {
            						return;
            				}
            				var renders = entity.findComponents('render');
            				for(var i = 0; i < renders.length; i++){
            						var renderComponent = renders[i];
            						this._applyMaterialVariant(variant, renderComponent.meshInstances);
            				}
            		}
            		applyMaterialVariantInstances(instances, name) {
            				var variant = name ? this.data.variants[name] : null;
            				if (variant === undefined) {
            						return;
            				}
            				this._applyMaterialVariant(variant, instances);
            		}
            		_applyMaterialVariant(variant, instances) {
            				instances.forEach((instance)=>{
            						if (variant === null) {
            								instance.material = this._defaultMaterial;
            						} else {
            								var meshVariants = this.data.meshVariants[instance.mesh.id];
            								if (meshVariants) {
            										instance.material = this.data.materials[meshVariants[variant]];
            								}
            						}
            				});
            		}
            		static createSceneHierarchy(sceneNodes, nodeType) {
            				var root = null;
            				if (sceneNodes.length === 1) {
            						root = sceneNodes[0];
            				} else {
            						root = new nodeType('SceneGroup');
            						for (var scene of sceneNodes){
            								root.addChild(scene);
            						}
            				}
            				return root;
            		}
            		static createModel(glb, defaultMaterial) {
            				var createMeshInstance = function createMeshInstance(model, mesh, skins, skinInstances, materials, node, gltfNode) {
            						var materialIndex = glb.meshDefaultMaterials[mesh.id];
            						var material = materialIndex === undefined ? defaultMaterial : materials[materialIndex];
            						var meshInstance = new MeshInstance(mesh, material, node);
            						if (mesh.morph) {
            								var morphInstance = new MorphInstance(mesh.morph);
            								meshInstance.morphInstance = morphInstance;
            								model.morphInstances.push(morphInstance);
            						}
            						if (gltfNode.hasOwnProperty('skin')) {
            								var skinIndex = gltfNode.skin;
            								var skin = skins[skinIndex];
            								mesh.skin = skin;
            								var skinInstance = skinInstances[skinIndex];
            								meshInstance.skinInstance = skinInstance;
            								model.skinInstances.push(skinInstance);
            						}
            						model.meshInstances.push(meshInstance);
            				};
            				var model = new Model();
            				var skinInstances = [];
            				for (var skin of glb.skins){
            						var skinInstance = new SkinInstance(skin);
            						skinInstance.bones = skin.bones;
            						skinInstances.push(skinInstance);
            				}
            				model.graph = GlbContainerResource.createSceneHierarchy(glb.scenes, GraphNode);
            				for(var i = 0; i < glb.nodes.length; i++){
            						var node = glb.nodes[i];
            						if (node.root === model.graph) {
            								var gltfNode = glb.gltf.nodes[i];
            								if (gltfNode.hasOwnProperty('mesh')) {
            										var meshGroup = glb.renders[gltfNode.mesh].meshes;
            										for(var mi = 0; mi < meshGroup.length; mi++){
            												var mesh = meshGroup[mi];
            												if (mesh) {
            														createMeshInstance(model, mesh, glb.skins, skinInstances, glb.materials, node, gltfNode);
            												}
            										}
            								}
            						}
            				}
            				return model;
            		}
            		destroy() {
            				var registry = this._assets;
            				var destroyAsset = function destroyAsset(asset) {
            						registry.remove(asset);
            						asset.unload();
            				};
            				var destroyAssets = function destroyAssets(assets) {
            						assets.forEach((asset)=>{
            								destroyAsset(asset);
            						});
            				};
            				if (this.animations) {
            						destroyAssets(this.animations);
            						this.animations = null;
            				}
            				if (this.textures) {
            						destroyAssets(this.textures);
            						this.textures = null;
            				}
            				if (this.materials) {
            						destroyAssets(this.materials);
            						this.materials = null;
            				}
            				if (this.renders) {
            						destroyAssets(this.renders);
            						this.renders = null;
            				}
            				if (this._model) {
            						destroyAsset(this._model);
            						this._model = null;
            				}
            				this.data = null;
            				this.assets = null;
            		}
            		constructor(data, asset, assets, defaultMaterial){
            				var createAsset = function createAsset(type, resource, index) {
            						var subAsset = GlbContainerResource.createAsset(asset.name, type, resource, index);
            						assets.add(subAsset);
            						return subAsset;
            				};
            				var renders = [];
            				for(var i = 0; i < data.renders.length; ++i){
            						renders.push(createAsset('render', data.renders[i], i));
            				}
            				var materials = [];
            				for(var i1 = 0; i1 < data.materials.length; ++i1){
            						materials.push(createAsset('material', data.materials[i1], i1));
            				}
            				var animations = [];
            				for(var i2 = 0; i2 < data.animations.length; ++i2){
            						animations.push(createAsset('animation', data.animations[i2], i2));
            				}
            				this.data = data;
            				this._model = null;
            				this._assetName = asset.name;
            				this._assets = assets;
            				this._defaultMaterial = defaultMaterial;
            				this.renders = renders;
            				this.materials = materials;
            				this.textures = data.textures;
            				this.animations = animations;
            		}
            }
            
            class GlbContainerParser {
            		_getUrlWithoutParams(url) {
            				return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
            		}
            		load(url, callback, asset) {
            				Asset.fetchArrayBuffer(url.load, (err, result)=>{
            						if (err) {
            								callback(err);
            						} else {
            								GlbParser.parse(this._getUrlWithoutParams(url.original), path.extractPath(url.load), result, this._device, asset.registry, asset.options, (err, result)=>{
            										if (err) {
            												callback(err);
            										} else {
            												callback(null, new GlbContainerResource(result, asset, this._assets, this._defaultMaterial));
            										}
            								});
            						}
            				}, asset, this.maxRetries);
            		}
            		open(url, data, asset) {
            				return data;
            		}
            		patch(asset, assets) {}
            		constructor(device, assets, maxRetries){
            				this._device = device;
            				this._assets = assets;
            				this._defaultMaterial = GlbParser.createDefaultMaterial();
            				this.maxRetries = maxRetries;
            		}
            }
            
            class ContainerHandler extends ResourceHandler {
            		set maxRetries(value) {
            				this.glbContainerParser.maxRetries = value;
            				for(var parser in this.parsers){
            						if (this.parsers.hasOwnProperty(parser)) {
            								this.parsers[parser].maxRetries = value;
            						}
            				}
            		}
            		get maxRetries() {
            				return this.glbContainerParser.maxRetries;
            		}
            		_getUrlWithoutParams(url) {
            				return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
            		}
            		_getParser(url) {
            				var ext = url ? path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace('.', '') : null;
            				return this.parsers[ext] || this.glbContainerParser;
            		}
            		load(url, callback, asset) {
            				if (typeof url === 'string') {
            						url = {
            								load: url,
            								original: url
            						};
            				}
            				this._getParser(url.original).load(url, callback, asset);
            		}
            		open(url, data, asset) {
            				return this._getParser(url).open(url, data, asset);
            		}
            		constructor(app){
            				super(app, 'container');
            				this.glbContainerParser = new GlbContainerParser(app.graphicsDevice, app.assets, 0);
            				this.parsers = {};
            		}
            }
            
            class CssHandler extends ResourceHandler {
            		load(url, callback) {
            				if (typeof url === 'string') {
            						url = {
            								load: url,
            								original: url
            						};
            				}
            				http.get(url.load, {
            						retry: this.maxRetries > 0,
            						maxRetries: this.maxRetries
            				}, (err, response)=>{
            						if (!err) {
            								callback(null, response);
            						} else {
            								callback("Error loading css resource: " + url.original + " [" + err + "]");
            						}
            				});
            		}
            		openBinary(data) {
            				var _this_decoder;
            				(_this_decoder = this.decoder) != null ? _this_decoder : this.decoder = new TextDecoder('utf-8');
            				return this.decoder.decode(data);
            		}
            		constructor(app){
            				super(app, 'css'), this.decoder = null;
            		}
            }
            
            class CubemapHandler extends ResourceHandler {
            		load(url, callback, asset) {
            				this.loadAssets(asset, callback);
            		}
            		open(url, data, asset) {
            				return asset ? asset.resource : null;
            		}
            		patch(asset, registry) {
            				this.loadAssets(asset, (err, result)=>{
            						if (err) {
            								registry.fire('error', asset);
            								registry.fire("error:" + asset.id, err, asset);
            								asset.fire('error', asset);
            						}
            				});
            		}
            		getAssetIds(cubemapAsset) {
            				var result = [];
            				result[0] = cubemapAsset.file;
            				if ((cubemapAsset.loadFaces || !cubemapAsset.file) && cubemapAsset.data && cubemapAsset.data.textures) {
            						for(var i = 0; i < 6; ++i){
            								result[i + 1] = cubemapAsset.data.textures[i];
            						}
            				} else {
            						result[1] = result[2] = result[3] = result[4] = result[5] = result[6] = null;
            				}
            				return result;
            		}
            		compareAssetIds(assetIdA, assetIdB) {
            				if (assetIdA && assetIdB) {
            						if (parseInt(assetIdA, 10) === assetIdA || typeof assetIdA === 'string') {
            								return assetIdA === assetIdB;
            						}
            						return assetIdA.url === assetIdB.url;
            				}
            				return assetIdA !== null === (assetIdB !== null);
            		}
            		update(cubemapAsset, assetIds, assets) {
            				var assetData = cubemapAsset.data || {};
            				var oldAssets = cubemapAsset._handlerState.assets;
            				var oldResources = cubemapAsset._resources;
            				var tex, mip, i;
            				var resources = [
            						null,
            						null,
            						null,
            						null,
            						null,
            						null,
            						null
            				];
            				var getType = function getType() {
            						if (assetData.hasOwnProperty('type')) {
            								return assetData.type;
            						}
            						if (assetData.hasOwnProperty('rgbm')) {
            								return assetData.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
            						}
            						return null;
            				};
            				if (!cubemapAsset.loaded || assets[0] !== oldAssets[0]) {
            						if (assets[0]) {
            								tex = assets[0].resource;
            								if (tex.cubemap) {
            										for(i = 0; i < 6; ++i){
            												resources[i + 1] = new Texture(this._device, {
            														name: cubemapAsset.name + "_prelitCubemap" + (tex.width >> i),
            														cubemap: true,
            														type: getType() || tex.type,
            														width: tex.width >> i,
            														height: tex.height >> i,
            														format: tex.format,
            														levels: [
            																tex._levels[i]
            														],
            														addressU: ADDRESS_CLAMP_TO_EDGE,
            														addressV: ADDRESS_CLAMP_TO_EDGE,
            														mipmaps: i === 0
            												});
            										}
            								} else {
            										resources[1] = tex;
            								}
            						}
            				} else {
            						resources[1] = oldResources[1] || null;
            						resources[2] = oldResources[2] || null;
            						resources[3] = oldResources[3] || null;
            						resources[4] = oldResources[4] || null;
            						resources[5] = oldResources[5] || null;
            						resources[6] = oldResources[6] || null;
            				}
            				var faceAssets = assets.slice(1);
            				if (!cubemapAsset.loaded || !this.cmpArrays(faceAssets, oldAssets.slice(1))) {
            						if (faceAssets.indexOf(null) === -1) {
            								var faceTextures = faceAssets.map((asset)=>{
            										return asset.resource;
            								});
            								var faceLevels = [];
            								for(mip = 0; mip < faceTextures[0]._levels.length; ++mip){
            										faceLevels.push(faceTextures.map((faceTexture)=>{
            												return faceTexture._levels[mip];
            										}));
            								}
            								var format = faceTextures[0].format;
            								var _assetData_mipmaps;
            								var faces = new Texture(this._device, {
            										name: "" + cubemapAsset.name + "_faces",
            										cubemap: true,
            										type: getType() || faceTextures[0].type,
            										width: faceTextures[0].width,
            										height: faceTextures[0].height,
            										format: format === PIXELFORMAT_RGB8 ? PIXELFORMAT_RGBA8 : format,
            										mipmaps: (_assetData_mipmaps = assetData.mipmaps) != null ? _assetData_mipmaps : true,
            										levels: faceLevels,
            										minFilter: assetData.hasOwnProperty('minFilter') ? assetData.minFilter : faceTextures[0].minFilter,
            										magFilter: assetData.hasOwnProperty('magFilter') ? assetData.magFilter : faceTextures[0].magFilter,
            										anisotropy: assetData.hasOwnProperty('anisotropy') ? assetData.anisotropy : 1,
            										addressU: ADDRESS_CLAMP_TO_EDGE,
            										addressV: ADDRESS_CLAMP_TO_EDGE
            								});
            								resources[0] = faces;
            						}
            				} else {
            						resources[0] = oldResources[0] || null;
            				}
            				if (!this.cmpArrays(resources, oldResources)) {
            						cubemapAsset.resources = resources;
            						cubemapAsset._handlerState.assetIds = assetIds;
            						cubemapAsset._handlerState.assets = assets;
            						for(i = 0; i < oldResources.length; ++i){
            								if (oldResources[i] !== null && resources.indexOf(oldResources[i]) === -1) {
            										oldResources[i].destroy();
            								}
            						}
            				}
            				for(i = 0; i < oldAssets.length; ++i){
            						if (oldAssets[i] !== null && assets.indexOf(oldAssets[i]) === -1) {
            								oldAssets[i].unload();
            						}
            				}
            		}
            		cmpArrays(arr1, arr2) {
            				if (arr1.length !== arr2.length) {
            						return false;
            				}
            				for(var i = 0; i < arr1.length; ++i){
            						if (arr1[i] !== arr2[i]) {
            								return false;
            						}
            				}
            				return true;
            		}
            		resolveId(value) {
            				var valueInt = parseInt(value, 10);
            				return valueInt === value || valueInt.toString() === value ? valueInt : value;
            		}
            		loadAssets(cubemapAsset, callback) {
            				if (!cubemapAsset.hasOwnProperty('_handlerState')) {
            						cubemapAsset._handlerState = {
            								assetIds: [
            										null,
            										null,
            										null,
            										null,
            										null,
            										null,
            										null
            								],
            								assets: [
            										null,
            										null,
            										null,
            										null,
            										null,
            										null,
            										null
            								]
            						};
            				}
            				var self = this;
            				var assetIds = self.getAssetIds(cubemapAsset);
            				var assets = [
            						null,
            						null,
            						null,
            						null,
            						null,
            						null,
            						null
            				];
            				var loadedAssetIds = cubemapAsset._handlerState.assetIds;
            				var loadedAssets = cubemapAsset._handlerState.assets;
            				var registry = self._registry;
            				var awaiting = 7;
            				var onLoad = function onLoad(index, asset) {
            						assets[index] = asset;
            						awaiting--;
            						if (awaiting === 0) {
            								self.update(cubemapAsset, assetIds, assets);
            								callback(null, cubemapAsset.resources);
            						}
            				};
            				var onError = function onError(index, err, asset) {
            						callback(err);
            				};
            				var processTexAsset = function processTexAsset(index, texAsset) {
            						if (texAsset.loaded) {
            								onLoad(index, texAsset);
            						} else {
            								registry.once("load:" + texAsset.id, onLoad.bind(self, index));
            								registry.once("error:" + texAsset.id, onError.bind(self, index));
            								if (!texAsset.loading) {
            										registry.load(texAsset);
            								}
            						}
            				};
            				var texAsset;
            				for(var i = 0; i < 7; ++i){
            						var assetId = this.resolveId(assetIds[i]);
            						if (!assetId) {
            								onLoad(i, null);
            						} else if (self.compareAssetIds(assetId, loadedAssetIds[i])) {
            								processTexAsset(i, loadedAssets[i]);
            						} else if (parseInt(assetId, 10) === assetId) {
            								texAsset = registry.get(assetId);
            								if (texAsset) {
            										processTexAsset(i, texAsset);
            								} else {
            										setTimeout(((index, assetId_)=>{
            												var texAsset = registry.get(assetId_);
            												if (texAsset) {
            														processTexAsset(index, texAsset);
            												} else {
            														onError(index, "failed to find dependent cubemap asset=" + assetId_);
            												}
            										}).bind(null, i, assetId));
            								}
            						} else {
            								var file = typeof assetId === 'string' ? {
            										url: assetId,
            										filename: assetId
            								} : assetId;
            								var data = file.url.search('.dds') === -1 ? {
            										type: 'rgbp',
            										addressu: 'clamp',
            										addressv: 'clamp',
            										mipmaps: false
            								} : null;
            								texAsset = new Asset(cubemapAsset.name + "_part_" + i, 'texture', file, data);
            								registry.add(texAsset);
            								processTexAsset(i, texAsset);
            						}
            				}
            		}
            		constructor(app){
            				super(app, 'cubemap');
            				this._device = app.graphicsDevice;
            				this._registry = app.assets;
            				this._loader = app.loader;
            		}
            }
            
            class FolderHandler extends ResourceHandler {
            		load(url, callback) {
            				callback(null, null);
            		}
            		constructor(app){
            				super(app, 'folder');
            		}
            }
            
            class Font {
            		set data(value) {
            				this._data = value;
            				if (!value) {
            						return;
            				}
            				if (this._data.intensity !== undefined) {
            						this.intensity = this._data.intensity;
            				}
            				if (!this._data.info) {
            						this._data.info = {};
            				}
            				if (!this._data.version || this._data.version < 2) {
            						this._data.info.maps = [
            								{
            										width: this._data.info.width,
            										height: this._data.info.height
            								}
            						];
            						if (this._data.chars) {
            								for(var key in this._data.chars){
            										this._data.chars[key].map = 0;
            								}
            						}
            				}
            		}
            		get data() {
            				return this._data;
            		}
            		constructor(textures, data){
            				this.type = data ? data.type || FONT_MSDF : FONT_MSDF;
            				this.em = 1;
            				this.textures = textures;
            				this.intensity = 0.0;
            				this._data = null;
            				this.data = data;
            		}
            }
            
            function upgradeDataSchema(data) {
            		if (data.version < 3) {
            				if (data.version < 2) {
            						data.info.maps = data.info.maps || [
            								{
            										width: data.info.width,
            										height: data.info.height
            								}
            						];
            				}
            				data.chars = Object.keys(data.chars || {}).reduce((newChars, key)=>{
            						var existing = data.chars[key];
            						var newKey = existing.letter !== undefined ? existing.letter : string.fromCodePoint(key);
            						if (data.version < 2) {
            								existing.map = existing.map || 0;
            						}
            						newChars[newKey] = existing;
            						return newChars;
            				}, {});
            				data.version = 3;
            		}
            		return data;
            }
            class FontHandler extends ResourceHandler {
            		load(url, callback, asset) {
            				if (typeof url === 'string') {
            						url = {
            								load: url,
            								original: url
            						};
            				}
            				var self = this;
            				if (path.getExtension(url.original) === '.json') {
            						http.get(url.load, {
            								retry: this.maxRetries > 0,
            								maxRetries: this.maxRetries
            						}, (err, response)=>{
            								if (!err) {
            										var data = upgradeDataSchema(response);
            										self._loadTextures(url.load.replace('.json', '.png'), data, (err, textures)=>{
            												if (err) {
            														callback(err);
            												} else {
            														callback(null, {
            																data: data,
            																textures: textures
            														});
            												}
            										});
            								} else {
            										callback("Error loading font resource: " + url.original + " [" + err + "]");
            								}
            						});
            				} else {
            						if (asset && asset.data) {
            								asset.data = upgradeDataSchema(asset.data);
            						}
            						this._loadTextures(url.load, asset && asset.data, callback);
            				}
            		}
            		_loadTextures(url, data, callback) {
            				var numTextures = data.info.maps.length;
            				var numLoaded = 0;
            				var error = null;
            				var textures = new Array(numTextures);
            				var loader = this._loader;
            				var loadTexture = function loadTexture(index) {
            						var onLoaded = function onLoaded(err, texture) {
            								if (error) return;
            								if (err) {
            										error = err;
            										callback(err);
            										return;
            								}
            								texture.upload();
            								textures[index] = texture;
            								numLoaded++;
            								if (numLoaded === numTextures) {
            										callback(null, textures);
            								}
            						};
            						if (index === 0) {
            								loader.load(url, 'texture', onLoaded);
            						} else {
            								loader.load(url.replace('.png', "" + index + ".png"), 'texture', onLoaded);
            						}
            				};
            				for(var i = 0; i < numTextures; i++){
            						loadTexture(i);
            				}
            		}
            		open(url, data, asset) {
            				var font;
            				if (data.textures) {
            						font = new Font(data.textures, data.data);
            				} else {
            						font = new Font(data, null);
            				}
            				return font;
            		}
            		patch(asset, assets) {
            				var font = asset.resource;
            				if (!font.data && asset.data) {
            						font.data = asset.data;
            				} else if (!asset.data && font.data) {
            						asset.data = font.data;
            				}
            				if (asset.data) {
            						asset.data = upgradeDataSchema(asset.data);
            				}
            		}
            		constructor(app){
            				super(app, 'font');
            				this._loader = app.loader;
            				this.maxRetries = 0;
            		}
            }
            
            var SH_C0$1 = 0.28209479177387814;
            class SplatCompressedIterator {
            		constructor(gsplatData, p, r, s, c, sh){
            				var unpackUnorm = (value, bits)=>{
            						var t = (1 << bits) - 1;
            						return (value & t) / t;
            				};
            				var unpack111011 = (result, value)=>{
            						result.x = unpackUnorm(value >>> 21, 11);
            						result.y = unpackUnorm(value >>> 11, 10);
            						result.z = unpackUnorm(value, 11);
            				};
            				var unpack8888 = (result, value)=>{
            						result.x = unpackUnorm(value >>> 24, 8);
            						result.y = unpackUnorm(value >>> 16, 8);
            						result.z = unpackUnorm(value >>> 8, 8);
            						result.w = unpackUnorm(value, 8);
            				};
            				var unpackRot = (result, value)=>{
            						var norm = 1.0 / (Math.sqrt(2) * 0.5);
            						var a = (unpackUnorm(value >>> 20, 10) - 0.5) * norm;
            						var b = (unpackUnorm(value >>> 10, 10) - 0.5) * norm;
            						var c = (unpackUnorm(value, 10) - 0.5) * norm;
            						var m = Math.sqrt(1.0 - (a * a + b * b + c * c));
            						switch(value >>> 30){
            								case 0:
            										result.set(a, b, c, m);
            										break;
            								case 1:
            										result.set(m, b, c, a);
            										break;
            								case 2:
            										result.set(b, m, c, a);
            										break;
            								case 3:
            										result.set(b, c, m, a);
            										break;
            						}
            				};
            				var lerp = (a, b, t)=>a * (1 - t) + b * t;
            				var { chunkData, chunkSize, vertexData, shData0, shData1, shData2, shBands } = gsplatData;
            				var shCoeffs = [
            						3,
            						8,
            						15
            				][shBands - 1];
            				this.read = (i)=>{
            						var ci = Math.floor(i / 256) * chunkSize;
            						if (p) {
            								unpack111011(p, vertexData[i * 4 + 0]);
            								p.x = lerp(chunkData[ci + 0], chunkData[ci + 3], p.x);
            								p.y = lerp(chunkData[ci + 1], chunkData[ci + 4], p.y);
            								p.z = lerp(chunkData[ci + 2], chunkData[ci + 5], p.z);
            						}
            						if (r) {
            								unpackRot(r, vertexData[i * 4 + 1]);
            						}
            						if (s) {
            								unpack111011(s, vertexData[i * 4 + 2]);
            								s.x = lerp(chunkData[ci + 6], chunkData[ci + 9], s.x);
            								s.y = lerp(chunkData[ci + 7], chunkData[ci + 10], s.y);
            								s.z = lerp(chunkData[ci + 8], chunkData[ci + 11], s.z);
            						}
            						if (c) {
            								unpack8888(c, vertexData[i * 4 + 3]);
            								if (chunkSize > 12) {
            										c.x = lerp(chunkData[ci + 12], chunkData[ci + 15], c.x);
            										c.y = lerp(chunkData[ci + 13], chunkData[ci + 16], c.y);
            										c.z = lerp(chunkData[ci + 14], chunkData[ci + 17], c.z);
            								}
            						}
            						if (sh && shBands > 0) {
            								var shData = [
            										shData0,
            										shData1,
            										shData2
            								];
            								for(var j = 0; j < 3; ++j){
            										for(var k = 0; k < 15; ++k){
            												sh[j * 15 + k] = k < shCoeffs ? shData[j][i * 16 + k] * (8 / 255) - 4 : 0;
            										}
            								}
            						}
            				};
            		}
            }
            class GSplatCompressedData {
            		createIter(p, r, s, c, sh) {
            				return new SplatCompressedIterator(this, p, r, s, c, sh);
            		}
            		calcAabb(result) {
            				var { chunkData, numChunks, chunkSize } = this;
            				var s = Math.exp(Math.max(chunkData[9], chunkData[10], chunkData[11]));
            				var mx = chunkData[0] - s;
            				var my = chunkData[1] - s;
            				var mz = chunkData[2] - s;
            				var Mx = chunkData[3] + s;
            				var My = chunkData[4] + s;
            				var Mz = chunkData[5] + s;
            				for(var i = 1; i < numChunks; ++i){
            						var off = i * chunkSize;
            						s = Math.exp(Math.max(chunkData[off + 9], chunkData[off + 10], chunkData[off + 11]));
            						mx = Math.min(mx, chunkData[off + 0] - s);
            						my = Math.min(my, chunkData[off + 1] - s);
            						mz = Math.min(mz, chunkData[off + 2] - s);
            						Mx = Math.max(Mx, chunkData[off + 3] + s);
            						My = Math.max(My, chunkData[off + 4] + s);
            						Mz = Math.max(Mz, chunkData[off + 5] + s);
            				}
            				result.center.set((mx + Mx) * 0.5, (my + My) * 0.5, (mz + Mz) * 0.5);
            				result.halfExtents.set((Mx - mx) * 0.5, (My - my) * 0.5, (Mz - mz) * 0.5);
            				return true;
            		}
            		getCenters(result) {
            				var { vertexData, chunkData, numChunks, chunkSize } = this;
            				var mx, my, mz, Mx, My, Mz;
            				for(var c = 0; c < numChunks; ++c){
            						var off = c * chunkSize;
            						mx = chunkData[off + 0];
            						my = chunkData[off + 1];
            						mz = chunkData[off + 2];
            						Mx = chunkData[off + 3];
            						My = chunkData[off + 4];
            						Mz = chunkData[off + 5];
            						var end = Math.min(this.numSplats, (c + 1) * 256);
            						for(var i = c * 256; i < end; ++i){
            								var p = vertexData[i * 4];
            								var px = (p >>> 21) / 2047;
            								var py = (p >>> 11 & 0x3ff) / 1023;
            								var pz = (p & 0x7ff) / 2047;
            								result[i * 3 + 0] = (1 - px) * mx + px * Mx;
            								result[i * 3 + 1] = (1 - py) * my + py * My;
            								result[i * 3 + 2] = (1 - pz) * mz + pz * Mz;
            						}
            				}
            		}
            		getChunks(result) {
            				var { chunkData, numChunks, chunkSize } = this;
            				var mx, my, mz, Mx, My, Mz;
            				for(var c = 0; c < numChunks; ++c){
            						var off = c * chunkSize;
            						mx = chunkData[off + 0];
            						my = chunkData[off + 1];
            						mz = chunkData[off + 2];
            						Mx = chunkData[off + 3];
            						My = chunkData[off + 4];
            						Mz = chunkData[off + 5];
            						result[c * 6 + 0] = mx;
            						result[c * 6 + 1] = my;
            						result[c * 6 + 2] = mz;
            						result[c * 6 + 3] = Mx;
            						result[c * 6 + 4] = My;
            						result[c * 6 + 5] = Mz;
            				}
            		}
            		calcFocalPoint(result) {
            				var { chunkData, numChunks, chunkSize } = this;
            				result.x = 0;
            				result.y = 0;
            				result.z = 0;
            				for(var i = 0; i < numChunks; ++i){
            						var off = i * chunkSize;
            						result.x += chunkData[off + 0] + chunkData[off + 3];
            						result.y += chunkData[off + 1] + chunkData[off + 4];
            						result.z += chunkData[off + 2] + chunkData[off + 5];
            				}
            				result.mulScalar(0.5 / numChunks);
            		}
            		get isCompressed() {
            				return true;
            		}
            		get numChunks() {
            				return Math.ceil(this.numSplats / 256);
            		}
            		get chunkSize() {
            				return this.chunkData.length / this.numChunks;
            		}
            		decompress() {
            				var members = [
            						'x',
            						'y',
            						'z',
            						'f_dc_0',
            						'f_dc_1',
            						'f_dc_2',
            						'opacity',
            						'scale_0',
            						'scale_1',
            						'scale_2',
            						'rot_0',
            						'rot_1',
            						'rot_2',
            						'rot_3'
            				];
            				var { shBands } = this;
            				if (shBands > 0) {
            						var shMembers = [];
            						for(var i = 0; i < 45; ++i){
            								shMembers.push("f_rest_" + i);
            						}
            						members.splice(members.indexOf('f_dc_0') + 1, 0, ...shMembers);
            				}
            				var data = {};
            				members.forEach((name)=>{
            						data[name] = new Float32Array(this.numSplats);
            				});
            				var p = new Vec3();
            				var r = new Quat();
            				var s = new Vec3();
            				var c = new Vec4();
            				var sh = shBands > 0 ? new Float32Array(45) : null;
            				var iter = this.createIter(p, r, s, c, sh);
            				for(var i1 = 0; i1 < this.numSplats; ++i1){
            						iter.read(i1);
            						data.x[i1] = p.x;
            						data.y[i1] = p.y;
            						data.z[i1] = p.z;
            						data.rot_1[i1] = r.x;
            						data.rot_2[i1] = r.y;
            						data.rot_3[i1] = r.z;
            						data.rot_0[i1] = r.w;
            						data.scale_0[i1] = s.x;
            						data.scale_1[i1] = s.y;
            						data.scale_2[i1] = s.z;
            						data.f_dc_0[i1] = (c.x - 0.5) / SH_C0$1;
            						data.f_dc_1[i1] = (c.y - 0.5) / SH_C0$1;
            						data.f_dc_2[i1] = (c.z - 0.5) / SH_C0$1;
            						data.opacity[i1] = c.w <= 0 ? -40 : c.w >= 1 ? 40 : -Math.log(1 / c.w - 1);
            						if (sh) {
            								for(var c1 = 0; c1 < 45; ++c1){
            										data["f_rest_" + c1][i1] = sh[c1];
            								}
            						}
            				}
            				return new GSplatData([
            						{
            								name: 'vertex',
            								count: this.numSplats,
            								properties: members.map((name)=>{
            										return {
            												name: name,
            												type: 'float',
            												byteSize: 4,
            												storage: data[name]
            										};
            								})
            						}
            				]);
            		}
            }
            
            function _extends$7() {
            		_extends$7 = Object.assign || function(target) {
            				for(var i = 1; i < arguments.length; i++){
            						var source = arguments[i];
            						for(var key in source){
            								if (Object.prototype.hasOwnProperty.call(source, key)) {
            										target[key] = source[key];
            								}
            						}
            				}
            				return target;
            		};
            		return _extends$7.apply(this, arguments);
            }
            var strideCopy = (target, targetStride, src, srcStride, numEntries)=>{
            		for(var i = 0; i < numEntries; ++i){
            				for(var j = 0; j < srcStride; ++j){
            						target[i * targetStride + j] = src[i * srcStride + j];
            				}
            		}
            };
            class GSplatCompressed {
            		destroy() {
            				var _this_packedTexture, _this_chunkTexture, _this_shTexture0, _this_shTexture1, _this_shTexture2;
            				(_this_packedTexture = this.packedTexture) == null ? void 0 : _this_packedTexture.destroy();
            				(_this_chunkTexture = this.chunkTexture) == null ? void 0 : _this_chunkTexture.destroy();
            				(_this_shTexture0 = this.shTexture0) == null ? void 0 : _this_shTexture0.destroy();
            				(_this_shTexture1 = this.shTexture1) == null ? void 0 : _this_shTexture1.destroy();
            				(_this_shTexture2 = this.shTexture2) == null ? void 0 : _this_shTexture2.destroy();
            		}
            		createMaterial(options) {
            				var result = createGSplatMaterial(options);
            				result.setDefine('GSPLAT_COMPRESSED_DATA', true);
            				result.setParameter('packedTexture', this.packedTexture);
            				result.setParameter('chunkTexture', this.chunkTexture);
            				result.setParameter('numSplats', this.numSplatsVisible);
            				if (this.shTexture0) {
            						result.setDefine('SH_BANDS', 3);
            						result.setParameter('shTexture0', this.shTexture0);
            						result.setParameter('shTexture1', this.shTexture1);
            						result.setParameter('shTexture2', this.shTexture2);
            				} else {
            						result.setDefine('SH_BANDS', 0);
            				}
            				return result;
            		}
            		evalTextureSize(count) {
            				var width = Math.ceil(Math.sqrt(count));
            				var height = Math.ceil(count / width);
            				return new Vec2(width, height);
            		}
            		createTexture(name, format, size, data) {
            				return new Texture(this.device, _extends$7({
            						name: name,
            						width: size.x,
            						height: size.y,
            						format: format,
            						cubemap: false,
            						mipmaps: false,
            						minFilter: FILTER_NEAREST,
            						magFilter: FILTER_NEAREST,
            						addressU: ADDRESS_CLAMP_TO_EDGE,
            						addressV: ADDRESS_CLAMP_TO_EDGE
            				}, data ? {
            						levels: [
            								data
            						]
            				} : {}));
            		}
            		constructor(device, gsplatData){
            				var { chunkData, chunkSize, numChunks, numSplats, vertexData, shBands } = gsplatData;
            				this.device = device;
            				this.numSplats = numSplats;
            				this.numSplatsVisible = numSplats;
            				this.aabb = new BoundingBox();
            				gsplatData.calcAabb(this.aabb);
            				this.centers = new Float32Array(numSplats * 3);
            				gsplatData.getCenters(this.centers);
            				this.chunks = new Float32Array(numChunks * 6);
            				gsplatData.getChunks(this.chunks);
            				this.packedTexture = this.createTexture('packedData', PIXELFORMAT_RGBA32U, this.evalTextureSize(numSplats), vertexData);
            				var chunkTextureSize = this.evalTextureSize(numChunks);
            				chunkTextureSize.x *= 5;
            				this.chunkTexture = this.createTexture('chunkData', PIXELFORMAT_RGBA32F, chunkTextureSize);
            				var chunkTextureData = this.chunkTexture.lock();
            				strideCopy(chunkTextureData, 20, chunkData, chunkSize, numChunks);
            				if (chunkSize === 12) {
            						for(var i = 0; i < numChunks; ++i){
            								chunkTextureData[i * 20 + 15] = 1;
            								chunkTextureData[i * 20 + 16] = 1;
            								chunkTextureData[i * 20 + 17] = 1;
            						}
            				}
            				this.chunkTexture.unlock();
            				if (shBands > 0) {
            						var size = this.evalTextureSize(numSplats);
            						this.shTexture0 = this.createTexture('shTexture0', PIXELFORMAT_RGBA32U, size, new Uint32Array(gsplatData.shData0.buffer));
            						this.shTexture1 = this.createTexture('shTexture1', PIXELFORMAT_RGBA32U, size, new Uint32Array(gsplatData.shData1.buffer));
            						this.shTexture2 = this.createTexture('shTexture2', PIXELFORMAT_RGBA32U, size, new Uint32Array(gsplatData.shData2.buffer));
            				} else {
            						this.shTexture0 = null;
            						this.shTexture1 = null;
            						this.shTexture2 = null;
            				}
            		}
            }
            
            class GSplatSogs {
            		destroy() {}
            		createMaterial(options) {
            				var { gsplatData } = this;
            				var result = createGSplatMaterial(options);
            				result.setDefine('GSPLAT_SOGS_DATA', true);
            				result.setDefine('SH_BANDS', this.gsplatData.shBands);
            				[
            						'means_l',
            						'means_u',
            						'quats',
            						'scales',
            						'opacities',
            						'sh0',
            						'sh_centroids',
            						'sh_labels_u',
            						'sh_labels_l'
            				].forEach((name)=>{
            						result.setParameter(name, gsplatData[name]);
            				});
            				[
            						'means',
            						'quats',
            						'scales',
            						'opacities',
            						'sh0',
            						'shN'
            				].forEach((name)=>{
            						var v = gsplatData.meta[name];
            						if (v) {
            								result.setParameter("" + name + "_mins", v.mins);
            								result.setParameter("" + name + "_maxs", v.maxs);
            						}
            				});
            				return result;
            		}
            		evalTextureSize(count) {
            				return new Vec2(this.gsplatData.means_l.width, this.gsplatData.means_l.height);
            		}
            		createTexture(name, format, size) {
            				return new Texture(this.device, {
            						name: name,
            						width: size.x,
            						height: size.y,
            						format: format,
            						cubemap: false,
            						mipmaps: false,
            						minFilter: FILTER_NEAREST,
            						magFilter: FILTER_NEAREST,
            						addressU: ADDRESS_CLAMP_TO_EDGE,
            						addressV: ADDRESS_CLAMP_TO_EDGE
            				});
            		}
            		constructor(device, gsplatData){
            				this.device = device;
            				this.gsplatData = gsplatData;
            				var { meta } = gsplatData;
            				this.numSplats = meta.means.shape[0];
            				this.numSplatsVisible = this.numSplats;
            				this.aabb = new BoundingBox();
            				gsplatData.calcAabb(this.aabb);
            				this.centers = new Float32Array(this.numSplats * 3);
            				gsplatData.getCenters(this.centers);
            		}
            }
            
            class GSplatResource {
            		destroy() {
            				var _this_splat;
            				this.app = null;
            				this.splatData = null;
            				(_this_splat = this.splat) == null ? void 0 : _this_splat.destroy();
            				this.splat = null;
            		}
            		createSplat() {
            				if (!this.splat) {
            						var { app, splatData } = this;
            						var gsplatClass = splatData.isCompressed ? GSplatCompressed : splatData.isSogs ? GSplatSogs : GSplat;
            						this.splat = new gsplatClass(app.graphicsDevice, splatData);
            				}
            				return this.splat;
            		}
            		instantiate(options) {
            				if (options === void 0) options = {};
            				var splatInstance = this.createInstance(options);
            				var entity = new Entity(undefined, this.app);
            				var component = entity.addComponent('gsplat', {
            						instance: splatInstance
            				});
            				entity.setLocalEulerAngles(0, 0, 180);
            				component.customAabb = splatInstance.splat.aabb.clone();
            				return entity;
            		}
            		createInstance(options) {
            				if (options === void 0) options = {};
            				var splat = this.createSplat();
            				return new GSplatInstance(splat, options);
            		}
            		constructor(app, splatData, comments){
            				this.splat = null;
            				this.comments = null;
            				this.app = app;
            				this.splatData = splatData;
            				this.comments = comments;
            		}
            }
            
            function asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, key, arg) {
            		try {
            				var info = gen[key](arg);
            				var value = info.value;
            		} catch (error) {
            				reject(error);
            				return;
            		}
            		if (info.done) {
            				resolve(value);
            		} else {
            				Promise.resolve(value).then(_next, _throw);
            		}
            }
            function _async_to_generator$1(fn) {
            		return function() {
            				var self = this, args = arguments;
            				return new Promise(function(resolve, reject) {
            						var gen = fn.apply(self, args);
            						function _next(value) {
            								asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, "next", value);
            						}
            						function _throw(err) {
            								asyncGeneratorStep$1(gen, resolve, reject, _next, _throw, "throw", err);
            						}
            						_next(undefined);
            				});
            		};
            }
            var magicBytes = new Uint8Array([
            		112,
            		108,
            		121,
            		10
            ]);
            var endHeaderBytes = new Uint8Array([
            		10,
            		101,
            		110,
            		100,
            		95,
            		104,
            		101,
            		97,
            		100,
            		101,
            		114,
            		10
            ]);
            var dataTypeMap = new Map([
            		[
            				'char',
            				Int8Array
            		],
            		[
            				'uchar',
            				Uint8Array
            		],
            		[
            				'short',
            				Int16Array
            		],
            		[
            				'ushort',
            				Uint16Array
            		],
            		[
            				'int',
            				Int32Array
            		],
            		[
            				'uint',
            				Uint32Array
            		],
            		[
            				'float',
            				Float32Array
            		],
            		[
            				'double',
            				Float64Array
            		]
            ]);
            class StreamBuf {
            		read() {
            				var _this = this;
            				return _async_to_generator$1(function*() {
            						var { value, done } = yield _this.reader.read();
            						if (done) {
            								throw new Error('Stream finished before end of header');
            						}
            						_this.push(value);
            						_this.progressFunc == null ? void 0 : _this.progressFunc.call(_this, value.byteLength);
            				})();
            		}
            		push(data) {
            				if (!this.data) {
            						this.data = data;
            						this.view = new DataView(this.data.buffer);
            						this.tail = data.length;
            				} else {
            						var remaining = this.tail - this.head;
            						var newSize = remaining + data.length;
            						if (this.data.length >= newSize) {
            								if (this.head > 0) {
            										this.data.copyWithin(0, this.head, this.tail);
            										this.data.set(data, remaining);
            										this.head = 0;
            										this.tail = newSize;
            								} else {
            										this.data.set(data, this.tail);
            										this.tail += data.length;
            								}
            						} else {
            								var tmp = new Uint8Array(newSize);
            								if (this.head > 0 || this.tail < this.data.length) {
            										tmp.set(this.data.subarray(this.head, this.tail), 0);
            								} else {
            										tmp.set(this.data, 0);
            								}
            								tmp.set(data, remaining);
            								this.data = tmp;
            								this.view = new DataView(this.data.buffer);
            								this.head = 0;
            								this.tail = newSize;
            						}
            				}
            		}
            		compact() {
            				if (this.head > 0) {
            						this.data.copyWithin(0, this.head, this.tail);
            						this.tail -= this.head;
            						this.head = 0;
            				}
            		}
            		get remaining() {
            				return this.tail - this.head;
            		}
            		getInt8() {
            				var result = this.view.getInt8(this.head);
            				this.head++;
            				return result;
            		}
            		getUint8() {
            				var result = this.view.getUint8(this.head);
            				this.head++;
            				return result;
            		}
            		getInt16() {
            				var result = this.view.getInt16(this.head, true);
            				this.head += 2;
            				return result;
            		}
            		getUint16() {
            				var result = this.view.getUint16(this.head, true);
            				this.head += 2;
            				return result;
            		}
            		getInt32() {
            				var result = this.view.getInt32(this.head, true);
            				this.head += 4;
            				return result;
            		}
            		getUint32() {
            				var result = this.view.getUint32(this.head, true);
            				this.head += 4;
            				return result;
            		}
            		getFloat32() {
            				var result = this.view.getFloat32(this.head, true);
            				this.head += 4;
            				return result;
            		}
            		getFloat64() {
            				var result = this.view.getFloat64(this.head, true);
            				this.head += 8;
            				return result;
            		}
            		constructor(reader, progressFunc){
            				this.head = 0;
            				this.tail = 0;
            				this.reader = reader;
            				this.progressFunc = progressFunc;
            		}
            }
            var parseHeader = (lines)=>{
            		var elements = [];
            		var comments = [];
            		var format;
            		for(var i = 1; i < lines.length; ++i){
            				var words = lines[i].split(' ');
            				switch(words[0]){
            						case 'comment':
            								comments.push(words.slice(1).join(' '));
            								break;
            						case 'format':
            								format = words[1];
            								break;
            						case 'element':
            								elements.push({
            										name: words[1],
            										count: parseInt(words[2], 10),
            										properties: []
            								});
            								break;
            						case 'property':
            								{
            										if (!dataTypeMap.has(words[1])) {
            												throw new Error("Unrecognized property data type '" + words[1] + "' in ply header");
            										}
            										var element = elements[elements.length - 1];
            										element.properties.push({
            												type: words[1],
            												name: words[2],
            												storage: null,
            												byteSize: dataTypeMap.get(words[1]).BYTES_PER_ELEMENT
            										});
            										break;
            								}
            						default:
            								throw new Error("Unrecognized header value '" + words[0] + "' in ply header");
            				}
            		}
            		return {
            				elements,
            				format,
            				comments
            		};
            };
            var isCompressedPly = (elements)=>{
            		var chunkProperties = [
            				'min_x',
            				'min_y',
            				'min_z',
            				'max_x',
            				'max_y',
            				'max_z',
            				'min_scale_x',
            				'min_scale_y',
            				'min_scale_z',
            				'max_scale_x',
            				'max_scale_y',
            				'max_scale_z',
            				'min_r',
            				'min_g',
            				'min_b',
            				'max_r',
            				'max_g',
            				'max_b'
            		];
            		var vertexProperties = [
            				'packed_position',
            				'packed_rotation',
            				'packed_scale',
            				'packed_color'
            		];
            		var shProperties = new Array(45).fill('').map((_, i)=>"f_rest_" + i);
            		var hasBaseElements = ()=>{
            				return elements[0].name === 'chunk' && elements[0].properties.every((p, i)=>p.name === chunkProperties[i] && p.type === 'float') && elements[1].name === 'vertex' && elements[1].properties.every((p, i)=>p.name === vertexProperties[i] && p.type === 'uint');
            		};
            		var hasSHElements = ()=>{
            				return elements[2].name === 'sh' && [
            						9,
            						24,
            						45
            				].indexOf(elements[2].properties.length) !== -1 && elements[2].properties.every((p, i)=>p.name === shProperties[i] && p.type === 'uchar');
            		};
            		return elements.length === 2 && hasBaseElements() || elements.length === 3 && hasBaseElements() && hasSHElements();
            };
            var isFloatPly = (elements)=>{
            		return elements.length === 1 && elements[0].name === 'vertex' && elements[0].properties.every((p)=>p.type === 'float');
            };
            var readCompressedPly = /*#__PURE__*/ _async_to_generator$1(function*(streamBuf, elements) {
            		var result = new GSplatCompressedData();
            		var numChunks = elements[0].count;
            		var numChunkProperties = elements[0].properties.length;
            		var numVertices = elements[1].count;
            		var evalStorageSize = (count)=>{
            				var width = Math.ceil(Math.sqrt(count));
            				var height = Math.ceil(count / width);
            				return width * height;
            		};
            		var storageSize = evalStorageSize(numVertices);
            		result.numSplats = numVertices;
            		result.chunkData = new Float32Array(numChunks * numChunkProperties);
            		result.vertexData = new Uint32Array(storageSize * 4);
            		var read = /*#__PURE__*/ _async_to_generator$1(function*(buffer, length) {
            				var target = new Uint8Array(buffer);
            				var cursor = 0;
            				while(cursor < length){
            						while(streamBuf.remaining === 0){
            								yield streamBuf.read();
            						}
            						var toCopy = Math.min(length - cursor, streamBuf.remaining);
            						var src = streamBuf.data;
            						for(var i = 0; i < toCopy; ++i){
            								target[cursor++] = src[streamBuf.head++];
            						}
            				}
            		});
            		yield read(result.chunkData.buffer, numChunks * numChunkProperties * 4);
            		yield read(result.vertexData.buffer, numVertices * 4 * 4);
            		if (elements.length === 3) {
            				var texStorageSize = storageSize * 16;
            				var shData0 = new Uint8Array(texStorageSize);
            				var shData1 = new Uint8Array(texStorageSize);
            				var shData2 = new Uint8Array(texStorageSize);
            				var chunkSize = 1024;
            				var srcCoeffs = elements[2].properties.length / 3;
            				var tmpBuf = new Uint8Array(chunkSize * srcCoeffs * 3);
            				for(var i = 0; i < result.numSplats; i += chunkSize){
            						var toRead = Math.min(chunkSize, result.numSplats - i);
            						yield read(tmpBuf.buffer, toRead * srcCoeffs * 3);
            						for(var j = 0; j < toRead; ++j){
            								for(var k = 0; k < 15; ++k){
            										var tidx = (i + j) * 16 + k;
            										if (k < srcCoeffs) {
            												shData0[tidx] = tmpBuf[(j * 3 + 0) * srcCoeffs + k];
            												shData1[tidx] = tmpBuf[(j * 3 + 1) * srcCoeffs + k];
            												shData2[tidx] = tmpBuf[(j * 3 + 2) * srcCoeffs + k];
            										} else {
            												shData0[tidx] = 127;
            												shData1[tidx] = 127;
            												shData2[tidx] = 127;
            										}
            								}
            						}
            				}
            				result.shData0 = shData0;
            				result.shData1 = shData1;
            				result.shData2 = shData2;
            				result.shBands = ({
            						3: 1,
            						8: 2,
            						15: 3
            				})[srcCoeffs];
            		} else {
            				result.shBands = 0;
            		}
            		return result;
            });
            var readFloatPly = /*#__PURE__*/ _async_to_generator$1(function*(streamBuf, elements) {
            		var element = elements[0];
            		var properties = element.properties;
            		var numProperties = properties.length;
            		var storage = properties.map((p)=>p.storage);
            		var inputSize = properties.reduce((a, p)=>a + p.byteSize, 0);
            		var vertexIdx = 0;
            		var floatData;
            		var checkFloatData = ()=>{
            				var buffer = streamBuf.data.buffer;
            				if ((floatData == null ? void 0 : floatData.buffer) !== buffer) {
            						floatData = new Float32Array(buffer, 0, buffer.byteLength / 4);
            				}
            		};
            		checkFloatData();
            		while(vertexIdx < element.count){
            				while(streamBuf.remaining < inputSize){
            						yield streamBuf.read();
            						checkFloatData();
            				}
            				var toRead = Math.min(element.count - vertexIdx, Math.floor(streamBuf.remaining / inputSize));
            				for(var j = 0; j < numProperties; ++j){
            						var s = storage[j];
            						for(var n = 0; n < toRead; ++n){
            								s[n + vertexIdx] = floatData[n * numProperties + j];
            						}
            				}
            				vertexIdx += toRead;
            				streamBuf.head += toRead * inputSize;
            		}
            		return new GSplatData(elements);
            });
            var readGeneralPly = /*#__PURE__*/ _async_to_generator$1(function*(streamBuf, elements) {
            		for(var i = 0; i < elements.length; ++i){
            				var element = elements[i];
            				var inputSize = element.properties.reduce((a, p)=>a + p.byteSize, 0);
            				var propertyParsingFunctions = element.properties.map((p)=>{
            						if (p.storage) {
            								switch(p.type){
            										case 'char':
            												return (streamBuf, c)=>{
            														p.storage[c] = streamBuf.getInt8();
            												};
            										case 'uchar':
            												return (streamBuf, c)=>{
            														p.storage[c] = streamBuf.getUint8();
            												};
            										case 'short':
            												return (streamBuf, c)=>{
            														p.storage[c] = streamBuf.getInt16();
            												};
            										case 'ushort':
            												return (streamBuf, c)=>{
            														p.storage[c] = streamBuf.getUint16();
            												};
            										case 'int':
            												return (streamBuf, c)=>{
            														p.storage[c] = streamBuf.getInt32();
            												};
            										case 'uint':
            												return (streamBuf, c)=>{
            														p.storage[c] = streamBuf.getUint32();
            												};
            										case 'float':
            												return (streamBuf, c)=>{
            														p.storage[c] = streamBuf.getFloat32();
            												};
            										case 'double':
            												return (streamBuf, c)=>{
            														p.storage[c] = streamBuf.getFloat64();
            												};
            										default:
            												throw new Error("Unsupported property data type '" + p.type + "' in ply header");
            								}
            						} else {
            								return (streamBuf)=>{
            										streamBuf.head += p.byteSize;
            								};
            						}
            				});
            				var c = 0;
            				while(c < element.count){
            						while(streamBuf.remaining < inputSize){
            								yield streamBuf.read();
            						}
            						var toRead = Math.min(element.count - c, Math.floor(streamBuf.remaining / inputSize));
            						for(var n = 0; n < toRead; ++n){
            								for(var j = 0; j < element.properties.length; ++j){
            										propertyParsingFunctions[j](streamBuf, c);
            								}
            								c++;
            						}
            				}
            		}
            		return new GSplatData(elements);
            });
            var readPly = /*#__PURE__*/ _async_to_generator$1(function*(reader, propertyFilter, progressFunc) {
            		if (propertyFilter === void 0) propertyFilter = null;
            		if (progressFunc === void 0) progressFunc = null;
            		var find = (buf, search)=>{
            				var endIndex = buf.length - search.length;
            				var i, j;
            				for(i = 0; i <= endIndex; ++i){
            						for(j = 0; j < search.length; ++j){
            								if (buf[i + j] !== search[j]) {
            										break;
            								}
            						}
            						if (j === search.length) {
            								return i;
            						}
            				}
            				return -1;
            		};
            		var startsWith = (a, b)=>{
            				if (a.length < b.length) {
            						return false;
            				}
            				for(var i = 0; i < b.length; ++i){
            						if (a[i] !== b[i]) {
            								return false;
            						}
            				}
            				return true;
            		};
            		var streamBuf = new StreamBuf(reader, progressFunc);
            		var headerLength;
            		while(true){
            				yield streamBuf.read();
            				if (streamBuf.tail >= magicBytes.length && !startsWith(streamBuf.data, magicBytes)) {
            						throw new Error('Invalid ply header');
            				}
            				headerLength = find(streamBuf.data, endHeaderBytes);
            				if (headerLength !== -1) {
            						break;
            				}
            		}
            		var lines = new TextDecoder('ascii').decode(streamBuf.data.subarray(0, headerLength)).split('\n');
            		var { elements, format, comments } = parseHeader(lines);
            		if (format !== 'binary_little_endian') {
            				throw new Error('Unsupported ply format');
            		}
            		streamBuf.head = headerLength + endHeaderBytes.length;
            		streamBuf.compact();
            		var readData = /*#__PURE__*/ _async_to_generator$1(function*() {
            				if (isCompressedPly(elements)) {
            						return yield readCompressedPly(streamBuf, elements);
            				}
            				elements.forEach((e)=>{
            						e.properties.forEach((p)=>{
            								var storageType = dataTypeMap.get(p.type);
            								if (storageType) {
            										var storage = !propertyFilter || propertyFilter(p.name) ? new storageType(e.count) : null;
            										p.storage = storage;
            								}
            						});
            				});
            				if (isFloatPly(elements)) {
            						return yield readFloatPly(streamBuf, elements);
            				}
            				return yield readGeneralPly(streamBuf, elements);
            		});
            		return {
            				data: yield readData(),
            				comments
            		};
            });
            var defaultElementFilter = (val)=>true;
            class PlyParser {
            		load(url, callback, asset) {
            				var _this = this;
            				return _async_to_generator$1(function*() {
            						try {
            								var _asset_file;
            								var _asset_file_contents;
            								var response = yield (_asset_file_contents = (_asset_file = asset.file) == null ? void 0 : _asset_file.contents) != null ? _asset_file_contents : fetch(url.load);
            								if (!response || !response.body) {
            										callback('Error loading resource', null);
            								} else {
            										var _response_headers_get;
            										var totalLength = parseInt((_response_headers_get = response.headers.get('content-length')) != null ? _response_headers_get : '0', 10);
            										var totalReceived = 0;
            										var _asset_data_elementFilter;
            										var { data, comments } = yield readPly(response.body.getReader(), (_asset_data_elementFilter = asset.data.elementFilter) != null ? _asset_data_elementFilter : defaultElementFilter, (bytes)=>{
            												totalReceived += bytes;
            												if (asset) {
            														asset.fire('progress', totalReceived, totalLength);
            												}
            										});
            										if (!data.isCompressed) {
            												var _asset_data_reorder;
            												if ((_asset_data_reorder = asset.data.reorder) != null ? _asset_data_reorder : true) {
            														data.reorderData();
            												}
            										}
            										var resource = new GSplatResource(_this.app, data.isCompressed && asset.data.decompress ? data.decompress() : data, comments);
            										callback(null, resource);
            								}
            						} catch (err) {
            								callback(err, null);
            						}
            				})();
            		}
            		open(url, data) {
            				return data;
            		}
            		constructor(app, maxRetries){
            				this.app = app;
            				this.maxRetries = maxRetries;
            		}
            }
            
            var offscreen = null;
            var ctx = null;
            var readImageData = (imageBitmap)=>{
            		if (!offscreen || offscreen.width !== imageBitmap.width || offscreen.height !== imageBitmap.height) {
            				offscreen = new OffscreenCanvas(imageBitmap.width, imageBitmap.height);
            				ctx = offscreen.getContext('2d');
            				ctx.globalCompositeOperation = 'copy';
            		}
            		ctx.drawImage(imageBitmap, 0, 0);
            		return ctx.getImageData(0, 0, imageBitmap.width, imageBitmap.height).data;
            };
            var SH_C0 = 0.28209479177387814;
            class GSplatSogsIterator {
            		constructor(data, p, r, s, c, sh){
            				var lerp = (a, b, t)=>a * (1 - t) + b * t;
            				var { meta } = data;
            				var { means, quats, scales, opacities, sh0, shN } = meta;
            				var means_l_data = p && readImageData(data.means_l._levels[0]);
            				var means_u_data = p && readImageData(data.means_u._levels[0]);
            				var quats_data = r && readImageData(data.quats._levels[0]);
            				var scales_data = s && readImageData(data.scales._levels[0]);
            				var opacities_data = c && readImageData(data.opacities._levels[0]);
            				var sh0_data = c && readImageData(data.sh0._levels[0]);
            				var sh_labels_l_data = sh && readImageData(data.sh_labels_l._levels[0]);
            				var sh_labels_u_data = sh && readImageData(data.sh_labels_u._levels[0]);
            				var sh_centroids_data = sh && readImageData(data.sh_centroids._levels[0]);
            				this.read = (i)=>{
            						if (p) {
            								var nx = lerp(means.mins[0], means.maxs[0], ((means_u_data[i * 4 + 0] << 8) + means_l_data[i * 4 + 0]) / 65535);
            								var ny = lerp(means.mins[1], means.maxs[1], ((means_u_data[i * 4 + 1] << 8) + means_l_data[i * 4 + 1]) / 65535);
            								var nz = lerp(means.mins[2], means.maxs[2], ((means_u_data[i * 4 + 2] << 8) + means_l_data[i * 4 + 2]) / 65535);
            								p.x = Math.sign(nx) * (Math.exp(Math.abs(nx)) - 1);
            								p.y = Math.sign(ny) * (Math.exp(Math.abs(ny)) - 1);
            								p.z = Math.sign(nz) * (Math.exp(Math.abs(nz)) - 1);
            						}
            						if (r) {
            								var qx = lerp(quats.mins[0], quats.maxs[0], quats_data[i * 4 + 0] / 255);
            								var qy = lerp(quats.mins[1], quats.maxs[1], quats_data[i * 4 + 1] / 255);
            								var qz = lerp(quats.mins[2], quats.maxs[2], quats_data[i * 4 + 2] / 255);
            								var qw = Math.sqrt(Math.max(0, 1 - (qx * qx + qy * qy + qz * qz)));
            								r.set(qy, qz, qw, qx);
            						}
            						if (s) {
            								var sx = lerp(scales.mins[0], scales.maxs[0], scales_data[i * 4 + 0] / 255);
            								var sy = lerp(scales.mins[1], scales.maxs[1], scales_data[i * 4 + 1] / 255);
            								var sz = lerp(scales.mins[2], scales.maxs[2], scales_data[i * 4 + 2] / 255);
            								s.set(sx, sy, sz);
            						}
            						if (c) {
            								var _$r = lerp(sh0.mins[0], sh0.maxs[0], sh0_data[i * 4 + 0] / 255);
            								var g = lerp(sh0.mins[1], sh0.maxs[1], sh0_data[i * 4 + 1] / 255);
            								var b = lerp(sh0.mins[2], sh0.maxs[2], sh0_data[i * 4 + 2] / 255);
            								var a = lerp(opacities.mins[0], opacities.maxs[0], opacities_data[i * 4 + 0] / 255);
            								c.set(0.5 + _$r * SH_C0, 0.5 + g * SH_C0, 0.5 + b * SH_C0, 1.0 / (1.0 + Math.exp(a * -1)));
            						}
            						if (sh) {
            								var n = sh_labels_l_data[i * 4 + 0] + (sh_labels_u_data[i * 4 + 0] << 8);
            								var u = n % 64 * 15;
            								var v = Math.floor(n / 64);
            								for(var j = 0; j < 3; ++j){
            										for(var k = 0; k < 15; ++k){
            												sh[j * 15 + k] = lerp(shN.mins, shN.maxs, sh_centroids_data[(u + k) * 4 + j + v * data.sh_centroids.width * 4] / 255);
            										}
            								}
            						}
            				};
            		}
            }
            class GSplatSogsData {
            		createIter(p, r, s, c, sh) {
            				return new GSplatSogsIterator(this, p, r, s, c, sh);
            		}
            		calcAabb(result) {
            				var { mins, maxs } = this.meta.means;
            				var map = (v)=>Math.sign(v) * (Math.exp(Math.abs(v)) - 1);
            				result.center.set((map(mins[0]) + map(maxs[0])) * 0.5, (map(mins[1]) + map(maxs[1])) * 0.5, (map(mins[2]) + map(maxs[2])) * 0.5);
            				result.halfExtents.set((map(maxs[0]) - map(mins[0])) * 0.5, (map(maxs[1]) - map(mins[1])) * 0.5, (map(maxs[2]) - map(mins[2])) * 0.5);
            		}
            		getCenters(result) {
            				var p = new Vec3();
            				var iter = this.createIter(p);
            				for(var i = 0; i < this.numSplats; i++){
            						iter.read(i);
            						result[i * 3 + 0] = p.x;
            						result[i * 3 + 1] = p.y;
            						result[i * 3 + 2] = p.z;
            				}
            		}
            		calcFocalPoint(result, pred) {
            				result.set(0, 0, 0);
            		}
            		get isSogs() {
            				return true;
            		}
            		decompress() {
            				var members = [
            						'x',
            						'y',
            						'z',
            						'f_dc_0',
            						'f_dc_1',
            						'f_dc_2',
            						'opacity',
            						'scale_0',
            						'scale_1',
            						'scale_2',
            						'rot_0',
            						'rot_1',
            						'rot_2',
            						'rot_3'
            				];
            				var { shBands } = this;
            				if (shBands > 0) {
            						var shMembers = [];
            						for(var i = 0; i < 45; ++i){
            								shMembers.push("f_rest_" + i);
            						}
            						members.splice(members.indexOf('f_dc_0') + 1, 0, ...shMembers);
            				}
            				var data = {};
            				members.forEach((name)=>{
            						data[name] = new Float32Array(this.numSplats);
            				});
            				var p = new Vec3();
            				var r = new Quat();
            				var s = new Vec3();
            				var c = new Vec4();
            				var sh = shBands > 0 ? new Float32Array(45) : null;
            				var iter = this.createIter(p, r, s, c, sh);
            				for(var i1 = 0; i1 < this.numSplats; ++i1){
            						iter.read(i1);
            						data.x[i1] = p.x;
            						data.y[i1] = p.y;
            						data.z[i1] = p.z;
            						data.rot_1[i1] = r.x;
            						data.rot_2[i1] = r.y;
            						data.rot_3[i1] = r.z;
            						data.rot_0[i1] = r.w;
            						data.scale_0[i1] = s.x;
            						data.scale_1[i1] = s.y;
            						data.scale_2[i1] = s.z;
            						data.f_dc_0[i1] = (c.x - 0.5) / SH_C0;
            						data.f_dc_1[i1] = (c.y - 0.5) / SH_C0;
            						data.f_dc_2[i1] = (c.z - 0.5) / SH_C0;
            						data.opacity[i1] = c.w <= 0 ? -40 : c.w >= 1 ? 40 : -Math.log(1 / c.w - 1);
            						if (sh) {
            								for(var c1 = 0; c1 < 45; ++c1){
            										data["f_rest_" + c1][i1] = sh[c1];
            								}
            						}
            				}
            				return new GSplatData([
            						{
            								name: 'vertex',
            								count: this.numSplats,
            								properties: members.map((name)=>{
            										return {
            												name: name,
            												type: 'float',
            												byteSize: 4,
            												storage: data[name]
            										};
            								})
            						}
            				]);
            		}
            }
            
            function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
            		try {
            				var info = gen[key](arg);
            				var value = info.value;
            		} catch (error) {
            				reject(error);
            				return;
            		}
            		if (info.done) {
            				resolve(value);
            		} else {
            				Promise.resolve(value).then(_next, _throw);
            		}
            }
            function _async_to_generator(fn) {
            		return function() {
            				var self = this, args = arguments;
            				return new Promise(function(resolve, reject) {
            						var gen = fn.apply(self, args);
            						function _next(value) {
            								asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            						}
            						function _throw(err) {
            								asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            						}
            						_next(undefined);
            				});
            		};
            }
            class SogsParser {
            		loadTextures(url, callback, asset, meta) {
            				var _this = this;
            				return _async_to_generator(function*() {
            						var _textures_shN__resource, _textures_shN_, _textures_shN, _textures_shN_1, _textures_shN1, _textures_shN_2, _textures_shN2, _textures_shN_3, _textures_shN3, _asset_data;
            						var { assets } = _this.app;
            						var subs = [
            								'means',
            								'opacities',
            								'quats',
            								'scales',
            								'sh0',
            								'shN'
            						];
            						var textures = {};
            						var promises = [];
            						subs.forEach((sub)=>{
            								var _meta_sub;
            								var _meta_sub_files;
            								var files = (_meta_sub_files = (_meta_sub = meta[sub]) == null ? void 0 : _meta_sub.files) != null ? _meta_sub_files : [];
            								textures[sub] = files.map((filename)=>{
            										var _asset_options_mapUrl, _asset_options;
            										var _asset_options_mapUrl1;
            										var texture = new Asset(filename, 'texture', {
            												url: (_asset_options_mapUrl1 = (_asset_options = asset.options) == null ? void 0 : (_asset_options_mapUrl = _asset_options.mapUrl) == null ? void 0 : _asset_options_mapUrl.call(_asset_options, filename)) != null ? _asset_options_mapUrl1 : new URL(filename, url.load).toString(),
            												filename
            										}, {
            												mipmaps: false
            										});
            										var promise = new Promise((resolve, reject)=>{
            												texture.on('load', ()=>resolve(null));
            												texture.on('error', (err)=>reject(err));
            										});
            										assets.add(texture);
            										assets.load(texture);
            										promises.push(promise);
            										return texture;
            								});
            						});
            						yield Promise.allSettled(promises);
            						var widths = {
            								192: 1,
            								512: 2,
            								960: 3
            						};
            						var data = new GSplatSogsData();
            						data.meta = meta;
            						data.numSplats = meta.means.shape[0];
            						var _widths_textures_shN__resource_width;
            						data.shBands = (_widths_textures_shN__resource_width = widths[(_textures_shN = textures.shN) == null ? void 0 : (_textures_shN_ = _textures_shN[0]) == null ? void 0 : (_textures_shN__resource = _textures_shN_.resource) == null ? void 0 : _textures_shN__resource.width]) != null ? _widths_textures_shN__resource_width : 0;
            						data.means_l = textures.means[0].resource;
            						data.means_u = textures.means[1].resource;
            						data.opacities = textures.opacities[0].resource;
            						data.quats = textures.quats[0].resource;
            						data.scales = textures.scales[0].resource;
            						data.sh0 = textures.sh0[0].resource;
            						data.sh_centroids = (_textures_shN1 = textures.shN) == null ? void 0 : (_textures_shN_1 = _textures_shN1[0]) == null ? void 0 : _textures_shN_1.resource;
            						data.sh_labels_l = (_textures_shN2 = textures.shN) == null ? void 0 : (_textures_shN_2 = _textures_shN2[1]) == null ? void 0 : _textures_shN_2.resource;
            						data.sh_labels_u = (_textures_shN3 = textures.shN) == null ? void 0 : (_textures_shN_3 = _textures_shN3[2]) == null ? void 0 : _textures_shN_3.resource;
            						var resource = new GSplatResource(_this.app, ((_asset_data = asset.data) == null ? void 0 : _asset_data.decompress) ? data.decompress() : data, []);
            						callback(null, resource);
            				})();
            		}
            		load(url, callback, asset) {
            				var _asset_data;
            				if ((_asset_data = asset.data) == null ? void 0 : _asset_data.means) {
            						this.loadTextures(url, callback, asset, asset.data);
            				} else {
            						if (typeof url === 'string') {
            								url = {
            										load: url,
            										original: url
            								};
            						}
            						var options = {
            								retry: this.maxRetries > 0,
            								maxRetries: this.maxRetries,
            								responseType: Http.ResponseType.JSON
            						};
            						http.get(url.load, options, (err, meta)=>{
            								if (!err) {
            										this.loadTextures(url, callback, asset, meta);
            								} else {
            										callback("Error loading gsplat meta: " + url.original + " [" + err + "]");
            								}
            						});
            				}
            		}
            		constructor(app, maxRetries){
            				this.app = app;
            				this.maxRetries = maxRetries;
            		}
            }
            
            class GSplatHandler extends ResourceHandler {
            		_getUrlWithoutParams(url) {
            				return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
            		}
            		_getParser(url) {
            				var ext = path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace('.', '');
            				return this.parsers[ext] || this.parsers.ply;
            		}
            		load(url, callback, asset) {
            				if (typeof url === 'string') {
            						url = {
            								load: url,
            								original: url
            						};
            				}
            				this._getParser(url.original).load(url, callback, asset);
            		}
            		open(url, data, asset) {
            				return data;
            		}
            		constructor(app){
            				super(app, 'gsplat');
            				this.parsers = {
            						ply: new PlyParser(app, 3),
            						json: new SogsParser(app, 3)
            				};
            		}
            }
            
            class CompressUtils {
            		static setCompressedPRS(entity, data, compressed) {
            				var a = compressed.singleVecs;
            				var b, i;
            				var v = data.___1;
            				if (!v) {
            						b = compressed.tripleVecs;
            						i = data.___2;
            				}
            				var n = v ? v[0] : b[i];
            				entity.setLocalPosition(a[n], a[n + 1], a[n + 2]);
            				n = v ? v[1] : b[i + 1];
            				entity.setLocalEulerAngles(a[n], a[n + 1], a[n + 2]);
            				n = v ? v[2] : b[i + 2];
            				entity.setLocalScale(a[n], a[n + 1], a[n + 2]);
            		}
            		static oneCharToKey(s, data) {
            				var i = s.charCodeAt(0) - data.fieldFirstCode;
            				return data.fieldArray[i];
            		}
            		static multCharToKey(s, data) {
            				var ind = 0;
            				for(var i = 0; i < s.length; i++){
            						ind = ind * data.fieldCodeBase + s.charCodeAt(i) - data.fieldFirstCode;
            				}
            				return data.fieldArray[ind];
            		}
            }
            
            class Decompress {
            		run() {
            				var type = Object.prototype.toString.call(this._node);
            				if (type === '[object Object]') {
            						this._handleMap();
            				} else if (type === '[object Array]') {
            						this._handleArray();
            				} else {
            						this._result = this._node;
            				}
            				return this._result;
            		}
            		_handleMap() {
            				this._result = {};
            				var a = Object.keys(this._node);
            				a.forEach(this._handleKey, this);
            		}
            		_handleKey(origKey) {
            				var newKey = origKey;
            				var len = origKey.length;
            				if (len === 1) {
            						newKey = CompressUtils.oneCharToKey(origKey, this._data);
            				} else if (len === 2) {
            						newKey = CompressUtils.multCharToKey(origKey, this._data);
            				}
            				this._result[newKey] = new Decompress(this._node[origKey], this._data).run();
            		}
            		_handleArray() {
            				this._result = [];
            				this._node.forEach(this._handleArElt, this);
            		}
            		_handleArElt(elt) {
            				var v = new Decompress(elt, this._data).run();
            				this._result.push(v);
            		}
            		constructor(node, data){
            				this._node = node;
            				this._data = data;
            		}
            }
            
            class SceneParser {
            		parse(data) {
            				var entities = {};
            				var parent = null;
            				var compressed = data.compressedFormat;
            				if (compressed && !data.entDecompressed) {
            						data.entDecompressed = true;
            						data.entities = new Decompress(data.entities, compressed).run();
            				}
            				for(var id in data.entities){
            						var curData = data.entities[id];
            						var curEnt = this._createEntity(curData, compressed);
            						entities[id] = curEnt;
            						if (curData.parent === null) {
            								parent = curEnt;
            						}
            				}
            				for(var id1 in data.entities){
            						var curEnt1 = entities[id1];
            						var children = data.entities[id1].children;
            						var len = children.length;
            						for(var i = 0; i < len; i++){
            								var childEnt = entities[children[i]];
            								if (childEnt) {
            										curEnt1.addChild(childEnt);
            								}
            						}
            				}
            				this._openComponentData(parent, data.entities);
            				return parent;
            		}
            		_createEntity(data, compressed) {
            				var entity = new Entity(data.name, this._app);
            				entity.setGuid(data.resource_id);
            				this._setPosRotScale(entity, data, compressed);
            				var _data_enabled;
            				entity._enabled = (_data_enabled = data.enabled) != null ? _data_enabled : true;
            				if (this._isTemplate) {
            						entity._template = true;
            				} else {
            						entity._enabledInHierarchy = entity._enabled;
            				}
            				entity.template = data.template;
            				if (data.tags) {
            						for(var i = 0; i < data.tags.length; i++){
            								entity.tags.add(data.tags[i]);
            						}
            				}
            				return entity;
            		}
            		_setPosRotScale(entity, data, compressed) {
            				if (compressed) {
            						CompressUtils.setCompressedPRS(entity, data, compressed);
            				} else {
            						var p = data.position;
            						var r = data.rotation;
            						var s = data.scale;
            						entity.setLocalPosition(p[0], p[1], p[2]);
            						entity.setLocalEulerAngles(r[0], r[1], r[2]);
            						entity.setLocalScale(s[0], s[1], s[2]);
            				}
            		}
            		_openComponentData(entity, entities) {
            				var systemsList = this._app.systems.list;
            				var len = systemsList.length;
            				var entityData = entities[entity.getGuid()];
            				for(var i = 0; i < len; i++){
            						var system = systemsList[i];
            						var componentData = entityData.components[system.id];
            						if (componentData) {
            								system.addComponent(entity, componentData);
            						}
            				}
            				len = entityData.children.length;
            				var children = entity._children;
            				for(var i1 = 0; i1 < len; i1++){
            						if (children[i1]) {
            								children[i1] = this._openComponentData(children[i1], entities);
            						}
            				}
            				return entity;
            		}
            		constructor(app, isTemplate){
            				this._app = app;
            				this._isTemplate = isTemplate;
            		}
            }
            
            class SceneUtils {
            		static load(url, maxRetries, callback) {
            				if (typeof url === 'string') {
            						url = {
            								load: url,
            								original: url
            						};
            				}
            				http.get(url.load, {
            						retry: maxRetries > 0,
            						maxRetries: maxRetries
            				}, (err, response)=>{
            						if (!err) {
            								callback(err, response);
            						} else {
            								var errMsg = "Error while loading scene JSON " + url.original;
            								if (err.message) {
            										errMsg += ": " + err.message;
            										if (err.stack) {
            												errMsg += "\n" + err.stack;
            										}
            								} else {
            										errMsg += ": " + err;
            								}
            								callback(errMsg);
            						}
            				});
            		}
            }
            
            class HierarchyHandler extends ResourceHandler {
            		load(url, callback) {
            				SceneUtils.load(url, this.maxRetries, callback);
            		}
            		open(url, data) {
            				this._app.systems.script.preloading = true;
            				var parser = new SceneParser(this._app, false);
            				var parent = parser.parse(data);
            				this._app.systems.script.preloading = false;
            				return parent;
            		}
            		constructor(app){
            				super(app, 'hierarchy');
            		}
            }
            
            class HtmlHandler extends ResourceHandler {
            		load(url, callback) {
            				if (typeof url === 'string') {
            						url = {
            								load: url,
            								original: url
            						};
            				}
            				http.get(url.load, {
            						retry: this.maxRetries > 0,
            						maxRetries: this.maxRetries
            				}, (err, response)=>{
            						if (!err) {
            								callback(null, response);
            						} else {
            								callback("Error loading html resource: " + url.original + " [" + err + "]");
            						}
            				});
            		}
            		openBinary(data) {
            				var _this_decoder;
            				(_this_decoder = this.decoder) != null ? _this_decoder : this.decoder = new TextDecoder('utf-8');
            				return this.decoder.decode(data);
            		}
            		constructor(app){
            				super(app, 'html'), this.decoder = null;
            		}
            }
            
            class JsonHandler extends ResourceHandler {
            		load(url, callback) {
            				if (typeof url === 'string') {
            						url = {
            								load: url,
            								original: url
            						};
            				}
            				var options = {
            						retry: this.maxRetries > 0,
            						maxRetries: this.maxRetries
            				};
            				if (url.load.startsWith('blob:')) {
            						options.responseType = Http.ResponseType.JSON;
            				}
            				http.get(url.load, options, (err, response)=>{
            						if (!err) {
            								callback(null, response);
            						} else {
            								callback("Error loading JSON resource: " + url.original + " [" + err + "]");
            						}
            				});
            		}
            		openBinary(data) {
            				var _this_decoder;
            				(_this_decoder = this.decoder) != null ? _this_decoder : this.decoder = new TextDecoder('utf-8');
            				return JSON.parse(this.decoder.decode(data));
            		}
            		constructor(app){
            				super(app, 'json'), this.decoder = null;
            		}
            }
            
            class StandardMaterialValidator {
            		setInvalid(key, data) {
            				this.valid = false;
            				if (this.removeInvalid) {
            						delete data[key];
            				}
            		}
            		validate(data) {
            				var TYPES = standardMaterialParameterTypes;
            				var REMOVED = standardMaterialRemovedParameters;
            				var pathMapping = data.mappingFormat === 'path';
            				for(var key in data){
            						var type = TYPES[key];
            						if (!type) {
            								if (REMOVED[key]) {
            										delete data[key];
            								} else {
            										this.valid = false;
            								}
            								continue;
            						}
            						if (type.startsWith('enum')) {
            								var enumType = type.split(':')[1];
            								if (this.enumValidators[enumType]) {
            										if (!this.enumValidators[enumType](data[key])) {
            												this.setInvalid(key, data);
            										}
            								}
            						} else if (type === 'number') {
            								if (typeof data[key] !== 'number') {
            										this.setInvalid(key, data);
            								}
            						} else if (type === 'boolean') {
            								if (typeof data[key] !== 'boolean') {
            										this.setInvalid(key, data);
            								}
            						} else if (type === 'string') {
            								if (typeof data[key] !== 'string') {
            										this.setInvalid(key, data);
            								}
            						} else if (type === 'vec2') {
            								if (!(data[key] instanceof Array && data[key].length === 2)) {
            										this.setInvalid(key, data);
            								}
            						} else if (type === 'rgb') {
            								if (!(data[key] instanceof Array && data[key].length === 3)) {
            										this.setInvalid(key, data);
            								}
            						} else if (type === 'texture') {
            								if (!pathMapping) {
            										if (!(typeof data[key] === 'number' || data[key] === null)) {
            												if (!(data[key] instanceof Texture)) {
            														this.setInvalid(key, data);
            												}
            										}
            								} else {
            										if (!(typeof data[key] === 'string' || data[key] === null)) {
            												if (!(data[key] instanceof Texture)) {
            														this.setInvalid(key, data);
            												}
            										}
            								}
            						} else if (type === 'boundingbox') {
            								if (!(data[key].center && data[key].center instanceof Array && data[key].center.length === 3)) {
            										this.setInvalid(key, data);
            								}
            								if (!(data[key].halfExtents && data[key].halfExtents instanceof Array && data[key].halfExtents.length === 3)) {
            										this.setInvalid(key, data);
            								}
            						} else if (type === 'cubemap') {
            								if (!(typeof data[key] === 'number' || data[key] === null || data[key] === undefined)) {
            										if (!(data[key] instanceof Texture && data[key].cubemap)) {
            												this.setInvalid(key, data);
            										}
            								}
            						} else if (type === 'chunks') {
            								var chunkNames = Object.keys(data[key]);
            								for(var i = 0; i < chunkNames.length; i++){
            										if (typeof data[key][chunkNames[i]] !== 'string') {
            												this.setInvalid(chunkNames[i], data[key]);
            										}
            								}
            						} else {
            								console.error("Unknown material type: " + type);
            						}
            				}
            				data.validated = true;
            				return this.valid;
            		}
            		_createEnumValidator(values) {
            				return function(value) {
            						return values.indexOf(value) >= 0;
            				};
            		}
            		constructor(){
            				this.removeInvalid = true;
            				this.valid = true;
            				this.enumValidators = {
            						occludeSpecular: this._createEnumValidator([
            								SPECOCC_NONE,
            								SPECOCC_AO,
            								SPECOCC_GLOSSDEPENDENT
            						]),
            						cull: this._createEnumValidator([
            								CULLFACE_NONE,
            								CULLFACE_BACK,
            								CULLFACE_FRONT,
            								CULLFACE_FRONTANDBACK
            						]),
            						blendType: this._createEnumValidator([
            								BLEND_SUBTRACTIVE,
            								BLEND_ADDITIVE,
            								BLEND_NORMAL,
            								BLEND_NONE,
            								BLEND_PREMULTIPLIED,
            								BLEND_MULTIPLICATIVE,
            								BLEND_ADDITIVEALPHA,
            								BLEND_MULTIPLICATIVE2X,
            								BLEND_SCREEN,
            								BLEND_MIN,
            								BLEND_MAX
            						]),
            						depthFunc: this._createEnumValidator([
            								FUNC_NEVER,
            								FUNC_LESS,
            								FUNC_EQUAL,
            								FUNC_LESSEQUAL,
            								FUNC_GREATER,
            								FUNC_NOTEQUAL,
            								FUNC_GREATEREQUAL,
            								FUNC_ALWAYS
            						])
            				};
            		}
            }
            
            function _extends$6() {
            		_extends$6 = Object.assign || function(target) {
            				for(var i = 1; i < arguments.length; i++){
            						var source = arguments[i];
            						for(var key in source){
            								if (Object.prototype.hasOwnProperty.call(source, key)) {
            										target[key] = source[key];
            								}
            						}
            				}
            				return target;
            		};
            		return _extends$6.apply(this, arguments);
            }
            class JsonStandardMaterialParser {
            		parse(input) {
            				var migrated = this.migrate(input);
            				var validated = this._validate(migrated);
            				var material = new StandardMaterial();
            				this.initialize(material, validated);
            				return material;
            		}
            		initialize(material, data) {
            				if (!data.validated) {
            						data = this._validate(data);
            				}
            				if (data.chunks) {
            						material.chunks = _extends$6({}, data.chunks);
            				}
            				for(var key in data){
            						var type = standardMaterialParameterTypes[key];
            						var value = data[key];
            						if (type === 'vec2') {
            								material[key] = new Vec2(value[0], value[1]);
            						} else if (type === 'rgb') {
            								material[key] = new Color(value[0], value[1], value[2]);
            						} else if (type === 'texture') {
            								if (value instanceof Texture) {
            										material[key] = value;
            								} else if (!(material[key] instanceof Texture && typeof value === 'number' && value > 0)) {
            										material[key] = null;
            								}
            						} else if (type === 'cubemap') {
            								if (value instanceof Texture) {
            										material[key] = value;
            								} else if (!(material[key] instanceof Texture && typeof value === 'number' && value > 0)) {
            										material[key] = null;
            								}
            								if (key === 'cubeMap' && !value) {
            										material.prefilteredCubemaps = null;
            								}
            						} else if (type === 'boundingbox') {
            								var center = new Vec3(value.center[0], value.center[1], value.center[2]);
            								var halfExtents = new Vec3(value.halfExtents[0], value.halfExtents[1], value.halfExtents[2]);
            								material[key] = new BoundingBox(center, halfExtents);
            						} else {
            								material[key] = data[key];
            						}
            				}
            				material.update();
            		}
            		migrate(data) {
            				if (data.shader) delete data.shader;
            				if (data.mapping_format) {
            						data.mappingFormat = data.mapping_format;
            						delete data.mapping_format;
            				}
            				var i;
            				var RENAMED_PROPERTIES = [
            						[
            								'bumpMapFactor',
            								'bumpiness'
            						],
            						[
            								'aoUvSet',
            								'aoMapUv'
            						],
            						[
            								'aoMapVertexColor',
            								'aoVertexColor'
            						],
            						[
            								'diffuseMapVertexColor',
            								'diffuseVertexColor'
            						],
            						[
            								'emissiveMapVertexColor',
            								'emissiveVertexColor'
            						],
            						[
            								'specularMapVertexColor',
            								'specularVertexColor'
            						],
            						[
            								'metalnessMapVertexColor',
            								'metalnessVertexColor'
            						],
            						[
            								'opacityMapVertexColor',
            								'opacityVertexColor'
            						],
            						[
            								'glossMapVertexColor',
            								'glossVertexColor'
            						],
            						[
            								'lightMapVertexColor',
            								'lightVertexColor'
            						],
            						[
            								'specularMapTint',
            								'specularTint'
            						],
            						[
            								'metalnessMapTint',
            								'metalnessTint'
            						],
            						[
            								'clearCoatGlossiness',
            								'clearCoatGloss'
            						]
            				];
            				for(i = 0; i < RENAMED_PROPERTIES.length; i++){
            						var _old = RENAMED_PROPERTIES[i][0];
            						var _new = RENAMED_PROPERTIES[i][1];
            						if (data[_old] !== undefined) {
            								if (data[_new] === undefined) {
            										data[_new] = data[_old];
            								}
            								delete data[_old];
            						}
            				}
            				var DEPRECATED_PROPERTIES = [
            						'fresnelFactor',
            						'shadowSampleType'
            				];
            				for(i = 0; i < DEPRECATED_PROPERTIES.length; i++){
            						var name = DEPRECATED_PROPERTIES[i];
            						if (data.hasOwnProperty(name)) {
            								delete data[name];
            						}
            				}
            				return data;
            		}
            		_validate(data) {
            				if (!data.validated) {
            						if (!this._validator) {
            								this._validator = new StandardMaterialValidator();
            						}
            						this._validator.validate(data);
            				}
            				return data;
            		}
            		constructor(){
            				this._validator = null;
            		}
            }
            
            var PLACEHOLDER_MAP = {
            		aoMap: 'white',
            		aoDetailMap: 'white',
            		diffuseMap: 'gray',
            		diffuseDetailMap: 'gray',
            		specularMap: 'gray',
            		specularityFactorMap: 'white',
            		metalnessMap: 'black',
            		glossMap: 'gray',
            		sheenMap: 'black',
            		sheenGlossMap: 'gray',
            		clearCoatMap: 'black',
            		clearCoatGlossMap: 'gray',
            		clearCoatNormalMap: 'normal',
            		refractionMap: 'white',
            		emissiveMap: 'gray',
            		normalMap: 'normal',
            		normalDetailMap: 'normal',
            		heightMap: 'gray',
            		opacityMap: 'gray',
            		sphereMap: 'gray',
            		lightMap: 'white',
            		thicknessMap: 'black',
            		iridescenceMap: 'black',
            		iridescenceThicknessMap: 'black',
            		envAtlas: 'black'
            };
            class MaterialHandler extends ResourceHandler {
            		load(url, callback) {
            				if (typeof url === 'string') {
            						url = {
            								load: url,
            								original: url
            						};
            				}
            				http.get(url.load, {
            						retry: this.maxRetries > 0,
            						maxRetries: this.maxRetries
            				}, (err, response)=>{
            						if (!err) {
            								if (callback) {
            										response._engine = true;
            										callback(null, response);
            								}
            						} else {
            								if (callback) {
            										callback("Error loading material: " + url.original + " [" + err + "]");
            								}
            						}
            				});
            		}
            		open(url, data) {
            				var material = this._parser.parse(data);
            				if (data._engine) {
            						material._data = data;
            						delete data._engine;
            				}
            				return material;
            		}
            		patch(asset, assets) {
            				if (asset.resource._data) {
            						asset._data = asset.resource._data;
            						delete asset.resource._data;
            				}
            				asset.data.name = asset.name;
            				asset.resource.name = asset.name;
            				this._bindAndAssignAssets(asset, assets);
            				asset.off('unload', this._onAssetUnload, this);
            				asset.on('unload', this._onAssetUnload, this);
            		}
            		_onAssetUnload(asset) {
            				delete asset.data.parameters;
            				delete asset.data.chunks;
            				delete asset.data.name;
            		}
            		_assignTexture(parameterName, materialAsset, texture) {
            				materialAsset.resource[parameterName] = texture;
            		}
            		_getPlaceholderTexture(parameterName) {
            				var placeholder = PLACEHOLDER_MAP[parameterName];
            				return getBuiltInTexture(this._device, placeholder);
            		}
            		_assignPlaceholderTexture(parameterName, materialAsset) {
            				materialAsset.resource[parameterName] = this._getPlaceholderTexture(parameterName);
            		}
            		_onTextureLoad(parameterName, materialAsset, textureAsset) {
            				this._assignTexture(parameterName, materialAsset, textureAsset.resource);
            				materialAsset.resource.update();
            		}
            		_onTextureAdd(parameterName, materialAsset, textureAsset) {
            				this._assets.load(textureAsset);
            		}
            		_onTextureRemoveOrUnload(parameterName, materialAsset, textureAsset) {
            				var material = materialAsset.resource;
            				if (material) {
            						if (materialAsset.resource[parameterName] === textureAsset.resource) {
            								this._assignPlaceholderTexture(parameterName, materialAsset);
            								material.update();
            						}
            				}
            		}
            		_assignCubemap(parameterName, materialAsset, textures) {
            				materialAsset.resource[parameterName] = textures[0];
            				if (parameterName === 'cubeMap') {
            						var prefiltered = textures.slice(1);
            						if (prefiltered.every((t)=>t)) {
            								materialAsset.resource.prefilteredCubemaps = prefiltered;
            						} else if (prefiltered[0]) {
            								materialAsset.resource.envAtlas = prefiltered[0];
            						}
            				}
            		}
            		_onCubemapLoad(parameterName, materialAsset, cubemapAsset) {
            				this._assignCubemap(parameterName, materialAsset, cubemapAsset.resources);
            				this._parser.initialize(materialAsset.resource, materialAsset.data);
            		}
            		_onCubemapAdd(parameterName, materialAsset, cubemapAsset) {
            				this._assets.load(cubemapAsset);
            		}
            		_onCubemapRemoveOrUnload(parameterName, materialAsset, cubemapAsset) {
            				var material = materialAsset.resource;
            				if (materialAsset.data.prefilteredCubeMap128 === cubemapAsset.resources[1]) {
            						this._assignCubemap(parameterName, materialAsset, [
            								null,
            								null,
            								null,
            								null,
            								null,
            								null,
            								null
            						]);
            						material.update();
            				}
            		}
            		_bindAndAssignAssets(materialAsset, assets) {
            				var data = this._parser.migrate(materialAsset.data);
            				var material = materialAsset.resource;
            				var pathMapping = data.mappingFormat === 'path';
            				var TEXTURES = standardMaterialTextureParameters;
            				var i, name, assetReference;
            				for(i = 0; i < TEXTURES.length; i++){
            						name = TEXTURES[i];
            						assetReference = material._assetReferences[name];
            						var dataAssetId = data[name];
            						var materialTexture = material[name];
            						var isPlaceHolderTexture = materialTexture === this._getPlaceholderTexture(name);
            						var dataValidated = data.validated;
            						if (dataAssetId && (!materialTexture || !dataValidated || isPlaceHolderTexture)) {
            								if (!assetReference) {
            										assetReference = new AssetReference(name, materialAsset, assets, {
            												load: this._onTextureLoad,
            												add: this._onTextureAdd,
            												remove: this._onTextureRemoveOrUnload,
            												unload: this._onTextureRemoveOrUnload
            										}, this);
            										material._assetReferences[name] = assetReference;
            								}
            								if (pathMapping) {
            										assetReference.url = materialAsset.getAbsoluteUrl(dataAssetId);
            								} else {
            										assetReference.id = dataAssetId;
            								}
            								if (assetReference.asset) {
            										if (assetReference.asset.resource) {
            												this._assignTexture(name, materialAsset, assetReference.asset.resource);
            										} else {
            												this._assignPlaceholderTexture(name, materialAsset);
            										}
            										assets.load(assetReference.asset);
            								}
            						} else {
            								if (assetReference) {
            										if (pathMapping) {
            												assetReference.url = null;
            										} else {
            												assetReference.id = null;
            										}
            								}
            						}
            				}
            				var CUBEMAPS = standardMaterialCubemapParameters;
            				for(i = 0; i < CUBEMAPS.length; i++){
            						name = CUBEMAPS[i];
            						assetReference = material._assetReferences[name];
            						if (data[name] && !materialAsset.data.prefilteredCubeMap128) {
            								if (!assetReference) {
            										assetReference = new AssetReference(name, materialAsset, assets, {
            												load: this._onCubemapLoad,
            												add: this._onCubemapAdd,
            												remove: this._onCubemapRemoveOrUnload,
            												unload: this._onCubemapRemoveOrUnload
            										}, this);
            										material._assetReferences[name] = assetReference;
            								}
            								if (pathMapping) {
            										assetReference.url = data[name];
            								} else {
            										assetReference.id = data[name];
            								}
            								if (assetReference.asset) {
            										if (assetReference.asset.loaded) {
            												this._assignCubemap(name, materialAsset, assetReference.asset.resources);
            										}
            										assets.load(assetReference.asset);
            								}
            						}
            				}
            				this._parser.initialize(material, data);
            		}
            		constructor(app){
            				super(app, 'material');
            				this._assets = app.assets;
            				this._device = app.graphicsDevice;
            				this._parser = new JsonStandardMaterialParser();
            		}
            }
            
            class GlbModelParser {
            		parse(data, callback, asset) {
            				var _asset_options;
            				GlbParser.parse('filename.glb', '', data, this._device, this._assets, (_asset_options = asset == null ? void 0 : asset.options) != null ? _asset_options : {}, (err, result)=>{
            						if (err) {
            								callback(err);
            						} else {
            								var model = GlbContainerResource.createModel(result, this._defaultMaterial);
            								result.destroy();
            								callback(null, model);
            						}
            				});
            		}
            		constructor(modelHandler){
            				this._device = modelHandler.device;
            				this._defaultMaterial = modelHandler.defaultMaterial;
            				this._assets = modelHandler.assets;
            		}
            }
            
            var JSON_PRIMITIVE_TYPE = {
            		'points': PRIMITIVE_POINTS,
            		'lines': PRIMITIVE_LINES,
            		'lineloop': PRIMITIVE_LINELOOP,
            		'linestrip': PRIMITIVE_LINESTRIP,
            		'triangles': PRIMITIVE_TRIANGLES,
            		'trianglestrip': PRIMITIVE_TRISTRIP,
            		'trianglefan': PRIMITIVE_TRIFAN
            };
            var JSON_VERTEX_ELEMENT_TYPE = {
            		'int8': TYPE_INT8,
            		'uint8': TYPE_UINT8,
            		'int16': TYPE_INT16,
            		'uint16': TYPE_UINT16,
            		'int32': TYPE_INT32,
            		'uint32': TYPE_UINT32,
            		'float32': TYPE_FLOAT32
            };
            class JsonModelParser {
            		parse(data, callback) {
            				var modelData = data.model;
            				if (!modelData) {
            						callback(null, null);
            						return;
            				}
            				if (modelData.version <= 1) {
            						callback('JsonModelParser#parse: Trying to parse unsupported model format.');
            						return;
            				}
            				var nodes = this._parseNodes(data);
            				var skins = this._parseSkins(data, nodes);
            				var vertexBuffers = this._parseVertexBuffers(data);
            				var indices = this._parseIndexBuffers(data, vertexBuffers);
            				var morphs = this._parseMorphs(data, nodes, vertexBuffers);
            				var meshes = this._parseMeshes(data, skins.skins, morphs.morphs, vertexBuffers, indices.buffer, indices.data);
            				var meshInstances = this._parseMeshInstances(data, nodes, meshes, skins.skins, skins.instances, morphs.morphs, morphs.instances);
            				var model = new Model();
            				model.graph = nodes[0];
            				model.meshInstances = meshInstances;
            				model.skinInstances = skins.instances;
            				model.morphInstances = morphs.instances;
            				model.getGraph().syncHierarchy();
            				callback(null, model);
            		}
            		_parseNodes(data) {
            				var modelData = data.model;
            				var nodes = [];
            				var i;
            				for(i = 0; i < modelData.nodes.length; i++){
            						var nodeData = modelData.nodes[i];
            						var node = new GraphNode(nodeData.name);
            						node.setLocalPosition(nodeData.position[0], nodeData.position[1], nodeData.position[2]);
            						node.setLocalEulerAngles(nodeData.rotation[0], nodeData.rotation[1], nodeData.rotation[2]);
            						node.setLocalScale(nodeData.scale[0], nodeData.scale[1], nodeData.scale[2]);
            						node.scaleCompensation = !!nodeData.scaleCompensation;
            						nodes.push(node);
            				}
            				for(i = 1; i < modelData.parents.length; i++){
            						nodes[modelData.parents[i]].addChild(nodes[i]);
            				}
            				return nodes;
            		}
            		_parseSkins(data, nodes) {
            				var modelData = data.model;
            				var skins = [];
            				var skinInstances = [];
            				var i, j;
            				for(i = 0; i < modelData.skins.length; i++){
            						var skinData = modelData.skins[i];
            						var inverseBindMatrices = [];
            						for(j = 0; j < skinData.inverseBindMatrices.length; j++){
            								var ibm = skinData.inverseBindMatrices[j];
            								inverseBindMatrices[j] = new Mat4().set(ibm);
            						}
            						var skin = new Skin(this._device, inverseBindMatrices, skinData.boneNames);
            						skins.push(skin);
            						var skinInstance = new SkinInstance(skin);
            						var bones = [];
            						for(j = 0; j < skin.boneNames.length; j++){
            								var boneName = skin.boneNames[j];
            								var bone = nodes[0].findByName(boneName);
            								bones.push(bone);
            						}
            						skinInstance.bones = bones;
            						skinInstances.push(skinInstance);
            				}
            				return {
            						skins: skins,
            						instances: skinInstances
            				};
            		}
            		_getMorphVertexCount(modelData, morphIndex, vertexBuffers) {
            				for(var i = 0; i < modelData.meshes.length; i++){
            						var meshData = modelData.meshes[i];
            						if (meshData.morph === morphIndex) {
            								var vertexBuffer = vertexBuffers[meshData.vertices];
            								return vertexBuffer.numVertices;
            						}
            				}
            				return undefined;
            		}
            		_parseMorphs(data, nodes, vertexBuffers) {
            				var modelData = data.model;
            				var morphs = [];
            				var morphInstances = [];
            				var i, j, vertexCount;
            				var targets, morphTarget, morphTargetArray;
            				if (modelData.morphs) {
            						var sparseToFull = function sparseToFull(data, indices, totalCount) {
            								var full = new Float32Array(totalCount * 3);
            								for(var s = 0; s < indices.length; s++){
            										var dstIndex = indices[s] * 3;
            										full[dstIndex] = data[s * 3];
            										full[dstIndex + 1] = data[s * 3 + 1];
            										full[dstIndex + 2] = data[s * 3 + 2];
            								}
            								return full;
            						};
            						for(i = 0; i < modelData.morphs.length; i++){
            								targets = modelData.morphs[i].targets;
            								morphTargetArray = [];
            								vertexCount = this._getMorphVertexCount(modelData, i, vertexBuffers);
            								for(j = 0; j < targets.length; j++){
            										var targetAabb = targets[j].aabb;
            										var min = targetAabb.min;
            										var max = targetAabb.max;
            										var aabb = new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
            										var indices = targets[j].indices;
            										var deltaPositions = targets[j].deltaPositions;
            										var deltaNormals = targets[j].deltaNormals;
            										if (indices) {
            												deltaPositions = sparseToFull(deltaPositions, indices, vertexCount);
            												deltaNormals = sparseToFull(deltaNormals, indices, vertexCount);
            										}
            										morphTarget = new MorphTarget({
            												deltaPositions: deltaPositions,
            												deltaNormals: deltaNormals,
            												name: targets[j].name,
            												aabb: aabb
            										});
            										morphTargetArray.push(morphTarget);
            								}
            								var morph = new Morph(morphTargetArray, this._device);
            								morphs.push(morph);
            								var morphInstance = new MorphInstance(morph);
            								morphInstances.push(morphInstance);
            						}
            				}
            				return {
            						morphs: morphs,
            						instances: morphInstances
            				};
            		}
            		_parseVertexBuffers(data) {
            				var modelData = data.model;
            				var vertexBuffers = [];
            				var attributeMap = {
            						position: SEMANTIC_POSITION,
            						normal: SEMANTIC_NORMAL,
            						tangent: SEMANTIC_TANGENT,
            						blendWeight: SEMANTIC_BLENDWEIGHT,
            						blendIndices: SEMANTIC_BLENDINDICES,
            						color: SEMANTIC_COLOR,
            						texCoord0: SEMANTIC_TEXCOORD0,
            						texCoord1: SEMANTIC_TEXCOORD1,
            						texCoord2: SEMANTIC_TEXCOORD2,
            						texCoord3: SEMANTIC_TEXCOORD3,
            						texCoord4: SEMANTIC_TEXCOORD4,
            						texCoord5: SEMANTIC_TEXCOORD5,
            						texCoord6: SEMANTIC_TEXCOORD6,
            						texCoord7: SEMANTIC_TEXCOORD7
            				};
            				for(var i = 0; i < modelData.vertices.length; i++){
            						var vertexData = modelData.vertices[i];
            						var formatDesc = [];
            						for(var attributeName in vertexData){
            								var attribute = vertexData[attributeName];
            								formatDesc.push({
            										semantic: attributeMap[attributeName],
            										components: attribute.components,
            										type: JSON_VERTEX_ELEMENT_TYPE[attribute.type],
            										normalize: attributeMap[attributeName] === SEMANTIC_COLOR
            								});
            						}
            						var vertexFormat = new VertexFormat(this._device, formatDesc);
            						var numVertices = vertexData.position.data.length / vertexData.position.components;
            						var vertexBuffer = new VertexBuffer(this._device, vertexFormat, numVertices);
            						var iterator = new VertexIterator(vertexBuffer);
            						for(var j = 0; j < numVertices; j++){
            								for(var attributeName1 in vertexData){
            										var attribute1 = vertexData[attributeName1];
            										switch(attribute1.components){
            												case 1:
            														iterator.element[attributeMap[attributeName1]].set(attribute1.data[j]);
            														break;
            												case 2:
            														iterator.element[attributeMap[attributeName1]].set(attribute1.data[j * 2], 1.0 - attribute1.data[j * 2 + 1]);
            														break;
            												case 3:
            														iterator.element[attributeMap[attributeName1]].set(attribute1.data[j * 3], attribute1.data[j * 3 + 1], attribute1.data[j * 3 + 2]);
            														break;
            												case 4:
            														iterator.element[attributeMap[attributeName1]].set(attribute1.data[j * 4], attribute1.data[j * 4 + 1], attribute1.data[j * 4 + 2], attribute1.data[j * 4 + 3]);
            														break;
            										}
            								}
            								iterator.next();
            						}
            						iterator.end();
            						vertexBuffers.push(vertexBuffer);
            				}
            				return vertexBuffers;
            		}
            		_parseIndexBuffers(data, vertexBuffers) {
            				var modelData = data.model;
            				var indexBuffer = null;
            				var indexData = null;
            				var i;
            				var numIndices = 0;
            				for(i = 0; i < modelData.meshes.length; i++){
            						var meshData = modelData.meshes[i];
            						if (meshData.indices !== undefined) {
            								numIndices += meshData.indices.length;
            						}
            				}
            				var maxVerts = 0;
            				for(i = 0; i < vertexBuffers.length; i++){
            						maxVerts = Math.max(maxVerts, vertexBuffers[i].numVertices);
            				}
            				if (numIndices > 0) {
            						if (maxVerts > 0xFFFF) {
            								indexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT32, numIndices);
            								indexData = new Uint32Array(indexBuffer.lock());
            						} else {
            								indexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT16, numIndices);
            								indexData = new Uint16Array(indexBuffer.lock());
            						}
            				}
            				return {
            						buffer: indexBuffer,
            						data: indexData
            				};
            		}
            		_parseMeshes(data, skins, morphs, vertexBuffers, indexBuffer, indexData) {
            				var modelData = data.model;
            				var meshes = [];
            				var indexBase = 0;
            				for(var i = 0; i < modelData.meshes.length; i++){
            						var meshData = modelData.meshes[i];
            						var meshAabb = meshData.aabb;
            						var min = meshAabb.min;
            						var max = meshAabb.max;
            						var aabb = new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));
            						var indexed = meshData.indices !== undefined;
            						var mesh = new Mesh(this._device);
            						mesh.vertexBuffer = vertexBuffers[meshData.vertices];
            						mesh.indexBuffer[0] = indexed ? indexBuffer : null;
            						mesh.primitive[0].type = JSON_PRIMITIVE_TYPE[meshData.type];
            						mesh.primitive[0].base = indexed ? meshData.base + indexBase : meshData.base;
            						mesh.primitive[0].count = meshData.count;
            						mesh.primitive[0].indexed = indexed;
            						mesh.skin = meshData.skin !== undefined ? skins[meshData.skin] : null;
            						mesh.morph = meshData.morph !== undefined ? morphs[meshData.morph] : null;
            						mesh.aabb = aabb;
            						if (indexed) {
            								indexData.set(meshData.indices, indexBase);
            								indexBase += meshData.indices.length;
            						}
            						meshes.push(mesh);
            				}
            				if (indexBuffer !== null) {
            						indexBuffer.unlock();
            				}
            				return meshes;
            		}
            		_parseMeshInstances(data, nodes, meshes, skins, skinInstances, morphs, morphInstances) {
            				var modelData = data.model;
            				var meshInstances = [];
            				var i;
            				for(i = 0; i < modelData.meshInstances.length; i++){
            						var meshInstanceData = modelData.meshInstances[i];
            						var node = nodes[meshInstanceData.node];
            						var mesh = meshes[meshInstanceData.mesh];
            						var meshInstance = new MeshInstance(mesh, this._defaultMaterial, node);
            						if (mesh.skin) {
            								var skinIndex = skins.indexOf(mesh.skin);
            								meshInstance.skinInstance = skinInstances[skinIndex];
            						}
            						if (mesh.morph) {
            								var morphIndex = morphs.indexOf(mesh.morph);
            								meshInstance.morphInstance = morphInstances[morphIndex];
            						}
            						meshInstances.push(meshInstance);
            				}
            				return meshInstances;
            		}
            		constructor(modelHandler){
            				this._device = modelHandler.device;
            				this._defaultMaterial = modelHandler.defaultMaterial;
            		}
            }
            
            class ModelHandler extends ResourceHandler {
            		load(url, callback, asset) {
            				if (typeof url === 'string') {
            						url = {
            								load: url,
            								original: url
            						};
            				}
            				var options = {
            						retry: this.maxRetries > 0,
            						maxRetries: this.maxRetries
            				};
            				if (url.load.startsWith('blob:') || url.load.startsWith('data:')) {
            						if (path.getExtension(url.original).toLowerCase() === '.glb') {
            								options.responseType = Http.ResponseType.ARRAY_BUFFER;
            						} else {
            								options.responseType = Http.ResponseType.JSON;
            						}
            				}
            				http.get(url.load, options, (err, response)=>{
            						if (!callback) {
            								return;
            						}
            						if (!err) {
            								for(var i = 0; i < this._parsers.length; i++){
            										var p = this._parsers[i];
            										if (p.decider(url.original, response)) {
            												p.parser.parse(response, (err, parseResult)=>{
            														if (err) {
            																callback(err);
            														} else {
            																callback(null, parseResult);
            														}
            												}, asset);
            												return;
            										}
            								}
            								callback('No parsers found');
            						} else {
            								callback("Error loading model: " + url.original + " [" + err + "]");
            						}
            				});
            		}
            		open(url, data) {
            				return data;
            		}
            		patch(asset, assets) {
            				if (!asset.resource) {
            						return;
            				}
            				var data = asset.data;
            				var self = this;
            				asset.resource.meshInstances.forEach((meshInstance, i)=>{
            						if (data.mapping) {
            								var handleMaterial = function handleMaterial1(asset) {
            										if (asset.resource) {
            												meshInstance.material = asset.resource;
            										} else {
            												asset.once('load', handleMaterial);
            												assets.load(asset);
            										}
            										asset.once('remove', (asset)=>{
            												if (meshInstance.material === asset.resource) {
            														meshInstance.material = self.defaultMaterial;
            												}
            										});
            								};
            								if (!data.mapping[i]) {
            										meshInstance.material = self.defaultMaterial;
            										return;
            								}
            								var id = data.mapping[i].material;
            								var url = data.mapping[i].path;
            								var material;
            								if (id !== undefined) {
            										if (!id) {
            												meshInstance.material = self.defaultMaterial;
            										} else {
            												material = assets.get(id);
            												if (material) {
            														handleMaterial(material);
            												} else {
            														assets.once("add:" + id, handleMaterial);
            												}
            										}
            								} else if (url) {
            										var path = asset.getAbsoluteUrl(data.mapping[i].path);
            										material = assets.getByUrl(path);
            										if (material) {
            												handleMaterial(material);
            										} else {
            												assets.once("add:url:" + path, handleMaterial);
            										}
            								}
            						}
            				});
            		}
            		addParser(parser, decider) {
            				this._parsers.push({
            						parser: parser,
            						decider: decider
            				});
            		}
            		constructor(app){
            				super(app, 'model');
            				this._parsers = [];
            				this.device = app.graphicsDevice;
            				this.assets = app.assets;
            				this.defaultMaterial = getDefaultMaterial(this.device);
            				this.addParser(new JsonModelParser(this), (url, data)=>{
            						return path.getExtension(url) === '.json';
            				});
            				this.addParser(new GlbModelParser(this), (url, data)=>{
            						return path.getExtension(url) === '.glb';
            				});
            		}
            }
            
            class SceneHandler extends ResourceHandler {
            		load(url, callback) {
            				SceneUtils.load(url, this.maxRetries, callback);
            		}
            		open(url, data) {
            				this._app.systems.script.preloading = true;
            				var parser = new SceneParser(this._app, false);
            				var parent = parser.parse(data);
            				var scene = this._app.scene;
            				scene.root = parent;
            				this._app.applySceneSettings(data.settings);
            				this._app.systems.script.preloading = false;
            				return scene;
            		}
            		constructor(app){
            				super(app, 'scene');
            		}
            }
            
            class ScriptTypes {
            		static push(Type) {
            				ScriptTypes._types.push(Type);
            		}
            }
            ScriptTypes._types = [];
            
            var reservedScriptNames = new Set([
            		'system',
            		'entity',
            		'create',
            		'destroy',
            		'swap',
            		'move',
            		'data',
            		"scripts",
            		"_scripts",
            		"_scriptsIndex",
            		"_scriptsData",
            		'enabled',
            		'_oldState',
            		'onEnable',
            		'onDisable',
            		'onPostStateChange',
            		'_onSetEnabled',
            		'_checkState',
            		'_onBeforeRemove',
            		'_onInitializeAttributes',
            		'_onInitialize',
            		'_onPostInitialize',
            		'_onUpdate',
            		'_onPostUpdate',
            		'_callbacks',
            		'_callbackActive',
            		'has',
            		'get',
            		'on',
            		'off',
            		'fire',
            		'once',
            		'hasEvent'
            ]);
            var reservedAttributes = {};
            ScriptAttributes.reservedNames.forEach((value, value2, set)=>{
            		reservedAttributes[value] = 1;
            });
            function registerScript(script, name, app) {
            		if (typeof script !== 'function') {
            				throw new Error("script class: '" + script + "' must be a constructor function (i.e. class).");
            		}
            		if (!(script.prototype instanceof Script)) {
            				throw new Error("script class: '" + ScriptType.__getScriptName(script) + "' does not extend pc.Script.");
            		}
            		name = name || script.__name || ScriptType.__getScriptName(script);
            		if (reservedScriptNames.has(name)) {
            				throw new Error("script name: '" + name + "' is reserved, please change script name");
            		}
            		script.__name = name;
            		var registry = AppBase.getApplication().scripts;
            		registry.add(script);
            		ScriptTypes.push(script);
            }
            
            var toLowerCamelCase = (str)=>str[0].toLowerCase() + str.substring(1);
            class ScriptHandler extends ResourceHandler {
            		clearCache() {
            				for(var key in this._cache){
            						var element = this._cache[key];
            						var parent = element.parentNode;
            						if (parent) {
            								parent.removeChild(element);
            						}
            				}
            				this._cache = {};
            		}
            		load(url, callback) {
            				if (typeof url === 'string') {
            						url = {
            								load: url,
            								original: url
            						};
            				}
            				var self = this;
            				this._app;
            				var onScriptLoad = (url.load, (err, url, extra)=>{
            						if (!err) {
            								var obj = {};
            								for(var i = 0; i < ScriptTypes._types.length; i++){
            										obj[ScriptTypes._types[i].name] = ScriptTypes._types[i];
            								}
            								ScriptTypes._types.length = 0;
            								callback(null, obj, extra);
            								var urlWithoutEndHash = url.split('&hash=')[0];
            								delete self._loader._cache[ResourceLoader.makeKey(urlWithoutEndHash, "script")];
            						} else {
            								callback(err);
            						}
            				});
            				var [basePath] = url.load.split('?');
            				var isEsmScript = basePath.endsWith('.mjs');
            				if (isEsmScript) {
            						this._loadModule(basePath, onScriptLoad);
            				} else {
            						this._loadScript(url.load, onScriptLoad);
            				}
            		}
            		open(url, data) {
            				return data;
            		}
            		patch(asset, assets) {}
            		_loadScript(url, callback) {
            				var head = document.head;
            				var element = document.createElement("script");
            				this._cache[url] = element;
            				element.async = false;
            				element.addEventListener('error', (e)=>{
            						callback("Script: " + e.target.src + " failed to load");
            				}, false);
            				var done = false;
            				element.onload = element.onreadystatechange = function() {
            						if (!done && (!this.readyState || this.readyState === 'loaded' || this.readyState === 'complete')) {
            								done = true;
            								callback(null, url, element);
            						}
            				};
            				element.src = url;
            				head.appendChild(element);
            		}
            		_loadModule(url, callback) {
            				var isBrowserWithOrigin = platform.browser && window.location.origin !== 'null';
            				var baseUrl = isBrowserWithOrigin ? window.location.origin + window.location.pathname : import.meta.url;
            				var importUrl = new URL(url, baseUrl);
            				import(/* @vite-ignore */ /* webpackIgnore: true */ importUrl.toString()).then((module)=>{
            						var _this__app_assets_find_data, _this__app_assets_find;
            						var filename = importUrl.pathname.split('/').pop();
            						var scriptSchema = (_this__app_assets_find = this._app.assets.find(filename, "script")) == null ? void 0 : (_this__app_assets_find_data = _this__app_assets_find.data) == null ? void 0 : _this__app_assets_find_data.scripts;
            						for(var key in module){
            								var scriptClass = module[key];
            								var extendsScriptType = scriptClass.prototype instanceof Script;
            								if (extendsScriptType) {
            										var scriptName = toLowerCamelCase(scriptClass.name);
            										registerScript(scriptClass, scriptName);
            										if (scriptSchema) this._app.scripts.addSchema(scriptName, scriptSchema[scriptName]);
            								}
            						}
            						callback(null, url, null);
            				}).catch((err)=>{
            						callback(err);
            				});
            		}
            		constructor(app){
            				super(app, "script");
            				this._scripts = {};
            				this._cache = {};
            		}
            }
            
            class ShaderHandler extends ResourceHandler {
            		load(url, callback) {
            				if (typeof url === 'string') {
            						url = {
            								load: url,
            								original: url
            						};
            				}
            				http.get(url.load, {
            						retry: this.maxRetries > 0,
            						maxRetries: this.maxRetries
            				}, (err, response)=>{
            						if (!err) {
            								callback(null, response);
            						} else {
            								callback("Error loading shader resource: " + url.original + " [" + err + "]");
            						}
            				});
            		}
            		openBinary(data) {
            				var _this_decoder;
            				(_this_decoder = this.decoder) != null ? _this_decoder : this.decoder = new TextDecoder('utf-8');
            				return this.decoder.decode(data);
            		}
            		constructor(app){
            				super(app, 'shader'), this.decoder = null;
            		}
            }
            
            function onTextureAtlasLoaded(atlasAsset) {
            		var spriteAsset = this;
            		if (spriteAsset.resource) {
            				spriteAsset.resource.atlas = atlasAsset.resource;
            		}
            }
            function onTextureAtlasAdded(atlasAsset) {
            		var spriteAsset = this;
            		spriteAsset.registry.load(atlasAsset);
            }
            class SpriteHandler extends ResourceHandler {
            		load(url, callback) {
            				if (typeof url === 'string') {
            						url = {
            								load: url,
            								original: url
            						};
            				}
            				if (path.getExtension(url.original) === '.json') {
            						http.get(url.load, {
            								retry: this.maxRetries > 0,
            								maxRetries: this.maxRetries
            						}, (err, response)=>{
            								if (!err) {
            										callback(null, response);
            								} else {
            										callback(err);
            								}
            						});
            				}
            		}
            		open(url, data) {
            				var sprite = new Sprite(this._device);
            				if (url) {
            						sprite.__data = data;
            				}
            				return sprite;
            		}
            		patch(asset, assets) {
            				var sprite = asset.resource;
            				if (sprite.__data) {
            						asset.data.pixelsPerUnit = sprite.__data.pixelsPerUnit;
            						asset.data.renderMode = sprite.__data.renderMode;
            						asset.data.frameKeys = sprite.__data.frameKeys;
            						if (sprite.__data.textureAtlasAsset) {
            								var atlas = assets.getByUrl(sprite.__data.textureAtlasAsset);
            								if (atlas) {
            										asset.data.textureAtlasAsset = atlas.id;
            								} else {
            										console.warn("Could not find textureatlas with url: " + sprite.__data.textureAtlasAsset);
            								}
            						}
            				}
            				sprite.startUpdate();
            				sprite.renderMode = asset.data.renderMode;
            				sprite.pixelsPerUnit = asset.data.pixelsPerUnit;
            				sprite.frameKeys = asset.data.frameKeys;
            				this._updateAtlas(asset);
            				sprite.endUpdate();
            				asset.off('change', this._onAssetChange, this);
            				asset.on('change', this._onAssetChange, this);
            		}
            		_updateAtlas(asset) {
            				var sprite = asset.resource;
            				if (!asset.data.textureAtlasAsset) {
            						sprite.atlas = null;
            						return;
            				}
            				this._assets.off("load:" + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);
            				this._assets.on("load:" + asset.data.textureAtlasAsset, onTextureAtlasLoaded, asset);
            				var atlasAsset = this._assets.get(asset.data.textureAtlasAsset);
            				if (atlasAsset && atlasAsset.resource) {
            						sprite.atlas = atlasAsset.resource;
            				} else {
            						if (!atlasAsset) {
            								this._assets.off("add:" + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);
            								this._assets.on("add:" + asset.data.textureAtlasAsset, onTextureAtlasAdded, asset);
            						} else {
            								this._assets.load(atlasAsset);
            						}
            				}
            		}
            		_onAssetChange(asset, attribute, value, oldValue) {
            				if (attribute === 'data') {
            						if (value && value.textureAtlasAsset && oldValue && value.textureAtlasAsset !== oldValue.textureAtlasAsset) {
            								this._assets.off("load:" + oldValue.textureAtlasAsset, onTextureAtlasLoaded, asset);
            								this._assets.off("add:" + oldValue.textureAtlasAsset, onTextureAtlasAdded, asset);
            						}
            				}
            		}
            		constructor(app){
            				super(app, 'sprite');
            				this._assets = app.assets;
            				this._device = app.graphicsDevice;
            		}
            }
            
            class Template {
            		instantiate() {
            				if (!this._templateRoot) {
            						this._parseTemplate();
            				}
            				return this._templateRoot.clone();
            		}
            		_parseTemplate() {
            				var parser = new SceneParser(this._app, true);
            				this._templateRoot = parser.parse(this._data);
            		}
            		constructor(app, data){
            				this._templateRoot = null;
            				this._app = app;
            				this._data = data;
            		}
            }
            
            class TemplateHandler extends ResourceHandler {
            		load(url, callback) {
            				if (typeof url === 'string') {
            						url = {
            								load: url,
            								original: url
            						};
            				}
            				var options = {
            						retry: this.maxRetries > 0,
            						maxRetries: this.maxRetries
            				};
            				http.get(url.load, options, (err, response)=>{
            						if (err) {
            								callback("Error requesting template: " + url.original);
            						} else {
            								callback(err, response);
            						}
            				});
            		}
            		open(url, data) {
            				return new Template(this._app, data);
            		}
            		openBinary(data) {
            				var _this_decoder;
            				(_this_decoder = this.decoder) != null ? _this_decoder : this.decoder = new TextDecoder('utf-8');
            				return new Template(this._app, JSON.parse(this.decoder.decode(data)));
            		}
            		constructor(app){
            				super(app, 'template'), this.decoder = null;
            		}
            }
            
            class TextHandler extends ResourceHandler {
            		load(url, callback) {
            				if (typeof url === 'string') {
            						url = {
            								load: url,
            								original: url
            						};
            				}
            				http.get(url.load, {
            						retry: this.maxRetries > 0,
            						maxRetries: this.maxRetries
            				}, (err, response)=>{
            						if (!err) {
            								callback(null, response);
            						} else {
            								callback("Error loading text resource: " + url.original + " [" + err + "]");
            						}
            				});
            		}
            		openBinary(data) {
            				var _this_decoder;
            				(_this_decoder = this.decoder) != null ? _this_decoder : this.decoder = new TextDecoder('utf-8');
            				return this.decoder.decode(data);
            		}
            		constructor(app){
            				super(app, 'text'), this.decoder = null;
            		}
            }
            
            var JSON_ADDRESS_MODE$1 = {
            		'repeat': ADDRESS_REPEAT,
            		'clamp': ADDRESS_CLAMP_TO_EDGE,
            		'mirror': ADDRESS_MIRRORED_REPEAT
            };
            var JSON_FILTER_MODE$1 = {
            		'nearest': FILTER_NEAREST,
            		'linear': FILTER_LINEAR,
            		'nearest_mip_nearest': FILTER_NEAREST_MIPMAP_NEAREST,
            		'linear_mip_nearest': FILTER_LINEAR_MIPMAP_NEAREST,
            		'nearest_mip_linear': FILTER_NEAREST_MIPMAP_LINEAR,
            		'linear_mip_linear': FILTER_LINEAR_MIPMAP_LINEAR
            };
            var regexFrame = /^data\.frames\.(\d+)$/;
            class TextureAtlasHandler extends ResourceHandler {
            		load(url, callback) {
            				if (typeof url === 'string') {
            						url = {
            								load: url,
            								original: url
            						};
            				}
            				var self = this;
            				var handler = this._loader.getHandler('texture');
            				if (path.getExtension(url.original) === '.json') {
            						http.get(url.load, {
            								retry: this.maxRetries > 0,
            								maxRetries: this.maxRetries
            						}, (err, response)=>{
            								if (!err) {
            										var textureUrl = url.original.replace('.json', '.png');
            										self._loader.load(textureUrl, 'texture', (err, texture)=>{
            												if (err) {
            														callback(err);
            												} else {
            														callback(null, {
            																data: response,
            																texture: texture
            														});
            												}
            										});
            								} else {
            										callback(err);
            								}
            						});
            				} else {
            						handler.load(url, callback);
            				}
            		}
            		open(url, data, asset) {
            				var resource = new TextureAtlas();
            				if (data.texture && data.data) {
            						resource.texture = data.texture;
            						resource.__data = data.data;
            				} else {
            						var handler = this._loader.getHandler('texture');
            						var texture = handler.open(url, data, asset);
            						if (!texture) return null;
            						resource.texture = texture;
            				}
            				return resource;
            		}
            		patch(asset, assets) {
            				if (!asset.resource) {
            						return;
            				}
            				if (asset.resource.__data) {
            						if (asset.resource.__data.minfilter !== undefined) asset.data.minfilter = asset.resource.__data.minfilter;
            						if (asset.resource.__data.magfilter !== undefined) asset.data.magfilter = asset.resource.__data.magfilter;
            						if (asset.resource.__data.addressu !== undefined) asset.data.addressu = asset.resource.__data.addressu;
            						if (asset.resource.__data.addressv !== undefined) asset.data.addressv = asset.resource.__data.addressv;
            						if (asset.resource.__data.mipmaps !== undefined) asset.data.mipmaps = asset.resource.__data.mipmaps;
            						if (asset.resource.__data.anisotropy !== undefined) asset.data.anisotropy = asset.resource.__data.anisotropy;
            						if (asset.resource.__data.rgbm !== undefined) asset.data.rgbm = !!asset.resource.__data.rgbm;
            						asset.data.frames = asset.resource.__data.frames;
            						delete asset.resource.__data;
            				}
            				var texture = asset.resource.texture;
            				if (texture) {
            						texture.name = asset.name;
            						if (asset.data.hasOwnProperty('minfilter') && texture.minFilter !== JSON_FILTER_MODE$1[asset.data.minfilter]) {
            								texture.minFilter = JSON_FILTER_MODE$1[asset.data.minfilter];
            						}
            						if (asset.data.hasOwnProperty('magfilter') && texture.magFilter !== JSON_FILTER_MODE$1[asset.data.magfilter]) {
            								texture.magFilter = JSON_FILTER_MODE$1[asset.data.magfilter];
            						}
            						if (asset.data.hasOwnProperty('addressu') && texture.addressU !== JSON_ADDRESS_MODE$1[asset.data.addressu]) {
            								texture.addressU = JSON_ADDRESS_MODE$1[asset.data.addressu];
            						}
            						if (asset.data.hasOwnProperty('addressv') && texture.addressV !== JSON_ADDRESS_MODE$1[asset.data.addressv]) {
            								texture.addressV = JSON_ADDRESS_MODE$1[asset.data.addressv];
            						}
            						if (asset.data.hasOwnProperty('mipmaps') && texture.mipmaps !== asset.data.mipmaps) {
            								texture.mipmaps = asset.data.mipmaps;
            						}
            						if (asset.data.hasOwnProperty('anisotropy') && texture.anisotropy !== asset.data.anisotropy) {
            								texture.anisotropy = asset.data.anisotropy;
            						}
            						if (asset.data.hasOwnProperty('rgbm')) {
            								var type = asset.data.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;
            								if (texture.type !== type) {
            										texture.type = type;
            								}
            						}
            				}
            				asset.resource.texture = texture;
            				var frames = {};
            				for(var key in asset.data.frames){
            						var frame = asset.data.frames[key];
            						frames[key] = {
            								rect: new Vec4(frame.rect),
            								pivot: new Vec2(frame.pivot),
            								border: new Vec4(frame.border)
            						};
            				}
            				asset.resource.frames = frames;
            				asset.off('change', this._onAssetChange, this);
            				asset.on('change', this._onAssetChange, this);
            		}
            		_onAssetChange(asset, attribute, value) {
            				var frame;
            				if (attribute === 'data' || attribute === 'data.frames') {
            						var frames = {};
            						for(var key in value.frames){
            								frame = value.frames[key];
            								frames[key] = {
            										rect: new Vec4(frame.rect),
            										pivot: new Vec2(frame.pivot),
            										border: new Vec4(frame.border)
            								};
            						}
            						asset.resource.frames = frames;
            				} else {
            						var match = attribute.match(regexFrame);
            						if (match) {
            								var frameKey = match[1];
            								if (value) {
            										if (!asset.resource.frames[frameKey]) {
            												asset.resource.frames[frameKey] = {
            														rect: new Vec4(value.rect),
            														pivot: new Vec2(value.pivot),
            														border: new Vec4(value.border)
            												};
            										} else {
            												frame = asset.resource.frames[frameKey];
            												frame.rect.set(value.rect[0], value.rect[1], value.rect[2], value.rect[3]);
            												frame.pivot.set(value.pivot[0], value.pivot[1]);
            												frame.border.set(value.border[0], value.border[1], value.border[2], value.border[3]);
            										}
            										asset.resource.fire('set:frame', frameKey, asset.resource.frames[frameKey]);
            								} else {
            										if (asset.resource.frames[frameKey]) {
            												delete asset.resource.frames[frameKey];
            												asset.resource.fire('remove:frame', frameKey);
            										}
            								}
            						}
            				}
            		}
            		constructor(app){
            				super(app, 'textureatlas');
            				this._loader = app.loader;
            		}
            }
            
            function BasisWorker() {
            		var BASIS_FORMAT = {
            				cTFETC1: 0,
            				cTFETC2: 1,
            				cTFBC1: 2,
            				cTFBC3: 3,
            				cTFPVRTC1_4_RGB: 8,
            				cTFPVRTC1_4_RGBA: 9,
            				cTFASTC_4x4: 10,
            				cTFATC_RGB: 11,
            				cTFATC_RGBA_INTERPOLATED_ALPHA: 12,
            				cTFRGBA32: 13,
            				cTFRGB565: 14,
            				cTFRGBA4444: 16
            		};
            		var opaqueMapping = {
            				astc: BASIS_FORMAT.cTFASTC_4x4,
            				dxt: BASIS_FORMAT.cTFBC1,
            				etc1: BASIS_FORMAT.cTFETC1,
            				etc2: BASIS_FORMAT.cTFETC1,
            				pvr: BASIS_FORMAT.cTFPVRTC1_4_RGB,
            				atc: BASIS_FORMAT.cTFATC_RGB,
            				none: BASIS_FORMAT.cTFRGB565
            		};
            		var alphaMapping = {
            				astc: BASIS_FORMAT.cTFASTC_4x4,
            				dxt: BASIS_FORMAT.cTFBC3,
            				etc1: BASIS_FORMAT.cTFRGBA4444,
            				etc2: BASIS_FORMAT.cTFETC2,
            				pvr: BASIS_FORMAT.cTFPVRTC1_4_RGBA,
            				atc: BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA,
            				none: BASIS_FORMAT.cTFRGBA4444
            		};
            		var PIXEL_FORMAT = {
            				ETC1: 21,
            				ETC2_RGB: 22,
            				ETC2_RGBA: 23,
            				DXT1: 8,
            				DXT5: 10,
            				PVRTC_4BPP_RGB_1: 26,
            				PVRTC_4BPP_RGBA_1: 27,
            				ASTC_4x4: 28,
            				ATC_RGB: 29,
            				ATC_RGBA: 30,
            				R8_G8_B8_A8: 7,
            				R5_G6_B5: 3,
            				R4_G4_B4_A4: 5
            		};
            		var basisToEngineMapping = (basisFormat, deviceDetails)=>{
            				switch(basisFormat){
            						case BASIS_FORMAT.cTFETC1:
            								return deviceDetails.formats.etc2 ? PIXEL_FORMAT.ETC2_RGB : PIXEL_FORMAT.ETC1;
            						case BASIS_FORMAT.cTFETC2:
            								return PIXEL_FORMAT.ETC2_RGBA;
            						case BASIS_FORMAT.cTFBC1:
            								return PIXEL_FORMAT.DXT1;
            						case BASIS_FORMAT.cTFBC3:
            								return PIXEL_FORMAT.DXT5;
            						case BASIS_FORMAT.cTFPVRTC1_4_RGB:
            								return PIXEL_FORMAT.PVRTC_4BPP_RGB_1;
            						case BASIS_FORMAT.cTFPVRTC1_4_RGBA:
            								return PIXEL_FORMAT.PVRTC_4BPP_RGBA_1;
            						case BASIS_FORMAT.cTFASTC_4x4:
            								return PIXEL_FORMAT.ASTC_4x4;
            						case BASIS_FORMAT.cTFATC_RGB:
            								return PIXEL_FORMAT.ATC_RGB;
            						case BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:
            								return PIXEL_FORMAT.ATC_RGBA;
            						case BASIS_FORMAT.cTFRGBA32:
            								return PIXEL_FORMAT.R8_G8_B8_A8;
            						case BASIS_FORMAT.cTFRGB565:
            								return PIXEL_FORMAT.R5_G6_B5;
            						case BASIS_FORMAT.cTFRGBA4444:
            								return PIXEL_FORMAT.R4_G4_B4_A4;
            				}
            		};
            		var unswizzleGGGR = (data)=>{
            				var genB = function genB(R, G) {
            						var r = R * (2.0 / 255.0) - 1.0;
            						var g = G * (2.0 / 255.0) - 1.0;
            						var b = Math.sqrt(1.0 - Math.min(1.0, r * r + g * g));
            						return Math.max(0, Math.min(255, Math.floor((b + 1.0) * 0.5 * 255.0)));
            				};
            				for(var offset = 0; offset < data.length; offset += 4){
            						var R = data[offset + 3];
            						var G = data[offset + 1];
            						data[offset + 0] = R;
            						data[offset + 2] = genB(R, G);
            						data[offset + 3] = 255;
            				}
            				return data;
            		};
            		var pack565 = (data)=>{
            				var result = new Uint16Array(data.length / 4);
            				for(var offset = 0; offset < data.length; offset += 4){
            						var R = data[offset + 0];
            						var G = data[offset + 1];
            						var B = data[offset + 2];
            						result[offset / 4] = (R & 0xf8) << 8 | (G & 0xfc) << 3 | B >> 3;
            				}
            				return result;
            		};
            		var isPOT = (width, height)=>{
            				return (width & width - 1) === 0 && (height & height - 1) === 0;
            		};
            		var performanceNow = ()=>{
            				return typeof performance !== 'undefined' ? performance.now() : 0;
            		};
            		var basis;
            		var rgbPriority;
            		var rgbaPriority;
            		var chooseTargetFormat = (deviceDetails, hasAlpha, isUASTC)=>{
            				if (isUASTC) {
            						if (deviceDetails.formats.astc) {
            								return 'astc';
            						}
            				} else {
            						if (hasAlpha) {
            								if (deviceDetails.formats.etc2) {
            										return 'etc2';
            								}
            						} else {
            								if (deviceDetails.formats.etc2) {
            										return 'etc2';
            								}
            								if (deviceDetails.formats.etc1) {
            										return 'etc1';
            								}
            						}
            				}
            				var testInOrder = (priority)=>{
            						for(var i = 0; i < priority.length; ++i){
            								var format = priority[i];
            								if (deviceDetails.formats[format]) {
            										return format;
            								}
            						}
            						return 'none';
            				};
            				return testInOrder(hasAlpha ? rgbaPriority : rgbPriority);
            		};
            		var dimensionsValid = (width, height, format)=>{
            				switch(format){
            						case BASIS_FORMAT.cTFETC1:
            						case BASIS_FORMAT.cTFETC2:
            								return true;
            						case BASIS_FORMAT.cTFBC1:
            						case BASIS_FORMAT.cTFBC3:
            								return (width & 0x3) === 0 && (height & 0x3) === 0;
            						case BASIS_FORMAT.cTFPVRTC1_4_RGB:
            						case BASIS_FORMAT.cTFPVRTC1_4_RGBA:
            								return isPOT(width, height);
            						case BASIS_FORMAT.cTFASTC_4x4:
            								return true;
            						case BASIS_FORMAT.cTFATC_RGB:
            						case BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:
            								return true;
            				}
            				return false;
            		};
            		var transcodeKTX2 = (url, data, options)=>{
            				if (!basis.KTX2File) {
            						throw new Error('Basis transcoder module does not include support for KTX2.');
            				}
            				var funcStart = performanceNow();
            				var basisFile = new basis.KTX2File(new Uint8Array(data));
            				var width = basisFile.getWidth();
            				var height = basisFile.getHeight();
            				var levels = basisFile.getLevels();
            				var hasAlpha = !!basisFile.getHasAlpha();
            				var isUASTC = basisFile.isUASTC && basisFile.isUASTC();
            				if (!width || !height || !levels) {
            						basisFile.close();
            						basisFile.delete();
            						throw new Error("Invalid image dimensions url=" + url + " width=" + width + " height=" + height + " levels=" + levels);
            				}
            				var format = chooseTargetFormat(options.deviceDetails, hasAlpha, isUASTC);
            				var unswizzle = !!options.isGGGR && format === 'pvr';
            				var basisFormat;
            				if (unswizzle) {
            						basisFormat = BASIS_FORMAT.cTFRGBA32;
            				} else {
            						basisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];
            						if (!dimensionsValid(width, height, basisFormat)) {
            								basisFormat = hasAlpha ? BASIS_FORMAT.cTFRGBA32 : BASIS_FORMAT.cTFRGB565;
            						}
            				}
            				if (!basisFile.startTranscoding()) {
            						basisFile.close();
            						basisFile.delete();
            						throw new Error("Failed to start transcoding url=" + url);
            				}
            				var i;
            				var levelData = [];
            				for(var mip = 0; mip < levels; ++mip){
            						var dstSize = basisFile.getImageTranscodedSizeInBytes(mip, 0, 0, basisFormat);
            						var dst = new Uint8Array(dstSize);
            						if (!basisFile.transcodeImage(dst, mip, 0, 0, basisFormat, 0, -1, -1)) {
            								basisFile.close();
            								basisFile.delete();
            								throw new Error("Failed to transcode image url=" + url);
            						}
            						var is16BitFormat = basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444;
            						levelData.push(is16BitFormat ? new Uint16Array(dst.buffer) : dst);
            				}
            				basisFile.close();
            				basisFile.delete();
            				if (unswizzle) {
            						basisFormat = BASIS_FORMAT.cTFRGB565;
            						for(i = 0; i < levelData.length; ++i){
            								levelData[i] = pack565(unswizzleGGGR(levelData[i]));
            						}
            				}
            				return {
            						format: basisToEngineMapping(basisFormat, options.deviceDetails),
            						width: width,
            						height: height,
            						levels: levelData,
            						cubemap: false,
            						transcodeTime: performanceNow() - funcStart,
            						url: url,
            						unswizzledGGGR: unswizzle
            				};
            		};
            		var transcodeBasis = (url, data, options)=>{
            				var funcStart = performanceNow();
            				var basisFile = new basis.BasisFile(new Uint8Array(data));
            				var width = basisFile.getImageWidth(0, 0);
            				var height = basisFile.getImageHeight(0, 0);
            				var images = basisFile.getNumImages();
            				var levels = basisFile.getNumLevels(0);
            				var hasAlpha = !!basisFile.getHasAlpha();
            				var isUASTC = basisFile.isUASTC && basisFile.isUASTC();
            				if (!width || !height || !images || !levels) {
            						basisFile.close();
            						basisFile.delete();
            						throw new Error("Invalid image dimensions url=" + url + " width=" + width + " height=" + height + " images=" + images + " levels=" + levels);
            				}
            				var format = chooseTargetFormat(options.deviceDetails, hasAlpha, isUASTC);
            				var unswizzle = !!options.isGGGR && format === 'pvr';
            				var basisFormat;
            				if (unswizzle) {
            						basisFormat = BASIS_FORMAT.cTFRGBA32;
            				} else {
            						basisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];
            						if (!dimensionsValid(width, height, basisFormat)) {
            								basisFormat = hasAlpha ? BASIS_FORMAT.cTFRGBA32 : BASIS_FORMAT.cTFRGB565;
            						}
            				}
            				if (!basisFile.startTranscoding()) {
            						basisFile.close();
            						basisFile.delete();
            						throw new Error("Failed to start transcoding url=" + url);
            				}
            				var i;
            				var levelData = [];
            				for(var mip = 0; mip < levels; ++mip){
            						var dstSize = basisFile.getImageTranscodedSizeInBytes(0, mip, basisFormat);
            						var dst = new Uint8Array(dstSize);
            						if (!basisFile.transcodeImage(dst, 0, mip, basisFormat, 0, 0)) {
            								if (mip === levels - 1 && dstSize === levelData[mip - 1].buffer.byteLength) {
            										dst.set(new Uint8Array(levelData[mip - 1].buffer));
            										console.warn("Failed to transcode last mipmap level, using previous level instead url=" + url);
            								} else {
            										basisFile.close();
            										basisFile.delete();
            										throw new Error("Failed to transcode image url=" + url);
            								}
            						}
            						var is16BitFormat = basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444;
            						levelData.push(is16BitFormat ? new Uint16Array(dst.buffer) : dst);
            				}
            				basisFile.close();
            				basisFile.delete();
            				if (unswizzle) {
            						basisFormat = BASIS_FORMAT.cTFRGB565;
            						for(i = 0; i < levelData.length; ++i){
            								levelData[i] = pack565(unswizzleGGGR(levelData[i]));
            						}
            				}
            				return {
            						format: basisToEngineMapping(basisFormat, options.deviceDetails),
            						width: width,
            						height: height,
            						levels: levelData,
            						cubemap: false,
            						transcodeTime: performanceNow() - funcStart,
            						url: url,
            						unswizzledGGGR: unswizzle
            				};
            		};
            		var transcode = (url, data, options)=>{
            				return options.isKTX2 ? transcodeKTX2(url, data, options) : transcodeBasis(url, data, options);
            		};
            		var workerTranscode = (url, data, options)=>{
            				try {
            						var result = transcode(url, data, options);
            						result.levels = result.levels.map((v)=>v.buffer);
            						self.postMessage({
            								url: url,
            								data: result
            						}, result.levels);
            				} catch (err) {
            						self.postMessage({
            								url: url,
            								err: err
            						}, null);
            				}
            		};
            		var workerInit = (config, callback)=>{
            				var instantiateWasmFunc = (imports, successCallback)=>{
            						WebAssembly.instantiate(config.module, imports).then((result)=>{
            								successCallback(result);
            						}).catch((reason)=>{
            								console.error("instantiate failed + " + reason);
            						});
            						return {};
            				};
            				self.BASIS(config.module ? {
            						instantiateWasm: instantiateWasmFunc
            				} : null).then((instance)=>{
            						instance.initializeBasis();
            						basis = instance;
            						rgbPriority = config.rgbPriority;
            						rgbaPriority = config.rgbaPriority;
            						callback(null);
            				});
            		};
            		var queue = [];
            		self.onmessage = (message)=>{
            				var data = message.data;
            				switch(data.type){
            						case 'init':
            								workerInit(data.config, ()=>{
            										for(var i = 0; i < queue.length; ++i){
            												workerTranscode(queue[i].url, queue[i].data, queue[i].options);
            										}
            										queue.length = 0;
            								});
            								break;
            						case 'transcode':
            								if (basis) {
            										workerTranscode(data.url, data.data, data.options);
            								} else {
            										queue.push(data);
            								}
            								break;
            				}
            		};
            }
            
            var getCompressionFormats = (device)=>{
            		return {
            				astc: !!device.extCompressedTextureASTC,
            				atc: !!device.extCompressedTextureATC,
            				dxt: !!device.extCompressedTextureS3TC,
            				etc1: !!device.extCompressedTextureETC1,
            				etc2: !!device.extCompressedTextureETC,
            				pvr: !!device.extCompressedTexturePVRTC
            		};
            };
            var prepareWorkerModules = (config, callback)=>{
            		var getWorkerBlob = (basisCode)=>{
            				var code = [
            						'/* basis */',
            						basisCode,
            						'',
            						"(" + BasisWorker.toString() + ")()\n\n"
            				].join('\n');
            				return new Blob([
            						code
            				], {
            						type: "application/javascript"
            				});
            		};
            		var wasmSupported = ()=>{
            				try {
            						if (typeof WebAssembly === 'object' && typeof WebAssembly.instantiate === 'function') {
            								var module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));
            								if (module instanceof WebAssembly.Module) {
            										return new WebAssembly.Instance(module) instanceof WebAssembly.Instance;
            								}
            						}
            				} catch (e) {}
            				return false;
            		};
            		var sendResponse = (basisCode, module)=>{
            				callback(null, {
            						workerUrl: URL.createObjectURL(getWorkerBlob(basisCode)),
            						module: module,
            						rgbPriority: config.rgbPriority,
            						rgbaPriority: config.rgbaPriority
            				});
            		};
            		var options = {
            				cache: true,
            				responseType: 'text',
            				retry: config.maxRetries > 0,
            				maxRetries: config.maxRetries
            		};
            		if (config.glueUrl && config.wasmUrl && wasmSupported()) {
            				var basisCode = null;
            				var module = null;
            				http.get(config.glueUrl, options, (err, response)=>{
            						if (err) {
            								callback(err);
            						} else {
            								if (module) {
            										sendResponse(response, module);
            								} else {
            										basisCode = response;
            								}
            						}
            				});
            				var fetchPromise = fetch(config.wasmUrl);
            				var compileManual = ()=>{
            						fetchPromise.then((result)=>result.arrayBuffer()).then((buffer)=>WebAssembly.compile(buffer)).then((module_)=>{
            								if (basisCode) {
            										sendResponse(basisCode, module_);
            								} else {
            										module = module_;
            								}
            						}).catch((err)=>{
            								callback(err, null);
            						});
            				};
            				if (WebAssembly.compileStreaming) {
            						WebAssembly.compileStreaming(fetchPromise).then((module_)=>{
            								if (basisCode) {
            										sendResponse(basisCode, module_);
            								} else {
            										module = module_;
            								}
            						}).catch((err)=>{
            								compileManual();
            						});
            				} else {
            						compileManual();
            				}
            		} else {
            				http.get(config.fallbackUrl, options, (err, response)=>{
            						if (err) {
            								callback(err, null);
            						} else {
            								sendResponse(response, null);
            						}
            				});
            		}
            };
            class BasisQueue {
            		enqueueJob(url, data, callback, options) {
            				if (this.callbacks.hasOwnProperty(url)) {
            						this.callbacks[url].push(callback);
            				} else {
            						this.callbacks[url] = [
            								callback
            						];
            						var job = {
            								url: url,
            								data: data,
            								options: options
            						};
            						if (this.clients.length > 0) {
            								this.clients.shift().run(job);
            						} else {
            								this.queue.push(job);
            						}
            				}
            		}
            		enqueueClient(client) {
            				if (this.queue.length > 0) {
            						client.run(this.queue.shift());
            				} else {
            						this.clients.push(client);
            				}
            		}
            		handleResponse(url, err, data) {
            				var callback = this.callbacks[url];
            				if (err) {
            						for(var i = 0; i < callback.length; ++i){
            								callback[i](err);
            						}
            				} else {
            						if (data.format === PIXELFORMAT_RGB565 || data.format === PIXELFORMAT_RGBA4) {
            								data.levels = data.levels.map((v)=>{
            										return new Uint16Array(v);
            								});
            						} else {
            								data.levels = data.levels.map((v)=>{
            										return new Uint8Array(v);
            								});
            						}
            						for(var i1 = 0; i1 < callback.length; ++i1){
            								callback[i1](null, data);
            						}
            				}
            				delete this.callbacks[url];
            		}
            		constructor(){
            				this.callbacks = {};
            				this.queue = [];
            				this.clients = [];
            		}
            }
            class BasisClient {
            		run(job) {
            				var transfer = [];
            				if (job.data instanceof ArrayBuffer) {
            						transfer.push(job.data);
            				}
            				this.worker.postMessage({
            						type: 'transcode',
            						url: job.url,
            						format: job.format,
            						data: job.data,
            						options: job.options
            				}, transfer);
            				if (this.eager) {
            						this.queue.enqueueClient(this);
            				}
            		}
            		constructor(queue, config, eager){
            				this.queue = queue;
            				this.worker = new Worker(config.workerUrl);
            				this.worker.addEventListener('message', (message)=>{
            						var data = message.data;
            						this.queue.handleResponse(data.url, data.err, data.data);
            						if (!this.eager) {
            								this.queue.enqueueClient(this);
            						}
            				});
            				this.worker.postMessage({
            						type: 'init',
            						config: config
            				});
            				this.eager = eager;
            		}
            }
            var defaultNumWorkers = 1;
            var defaultRgbPriority = [
            		'etc2',
            		'etc1',
            		'astc',
            		'dxt',
            		'pvr',
            		'atc'
            ];
            var defaultRgbaPriority = [
            		'astc',
            		'dxt',
            		'etc2',
            		'pvr',
            		'atc'
            ];
            var defaultMaxRetries = 5;
            var queue = new BasisQueue();
            var lazyConfig = null;
            var initializing = false;
            function basisInitialize(config) {
            		if (initializing) {
            				return;
            		}
            		if (!config) {
            				config = lazyConfig || {};
            		} else if (config.lazyInit) {
            				lazyConfig = config;
            				return;
            		}
            		if (!config.glueUrl || !config.wasmUrl || !config.fallbackUrl) {
            				var moduleConfig = WasmModule.getConfig('BASIS');
            				if (moduleConfig) {
            						config = {
            								glueUrl: moduleConfig.glueUrl,
            								wasmUrl: moduleConfig.wasmUrl,
            								fallbackUrl: moduleConfig.fallbackUrl,
            								numWorkers: moduleConfig.numWorkers
            						};
            				}
            		}
            		if (config.glueUrl || config.wasmUrl || config.fallbackUrl) {
            				initializing = true;
            				var numWorkers = Math.max(1, Math.min(16, config.numWorkers || defaultNumWorkers));
            				var eagerWorkers = config.numWorkers === 1 || (config.hasOwnProperty('eagerWorkers') ? config.eagerWorkers : true);
            				config.rgbPriority = config.rgbPriority || defaultRgbPriority;
            				config.rgbaPriority = config.rgbaPriority || defaultRgbaPriority;
            				config.maxRetries = config.hasOwnProperty('maxRetries') ? config.maxRetries : defaultMaxRetries;
            				prepareWorkerModules(config, (err, clientConfig)=>{
            						if (err) {
            								console.error("failed to initialize basis worker: " + err);
            						} else {
            								for(var i = 0; i < numWorkers; ++i){
            										queue.enqueueClient(new BasisClient(queue, clientConfig, eagerWorkers));
            								}
            						}
            				});
            		}
            }
            var deviceDetails = null;
            function basisTranscode(device, url, data, callback, options) {
            		basisInitialize();
            		if (!deviceDetails) {
            				deviceDetails = {
            						formats: getCompressionFormats(device)
            				};
            		}
            		queue.enqueueJob(url, data, callback, {
            				deviceDetails: deviceDetails,
            				isGGGR: !!(options == null ? void 0 : options.isGGGR),
            				isKTX2: !!(options == null ? void 0 : options.isKTX2)
            		});
            		return initializing;
            }
            
            class TextureParser {
            		load(url, callback, asset) {
            				throw new Error('not implemented');
            		}
            		open(url, data, device) {
            				throw new Error('not implemented');
            		}
            }
            
            function _extends$5() {
            		_extends$5 = Object.assign || function(target) {
            				for(var i = 1; i < arguments.length; i++){
            						var source = arguments[i];
            						for(var key in source){
            								if (Object.prototype.hasOwnProperty.call(source, key)) {
            										target[key] = source[key];
            								}
            						}
            				}
            				return target;
            		};
            		return _extends$5.apply(this, arguments);
            }
            class BasisParser extends TextureParser {
            		load(url, callback, asset) {
            				var device = this.device;
            				var transcode = (data)=>{
            						var _asset_file_variants_basis, _asset_file_variants, _asset_file;
            						var basisModuleFound = basisTranscode(device, url.load, data, callback, {
            								isGGGR: ((asset == null ? void 0 : (_asset_file = asset.file) == null ? void 0 : (_asset_file_variants = _asset_file.variants) == null ? void 0 : (_asset_file_variants_basis = _asset_file_variants.basis) == null ? void 0 : _asset_file_variants_basis.opt) & 8) !== 0
            						});
            						if (!basisModuleFound) {
            								callback("Basis module not found. Asset [" + asset.name + "](" + asset.getFileUrl() + ") basis texture variant will not be loaded.");
            						}
            				};
            				Asset.fetchArrayBuffer(url.load, (err, result)=>{
            						if (err) {
            								callback(err);
            						} else {
            								transcode(result);
            						}
            				}, asset, this.maxRetries);
            		}
            		open(url, data, device, textureOptions) {
            				if (textureOptions === void 0) textureOptions = {};
            				var format = textureOptions.srgb ? pixelFormatLinearToGamma(data.format) : data.format;
            				var texture = new Texture(device, _extends$5({
            						name: url,
            						addressU: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
            						addressV: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
            						width: data.width,
            						height: data.height,
            						format: format,
            						cubemap: data.cubemap,
            						levels: data.levels
            				}, textureOptions));
            				texture.upload();
            				return texture;
            		}
            		constructor(registry, device){
            				super();
            				this.device = device;
            				this.maxRetries = 0;
            		}
            }
            
            function _extends$4() {
            		_extends$4 = Object.assign || function(target) {
            				for(var i = 1; i < arguments.length; i++){
            						var source = arguments[i];
            						for(var key in source){
            								if (Object.prototype.hasOwnProperty.call(source, key)) {
            										target[key] = source[key];
            								}
            						}
            				}
            				return target;
            		};
            		return _extends$4.apply(this, arguments);
            }
            class ImgParser extends TextureParser {
            		load(url, callback, asset) {
            				var _asset_file;
            				var hasContents = !!(asset == null ? void 0 : (_asset_file = asset.file) == null ? void 0 : _asset_file.contents);
            				if (hasContents) {
            						if (this.device.supportsImageBitmap) {
            								this._loadImageBitmapFromBlob(new Blob([
            										asset.file.contents
            								]), callback);
            								return;
            						}
            						url = {
            								load: URL.createObjectURL(new Blob([
            										asset.file.contents
            								])),
            								original: url.original
            						};
            				}
            				var handler = (err, result)=>{
            						if (hasContents) {
            								URL.revokeObjectURL(url.load);
            						}
            						callback(err, result);
            				};
            				var crossOrigin;
            				if (asset && asset.options && asset.options.hasOwnProperty('crossOrigin')) {
            						crossOrigin = asset.options.crossOrigin;
            				} else if (ABSOLUTE_URL.test(url.load)) {
            						crossOrigin = this.crossOrigin;
            				}
            				if (this.device.supportsImageBitmap) {
            						this._loadImageBitmap(url.load, url.original, crossOrigin, handler);
            				} else {
            						this._loadImage(url.load, url.original, crossOrigin, handler);
            				}
            		}
            		open(url, data, device, textureOptions) {
            				if (textureOptions === void 0) textureOptions = {};
            				var texture = new Texture(device, _extends$4({
            						name: url,
            						width: data.width,
            						height: data.height,
            						format: textureOptions.srgb ? PIXELFORMAT_SRGBA8 : PIXELFORMAT_RGBA8
            				}, textureOptions));
            				texture.setSource(data);
            				return texture;
            		}
            		_loadImage(url, originalUrl, crossOrigin, callback) {
            				var image = new Image();
            				if (crossOrigin) {
            						image.crossOrigin = crossOrigin;
            				}
            				var retries = 0;
            				var maxRetries = this.maxRetries;
            				var retryTimeout;
            				image.onload = function() {
            						callback(null, image);
            				};
            				image.onerror = function() {
            						if (retryTimeout) return;
            						if (maxRetries > 0 && ++retries <= maxRetries) {
            								var retryDelay = Math.pow(2, retries) * 100;
            								console.log("Error loading Texture from: '" + originalUrl + "' - Retrying in " + retryDelay + "ms...");
            								var idx = url.indexOf('?');
            								var separator = idx >= 0 ? '&' : '?';
            								retryTimeout = setTimeout(()=>{
            										image.src = url + separator + "retry=" + Date.now();
            										retryTimeout = null;
            								}, retryDelay);
            						} else {
            								callback("Error loading Texture from: '" + originalUrl + "'");
            						}
            				};
            				image.src = url;
            		}
            		_loadImageBitmap(url, originalUrl, crossOrigin, callback) {
            				var options = {
            						cache: true,
            						responseType: 'blob',
            						retry: this.maxRetries > 0,
            						maxRetries: this.maxRetries
            				};
            				http.get(url, options, (err, blob)=>{
            						if (err) {
            								callback(err);
            						} else {
            								this._loadImageBitmapFromBlob(blob, callback);
            						}
            				});
            		}
            		_loadImageBitmapFromBlob(blob, callback) {
            				createImageBitmap(blob, {
            						premultiplyAlpha: 'none',
            						colorSpaceConversion: 'none'
            				}).then((imageBitmap)=>callback(null, imageBitmap)).catch((e)=>callback(e));
            		}
            		constructor(registry, device){
            				super();
            				this.crossOrigin = registry.prefix ? 'anonymous' : null;
            				this.maxRetries = 0;
            				this.device = device;
            		}
            }
            
            function _extends$3() {
            		_extends$3 = Object.assign || function(target) {
            				for(var i = 1; i < arguments.length; i++){
            						var source = arguments[i];
            						for(var key in source){
            								if (Object.prototype.hasOwnProperty.call(source, key)) {
            										target[key] = source[key];
            								}
            						}
            				}
            				return target;
            		};
            		return _extends$3.apply(this, arguments);
            }
            var IDENTIFIER = [
            		0x58544BAB,
            		0xBB313120,
            		0x0A1A0A0D
            ];
            var KNOWN_FORMATS = {
            		0x83F0: PIXELFORMAT_DXT1,
            		0x83F2: PIXELFORMAT_DXT3,
            		0x83F3: PIXELFORMAT_DXT5,
            		0x8D64: PIXELFORMAT_ETC1,
            		0x9274: PIXELFORMAT_ETC2_RGB,
            		0x9278: PIXELFORMAT_ETC2_RGBA,
            		0x8C00: PIXELFORMAT_PVRTC_4BPP_RGB_1,
            		0x8C01: PIXELFORMAT_PVRTC_2BPP_RGB_1,
            		0x8C02: PIXELFORMAT_PVRTC_4BPP_RGBA_1,
            		0x8C03: PIXELFORMAT_PVRTC_2BPP_RGBA_1,
            		0x8051: PIXELFORMAT_RGB8,
            		0x8058: PIXELFORMAT_RGBA8,
            		0x8C41: PIXELFORMAT_SRGB8,
            		0x8C43: PIXELFORMAT_SRGBA8,
            		0x8C3A: PIXELFORMAT_111110F,
            		0x881B: PIXELFORMAT_RGB16F,
            		0x881A: PIXELFORMAT_RGBA16F
            };
            function createContainer(pixelFormat, buffer, byteOffset, byteSize) {
            		return pixelFormat === PIXELFORMAT_111110F ? new Uint32Array(buffer, byteOffset, byteSize / 4) : new Uint8Array(buffer, byteOffset, byteSize);
            }
            class KtxParser extends TextureParser {
            		load(url, callback, asset) {
            				Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);
            		}
            		open(url, data, device, textureOptions) {
            				if (textureOptions === void 0) textureOptions = {};
            				var textureData = this.parse(data);
            				if (!textureData) {
            						return null;
            				}
            				var format = textureOptions.srgb ? pixelFormatLinearToGamma(textureData.format) : textureData.format;
            				var texture = new Texture(device, _extends$3({
            						name: url,
            						addressU: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
            						addressV: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
            						width: textureData.width,
            						height: textureData.height,
            						format: format,
            						cubemap: textureData.cubemap,
            						levels: textureData.levels
            				}, textureOptions));
            				texture.upload();
            				return texture;
            		}
            		parse(data) {
            				var dataU32 = new Uint32Array(data);
            				if (IDENTIFIER[0] !== dataU32[0] || IDENTIFIER[1] !== dataU32[1] || IDENTIFIER[2] !== dataU32[2]) {
            						return null;
            				}
            				var header = {
            						endianness: dataU32[3],
            						glType: dataU32[4],
            						glTypeSize: dataU32[5],
            						glFormat: dataU32[6],
            						glInternalFormat: dataU32[7],
            						glBaseInternalFormat: dataU32[8],
            						pixelWidth: dataU32[9],
            						pixelHeight: dataU32[10],
            						pixelDepth: dataU32[11],
            						numberOfArrayElements: dataU32[12],
            						numberOfFaces: dataU32[13],
            						numberOfMipmapLevels: dataU32[14],
            						bytesOfKeyValueData: dataU32[15]
            				};
            				if (header.pixelDepth > 1) {
            						return null;
            				}
            				if (header.numberOfArrayElements !== 0) {
            						return null;
            				}
            				var format = KNOWN_FORMATS[header.glInternalFormat];
            				if (format === undefined) {
            						return null;
            				}
            				var offset = 16 + header.bytesOfKeyValueData / 4;
            				var isCubemap = header.numberOfFaces > 1;
            				var levels = [];
            				for(var mipmapLevel = 0; mipmapLevel < (header.numberOfMipmapLevels || 1); mipmapLevel++){
            						var imageSizeInBytes = dataU32[offset++];
            						if (isCubemap) {
            								levels.push([]);
            						}
            						var target = isCubemap ? levels[mipmapLevel] : levels;
            						for(var face = 0; face < (isCubemap ? 6 : 1); ++face){
            								target.push(createContainer(format, data, offset * 4, imageSizeInBytes));
            								offset += imageSizeInBytes + 3 >> 2;
            						}
            				}
            				return {
            						format: format,
            						width: header.pixelWidth,
            						height: header.pixelHeight,
            						levels: levels,
            						cubemap: isCubemap
            				};
            		}
            		constructor(registry){
            				super();
            				this.maxRetries = 0;
            		}
            }
            
            function _extends$2() {
            		_extends$2 = Object.assign || function(target) {
            				for(var i = 1; i < arguments.length; i++){
            						var source = arguments[i];
            						for(var key in source){
            								if (Object.prototype.hasOwnProperty.call(source, key)) {
            										target[key] = source[key];
            								}
            						}
            				}
            				return target;
            		};
            		return _extends$2.apply(this, arguments);
            }
            var KHRConstants = {
            		KHR_DF_MODEL_UASTC: 166
            };
            class Ktx2Parser extends TextureParser {
            		load(url, callback, asset) {
            				Asset.fetchArrayBuffer(url.load, (err, result)=>{
            						if (err) {
            								callback(err, result);
            						} else {
            								this.parse(result, url, callback, asset);
            						}
            				}, asset, this.maxRetries);
            		}
            		open(url, data, device, textureOptions) {
            				if (textureOptions === void 0) textureOptions = {};
            				var format = textureOptions.srgb ? pixelFormatLinearToGamma(data.format) : data.format;
            				var texture = new Texture(device, _extends$2({
            						name: url,
            						addressU: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
            						addressV: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
            						width: data.width,
            						height: data.height,
            						format: format,
            						cubemap: data.cubemap,
            						levels: data.levels
            				}, textureOptions));
            				texture.upload();
            				return texture;
            		}
            		parse(arraybuffer, url, callback, asset) {
            				var rs = new ReadStream(arraybuffer);
            				var magic = [
            						rs.readU32be(),
            						rs.readU32be(),
            						rs.readU32be()
            				];
            				if (magic[0] !== 0xAB4B5458 || magic[1] !== 0x203230BB || magic[2] !== 0x0D0A1A0A) {
            						return null;
            				}
            				var header = {
            						vkFormat: rs.readU32(),
            						typeSize: rs.readU32(),
            						pixelWidth: rs.readU32(),
            						pixelHeight: rs.readU32(),
            						pixelDepth: rs.readU32(),
            						layerCount: rs.readU32(),
            						faceCount: rs.readU32(),
            						levelCount: rs.readU32(),
            						supercompressionScheme: rs.readU32()
            				};
            				var index = {
            						dfdByteOffset: rs.readU32(),
            						dfdByteLength: rs.readU32(),
            						kvdByteOffset: rs.readU32(),
            						kvdByteLength: rs.readU32(),
            						sgdByteOffset: rs.readU64(),
            						sgdByteLength: rs.readU64()
            				};
            				var levels = [];
            				for(var i = 0; i < Math.max(1, header.levelCount); ++i){
            						levels.push({
            								byteOffset: rs.readU64(),
            								byteLength: rs.readU64(),
            								uncompressedByteLength: rs.readU64()
            						});
            				}
            				var dfdTotalSize = rs.readU32();
            				if (dfdTotalSize !== index.kvdByteOffset - index.dfdByteOffset) {
            						return null;
            				}
            				rs.skip(8);
            				var colorModel = rs.readU8();
            				rs.skip(index.dfdByteLength - 9);
            				rs.skip(index.kvdByteLength);
            				if (header.supercompressionScheme === 1 || colorModel === KHRConstants.KHR_DF_MODEL_UASTC) {
            						var _asset_file_variants_basis, _asset_file_variants, _asset_file;
            						var basisModuleFound = basisTranscode(this.device, url.load, arraybuffer, callback, {
            								isGGGR: ((asset == null ? void 0 : (_asset_file = asset.file) == null ? void 0 : (_asset_file_variants = _asset_file.variants) == null ? void 0 : (_asset_file_variants_basis = _asset_file_variants.basis) == null ? void 0 : _asset_file_variants_basis.opt) & 8) !== 0,
            								isKTX2: true
            						});
            						if (!basisModuleFound) {
            								callback("Basis module not found. Asset [" + asset.name + "](" + asset.getFileUrl() + ") basis texture variant will not be loaded.");
            						}
            				} else {
            						callback('unsupported KTX2 pixel format');
            				}
            		}
            		constructor(registry, device){
            				super();
            				this.maxRetries = 0;
            				this.device = device;
            		}
            }
            
            function _extends$1() {
            		_extends$1 = Object.assign || function(target) {
            				for(var i = 1; i < arguments.length; i++){
            						var source = arguments[i];
            						for(var key in source){
            								if (Object.prototype.hasOwnProperty.call(source, key)) {
            										target[key] = source[key];
            								}
            						}
            				}
            				return target;
            		};
            		return _extends$1.apply(this, arguments);
            }
            class DdsParser extends TextureParser {
            		load(url, callback, asset) {
            				Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);
            		}
            		open(url, data, device, textureOptions) {
            				if (textureOptions === void 0) textureOptions = {};
            				var header = new Uint32Array(data, 0, 128 / 4);
            				var width = header[4];
            				var height = header[3];
            				var mips = Math.max(header[7], 1);
            				var isFourCc = header[20] === 4;
            				var fcc = header[21];
            				var bpp = header[22];
            				var isCubemap = header[28] === 65024;
            				var FCC_DXT1 = 827611204;
            				var FCC_DXT5 = 894720068;
            				var FCC_FP16 = 113;
            				var FCC_FP32 = 116;
            				var FCC_ETC1 = 826496069;
            				var FCC_PVRTC_2BPP_RGB_1 = 825438800;
            				var FCC_PVRTC_2BPP_RGBA_1 = 825504336;
            				var FCC_PVRTC_4BPP_RGB_1 = 825439312;
            				var FCC_PVRTC_4BPP_RGBA_1 = 825504848;
            				var compressed = false;
            				var etc1 = false;
            				var pvrtc2 = false;
            				var pvrtc4 = false;
            				var format = null;
            				var componentSize = 1;
            				var texture;
            				if (isFourCc) {
            						if (fcc === FCC_DXT1) {
            								format = PIXELFORMAT_DXT1;
            								compressed = true;
            						} else if (fcc === FCC_DXT5) {
            								format = PIXELFORMAT_DXT5;
            								compressed = true;
            						} else if (fcc === FCC_FP16) {
            								format = PIXELFORMAT_RGBA16F;
            								componentSize = 2;
            						} else if (fcc === FCC_FP32) {
            								format = PIXELFORMAT_RGBA32F;
            								componentSize = 4;
            						} else if (fcc === FCC_ETC1) {
            								format = PIXELFORMAT_ETC1;
            								compressed = true;
            								etc1 = true;
            						} else if (fcc === FCC_PVRTC_2BPP_RGB_1 || fcc === FCC_PVRTC_2BPP_RGBA_1) {
            								format = fcc === FCC_PVRTC_2BPP_RGB_1 ? PIXELFORMAT_PVRTC_2BPP_RGB_1 : PIXELFORMAT_PVRTC_2BPP_RGBA_1;
            								compressed = true;
            								pvrtc2 = true;
            						} else if (fcc === FCC_PVRTC_4BPP_RGB_1 || fcc === FCC_PVRTC_4BPP_RGBA_1) {
            								format = fcc === FCC_PVRTC_4BPP_RGB_1 ? PIXELFORMAT_PVRTC_4BPP_RGB_1 : PIXELFORMAT_PVRTC_4BPP_RGBA_1;
            								compressed = true;
            								pvrtc4 = true;
            						}
            				} else {
            						if (bpp === 32) {
            								format = PIXELFORMAT_RGBA8;
            						}
            				}
            				if (!format) {
            						texture = new Texture(device, {
            								width: 4,
            								height: 4,
            								format: PIXELFORMAT_RGB8,
            								name: 'dds-legacy-empty'
            						});
            						return texture;
            				}
            				texture = new Texture(device, _extends$1({
            						name: url,
            						addressU: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
            						addressV: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,
            						width: width,
            						height: height,
            						format: format,
            						cubemap: isCubemap,
            						mipmaps: mips > 1
            				}, textureOptions));
            				var offset = 128;
            				var faces = isCubemap ? 6 : 1;
            				var mipSize;
            				var DXT_BLOCK_WIDTH = 4;
            				var DXT_BLOCK_HEIGHT = 4;
            				var blockSize = fcc === FCC_DXT1 ? 8 : 16;
            				var numBlocksAcross, numBlocksDown, numBlocks;
            				for(var face = 0; face < faces; face++){
            						var mipWidth = width;
            						var mipHeight = height;
            						for(var i = 0; i < mips; i++){
            								if (compressed) {
            										if (etc1) {
            												mipSize = Math.floor((mipWidth + 3) / 4) * Math.floor((mipHeight + 3) / 4) * 8;
            										} else if (pvrtc2) {
            												mipSize = Math.max(mipWidth, 16) * Math.max(mipHeight, 8) / 4;
            										} else if (pvrtc4) {
            												mipSize = Math.max(mipWidth, 8) * Math.max(mipHeight, 8) / 2;
            										} else {
            												numBlocksAcross = Math.floor((mipWidth + DXT_BLOCK_WIDTH - 1) / DXT_BLOCK_WIDTH);
            												numBlocksDown = Math.floor((mipHeight + DXT_BLOCK_HEIGHT - 1) / DXT_BLOCK_HEIGHT);
            												numBlocks = numBlocksAcross * numBlocksDown;
            												mipSize = numBlocks * blockSize;
            										}
            								} else {
            										mipSize = mipWidth * mipHeight * 4;
            								}
            								var mipBuff = format === PIXELFORMAT_RGBA32F ? new Float32Array(data, offset, mipSize) : format === PIXELFORMAT_RGBA16F ? new Uint16Array(data, offset, mipSize) : new Uint8Array(data, offset, mipSize);
            								if (!isCubemap) {
            										texture._levels[i] = mipBuff;
            								} else {
            										if (!texture._levels[i]) texture._levels[i] = [];
            										texture._levels[i][face] = mipBuff;
            								}
            								offset += mipSize * componentSize;
            								mipWidth = Math.max(mipWidth * 0.5, 1);
            								mipHeight = Math.max(mipHeight * 0.5, 1);
            						}
            				}
            				texture.upload();
            				return texture;
            		}
            		constructor(registry){
            				super();
            				this.maxRetries = 0;
            		}
            }
            
            function _extends() {
            		_extends = Object.assign || function(target) {
            				for(var i = 1; i < arguments.length; i++){
            						var source = arguments[i];
            						for(var key in source){
            								if (Object.prototype.hasOwnProperty.call(source, key)) {
            										target[key] = source[key];
            								}
            						}
            				}
            				return target;
            		};
            		return _extends.apply(this, arguments);
            }
            class HdrParser extends TextureParser {
            		load(url, callback, asset) {
            				Asset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);
            				if (asset.data && !asset.data.type) {
            						asset.data.type = TEXTURETYPE_RGBE;
            				}
            		}
            		open(url, data, device, textureOptions) {
            				if (textureOptions === void 0) textureOptions = {};
            				var textureData = this.parse(data);
            				if (!textureData) {
            						return null;
            				}
            				var texture = new Texture(device, _extends({
            						name: url,
            						addressU: ADDRESS_REPEAT,
            						addressV: ADDRESS_CLAMP_TO_EDGE,
            						minFilter: FILTER_NEAREST,
            						magFilter: FILTER_NEAREST,
            						width: textureData.width,
            						height: textureData.height,
            						levels: textureData.levels,
            						format: PIXELFORMAT_RGBA8,
            						type: TEXTURETYPE_RGBE,
            						mipmaps: false
            				}, textureOptions));
            				texture.upload();
            				return texture;
            		}
            		parse(data) {
            				var readStream = new ReadStream(data);
            				var magic = readStream.readLine();
            				if (!magic.startsWith('#?RADIANCE')) {
            						return null;
            				}
            				var variables = {};
            				while(true){
            						var line = readStream.readLine();
            						if (line.length === 0) {
            								break;
            						} else {
            								var parts = line.split('=');
            								if (parts.length === 2) {
            										variables[parts[0]] = parts[1];
            								}
            						}
            				}
            				if (!variables.hasOwnProperty('FORMAT')) {
            						return null;
            				}
            				var resolution = readStream.readLine().split(' ');
            				if (resolution.length !== 4) {
            						return null;
            				}
            				var height = parseInt(resolution[1], 10);
            				var width = parseInt(resolution[3], 10);
            				var pixels = this._readPixels(readStream, width, height, resolution[0] === '-Y');
            				if (!pixels) {
            						return null;
            				}
            				return {
            						width: width,
            						height: height,
            						levels: [
            								pixels
            						]
            				};
            		}
            		_readPixels(readStream, width, height, flipY) {
            				if (width < 8 || width > 0x7fff) {
            						return this._readPixelsFlat(readStream, width, height);
            				}
            				var rgbe = [
            						0,
            						0,
            						0,
            						0
            				];
            				readStream.readArray(rgbe);
            				if (rgbe[0] !== 2 || rgbe[1] !== 2 || (rgbe[2] & 0x80) !== 0) {
            						readStream.skip(-4);
            						return this._readPixelsFlat(readStream, width, height);
            				}
            				var buffer = new ArrayBuffer(width * height * 4);
            				var view = new Uint8Array(buffer);
            				var scanstart = flipY ? 0 : width * 4 * (height - 1);
            				var x, y, i, channel, count, value;
            				for(y = 0; y < height; ++y){
            						if (y) {
            								readStream.readArray(rgbe);
            						}
            						if ((rgbe[2] << 8) + rgbe[3] !== width) {
            								return null;
            						}
            						for(channel = 0; channel < 4; ++channel){
            								x = 0;
            								while(x < width){
            										count = readStream.readU8();
            										if (count > 128) {
            												count -= 128;
            												if (x + count > width) {
            														return null;
            												}
            												value = readStream.readU8();
            												for(i = 0; i < count; ++i){
            														view[scanstart + channel + 4 * x++] = value;
            												}
            										} else {
            												if (count === 0 || x + count > width) {
            														return null;
            												}
            												for(i = 0; i < count; ++i){
            														view[scanstart + channel + 4 * x++] = readStream.readU8();
            												}
            										}
            								}
            						}
            						scanstart += width * 4 * (flipY ? 1 : -1);
            				}
            				return view;
            		}
            		_readPixelsFlat(readStream, width, height) {
            				return readStream.remainingBytes === width * height * 4 ? new Uint8Array(readStream.arraybuffer, readStream.offset) : null;
            		}
            		constructor(registry){
            				super();
            				this.maxRetries = 0;
            		}
            }
            
            var JSON_ADDRESS_MODE = {
            		'repeat': ADDRESS_REPEAT,
            		'clamp': ADDRESS_CLAMP_TO_EDGE,
            		'mirror': ADDRESS_MIRRORED_REPEAT
            };
            var JSON_FILTER_MODE = {
            		'nearest': FILTER_NEAREST,
            		'linear': FILTER_LINEAR,
            		'nearest_mip_nearest': FILTER_NEAREST_MIPMAP_NEAREST,
            		'linear_mip_nearest': FILTER_LINEAR_MIPMAP_NEAREST,
            		'nearest_mip_linear': FILTER_NEAREST_MIPMAP_LINEAR,
            		'linear_mip_linear': FILTER_LINEAR_MIPMAP_LINEAR
            };
            var JSON_TEXTURE_TYPE = {
            		'default': TEXTURETYPE_DEFAULT,
            		'rgbm': TEXTURETYPE_RGBM,
            		'rgbe': TEXTURETYPE_RGBE,
            		'rgbp': TEXTURETYPE_RGBP,
            		'swizzleGGGR': TEXTURETYPE_SWIZZLEGGGR
            };
            var _completePartialMipmapChain = function _completePartialMipmapChain(texture) {
            		var requiredMipLevels = TextureUtils.calcMipLevelsCount(texture._width, texture._height);
            		var isHtmlElement = function isHtmlElement(object) {
            				return object instanceof HTMLCanvasElement || object instanceof HTMLImageElement || object instanceof HTMLVideoElement;
            		};
            		if (!(texture._format === PIXELFORMAT_RGBA8 || texture._format === PIXELFORMAT_RGBA32F) || texture._volume || texture._compressed || texture._levels.length === 1 || texture._levels.length === requiredMipLevels || isHtmlElement(texture._cubemap ? texture._levels[0][0] : texture._levels[0])) {
            				return;
            		}
            		var downsample = function downsample(width, height, data) {
            				var sampledWidth = Math.max(1, width >> 1);
            				var sampledHeight = Math.max(1, height >> 1);
            				var sampledData = new data.constructor(sampledWidth * sampledHeight * 4);
            				var xs = Math.floor(width / sampledWidth);
            				var ys = Math.floor(height / sampledHeight);
            				var xsys = xs * ys;
            				for(var y = 0; y < sampledHeight; ++y){
            						for(var x = 0; x < sampledWidth; ++x){
            								for(var e = 0; e < 4; ++e){
            										var sum = 0;
            										for(var sy = 0; sy < ys; ++sy){
            												for(var sx = 0; sx < xs; ++sx){
            														sum += data[(x * xs + sx + (y * ys + sy) * width) * 4 + e];
            												}
            										}
            										sampledData[(x + y * sampledWidth) * 4 + e] = sum / xsys;
            								}
            						}
            				}
            				return sampledData;
            		};
            		for(var level = texture._levels.length; level < requiredMipLevels; ++level){
            				var width = Math.max(1, texture._width >> level - 1);
            				var height = Math.max(1, texture._height >> level - 1);
            				if (texture._cubemap) {
            						var mips = [];
            						for(var face = 0; face < 6; ++face){
            								mips.push(downsample(width, height, texture._levels[level - 1][face]));
            						}
            						texture._levels.push(mips);
            				} else {
            						texture._levels.push(downsample(width, height, texture._levels[level - 1]));
            				}
            		}
            		texture._levelsUpdated = texture._cubemap ? [
            				[
            						true,
            						true,
            						true,
            						true,
            						true,
            						true
            				]
            		] : [
            				true
            		];
            };
            class TextureHandler extends ResourceHandler {
            		set crossOrigin(value) {
            				this.imgParser.crossOrigin = value;
            		}
            		get crossOrigin() {
            				return this.imgParser.crossOrigin;
            		}
            		set maxRetries(value) {
            				this.imgParser.maxRetries = value;
            				for(var parser in this.parsers){
            						if (this.parsers.hasOwnProperty(parser)) {
            								this.parsers[parser].maxRetries = value;
            						}
            				}
            		}
            		get maxRetries() {
            				return this.imgParser.maxRetries;
            		}
            		_getUrlWithoutParams(url) {
            				return url.indexOf('?') >= 0 ? url.split('?')[0] : url;
            		}
            		_getParser(url) {
            				var ext = path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace('.', '');
            				return this.parsers[ext] || this.imgParser;
            		}
            		_getTextureOptions(asset) {
            				var options = {};
            				if (asset) {
            						var _asset_name;
            						if (((_asset_name = asset.name) == null ? void 0 : _asset_name.length) > 0) {
            								options.name = asset.name;
            						}
            						var assetData = asset.data;
            						if (assetData.hasOwnProperty('minfilter')) {
            								options.minFilter = JSON_FILTER_MODE[assetData.minfilter];
            						}
            						if (assetData.hasOwnProperty('magfilter')) {
            								options.magFilter = JSON_FILTER_MODE[assetData.magfilter];
            						}
            						if (assetData.hasOwnProperty('addressu')) {
            								options.addressU = JSON_ADDRESS_MODE[assetData.addressu];
            						}
            						if (assetData.hasOwnProperty('addressv')) {
            								options.addressV = JSON_ADDRESS_MODE[assetData.addressv];
            						}
            						if (assetData.hasOwnProperty('mipmaps')) {
            								options.mipmaps = assetData.mipmaps;
            						}
            						if (assetData.hasOwnProperty('anisotropy')) {
            								options.anisotropy = assetData.anisotropy;
            						}
            						if (assetData.hasOwnProperty('flipY')) {
            								options.flipY = !!assetData.flipY;
            						}
            						if (assetData.hasOwnProperty('srgb')) {
            								options.srgb = !!assetData.srgb;
            						}
            						options.type = TEXTURETYPE_DEFAULT;
            						if (assetData.hasOwnProperty('type')) {
            								options.type = JSON_TEXTURE_TYPE[assetData.type];
            						} else if (assetData.hasOwnProperty('rgbm') && assetData.rgbm) {
            								options.type = TEXTURETYPE_RGBM;
            						} else if (asset.file && (asset.file.opt & 8) !== 0) {
            								options.type = TEXTURETYPE_SWIZZLEGGGR;
            						}
            				}
            				return options;
            		}
            		load(url, callback, asset) {
            				if (typeof url === 'string') {
            						url = {
            								load: url,
            								original: url
            						};
            				}
            				this._getParser(url.original).load(url, callback, asset);
            		}
            		open(url, data, asset) {
            				if (!url) {
            						return undefined;
            				}
            				var textureOptions = this._getTextureOptions(asset);
            				var texture = this._getParser(url).open(url, data, this._device, textureOptions);
            				if (texture === null) {
            						texture = new Texture(this._device, {
            								width: 4,
            								height: 4,
            								format: PIXELFORMAT_RGB8
            						});
            				} else {
            						_completePartialMipmapChain(texture);
            						if (data.unswizzledGGGR) {
            								asset.file.variants.basis.opt &= -9;
            						}
            				}
            				return texture;
            		}
            		patch(asset, assets) {
            				var texture = asset.resource;
            				if (!texture) {
            						return;
            				}
            				var options = this._getTextureOptions(asset);
            				for (var key of Object.keys(options)){
            						texture[key] = options[key];
            				}
            		}
            		constructor(app){
            				super(app, 'texture');
            				var assets = app.assets;
            				var device = app.graphicsDevice;
            				this._device = device;
            				this._assets = assets;
            				this.imgParser = new ImgParser(assets, device);
            				this.parsers = {
            						dds: new DdsParser(assets),
            						ktx: new KtxParser(assets),
            						ktx2: new Ktx2Parser(assets, device),
            						basis: new BasisParser(assets, device),
            						hdr: new HdrParser(assets)
            				};
            		}
            }
            
            var XRTYPE_INLINE = 'inline';
            var XRTYPE_VR = 'immersive-vr';
            var XRTYPE_AR = 'immersive-ar';
            var XRSPACE_VIEWER = 'viewer';
            var XRHAND_LEFT = 'left';
            var XRDEPTHSENSINGUSAGE_CPU = 'cpu-optimized';
            var XRDEPTHSENSINGUSAGE_GPU = 'gpu-optimized';
            var XRDEPTHSENSINGFORMAT_L8A8 = 'luminance-alpha';
            var XRDEPTHSENSINGFORMAT_R16U = 'unsigned-short';
            var XRDEPTHSENSINGFORMAT_F32 = 'float32';
            
            class XrDomOverlay {
            		get supported() {
            				return this._supported;
            		}
            		get available() {
            				return this._supported && this._manager.active && this._manager._session.domOverlayState !== null;
            		}
            		get state() {
            				if (!this._supported || !this._manager.active || !this._manager._session.domOverlayState) {
            						return null;
            				}
            				return this._manager._session.domOverlayState.type;
            		}
            		set root(value) {
            				if (!this._supported || this._manager.active) {
            						return;
            				}
            				this._root = value;
            		}
            		get root() {
            				return this._root;
            		}
            		constructor(manager){
            				this._supported = platform.browser && !!window.XRDOMOverlayState;
            				this._root = null;
            				this._manager = manager;
            		}
            }
            
            var poolVec3 = [];
            var poolQuat = [];
            class XrHitTestSource extends EventHandler {
            		remove() {
            				if (!this._xrHitTestSource) {
            						return;
            				}
            				var sources = this.manager.hitTest.sources;
            				var ind = sources.indexOf(this);
            				if (ind !== -1) sources.splice(ind, 1);
            				this.onStop();
            		}
            		onStop() {
            				this._xrHitTestSource.cancel();
            				this._xrHitTestSource = null;
            				this.fire('remove');
            				this.manager.hitTest.fire('remove', this);
            		}
            		update(frame) {
            				if (this._transient) {
            						var transientResults = frame.getHitTestResultsForTransientInput(this._xrHitTestSource);
            						for(var i = 0; i < transientResults.length; i++){
            								var transientResult = transientResults[i];
            								if (!transientResult.results.length) {
            										continue;
            								}
            								var inputSource = void 0;
            								if (transientResult.inputSource) {
            										inputSource = this.manager.input._getByInputSource(transientResult.inputSource);
            								}
            								this.updateHitResults(transientResult.results, inputSource);
            						}
            				} else {
            						var results = frame.getHitTestResults(this._xrHitTestSource);
            						if (!results.length) {
            								return;
            						}
            						this.updateHitResults(results);
            				}
            		}
            		updateHitResults(results, inputSource) {
            				if (this._inputSource && this._inputSource !== inputSource) {
            						return;
            				}
            				var _poolVec3_pop;
            				var origin = (_poolVec3_pop = poolVec3.pop()) != null ? _poolVec3_pop : new Vec3();
            				if (inputSource) {
            						origin.copy(inputSource.getOrigin());
            				} else {
            						origin.copy(this.manager.camera.getPosition());
            				}
            				var candidateDistance = Infinity;
            				var candidateHitTestResult = null;
            				var _poolVec3_pop1;
            				var position = (_poolVec3_pop1 = poolVec3.pop()) != null ? _poolVec3_pop1 : new Vec3();
            				var _poolQuat_pop;
            				var rotation = (_poolQuat_pop = poolQuat.pop()) != null ? _poolQuat_pop : new Quat();
            				for(var i = 0; i < results.length; i++){
            						var pose = results[i].getPose(this.manager._referenceSpace);
            						var distance = origin.distance(pose.transform.position);
            						if (distance >= candidateDistance) {
            								continue;
            						}
            						candidateDistance = distance;
            						candidateHitTestResult = results[i];
            						position.copy(pose.transform.position);
            						rotation.copy(pose.transform.orientation);
            				}
            				this.fire('result', position, rotation, inputSource || this._inputSource, candidateHitTestResult);
            				this.manager.hitTest.fire('result', this, position, rotation, inputSource || this._inputSource, candidateHitTestResult);
            				poolVec3.push(origin);
            				poolVec3.push(position);
            				poolQuat.push(rotation);
            		}
            		constructor(manager, xrHitTestSource, transient, inputSource = null){
            				super();
            				this.manager = manager;
            				this._xrHitTestSource = xrHitTestSource;
            				this._transient = transient;
            				this._inputSource = inputSource;
            		}
            }
            XrHitTestSource.EVENT_REMOVE = 'remove';
            XrHitTestSource.EVENT_RESULT = 'result';
            
            class XrHitTest extends EventHandler {
            		_onSessionStart() {
            				if (this.manager.session.enabledFeatures) {
            						var available = this.manager.session.enabledFeatures.indexOf('hit-test') !== -1;
            						if (!available) return;
            						this._available = available;
            						this.fire('available');
            				} else if (!this._checkingAvailability) {
            						this._checkingAvailability = true;
            						this.manager.session.requestReferenceSpace(XRSPACE_VIEWER).then((referenceSpace)=>{
            								this.manager.session.requestHitTestSource({
            										space: referenceSpace
            								}).then((hitTestSource)=>{
            										hitTestSource.cancel();
            										if (this.manager.active) {
            												this._available = true;
            												this.fire('available');
            										}
            								}).catch(()=>{});
            						}).catch(()=>{});
            				}
            		}
            		_onSessionEnd() {
            				if (!this._available) return;
            				this._available = false;
            				for(var i = 0; i < this.sources.length; i++){
            						this.sources[i].onStop();
            				}
            				this.sources = [];
            				this.fire('unavailable');
            		}
            		start(options) {
            				if (options === void 0) options = {};
            				if (!this._supported) {
            						options.callback == null ? void 0 : options.callback.call(options, new Error('XR HitTest is not supported'), null);
            						return;
            				}
            				if (!this._available) {
            						options.callback == null ? void 0 : options.callback.call(options, new Error('XR HitTest is not available'), null);
            						return;
            				}
            				if (!options.profile && !options.spaceType) {
            						options.spaceType = XRSPACE_VIEWER;
            				}
            				var xrRay;
            				var offsetRay = options.offsetRay;
            				if (offsetRay) {
            						var origin = new DOMPoint(offsetRay.origin.x, offsetRay.origin.y, offsetRay.origin.z, 1.0);
            						var direction = new DOMPoint(offsetRay.direction.x, offsetRay.direction.y, offsetRay.direction.z, 0.0);
            						xrRay = new XRRay(origin, direction);
            				}
            				var callback = options.callback;
            				if (options.spaceType) {
            						this.manager.session.requestReferenceSpace(options.spaceType).then((referenceSpace)=>{
            								if (!this.manager.session) {
            										var err = new Error('XR Session is not started (2)');
            										if (callback) callback(err);
            										this.fire('error', err);
            										return;
            								}
            								this.manager.session.requestHitTestSource({
            										space: referenceSpace,
            										entityTypes: options.entityTypes || undefined,
            										offsetRay: xrRay
            								}).then((xrHitTestSource)=>{
            										this._onHitTestSource(xrHitTestSource, false, options.inputSource, callback);
            								}).catch((ex)=>{
            										if (callback) callback(ex);
            										this.fire('error', ex);
            								});
            						}).catch((ex)=>{
            								if (callback) callback(ex);
            								this.fire('error', ex);
            						});
            				} else {
            						this.manager.session.requestHitTestSourceForTransientInput({
            								profile: options.profile,
            								entityTypes: options.entityTypes || undefined,
            								offsetRay: xrRay
            						}).then((xrHitTestSource)=>{
            								this._onHitTestSource(xrHitTestSource, true, options.inputSource, callback);
            						}).catch((ex)=>{
            								if (callback) callback(ex);
            								this.fire('error', ex);
            						});
            				}
            		}
            		_onHitTestSource(xrHitTestSource, transient, inputSource, callback) {
            				if (!this.manager.session) {
            						xrHitTestSource.cancel();
            						var err = new Error('XR Session is not started (3)');
            						if (callback) callback(err);
            						this.fire('error', err);
            						return;
            				}
            				var hitTestSource = new XrHitTestSource(this.manager, xrHitTestSource, transient, inputSource != null ? inputSource : null);
            				this.sources.push(hitTestSource);
            				if (callback) callback(null, hitTestSource);
            				this.fire('add', hitTestSource);
            		}
            		update(frame) {
            				if (!this._available) {
            						return;
            				}
            				for(var i = 0; i < this.sources.length; i++){
            						this.sources[i].update(frame);
            				}
            		}
            		get supported() {
            				return this._supported;
            		}
            		get available() {
            				return this._available;
            		}
            		constructor(manager){
            				super(), this._supported = platform.browser && !!(window.XRSession && window.XRSession.prototype.requestHitTestSource), this._available = false, this._checkingAvailability = false, this.sources = [];
            				this.manager = manager;
            				if (this._supported) {
            						this.manager.on('start', this._onSessionStart, this);
            						this.manager.on('end', this._onSessionEnd, this);
            				}
            		}
            }
            XrHitTest.EVENT_AVAILABLE = 'available';
            XrHitTest.EVENT_UNAVAILABLE = 'unavailable';
            XrHitTest.EVENT_ADD = 'add';
            XrHitTest.EVENT_REMOVE = 'remove';
            XrHitTest.EVENT_RESULT = 'result';
            XrHitTest.EVENT_ERROR = 'error';
            
            class XrTrackedImage extends EventHandler {
            		get image() {
            				return this._image;
            		}
            		set width(value) {
            				this._width = value;
            		}
            		get width() {
            				return this._width;
            		}
            		get trackable() {
            				return this._trackable;
            		}
            		get tracking() {
            				return this._tracking;
            		}
            		get emulated() {
            				return this._emulated;
            		}
            		prepare() {
            				if (this._bitmap) {
            						return {
            								image: this._bitmap,
            								widthInMeters: this._width
            						};
            				}
            				return createImageBitmap(this._image).then((bitmap)=>{
            						this._bitmap = bitmap;
            						return {
            								image: this._bitmap,
            								widthInMeters: this._width
            						};
            				});
            		}
            		destroy() {
            				this._image = null;
            				this._pose = null;
            				if (this._bitmap) {
            						this._bitmap.close();
            						this._bitmap = null;
            				}
            		}
            		getPosition() {
            				if (this._pose) this._position.copy(this._pose.transform.position);
            				return this._position;
            		}
            		getRotation() {
            				if (this._pose) this._rotation.copy(this._pose.transform.orientation);
            				return this._rotation;
            		}
            		constructor(image, width){
            				super(), this._bitmap = null, this._measuredWidth = 0, this._trackable = false, this._tracking = false, this._emulated = false, this._pose = null, this._position = new Vec3(), this._rotation = new Quat();
            				this._image = image;
            				this._width = width;
            		}
            }
            XrTrackedImage.EVENT_TRACKED = 'tracked';
            XrTrackedImage.EVENT_UNTRACKED = 'untracked';
            
            class XrImageTracking extends EventHandler {
            		add(image, width) {
            				if (!this._supported || this._manager.active) return null;
            				var trackedImage = new XrTrackedImage(image, width);
            				this._images.push(trackedImage);
            				return trackedImage;
            		}
            		remove(trackedImage) {
            				if (this._manager.active) return;
            				var ind = this._images.indexOf(trackedImage);
            				if (ind !== -1) {
            						trackedImage.destroy();
            						this._images.splice(ind, 1);
            				}
            		}
            		_onSessionStart() {
            				this._manager.session.getTrackedImageScores().then((images)=>{
            						this._available = true;
            						for(var i = 0; i < images.length; i++){
            								this._images[i]._trackable = images[i] === 'trackable';
            						}
            				}).catch((err)=>{
            						this._available = false;
            						this.fire('error', err);
            				});
            		}
            		_onSessionEnd() {
            				this._available = false;
            				for(var i = 0; i < this._images.length; i++){
            						var image = this._images[i];
            						image._pose = null;
            						image._measuredWidth = 0;
            						if (image._tracking) {
            								image._tracking = false;
            								image.fire('untracked');
            						}
            				}
            		}
            		prepareImages(callback) {
            				if (this._images.length) {
            						Promise.all(this._images.map((trackedImage)=>{
            								return trackedImage.prepare();
            						})).then((bitmaps)=>{
            								callback(null, bitmaps);
            						}).catch((err)=>{
            								callback(err, null);
            						});
            				} else {
            						callback(null, null);
            				}
            		}
            		update(frame) {
            				if (!this._available) return;
            				var results = frame.getImageTrackingResults();
            				var index = {};
            				for(var i = 0; i < results.length; i++){
            						index[results[i].index] = results[i];
            						var trackedImage = this._images[results[i].index];
            						trackedImage._emulated = results[i].trackingState === 'emulated';
            						trackedImage._measuredWidth = results[i].measuredWidthInMeters;
            						trackedImage._pose = frame.getPose(results[i].imageSpace, this._manager._referenceSpace);
            				}
            				for(var i1 = 0; i1 < this._images.length; i1++){
            						if (this._images[i1]._tracking && !index[i1]) {
            								this._images[i1]._tracking = false;
            								this._images[i1].fire('untracked');
            						} else if (!this._images[i1]._tracking && index[i1]) {
            								this._images[i1]._tracking = true;
            								this._images[i1].fire('tracked');
            						}
            				}
            		}
            		get supported() {
            				return this._supported;
            		}
            		get available() {
            				return this._available;
            		}
            		get images() {
            				return this._images;
            		}
            		constructor(manager){
            				super(), this._supported = platform.browser && !!window.XRImageTrackingResult, this._available = false, this._images = [];
            				this._manager = manager;
            				if (this._supported) {
            						this._manager.on('start', this._onSessionStart, this);
            						this._manager.on('end', this._onSessionEnd, this);
            				}
            		}
            }
            XrImageTracking.EVENT_ERROR = 'error';
            
            class XrFinger {
            		get index() {
            				return this._index;
            		}
            		get hand() {
            				return this._hand;
            		}
            		get joints() {
            				return this._joints;
            		}
            		get tip() {
            				return this._tip;
            		}
            		constructor(index, hand){
            				this._joints = [];
            				this._tip = null;
            				this._index = index;
            				this._hand = hand;
            				this._hand._fingers.push(this);
            		}
            }
            
            var tipJointIds = platform.browser && window.XRHand ? [
            		'thumb-tip',
            		'index-finger-tip',
            		'middle-finger-tip',
            		'ring-finger-tip',
            		'pinky-finger-tip'
            ] : [];
            var tipJointIdsIndex = {};
            for(var i = 0; i < tipJointIds.length; i++){
            		tipJointIdsIndex[tipJointIds[i]] = true;
            }
            class XrJoint {
            		update(pose) {
            				this._dirtyLocal = true;
            				this._radius = pose.radius;
            				this._localPosition.copy(pose.transform.position);
            				this._localRotation.copy(pose.transform.orientation);
            		}
            		_updateTransforms() {
            				if (this._dirtyLocal) {
            						this._dirtyLocal = false;
            						this._localTransform.setTRS(this._localPosition, this._localRotation, Vec3.ONE);
            				}
            				var manager = this._hand._manager;
            				var parent = manager.camera.parent;
            				if (parent) {
            						this._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);
            				} else {
            						this._worldTransform.copy(this._localTransform);
            				}
            		}
            		getPosition() {
            				this._updateTransforms();
            				this._worldTransform.getTranslation(this._position);
            				return this._position;
            		}
            		getRotation() {
            				this._updateTransforms();
            				this._rotation.setFromMat4(this._worldTransform);
            				return this._rotation;
            		}
            		get id() {
            				return this._id;
            		}
            		get index() {
            				return this._index;
            		}
            		get hand() {
            				return this._hand;
            		}
            		get finger() {
            				return this._finger;
            		}
            		get wrist() {
            				return this._wrist;
            		}
            		get tip() {
            				return this._tip;
            		}
            		get radius() {
            				return this._radius || 0.005;
            		}
            		constructor(index, id, hand, finger = null){
            				this._radius = null;
            				this._localTransform = new Mat4();
            				this._worldTransform = new Mat4();
            				this._localPosition = new Vec3();
            				this._localRotation = new Quat();
            				this._position = new Vec3();
            				this._rotation = new Quat();
            				this._dirtyLocal = true;
            				this._index = index;
            				this._id = id;
            				this._hand = hand;
            				this._finger = finger;
            				this._wrist = id === 'wrist';
            				this._tip = this._finger && !!tipJointIdsIndex[id];
            		}
            }
            
            var fingerJointIds = [];
            var vecA = new Vec3();
            var vecB = new Vec3();
            var vecC = new Vec3();
            if (platform.browser && window.XRHand) {
            		fingerJointIds = [
            				[
            						'thumb-metacarpal',
            						'thumb-phalanx-proximal',
            						'thumb-phalanx-distal',
            						'thumb-tip'
            				],
            				[
            						'index-finger-metacarpal',
            						'index-finger-phalanx-proximal',
            						'index-finger-phalanx-intermediate',
            						'index-finger-phalanx-distal',
            						'index-finger-tip'
            				],
            				[
            						'middle-finger-metacarpal',
            						'middle-finger-phalanx-proximal',
            						'middle-finger-phalanx-intermediate',
            						'middle-finger-phalanx-distal',
            						'middle-finger-tip'
            				],
            				[
            						'ring-finger-metacarpal',
            						'ring-finger-phalanx-proximal',
            						'ring-finger-phalanx-intermediate',
            						'ring-finger-phalanx-distal',
            						'ring-finger-tip'
            				],
            				[
            						'pinky-finger-metacarpal',
            						'pinky-finger-phalanx-proximal',
            						'pinky-finger-phalanx-intermediate',
            						'pinky-finger-phalanx-distal',
            						'pinky-finger-tip'
            				]
            		];
            }
            class XrHand extends EventHandler {
            		update(frame) {
            				var xrInputSource = this._inputSource._xrInputSource;
            				for(var j = 0; j < this._joints.length; j++){
            						var joint = this._joints[j];
            						var jointSpace = xrInputSource.hand.get(joint._id);
            						if (jointSpace) {
            								var pose = void 0;
            								if (frame.session.visibilityState !== 'hidden') {
            										pose = frame.getJointPose(jointSpace, this._manager._referenceSpace);
            								}
            								if (pose) {
            										joint.update(pose);
            										if (joint.wrist && !this._tracking) {
            												this._tracking = true;
            												this.fire('tracking');
            										}
            								} else if (joint.wrist) {
            										if (this._tracking) {
            												this._tracking = false;
            												this.fire('trackinglost');
            										}
            										break;
            								}
            						}
            				}
            				var j1 = this._jointsById['thumb-metacarpal'];
            				var j4 = this._jointsById['thumb-tip'];
            				var j6 = this._jointsById['index-finger-phalanx-proximal'];
            				var j9 = this._jointsById['index-finger-tip'];
            				var j16 = this._jointsById['ring-finger-phalanx-proximal'];
            				var j21 = this._jointsById['pinky-finger-phalanx-proximal'];
            				if (j1 && j4 && j6 && j9 && j16 && j21) {
            						this._inputSource._dirtyRay = true;
            						this._inputSource._rayLocal.origin.lerp(j4._localPosition, j9._localPosition, 0.5);
            						var jointL = j1;
            						var jointR = j21;
            						if (this._inputSource.handedness === XRHAND_LEFT) {
            								var t = jointL;
            								jointL = jointR;
            								jointR = t;
            						}
            						vecA.sub2(jointL._localPosition, this._wrist._localPosition);
            						vecB.sub2(jointR._localPosition, this._wrist._localPosition);
            						vecC.cross(vecA, vecB).normalize();
            						vecA.lerp(j6._localPosition, j16._localPosition, 0.5);
            						vecA.sub(this._wrist._localPosition).normalize();
            						this._inputSource._rayLocal.direction.lerp(vecC, vecA, 0.5).normalize();
            				}
            				var squeezing = this._fingerIsClosed(1) && this._fingerIsClosed(2) && this._fingerIsClosed(3) && this._fingerIsClosed(4);
            				if (squeezing) {
            						if (!this._inputSource._squeezing) {
            								this._inputSource._squeezing = true;
            								this._inputSource.fire('squeezestart');
            								this._manager.input.fire('squeezestart', this._inputSource);
            						}
            				} else {
            						if (this._inputSource._squeezing) {
            								this._inputSource._squeezing = false;
            								this._inputSource.fire('squeeze');
            								this._manager.input.fire('squeeze', this._inputSource);
            								this._inputSource.fire('squeezeend');
            								this._manager.input.fire('squeezeend', this._inputSource);
            						}
            				}
            		}
            		_fingerIsClosed(index) {
            				var finger = this._fingers[index];
            				vecA.sub2(finger.joints[0]._localPosition, finger.joints[1]._localPosition).normalize();
            				vecB.sub2(finger.joints[2]._localPosition, finger.joints[3]._localPosition).normalize();
            				return vecA.dot(vecB) < -0.8;
            		}
            		getJointById(id) {
            				return this._jointsById[id] || null;
            		}
            		get fingers() {
            				return this._fingers;
            		}
            		get joints() {
            				return this._joints;
            		}
            		get tips() {
            				return this._tips;
            		}
            		get wrist() {
            				return this._wrist;
            		}
            		get tracking() {
            				return this._tracking;
            		}
            		constructor(inputSource){
            				super(), this._tracking = false, this._fingers = [], this._joints = [], this._jointsById = {}, this._tips = [], this._wrist = null;
            				var xrHand = inputSource._xrInputSource.hand;
            				this._manager = inputSource._manager;
            				this._inputSource = inputSource;
            				if (xrHand.get('wrist')) {
            						var joint = new XrJoint(0, 'wrist', this, null);
            						this._wrist = joint;
            						this._joints.push(joint);
            						this._jointsById.wrist = joint;
            				}
            				for(var f = 0; f < fingerJointIds.length; f++){
            						var finger = new XrFinger(f, this);
            						for(var j = 0; j < fingerJointIds[f].length; j++){
            								var jointId = fingerJointIds[f][j];
            								if (!xrHand.get(jointId)) continue;
            								var joint1 = new XrJoint(j, jointId, this, finger);
            								this._joints.push(joint1);
            								this._jointsById[jointId] = joint1;
            								if (joint1.tip) {
            										this._tips.push(joint1);
            										finger._tip = joint1;
            								}
            								finger._joints.push(joint1);
            						}
            				}
            		}
            }
            XrHand.EVENT_TRACKING = 'tracking';
            XrHand.EVENT_TRACKINGLOST = 'trackinglost';
            
            var vec3A$1 = new Vec3();
            var quat = new Quat();
            var ids$1 = 0;
            class XrInputSource extends EventHandler {
            		get id() {
            				return this._id;
            		}
            		get inputSource() {
            				return this._xrInputSource;
            		}
            		get targetRayMode() {
            				return this._xrInputSource.targetRayMode;
            		}
            		get handedness() {
            				return this._xrInputSource.handedness;
            		}
            		get profiles() {
            				return this._xrInputSource.profiles;
            		}
            		get grip() {
            				return this._grip;
            		}
            		get hand() {
            				return this._hand;
            		}
            		get gamepad() {
            				return this._xrInputSource.gamepad || null;
            		}
            		get selecting() {
            				return this._selecting;
            		}
            		get squeezing() {
            				return this._squeezing;
            		}
            		set elementInput(value) {
            				if (this._elementInput === value) {
            						return;
            				}
            				this._elementInput = value;
            				if (!this._elementInput) {
            						this._elementEntity = null;
            				}
            		}
            		get elementInput() {
            				return this._elementInput;
            		}
            		get elementEntity() {
            				return this._elementEntity;
            		}
            		get hitTestSources() {
            				return this._hitTestSources;
            		}
            		update(frame) {
            				if (this._hand) {
            						this._hand.update(frame);
            				} else {
            						var gripSpace = this._xrInputSource.gripSpace;
            						if (gripSpace) {
            								var gripPose = frame.getPose(gripSpace, this._manager._referenceSpace);
            								if (gripPose) {
            										if (!this._grip) {
            												this._grip = true;
            												this._localTransform = new Mat4();
            												this._worldTransform = new Mat4();
            												this._localPositionLast = new Vec3();
            												this._localPosition = new Vec3();
            												this._localRotation = new Quat();
            												this._linearVelocity = new Vec3();
            										}
            										var timestamp = now();
            										var dt = (timestamp - this._velocitiesTimestamp) / 1000;
            										this._velocitiesTimestamp = timestamp;
            										this._dirtyLocal = true;
            										this._localPositionLast.copy(this._localPosition);
            										this._localPosition.copy(gripPose.transform.position);
            										this._localRotation.copy(gripPose.transform.orientation);
            										this._velocitiesAvailable = true;
            										if (this._manager.input.velocitiesSupported && gripPose.linearVelocity) {
            												this._linearVelocity.copy(gripPose.linearVelocity);
            										} else if (dt > 0) {
            												vec3A$1.sub2(this._localPosition, this._localPositionLast).divScalar(dt);
            												this._linearVelocity.lerp(this._linearVelocity, vec3A$1, 0.15);
            										}
            								} else {
            										this._velocitiesAvailable = false;
            								}
            						}
            						var targetRayPose = frame.getPose(this._xrInputSource.targetRaySpace, this._manager._referenceSpace);
            						if (targetRayPose) {
            								this._dirtyRay = true;
            								this._rayLocal.origin.copy(targetRayPose.transform.position);
            								this._rayLocal.direction.set(0, 0, -1);
            								quat.copy(targetRayPose.transform.orientation);
            								quat.transformVector(this._rayLocal.direction, this._rayLocal.direction);
            						}
            				}
            		}
            		_updateTransforms() {
            				if (this._dirtyLocal) {
            						this._dirtyLocal = false;
            						this._localTransform.setTRS(this._localPosition, this._localRotation, Vec3.ONE);
            				}
            				var parent = this._manager.camera.parent;
            				if (parent) {
            						this._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);
            				} else {
            						this._worldTransform.copy(this._localTransform);
            				}
            		}
            		_updateRayTransforms() {
            				var dirty = this._dirtyRay;
            				this._dirtyRay = false;
            				var parent = this._manager.camera.parent;
            				if (parent) {
            						var parentTransform = this._manager.camera.parent.getWorldTransform();
            						parentTransform.getTranslation(this._position);
            						this._rotation.setFromMat4(parentTransform);
            						this._rotation.transformVector(this._rayLocal.origin, this._ray.origin);
            						this._ray.origin.add(this._position);
            						this._rotation.transformVector(this._rayLocal.direction, this._ray.direction);
            				} else if (dirty) {
            						this._ray.origin.copy(this._rayLocal.origin);
            						this._ray.direction.copy(this._rayLocal.direction);
            				}
            		}
            		getPosition() {
            				if (!this._position) return null;
            				this._updateTransforms();
            				this._worldTransform.getTranslation(this._position);
            				return this._position;
            		}
            		getLocalPosition() {
            				return this._localPosition;
            		}
            		getRotation() {
            				if (!this._rotation) return null;
            				this._updateTransforms();
            				this._rotation.setFromMat4(this._worldTransform);
            				return this._rotation;
            		}
            		getLocalRotation() {
            				return this._localRotation;
            		}
            		getLinearVelocity() {
            				if (!this._velocitiesAvailable) {
            						return null;
            				}
            				return this._linearVelocity;
            		}
            		getOrigin() {
            				this._updateRayTransforms();
            				return this._ray.origin;
            		}
            		getDirection() {
            				this._updateRayTransforms();
            				return this._ray.direction;
            		}
            		hitTestStart(options) {
            				if (options === void 0) options = {};
            				options.inputSource = this;
            				options.profile = this._xrInputSource.profiles[0];
            				var callback = options.callback;
            				options.callback = (err, hitTestSource)=>{
            						if (hitTestSource) this.onHitTestSourceAdd(hitTestSource);
            						if (callback) callback(err, hitTestSource);
            				};
            				this._manager.hitTest.start(options);
            		}
            		onHitTestSourceAdd(hitTestSource) {
            				this._hitTestSources.push(hitTestSource);
            				this.fire('hittest:add', hitTestSource);
            				hitTestSource.on('result', (position, rotation, inputSource, hitTestResult)=>{
            						if (inputSource !== this) return;
            						this.fire('hittest:result', hitTestSource, position, rotation, hitTestResult);
            				});
            				hitTestSource.once('remove', ()=>{
            						this.onHitTestSourceRemove(hitTestSource);
            						this.fire('hittest:remove', hitTestSource);
            				});
            		}
            		onHitTestSourceRemove(hitTestSource) {
            				var ind = this._hitTestSources.indexOf(hitTestSource);
            				if (ind !== -1) this._hitTestSources.splice(ind, 1);
            		}
            		constructor(manager, xrInputSource){
            				super(), this._ray = new Ray(), this._rayLocal = new Ray(), this._grip = false, this._hand = null, this._velocitiesAvailable = false, this._velocitiesTimestamp = now(), this._localTransform = null, this._worldTransform = null, this._position = new Vec3(), this._rotation = new Quat(), this._localPosition = null, this._localPositionLast = null, this._localRotation = null, this._linearVelocity = null, this._dirtyLocal = true, this._dirtyRay = false, this._selecting = false, this._squeezing = false, this._elementInput = true, this._elementEntity = null, this._hitTestSources = [];
            				this._id = ++ids$1;
            				this._manager = manager;
            				this._xrInputSource = xrInputSource;
            				if (xrInputSource.hand) {
            						this._hand = new XrHand(this);
            				}
            		}
            }
            XrInputSource.EVENT_REMOVE = 'remove';
            XrInputSource.EVENT_SELECT = 'select';
            XrInputSource.EVENT_SELECTSTART = 'selectstart';
            XrInputSource.EVENT_SELECTEND = 'selectend';
            XrInputSource.EVENT_SQUEEZE = 'squeeze';
            XrInputSource.EVENT_SQUEEZESTART = 'squeezestart';
            XrInputSource.EVENT_SQUEEZEEND = 'squeezeend';
            XrInputSource.EVENT_HITTESTADD = 'hittest:add';
            XrInputSource.EVENT_HITTESTREMOVE = 'hittest:remove';
            XrInputSource.EVENT_HITTESTRESULT = 'hittest:result';
            
            class XrInput extends EventHandler {
            		_onSessionStart() {
            				var session = this.manager.session;
            				session.addEventListener('inputsourceschange', this._onInputSourcesChangeEvt);
            				session.addEventListener('select', (evt)=>{
            						var inputSource = this._getByInputSource(evt.inputSource);
            						inputSource.update(evt.frame);
            						inputSource.fire('select', evt);
            						this.fire('select', inputSource, evt);
            				});
            				session.addEventListener('selectstart', (evt)=>{
            						var inputSource = this._getByInputSource(evt.inputSource);
            						inputSource.update(evt.frame);
            						inputSource._selecting = true;
            						inputSource.fire('selectstart', evt);
            						this.fire('selectstart', inputSource, evt);
            				});
            				session.addEventListener('selectend', (evt)=>{
            						var inputSource = this._getByInputSource(evt.inputSource);
            						inputSource.update(evt.frame);
            						inputSource._selecting = false;
            						inputSource.fire('selectend', evt);
            						this.fire('selectend', inputSource, evt);
            				});
            				session.addEventListener('squeeze', (evt)=>{
            						var inputSource = this._getByInputSource(evt.inputSource);
            						inputSource.update(evt.frame);
            						inputSource.fire('squeeze', evt);
            						this.fire('squeeze', inputSource, evt);
            				});
            				session.addEventListener('squeezestart', (evt)=>{
            						var inputSource = this._getByInputSource(evt.inputSource);
            						inputSource.update(evt.frame);
            						inputSource._squeezing = true;
            						inputSource.fire('squeezestart', evt);
            						this.fire('squeezestart', inputSource, evt);
            				});
            				session.addEventListener('squeezeend', (evt)=>{
            						var inputSource = this._getByInputSource(evt.inputSource);
            						inputSource.update(evt.frame);
            						inputSource._squeezing = false;
            						inputSource.fire('squeezeend', evt);
            						this.fire('squeezeend', inputSource, evt);
            				});
            				var inputSources = session.inputSources;
            				for(var i = 0; i < inputSources.length; i++){
            						this._addInputSource(inputSources[i]);
            				}
            		}
            		_onSessionEnd() {
            				var i = this._inputSources.length;
            				while(i--){
            						var inputSource = this._inputSources[i];
            						this._inputSources.splice(i, 1);
            						inputSource.fire('remove');
            						this.fire('remove', inputSource);
            				}
            				var session = this.manager.session;
            				session.removeEventListener('inputsourceschange', this._onInputSourcesChangeEvt);
            		}
            		_onInputSourcesChange(evt) {
            				for(var i = 0; i < evt.removed.length; i++){
            						this._removeInputSource(evt.removed[i]);
            				}
            				for(var i1 = 0; i1 < evt.added.length; i1++){
            						this._addInputSource(evt.added[i1]);
            				}
            		}
            		_getByInputSource(xrInputSource) {
            				for(var i = 0; i < this._inputSources.length; i++){
            						if (this._inputSources[i].inputSource === xrInputSource) {
            								return this._inputSources[i];
            						}
            				}
            				return null;
            		}
            		_addInputSource(xrInputSource) {
            				if (this._getByInputSource(xrInputSource)) {
            						return;
            				}
            				var inputSource = new XrInputSource(this.manager, xrInputSource);
            				this._inputSources.push(inputSource);
            				this.fire('add', inputSource);
            		}
            		_removeInputSource(xrInputSource) {
            				for(var i = 0; i < this._inputSources.length; i++){
            						if (this._inputSources[i].inputSource !== xrInputSource) {
            								continue;
            						}
            						var inputSource = this._inputSources[i];
            						this._inputSources.splice(i, 1);
            						var h = inputSource.hitTestSources.length;
            						while(h--){
            								inputSource.hitTestSources[h].remove();
            						}
            						inputSource.fire('remove');
            						this.fire('remove', inputSource);
            						return;
            				}
            		}
            		update(frame) {
            				for(var i = 0; i < this._inputSources.length; i++){
            						this._inputSources[i].update(frame);
            				}
            		}
            		get inputSources() {
            				return this._inputSources;
            		}
            		constructor(manager){
            				var _window_XRPose_prototype, _window_XRPose;
            				super(), this._inputSources = [], this.velocitiesSupported = false;
            				this.manager = manager;
            				this.velocitiesSupported = !!(platform.browser && ((_window_XRPose = window.XRPose) == null ? void 0 : (_window_XRPose_prototype = _window_XRPose.prototype) == null ? void 0 : _window_XRPose_prototype.hasOwnProperty('linearVelocity')));
            				this._onInputSourcesChangeEvt = (evt)=>{
            						this._onInputSourcesChange(evt);
            				};
            				this.manager.on('start', this._onSessionStart, this);
            				this.manager.on('end', this._onSessionEnd, this);
            		}
            }
            XrInput.EVENT_ADD = 'add';
            XrInput.EVENT_REMOVE = 'remove';
            XrInput.EVENT_SELECT = 'select';
            XrInput.EVENT_SELECTSTART = 'selectstart';
            XrInput.EVENT_SELECTEND = 'selectend';
            XrInput.EVENT_SQUEEZE = 'squeeze';
            XrInput.EVENT_SQUEEZESTART = 'squeezestart';
            XrInput.EVENT_SQUEEZEEND = 'squeezeend';
            
            var vec3A = new Vec3();
            var vec3B = new Vec3();
            var mat4A = new Mat4();
            var mat4B = new Mat4();
            class XrLightEstimation extends EventHandler {
            		_onSessionStart() {
            				var supported = !!this._manager.session.requestLightProbe;
            				if (!supported) return;
            				this._supported = true;
            		}
            		_onSessionEnd() {
            				this._supported = false;
            				this._available = false;
            				this._lightProbeRequested = false;
            				this._lightProbe = null;
            		}
            		start() {
            				var err;
            				if (!this._manager.session) {
            						err = new Error('XR session is not running');
            				}
            				if (!err && this._manager.type !== XRTYPE_AR) {
            						err = new Error('XR session type is not AR');
            				}
            				if (!err && !this._supported) {
            						err = new Error('light-estimation is not supported');
            				}
            				if (!err && this._lightProbe || this._lightProbeRequested) {
            						err = new Error('light estimation is already requested');
            				}
            				if (err) {
            						this.fire('error', err);
            						return;
            				}
            				this._lightProbeRequested = true;
            				this._manager.session.requestLightProbe().then((lightProbe)=>{
            						var wasRequested = this._lightProbeRequested;
            						this._lightProbeRequested = false;
            						if (this._manager.active) {
            								if (wasRequested) {
            										this._lightProbe = lightProbe;
            								}
            						} else {
            								this.fire('error', new Error('XR session is not active'));
            						}
            				}).catch((ex)=>{
            						this._lightProbeRequested = false;
            						this.fire('error', ex);
            				});
            		}
            		end() {
            				this._lightProbeRequested = false;
            				this._lightProbe = null;
            				this._available = false;
            		}
            		update(frame) {
            				if (!this._lightProbe) return;
            				var lightEstimate = frame.getLightEstimate(this._lightProbe);
            				if (!lightEstimate) return;
            				if (!this._available) {
            						this._available = true;
            						this.fire('available');
            				}
            				var pli = lightEstimate.primaryLightIntensity;
            				this._intensity = Math.max(1.0, Math.max(pli.x, Math.max(pli.y, pli.z)));
            				vec3A.copy(pli).mulScalar(1 / this._intensity);
            				this._color.set(vec3A.x, vec3A.y, vec3A.z);
            				vec3A.set(0, 0, 0);
            				vec3B.copy(lightEstimate.primaryLightDirection);
            				mat4A.setLookAt(vec3B, vec3A, Vec3.UP);
            				mat4B.setFromAxisAngle(Vec3.RIGHT, 90);
            				mat4A.mul(mat4B);
            				this._rotation.setFromMat4(mat4A);
            				this._sphericalHarmonics.set(lightEstimate.sphericalHarmonicsCoefficients);
            		}
            		get supported() {
            				return this._supported;
            		}
            		get available() {
            				return this._available;
            		}
            		get intensity() {
            				return this._available ? this._intensity : null;
            		}
            		get color() {
            				return this._available ? this._color : null;
            		}
            		get rotation() {
            				return this._available ? this._rotation : null;
            		}
            		get sphericalHarmonics() {
            				return this._available ? this._sphericalHarmonics : null;
            		}
            		constructor(manager){
            				super(), this._supported = false, this._available = false, this._lightProbeRequested = false, this._lightProbe = null, this._intensity = 0, this._rotation = new Quat(), this._color = new Color(), this._sphericalHarmonics = new Float32Array(27);
            				this._manager = manager;
            				this._manager.on('start', this._onSessionStart, this);
            				this._manager.on('end', this._onSessionEnd, this);
            		}
            }
            XrLightEstimation.EVENT_AVAILABLE = 'available';
            XrLightEstimation.EVENT_ERROR = 'error';
            
            var ids = 0;
            class XrPlane extends EventHandler {
            		destroy() {
            				if (!this._xrPlane) return;
            				this._xrPlane = null;
            				this.fire('remove');
            		}
            		update(frame) {
            				var manager = this._planeDetection._manager;
            				var pose = frame.getPose(this._xrPlane.planeSpace, manager._referenceSpace);
            				if (pose) {
            						this._position.copy(pose.transform.position);
            						this._rotation.copy(pose.transform.orientation);
            				}
            				if (this._lastChangedTime !== this._xrPlane.lastChangedTime) {
            						this._lastChangedTime = this._xrPlane.lastChangedTime;
            						this.fire('change');
            				}
            		}
            		getPosition() {
            				return this._position;
            		}
            		getRotation() {
            				return this._rotation;
            		}
            		get id() {
            				return this._id;
            		}
            		get orientation() {
            				return this._orientation;
            		}
            		get points() {
            				return this._xrPlane.polygon;
            		}
            		get label() {
            				return this._xrPlane.semanticLabel || '';
            		}
            		constructor(planeDetection, xrPlane){
            				super(), this._position = new Vec3(), this._rotation = new Quat();
            				this._id = ++ids;
            				this._planeDetection = planeDetection;
            				this._xrPlane = xrPlane;
            				this._lastChangedTime = xrPlane.lastChangedTime;
            				this._orientation = xrPlane.orientation;
            		}
            }
            XrPlane.EVENT_REMOVE = 'remove';
            XrPlane.EVENT_CHANGE = 'change';
            
            class XrPlaneDetection extends EventHandler {
            		_onSessionStart() {
            				if (this._manager.session.enabledFeatures) {
            						var available = this._manager.session.enabledFeatures.indexOf('plane-detection') !== -1;
            						if (available) {
            								this._available = true;
            								this.fire('available');
            						}
            				}
            		}
            		_onSessionEnd() {
            				for(var i = 0; i < this._planes.length; i++){
            						this._planes[i].destroy();
            						this.fire('remove', this._planes[i]);
            				}
            				this._planesIndex.clear();
            				this._planes.length = 0;
            				if (this._available) {
            						this._available = false;
            						this.fire('unavailable');
            				}
            		}
            		update(frame) {
            				if (!this._available) {
            						if (!this._manager.session.enabledFeatures && frame.detectedPlanes.size) {
            								this._available = true;
            								this.fire('available');
            						} else {
            								return;
            						}
            				}
            				var detectedPlanes = frame.detectedPlanes;
            				for (var [xrPlane, plane] of this._planesIndex){
            						if (detectedPlanes.has(xrPlane)) {
            								continue;
            						}
            						this._planesIndex.delete(xrPlane);
            						this._planes.splice(this._planes.indexOf(plane), 1);
            						plane.destroy();
            						this.fire('remove', plane);
            				}
            				for (var xrPlane1 of detectedPlanes){
            						var plane1 = this._planesIndex.get(xrPlane1);
            						if (!plane1) {
            								plane1 = new XrPlane(this, xrPlane1);
            								this._planesIndex.set(xrPlane1, plane1);
            								this._planes.push(plane1);
            								plane1.update(frame);
            								this.fire('add', plane1);
            						} else {
            								plane1.update(frame);
            						}
            				}
            		}
            		get supported() {
            				return this._supported;
            		}
            		get available() {
            				return this._available;
            		}
            		get planes() {
            				return this._planes;
            		}
            		constructor(manager){
            				super(), this._supported = platform.browser && !!window.XRPlane, this._available = false, this._planesIndex = new Map(), this._planes = [];
            				this._manager = manager;
            				if (this._supported) {
            						this._manager.on('start', this._onSessionStart, this);
            						this._manager.on('end', this._onSessionEnd, this);
            				}
            		}
            }
            XrPlaneDetection.EVENT_AVAILABLE = 'available';
            XrPlaneDetection.EVENT_UNAVAILABLE = 'unavailable';
            XrPlaneDetection.EVENT_ADD = 'add';
            XrPlaneDetection.EVENT_REMOVE = 'remove';
            
            class XrAnchor extends EventHandler {
            		destroy() {
            				if (!this._xrAnchor) return;
            				var xrAnchor = this._xrAnchor;
            				this._xrAnchor.delete();
            				this._xrAnchor = null;
            				this.fire('destroy', xrAnchor, this);
            		}
            		update(frame) {
            				if (!this._xrAnchor) {
            						return;
            				}
            				var pose = frame.getPose(this._xrAnchor.anchorSpace, this._anchors.manager._referenceSpace);
            				if (pose) {
            						if (this._position.equals(pose.transform.position) && this._rotation.equals(pose.transform.orientation)) {
            								return;
            						}
            						this._position.copy(pose.transform.position);
            						this._rotation.copy(pose.transform.orientation);
            						this.fire('change');
            				}
            		}
            		getPosition() {
            				return this._position;
            		}
            		getRotation() {
            				return this._rotation;
            		}
            		persist(callback) {
            				if (!this._anchors.persistence) {
            						callback == null ? void 0 : callback(new Error('Persistent Anchors are not supported'), null);
            						return;
            				}
            				if (this._uuid) {
            						callback == null ? void 0 : callback(null, this._uuid);
            						return;
            				}
            				if (this._uuidRequests) {
            						if (callback) this._uuidRequests.push(callback);
            						return;
            				}
            				this._uuidRequests = [];
            				this._xrAnchor.requestPersistentHandle().then((uuid)=>{
            						this._uuid = uuid;
            						this._anchors._indexByUuid.set(this._uuid, this);
            						callback == null ? void 0 : callback(null, uuid);
            						for (var uuidRequest of this._uuidRequests){
            								uuidRequest(null, uuid);
            						}
            						this._uuidRequests = null;
            						this.fire('persist', uuid);
            				}).catch((ex)=>{
            						callback == null ? void 0 : callback(ex, null);
            						for (var uuidRequest of this._uuidRequests){
            								uuidRequest(ex, null);
            						}
            						this._uuidRequests = null;
            				});
            		}
            		forget(callback) {
            				if (!this._uuid) {
            						callback == null ? void 0 : callback(new Error('Anchor is not persistent'));
            						return;
            				}
            				this._anchors.forget(this._uuid, (ex)=>{
            						this._uuid = null;
            						callback == null ? void 0 : callback(ex);
            						this.fire('forget');
            				});
            		}
            		get uuid() {
            				return this._uuid;
            		}
            		get persistent() {
            				return !!this._uuid;
            		}
            		constructor(anchors, xrAnchor, uuid = null){
            				super(), this._position = new Vec3(), this._rotation = new Quat(), this._uuid = null, this._uuidRequests = null;
            				this._anchors = anchors;
            				this._xrAnchor = xrAnchor;
            				this._uuid = uuid;
            		}
            }
            XrAnchor.EVENT_DESTROY = 'destroy';
            XrAnchor.EVENT_CHANGE = 'change';
            XrAnchor.EVENT_PERSIST = 'persist';
            XrAnchor.EVENT_FORGET = 'forget';
            
            class XrAnchors extends EventHandler {
            		_onSessionStart() {
            				var available = this.manager.session.enabledFeatures.indexOf('anchors') !== -1;
            				if (!available) return;
            				this._available = available;
            				this.fire('available');
            		}
            		_onSessionEnd() {
            				if (!this._available) return;
            				this._available = false;
            				for(var i = 0; i < this._creationQueue.length; i++){
            						if (!this._creationQueue[i].callback) {
            								continue;
            						}
            						this._creationQueue[i].callback(new Error('session ended'), null);
            				}
            				this._creationQueue.length = 0;
            				this._index.clear();
            				this._indexByUuid.clear();
            				var i1 = this._list.length;
            				while(i1--){
            						this._list[i1].destroy();
            				}
            				this._list.length = 0;
            				this.fire('unavailable');
            		}
            		_createAnchor(xrAnchor, uuid) {
            				if (uuid === void 0) uuid = null;
            				var anchor = new XrAnchor(this, xrAnchor, uuid);
            				this._index.set(xrAnchor, anchor);
            				if (uuid) this._indexByUuid.set(uuid, anchor);
            				this._list.push(anchor);
            				anchor.once('destroy', this._onAnchorDestroy, this);
            				return anchor;
            		}
            		_onAnchorDestroy(xrAnchor, anchor) {
            				this._index.delete(xrAnchor);
            				if (anchor.uuid) this._indexByUuid.delete(anchor.uuid);
            				var ind = this._list.indexOf(anchor);
            				if (ind !== -1) this._list.splice(ind, 1);
            				this.fire('destroy', anchor);
            		}
            		create(position, rotation, callback) {
            				if (!this._available) {
            						callback == null ? void 0 : callback(new Error('Anchors API is not available'), null);
            						return;
            				}
            				if (window.XRHitTestResult && position instanceof XRHitTestResult) {
            						var hitResult = position;
            						callback = rotation;
            						if (!this._supported) {
            								callback == null ? void 0 : callback(new Error('Anchors API is not supported'), null);
            								return;
            						}
            						if (!hitResult.createAnchor) {
            								callback == null ? void 0 : callback(new Error('Creating Anchor from Hit Test is not supported'), null);
            								return;
            						}
            						hitResult.createAnchor().then((xrAnchor)=>{
            								var anchor = this._createAnchor(xrAnchor);
            								callback == null ? void 0 : callback(null, anchor);
            								this.fire('add', anchor);
            						}).catch((ex)=>{
            								callback == null ? void 0 : callback(ex, null);
            								this.fire('error', ex);
            						});
            				} else {
            						this._creationQueue.push({
            								transform: new XRRigidTransform(position, rotation),
            								callback: callback
            						});
            				}
            		}
            		restore(uuid, callback) {
            				if (!this._available) {
            						callback == null ? void 0 : callback(new Error('Anchors API is not available'), null);
            						return;
            				}
            				if (!this._persistence) {
            						callback == null ? void 0 : callback(new Error('Anchor Persistence is not supported'), null);
            						return;
            				}
            				if (!this.manager.active) {
            						callback == null ? void 0 : callback(new Error('WebXR session is not active'), null);
            						return;
            				}
            				this.manager.session.restorePersistentAnchor(uuid).then((xrAnchor)=>{
            						var anchor = this._createAnchor(xrAnchor, uuid);
            						callback == null ? void 0 : callback(null, anchor);
            						this.fire('add', anchor);
            				}).catch((ex)=>{
            						callback == null ? void 0 : callback(ex, null);
            						this.fire('error', ex);
            				});
            		}
            		forget(uuid, callback) {
            				if (!this._available) {
            						callback == null ? void 0 : callback(new Error('Anchors API is not available'));
            						return;
            				}
            				if (!this._persistence) {
            						callback == null ? void 0 : callback(new Error('Anchor Persistence is not supported'));
            						return;
            				}
            				if (!this.manager.active) {
            						callback == null ? void 0 : callback(new Error('WebXR session is not active'));
            						return;
            				}
            				this.manager.session.deletePersistentAnchor(uuid).then(()=>{
            						callback == null ? void 0 : callback(null);
            				}).catch((ex)=>{
            						callback == null ? void 0 : callback(ex);
            						this.fire('error', ex);
            				});
            		}
            		update(frame) {
            				if (!this._available) {
            						if (!this.manager.session.enabledFeatures && !this._checkingAvailability) {
            								this._checkingAvailability = true;
            								frame.createAnchor(new XRRigidTransform(), this.manager._referenceSpace).then((xrAnchor)=>{
            										xrAnchor.delete();
            										if (this.manager.active) {
            												this._available = true;
            												this.fire('available');
            										}
            								}).catch(()=>{});
            						}
            						return;
            				}
            				if (this._creationQueue.length) {
            						var _this, _loop = function(i) {
            								var request = _this._creationQueue[i];
            								frame.createAnchor(request.transform, _this.manager._referenceSpace).then((xrAnchor)=>{
            										if (request.callback) {
            												_this._callbacksAnchors.set(xrAnchor, request.callback);
            										}
            								}).catch((ex)=>{
            										if (request.callback) {
            												request.callback(ex, null);
            										}
            										_this.fire('error', ex);
            								});
            						};
            						for(var i = 0; i < this._creationQueue.length; i++)_this = this, _loop(i);
            						this._creationQueue.length = 0;
            				}
            				for (var [xrAnchor, anchor] of this._index){
            						if (frame.trackedAnchors.has(xrAnchor)) {
            								continue;
            						}
            						this._index.delete(xrAnchor);
            						anchor.destroy();
            				}
            				for(var i1 = 0; i1 < this._list.length; i1++){
            						this._list[i1].update(frame);
            				}
            				for (var xrAnchor1 of frame.trackedAnchors){
            						if (this._index.has(xrAnchor1)) {
            								continue;
            						}
            						try {
            								var tmp = xrAnchor1.anchorSpace;
            						} catch (ex) {
            								continue;
            						}
            						var anchor1 = this._createAnchor(xrAnchor1);
            						anchor1.update(frame);
            						var callback = this._callbacksAnchors.get(xrAnchor1);
            						if (callback) {
            								this._callbacksAnchors.delete(xrAnchor1);
            								callback(null, anchor1);
            						}
            						this.fire('add', anchor1);
            				}
            		}
            		get supported() {
            				return this._supported;
            		}
            		get available() {
            				return this._available;
            		}
            		get persistence() {
            				return this._persistence;
            		}
            		get uuids() {
            				if (!this._available) {
            						return null;
            				}
            				if (!this._persistence) {
            						return null;
            				}
            				if (!this.manager.active) {
            						return null;
            				}
            				return this.manager.session.persistentAnchors;
            		}
            		get list() {
            				return this._list;
            		}
            		constructor(manager){
            				var _window_XRSession, _window;
            				super(), this._supported = platform.browser && !!window.XRAnchor, this._available = false, this._checkingAvailability = false, this._persistence = platform.browser && !!((_window = window) == null ? void 0 : (_window_XRSession = _window.XRSession) == null ? void 0 : _window_XRSession.prototype.restorePersistentAnchor), this._creationQueue = [], this._index = new Map(), this._indexByUuid = new Map(), this._list = [], this._callbacksAnchors = new Map();
            				this.manager = manager;
            				if (this._supported) {
            						this.manager.on('start', this._onSessionStart, this);
            						this.manager.on('end', this._onSessionEnd, this);
            				}
            		}
            }
            XrAnchors.EVENT_AVAILABLE = 'available';
            XrAnchors.EVENT_UNAVAILABLE = 'unavailable';
            XrAnchors.EVENT_ERROR = 'error';
            XrAnchors.EVENT_ADD = 'add';
            XrAnchors.EVENT_DESTROY = 'destroy';
            
            class XrMesh extends EventHandler {
            		get xrMesh() {
            				return this._xrMesh;
            		}
            		get label() {
            				return this._xrMesh.semanticLabel || '';
            		}
            		get vertices() {
            				return this._xrMesh.vertices;
            		}
            		get indices() {
            				return this._xrMesh.indices;
            		}
            		destroy() {
            				if (!this._xrMesh) return;
            				this._xrMesh = null;
            				this.fire('remove');
            		}
            		update(frame) {
            				var manager = this._meshDetection._manager;
            				var pose = frame.getPose(this._xrMesh.meshSpace, manager._referenceSpace);
            				if (pose) {
            						this._position.copy(pose.transform.position);
            						this._rotation.copy(pose.transform.orientation);
            				}
            				if (this._lastChanged !== this._xrMesh.lastChangedTime) {
            						this._lastChanged = this._xrMesh.lastChangedTime;
            						this.fire('change');
            				}
            		}
            		getPosition() {
            				return this._position;
            		}
            		getRotation() {
            				return this._rotation;
            		}
            		constructor(meshDetection, xrMesh){
            				super(), this._lastChanged = 0, this._position = new Vec3(), this._rotation = new Quat();
            				this._meshDetection = meshDetection;
            				this._xrMesh = xrMesh;
            				this._lastChanged = this._xrMesh.lastChangedTime;
            		}
            }
            XrMesh.EVENT_REMOVE = 'remove';
            XrMesh.EVENT_CHANGE = 'change';
            
            class XrMeshDetection extends EventHandler {
            		update(frame) {
            				if (!this._available) {
            						if (!this._manager.session.enabledFeatures && frame.detectedMeshes.size) {
            								this._available = true;
            								this.fire('available');
            						} else {
            								return;
            						}
            				}
            				for (var xrMesh of frame.detectedMeshes){
            						var mesh = this._index.get(xrMesh);
            						if (!mesh) {
            								mesh = new XrMesh(this, xrMesh);
            								this._index.set(xrMesh, mesh);
            								this._list.push(mesh);
            								mesh.update(frame);
            								this.fire('add', mesh);
            						} else {
            								mesh.update(frame);
            						}
            				}
            				for (var mesh1 of this._index.values()){
            						if (frame.detectedMeshes.has(mesh1.xrMesh)) {
            								continue;
            						}
            						this._removeMesh(mesh1);
            				}
            		}
            		_removeMesh(mesh) {
            				this._index.delete(mesh.xrMesh);
            				this._list.splice(this._list.indexOf(mesh), 1);
            				mesh.destroy();
            				this.fire('remove', mesh);
            		}
            		_onSessionStart() {
            				if (this._manager.session.enabledFeatures) {
            						var available = this._manager.session.enabledFeatures.indexOf('mesh-detection') !== -1;
            						if (!available) return;
            						this._available = available;
            						this.fire('available');
            				}
            		}
            		_onSessionEnd() {
            				if (!this._available) return;
            				this._available = false;
            				for (var mesh of this._index.values()){
            						this._removeMesh(mesh);
            				}
            				this.fire('unavailable');
            		}
            		get supported() {
            				return this._supported;
            		}
            		get available() {
            				return this._available;
            		}
            		get meshes() {
            				return this._list;
            		}
            		constructor(manager){
            				super(), this._supported = platform.browser && !!window.XRMesh, this._available = false, this._index = new Map(), this._list = [];
            				this._manager = manager;
            				if (this._supported) {
            						this._manager.on('start', this._onSessionStart, this);
            						this._manager.on('end', this._onSessionEnd, this);
            				}
            		}
            }
            XrMeshDetection.EVENT_AVAILABLE = 'available';
            XrMeshDetection.EVENT_UNAVAILABLE = 'unavailable';
            XrMeshDetection.EVENT_ADD = 'add';
            XrMeshDetection.EVENT_REMOVE = 'remove';
            
            class XrView extends EventHandler {
            		get textureColor() {
            				return this._textureColor;
            		}
            		get textureDepth() {
            				return this._textureDepth;
            		}
            		get depthUvMatrix() {
            				return this._depthMatrix;
            		}
            		get depthValueToMeters() {
            				var _this__depthInfo;
            				return ((_this__depthInfo = this._depthInfo) == null ? void 0 : _this__depthInfo.rawValueToMeters) || 0;
            		}
            		get eye() {
            				return this._xrView.eye;
            		}
            		get viewport() {
            				return this._viewport;
            		}
            		get projMat() {
            				return this._projMat;
            		}
            		get projViewOffMat() {
            				return this._projViewOffMat;
            		}
            		get viewOffMat() {
            				return this._viewOffMat;
            		}
            		get viewInvOffMat() {
            				return this._viewInvOffMat;
            		}
            		get viewMat3() {
            				return this._viewMat3;
            		}
            		get positionData() {
            				return this._positionData;
            		}
            		update(frame, xrView) {
            				this._xrView = xrView;
            				if (this._manager.views.availableColor) {
            						this._xrCamera = this._xrView.camera;
            				}
            				var layer = frame.session.renderState.baseLayer;
            				var viewport = layer.getViewport(this._xrView);
            				this._viewport.x = viewport.x;
            				this._viewport.y = viewport.y;
            				this._viewport.z = viewport.width;
            				this._viewport.w = viewport.height;
            				this._projMat.set(this._xrView.projectionMatrix);
            				this._viewMat.set(this._xrView.transform.inverse.matrix);
            				this._viewInvMat.set(this._xrView.transform.matrix);
            				this._updateTextureColor();
            				this._updateDepth(frame);
            		}
            		_updateTextureColor() {
            				if (!this._manager.views.availableColor || !this._xrCamera || !this._textureColor) {
            						return;
            				}
            				var binding = this._manager.webglBinding;
            				if (!binding) {
            						return;
            				}
            				var texture = binding.getCameraImage(this._xrCamera);
            				if (!texture) {
            						return;
            				}
            				var device = this._manager.app.graphicsDevice;
            				var gl = device.gl;
            				if (!this._frameBufferSource) {
            						this._frameBufferSource = gl.createFramebuffer();
            						this._frameBuffer = gl.createFramebuffer();
            				} else {
            						var attachmentBaseConstant = gl.COLOR_ATTACHMENT0;
            						var width = this._xrCamera.width;
            						var height = this._xrCamera.height;
            						device.setFramebuffer(this._frameBufferSource);
            						gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentBaseConstant, gl.TEXTURE_2D, texture, 0);
            						device.setFramebuffer(this._frameBuffer);
            						gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentBaseConstant, gl.TEXTURE_2D, this._textureColor.impl._glTexture, 0);
            						gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._frameBufferSource);
            						gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._frameBuffer);
            						gl.blitFramebuffer(0, height, width, 0, 0, 0, width, height, gl.COLOR_BUFFER_BIT, gl.NEAREST);
            				}
            		}
            		_updateDepth(frame) {
            				var _this__depthInfo, _this__depthInfo1;
            				if (!this._manager.views.availableDepth || !this._textureDepth) {
            						return;
            				}
            				var gpu = this._manager.views.depthGpuOptimized;
            				var infoSource = gpu ? this._manager.webglBinding : frame;
            				if (!infoSource) {
            						this._depthInfo = null;
            						return;
            				}
            				var depthInfo = infoSource.getDepthInformation(this._xrView);
            				if (!depthInfo) {
            						this._depthInfo = null;
            						return;
            				}
            				var matrixDirty = !this._depthInfo !== !depthInfo;
            				this._depthInfo = depthInfo;
            				var width = ((_this__depthInfo = this._depthInfo) == null ? void 0 : _this__depthInfo.width) || 4;
            				var height = ((_this__depthInfo1 = this._depthInfo) == null ? void 0 : _this__depthInfo1.height) || 4;
            				var resized = false;
            				if (this._textureDepth.width !== width || this._textureDepth.height !== height) {
            						this._textureDepth._width = width;
            						this._textureDepth._height = height;
            						matrixDirty = true;
            						resized = true;
            				}
            				if (matrixDirty) {
            						if (this._depthInfo) {
            								this._depthMatrix.data.set(this._depthInfo.normDepthBufferFromNormView.matrix);
            						} else {
            								this._depthMatrix.setIdentity();
            						}
            				}
            				if (this._depthInfo) {
            						if (gpu) {
            								if (this._depthInfo.texture) {
            										var gl = this._manager.app.graphicsDevice.gl;
            										this._textureDepth.impl._glTexture = this._depthInfo.texture;
            										if (this._depthInfo.textureType === 'texture-array') {
            												this._textureDepth.impl._glTarget = gl.TEXTURE_2D_ARRAY;
            										} else {
            												this._textureDepth.impl._glTarget = gl.TEXTURE_2D;
            										}
            										switch(this._manager.views.depthPixelFormat){
            												case PIXELFORMAT_R32F:
            														this._textureDepth.impl._glInternalFormat = gl.R32F;
            														this._textureDepth.impl._glPixelType = gl.FLOAT;
            														this._textureDepth.impl._glFormat = gl.RED;
            														break;
            												case PIXELFORMAT_DEPTH:
            														this._textureDepth.impl._glInternalFormat = gl.DEPTH_COMPONENT16;
            														this._textureDepth.impl._glPixelType = gl.UNSIGNED_SHORT;
            														this._textureDepth.impl._glFormat = gl.DEPTH_COMPONENT;
            														break;
            										}
            										this._textureDepth.impl._glCreated = true;
            								}
            						} else {
            								this._textureDepth._levels[0] = new Uint8Array(this._depthInfo.data);
            								this._textureDepth.upload();
            						}
            				} else {
            						this._textureDepth._levels[0] = this._emptyDepthBuffer;
            						this._textureDepth.upload();
            				}
            				if (resized) this.fire('depth:resize', width, height);
            		}
            		updateTransforms(transform) {
            				if (transform) {
            						this._viewInvOffMat.mul2(transform, this._viewInvMat);
            						this.viewOffMat.copy(this._viewInvOffMat).invert();
            				} else {
            						this._viewInvOffMat.copy(this._viewInvMat);
            						this.viewOffMat.copy(this._viewMat);
            				}
            				this._viewMat3.setFromMat4(this._viewOffMat);
            				this._projViewOffMat.mul2(this._projMat, this._viewOffMat);
            				this._positionData[0] = this._viewInvOffMat.data[12];
            				this._positionData[1] = this._viewInvOffMat.data[13];
            				this._positionData[2] = this._viewInvOffMat.data[14];
            		}
            		_onDeviceLost() {
            				this._frameBufferSource = null;
            				this._frameBuffer = null;
            				this._depthInfo = null;
            		}
            		getDepth(u, v) {
            				var _this__depthInfo;
            				if (this._manager.views.depthGpuOptimized) {
            						return null;
            				}
            				var _this__depthInfo_getDepthInMeters;
            				return (_this__depthInfo_getDepthInMeters = (_this__depthInfo = this._depthInfo) == null ? void 0 : _this__depthInfo.getDepthInMeters(u, v)) != null ? _this__depthInfo_getDepthInMeters : null;
            		}
            		destroy() {
            				this._depthInfo = null;
            				if (this._textureColor) {
            						this._textureColor.destroy();
            						this._textureColor = null;
            				}
            				if (this._textureDepth) {
            						this._textureDepth.destroy();
            						this._textureDepth = null;
            				}
            				if (this._frameBufferSource) {
            						var gl = this._manager.app.graphicsDevice.gl;
            						gl.deleteFramebuffer(this._frameBufferSource);
            						this._frameBufferSource = null;
            						gl.deleteFramebuffer(this._frameBuffer);
            						this._frameBuffer = null;
            				}
            		}
            		constructor(manager, xrView, viewsCount){
            				super(), this._positionData = new Float32Array(3), this._viewport = new Vec4(), this._projMat = new Mat4(), this._projViewOffMat = new Mat4(), this._viewMat = new Mat4(), this._viewOffMat = new Mat4(), this._viewMat3 = new Mat3(), this._viewInvMat = new Mat4(), this._viewInvOffMat = new Mat4(), this._xrCamera = null, this._textureColor = null, this._textureDepth = null, this._depthInfo = null, this._emptyDepthBuffer = new Uint8Array(32), this._depthMatrix = new Mat4();
            				this._manager = manager;
            				this._xrView = xrView;
            				var device = this._manager.app.graphicsDevice;
            				if (this._manager.views.supportedColor) {
            						this._xrCamera = this._xrView.camera;
            						if (this._manager.views.availableColor && this._xrCamera) {
            								this._textureColor = new Texture(device, {
            										format: PIXELFORMAT_RGB8,
            										mipmaps: false,
            										addressU: ADDRESS_CLAMP_TO_EDGE,
            										addressV: ADDRESS_CLAMP_TO_EDGE,
            										minFilter: FILTER_LINEAR,
            										magFilter: FILTER_LINEAR,
            										width: this._xrCamera.width,
            										height: this._xrCamera.height,
            										name: "XrView-" + this._xrView.eye + "-Color"
            								});
            						}
            				}
            				if (this._manager.views.supportedDepth && this._manager.views.availableDepth) {
            						var filtering = this._manager.views.depthGpuOptimized ? FILTER_NEAREST : FILTER_LINEAR;
            						this._textureDepth = new Texture(device, {
            								format: this._manager.views.depthPixelFormat,
            								arrayLength: viewsCount === 1 ? 0 : viewsCount,
            								mipmaps: false,
            								addressU: ADDRESS_CLAMP_TO_EDGE,
            								addressV: ADDRESS_CLAMP_TO_EDGE,
            								minFilter: filtering,
            								magFilter: filtering,
            								width: 4,
            								height: 4,
            								name: "XrView-" + this._xrView.eye + "-Depth"
            						});
            						for(var i = 0; i < this._textureDepth._levels.length; i++){
            								this._textureDepth._levels[i] = this._emptyDepthBuffer;
            						}
            						this._textureDepth.upload();
            				}
            				if (this._textureColor || this._textureDepth) {
            						device.on('devicelost', this._onDeviceLost, this);
            				}
            		}
            }
            XrView.EVENT_DEPTHRESIZE = 'depth:resize';
            
            class XrViews extends EventHandler {
            		get list() {
            				return this._list;
            		}
            		get supportedColor() {
            				return this._supportedColor;
            		}
            		get supportedDepth() {
            				return this._supportedDepth;
            		}
            		get availableColor() {
            				return this._availableColor;
            		}
            		get availableDepth() {
            				return this._availableDepth;
            		}
            		get depthUsage() {
            				return this._depthUsage;
            		}
            		get depthGpuOptimized() {
            				return this._depthUsage === XRDEPTHSENSINGUSAGE_GPU;
            		}
            		get depthFormat() {
            				return this._depthFormat;
            		}
            		get depthPixelFormat() {
            				var _this__depthFormats_this__depthFormat;
            				return (_this__depthFormats_this__depthFormat = this._depthFormats[this._depthFormat]) != null ? _this__depthFormats_this__depthFormat : null;
            		}
            		update(frame, xrViews) {
            				for(var i = 0; i < xrViews.length; i++){
            						this._indexTmp.set(xrViews[i].eye, xrViews[i]);
            				}
            				for (var [eye, xrView] of this._indexTmp){
            						var view = this._index.get(eye);
            						if (!view) {
            								view = new XrView(this._manager, xrView, xrViews.length);
            								this._index.set(eye, view);
            								this._list.push(view);
            								view.update(frame, xrView);
            								this.fire('add', view);
            						} else {
            								view.update(frame, xrView);
            						}
            				}
            				for (var [eye1, view1] of this._index){
            						if (this._indexTmp.has(eye1)) {
            								continue;
            						}
            						view1.destroy();
            						this._index.delete(eye1);
            						var ind = this._list.indexOf(view1);
            						if (ind !== -1) this._list.splice(ind, 1);
            						this.fire('remove', view1);
            				}
            				this._indexTmp.clear();
            		}
            		get(eye) {
            				return this._index.get(eye) || null;
            		}
            		_onSessionStart() {
            				if (this._manager.type !== XRTYPE_AR) {
            						return;
            				}
            				if (!this._manager.session.enabledFeatures) {
            						return;
            				}
            				this._availableColor = this._manager.session.enabledFeatures.indexOf('camera-access') !== -1;
            				this._availableDepth = this._manager.session.enabledFeatures.indexOf('depth-sensing') !== -1;
            				if (this._availableDepth) {
            						var session = this._manager.session;
            						this._depthUsage = session.depthUsage;
            						this._depthFormat = session.depthDataFormat;
            				}
            		}
            		_onSessionEnd() {
            				for (var view of this._index.values()){
            						view.destroy();
            				}
            				this._index.clear();
            				this._availableColor = false;
            				this._availableDepth = false;
            				this._depthUsage = '';
            				this._depthFormat = '';
            				this._list.length = 0;
            		}
            		constructor(manager){
            				super(), this._index = new Map(), this._indexTmp = new Map(), this._list = [], this._supportedColor = platform.browser && !!window.XRCamera && !!window.XRWebGLBinding, this._supportedDepth = platform.browser && !!window.XRDepthInformation, this._availableColor = false, this._availableDepth = false, this._depthUsage = '', this._depthFormat = '', this._depthFormats = {
            						[XRDEPTHSENSINGFORMAT_L8A8]: PIXELFORMAT_LA8,
            						[XRDEPTHSENSINGFORMAT_R16U]: PIXELFORMAT_DEPTH,
            						[XRDEPTHSENSINGFORMAT_F32]: PIXELFORMAT_R32F
            				};
            				this._manager = manager;
            				this._manager.on('start', this._onSessionStart, this);
            				this._manager.on('end', this._onSessionEnd, this);
            		}
            }
            XrViews.EVENT_ADD = 'add';
            XrViews.EVENT_REMOVE = 'remove';
            
            class XrManager extends EventHandler {
            		destroy() {}
            		start(camera, type, spaceType, options) {
            				var _this_app_graphicsDevice;
            				var callback = options;
            				if (typeof options === 'object') {
            						callback = options.callback;
            				}
            				if (!this._available[type]) {
            						if (callback) callback(new Error('XR is not available'));
            						return;
            				}
            				if (this._session) {
            						if (callback) callback(new Error('XR session is already started'));
            						return;
            				}
            				this._camera = camera;
            				this._camera.camera.xr = this;
            				this._type = type;
            				this._spaceType = spaceType;
            				var _options_framebufferScaleFactor;
            				this._framebufferScaleFactor = (_options_framebufferScaleFactor = options == null ? void 0 : options.framebufferScaleFactor) != null ? _options_framebufferScaleFactor : 1.0;
            				this._setClipPlanes(camera.nearClip, camera.farClip);
            				var opts = {
            						requiredFeatures: [
            								spaceType
            						],
            						optionalFeatures: []
            				};
            				var webgl = (_this_app_graphicsDevice = this.app.graphicsDevice) == null ? void 0 : _this_app_graphicsDevice.isWebGL2;
            				if (type === XRTYPE_AR) {
            						opts.optionalFeatures.push('light-estimation');
            						opts.optionalFeatures.push('hit-test');
            						if (options) {
            								if (options.imageTracking && this.imageTracking.supported) {
            										opts.optionalFeatures.push('image-tracking');
            								}
            								if (options.planeDetection) {
            										opts.optionalFeatures.push('plane-detection');
            								}
            								if (options.meshDetection) {
            										opts.optionalFeatures.push('mesh-detection');
            								}
            						}
            						if (this.domOverlay.supported && this.domOverlay.root) {
            								opts.optionalFeatures.push('dom-overlay');
            								opts.domOverlay = {
            										root: this.domOverlay.root
            								};
            						}
            						if (options && options.anchors && this.anchors.supported) {
            								opts.optionalFeatures.push('anchors');
            						}
            						if (options && options.depthSensing && this.views.supportedDepth) {
            								opts.optionalFeatures.push('depth-sensing');
            								var usagePreference = [];
            								var dataFormatPreference = [];
            								usagePreference.push(XRDEPTHSENSINGUSAGE_GPU, XRDEPTHSENSINGUSAGE_CPU);
            								dataFormatPreference.push(XRDEPTHSENSINGFORMAT_F32, XRDEPTHSENSINGFORMAT_L8A8, XRDEPTHSENSINGFORMAT_R16U);
            								if (options.depthSensing.usagePreference) {
            										var ind = usagePreference.indexOf(options.depthSensing.usagePreference);
            										if (ind !== -1) usagePreference.splice(ind, 1);
            										usagePreference.unshift(options.depthSensing.usagePreference);
            								}
            								if (options.depthSensing.dataFormatPreference) {
            										var ind1 = dataFormatPreference.indexOf(options.depthSensing.dataFormatPreference);
            										if (ind1 !== -1) dataFormatPreference.splice(ind1, 1);
            										dataFormatPreference.unshift(options.depthSensing.dataFormatPreference);
            								}
            								opts.depthSensing = {
            										usagePreference: usagePreference,
            										dataFormatPreference: dataFormatPreference
            								};
            						}
            						if (webgl && options && options.cameraColor && this.views.supportedColor) {
            								opts.optionalFeatures.push('camera-access');
            						}
            				}
            				opts.optionalFeatures.push('hand-tracking');
            				if (options && options.optionalFeatures) {
            						opts.optionalFeatures = opts.optionalFeatures.concat(options.optionalFeatures);
            				}
            				if (this.imageTracking.supported && this.imageTracking.images.length) {
            						this.imageTracking.prepareImages((err, trackedImages)=>{
            								if (err) {
            										if (callback) callback(err);
            										this.fire('error', err);
            										return;
            								}
            								if (trackedImages !== null) {
            										opts.trackedImages = trackedImages;
            								}
            								this._onStartOptionsReady(type, spaceType, opts, callback);
            						});
            				} else {
            						this._onStartOptionsReady(type, spaceType, opts, callback);
            				}
            		}
            		_onStartOptionsReady(type, spaceType, options, callback) {
            				navigator.xr.requestSession(type, options).then((session)=>{
            						this._onSessionStart(session, spaceType, callback);
            				}).catch((ex)=>{
            						this._camera.camera.xr = null;
            						this._camera = null;
            						this._type = null;
            						this._spaceType = null;
            						if (callback) callback(ex);
            						this.fire('error', ex);
            				});
            		}
            		end(callback) {
            				if (!this._session) {
            						if (callback) callback(new Error('XR Session is not initialized'));
            						return;
            				}
            				this.webglBinding = null;
            				if (callback) this.once('end', callback);
            				this._session.end();
            		}
            		isAvailable(type) {
            				return this._available[type];
            		}
            		_deviceAvailabilityCheck() {
            				for(var key in this._available){
            						this._sessionSupportCheck(key);
            				}
            		}
            		initiateRoomCapture(callback) {
            				if (!this._session) {
            						callback(new Error('Session is not active'));
            						return;
            				}
            				if (!this._session.initiateRoomCapture) {
            						callback(new Error('Session does not support manual room capture'));
            						return;
            				}
            				this._session.initiateRoomCapture().then(()=>{
            						if (callback) callback(null);
            				}).catch((err)=>{
            						if (callback) callback(err);
            				});
            		}
            		updateTargetFrameRate(frameRate, callback) {
            				var _this__session;
            				if (!((_this__session = this._session) == null ? void 0 : _this__session.updateTargetFrameRate)) {
            						callback == null ? void 0 : callback(new Error('unable to update frameRate'));
            						return;
            				}
            				this._session.updateTargetFrameRate(frameRate).then(()=>{
            						callback == null ? void 0 : callback();
            				}).catch((err)=>{
            						callback == null ? void 0 : callback(err);
            				});
            		}
            		_sessionSupportCheck(type) {
            				navigator.xr.isSessionSupported(type).then((available)=>{
            						if (this._available[type] === available) {
            								return;
            						}
            						this._available[type] = available;
            						this.fire('available', type, available);
            						this.fire("available:" + type, available);
            				}).catch((ex)=>{
            						this.fire('error', ex);
            				});
            		}
            		_onSessionStart(session, spaceType, callback) {
            				var failed = false;
            				this._session = session;
            				var onVisibilityChange = ()=>{
            						this.fire('visibility:change', session.visibilityState);
            				};
            				var onClipPlanesChange = ()=>{
            						this._setClipPlanes(this._camera.nearClip, this._camera.farClip);
            				};
            				var onEnd = ()=>{
            						if (this._camera) {
            								this._camera.off('set_nearClip', onClipPlanesChange);
            								this._camera.off('set_farClip', onClipPlanesChange);
            								this._camera.camera.xr = null;
            								this._camera = null;
            						}
            						session.removeEventListener('end', onEnd);
            						session.removeEventListener('visibilitychange', onVisibilityChange);
            						if (!failed) this.fire('end');
            						this._session = null;
            						this._referenceSpace = null;
            						this._width = 0;
            						this._height = 0;
            						this._type = null;
            						this._spaceType = null;
            						if (this.app.systems) {
            								this.app.tick();
            						}
            				};
            				session.addEventListener('end', onEnd);
            				session.addEventListener('visibilitychange', onVisibilityChange);
            				this._camera.on('set_nearClip', onClipPlanesChange);
            				this._camera.on('set_farClip', onClipPlanesChange);
            				this._createBaseLayer();
            				if (this.session.supportedFrameRates) {
            						this._supportedFrameRates = Array.from(this.session.supportedFrameRates);
            				} else {
            						this._supportedFrameRates = null;
            				}
            				this._session.addEventListener('frameratechange', ()=>{
            						var _this__session;
            						this.fire('frameratechange', (_this__session = this._session) == null ? void 0 : _this__session.frameRate);
            				});
            				session.requestReferenceSpace(spaceType).then((referenceSpace)=>{
            						this._referenceSpace = referenceSpace;
            						this.app.tick();
            						if (callback) callback(null);
            						this.fire('start');
            				}).catch((ex)=>{
            						failed = true;
            						session.end();
            						if (callback) callback(ex);
            						this.fire('error', ex);
            				});
            		}
            		_setClipPlanes(near, far) {
            				if (this._depthNear === near && this._depthFar === far) {
            						return;
            				}
            				this._depthNear = near;
            				this._depthFar = far;
            				if (!this._session) {
            						return;
            				}
            				this._session.updateRenderState({
            						depthNear: this._depthNear,
            						depthFar: this._depthFar
            				});
            		}
            		_createBaseLayer() {
            				var device = this.app.graphicsDevice;
            				var framebufferScaleFactor = device.maxPixelRatio / window.devicePixelRatio * this._framebufferScaleFactor;
            				this._baseLayer = new XRWebGLLayer(this._session, device.gl, {
            						alpha: true,
            						depth: true,
            						stencil: true,
            						framebufferScaleFactor: framebufferScaleFactor,
            						antialias: false
            				});
            				if ((device == null ? void 0 : device.isWebGL2) && window.XRWebGLBinding) {
            						try {
            								this.webglBinding = new XRWebGLBinding(this._session, device.gl);
            						} catch (ex) {
            								this.fire('error', ex);
            						}
            				}
            				this._session.updateRenderState({
            						baseLayer: this._baseLayer,
            						depthNear: this._depthNear,
            						depthFar: this._depthFar
            				});
            		}
            		_onDeviceLost() {
            				if (!this._session) {
            						return;
            				}
            				if (this.webglBinding) {
            						this.webglBinding = null;
            				}
            				this._baseLayer = null;
            				this._session.updateRenderState({
            						baseLayer: this._baseLayer,
            						depthNear: this._depthNear,
            						depthFar: this._depthFar
            				});
            		}
            		_onDeviceRestored() {
            				if (!this._session) {
            						return;
            				}
            				setTimeout(()=>{
            						this.app.graphicsDevice.gl.makeXRCompatible().then(()=>{
            								this._createBaseLayer();
            						}).catch((ex)=>{
            								this.fire('error', ex);
            						});
            				}, 0);
            		}
            		update(frame) {
            				if (!this._session) return false;
            				var width = frame.session.renderState.baseLayer.framebufferWidth;
            				var height = frame.session.renderState.baseLayer.framebufferHeight;
            				if (this._width !== width || this._height !== height) {
            						this._width = width;
            						this._height = height;
            						this.app.graphicsDevice.setResolution(width, height);
            				}
            				var pose = frame.getViewerPose(this._referenceSpace);
            				if (!pose) return false;
            				var lengthOld = this.views.list.length;
            				this.views.update(frame, pose.views);
            				var posePosition = pose.transform.position;
            				var poseOrientation = pose.transform.orientation;
            				this._localPosition.set(posePosition.x, posePosition.y, posePosition.z);
            				this._localRotation.set(poseOrientation.x, poseOrientation.y, poseOrientation.z, poseOrientation.w);
            				if (lengthOld === 0 && this.views.list.length > 0) {
            						var viewProjMat = new Mat4();
            						var view = this.views.list[0];
            						viewProjMat.copy(view.projMat);
            						var data = viewProjMat.data;
            						var fov = 2.0 * Math.atan(1.0 / data[5]) * 180.0 / Math.PI;
            						var aspectRatio = data[5] / data[0];
            						var farClip = data[14] / (data[10] + 1);
            						var nearClip = data[14] / (data[10] - 1);
            						var horizontalFov = false;
            						var camera = this._camera.camera;
            						camera.setXrProperties({
            								aspectRatio,
            								farClip,
            								fov,
            								horizontalFov,
            								nearClip
            						});
            				}
            				this._camera.camera._node.setLocalPosition(this._localPosition);
            				this._camera.camera._node.setLocalRotation(this._localRotation);
            				this.input.update(frame);
            				if (this._type === XRTYPE_AR) {
            						if (this.hitTest.supported) {
            								this.hitTest.update(frame);
            						}
            						if (this.lightEstimation.supported) {
            								this.lightEstimation.update(frame);
            						}
            						if (this.imageTracking.supported) {
            								this.imageTracking.update(frame);
            						}
            						if (this.anchors.supported) {
            								this.anchors.update(frame);
            						}
            						if (this.planeDetection.supported) {
            								this.planeDetection.update(frame);
            						}
            						if (this.meshDetection.supported) {
            								this.meshDetection.update(frame);
            						}
            				}
            				this.fire('update', frame);
            				return true;
            		}
            		get supported() {
            				return this._supported;
            		}
            		get active() {
            				return !!this._session;
            		}
            		get type() {
            				return this._type;
            		}
            		get spaceType() {
            				return this._spaceType;
            		}
            		get session() {
            				return this._session;
            		}
            		get frameRate() {
            				var _this__session;
            				var _this__session_frameRate;
            				return (_this__session_frameRate = (_this__session = this._session) == null ? void 0 : _this__session.frameRate) != null ? _this__session_frameRate : null;
            		}
            		get supportedFrameRates() {
            				return this._supportedFrameRates;
            		}
            		get framebufferScaleFactor() {
            				return this._framebufferScaleFactor;
            		}
            		set fixedFoveation(value) {
            				var _this__baseLayer;
            				var _this__baseLayer_fixedFoveation;
            				if (((_this__baseLayer_fixedFoveation = (_this__baseLayer = this._baseLayer) == null ? void 0 : _this__baseLayer.fixedFoveation) != null ? _this__baseLayer_fixedFoveation : null) !== null) {
            						if (this.app.graphicsDevice.samples > 1) ;
            						this._baseLayer.fixedFoveation = value;
            				}
            		}
            		get fixedFoveation() {
            				var _this__baseLayer;
            				var _this__baseLayer_fixedFoveation;
            				return (_this__baseLayer_fixedFoveation = (_this__baseLayer = this._baseLayer) == null ? void 0 : _this__baseLayer.fixedFoveation) != null ? _this__baseLayer_fixedFoveation : null;
            		}
            		get camera() {
            				return this._camera ? this._camera.entity : null;
            		}
            		get visibilityState() {
            				if (!this._session) {
            						return null;
            				}
            				return this._session.visibilityState;
            		}
            		constructor(app){
            				super(), this._supported = platform.browser && !!navigator.xr, this._available = {}, this._type = null, this._spaceType = null, this._session = null, this._baseLayer = null, this.webglBinding = null, this._referenceSpace = null, this._camera = null, this._localPosition = new Vec3(), this._localRotation = new Quat(), this._depthNear = 0.1, this._depthFar = 1000, this._supportedFrameRates = null, this._width = 0, this._height = 0, this._framebufferScaleFactor = 1.0;
            				this.app = app;
            				this._available[XRTYPE_INLINE] = false;
            				this._available[XRTYPE_VR] = false;
            				this._available[XRTYPE_AR] = false;
            				this.views = new XrViews(this);
            				this.domOverlay = new XrDomOverlay(this);
            				this.hitTest = new XrHitTest(this);
            				this.imageTracking = new XrImageTracking(this);
            				this.planeDetection = new XrPlaneDetection(this);
            				this.meshDetection = new XrMeshDetection(this);
            				this.input = new XrInput(this);
            				this.lightEstimation = new XrLightEstimation(this);
            				this.anchors = new XrAnchors(this);
            				this.views = new XrViews(this);
            				if (this._supported) {
            						navigator.xr.addEventListener('devicechange', ()=>{
            								this._deviceAvailabilityCheck();
            						});
            						this._deviceAvailabilityCheck();
            						this.app.graphicsDevice.on('devicelost', this._onDeviceLost, this);
            						this.app.graphicsDevice.on('devicerestored', this._onDeviceRestored, this);
            				}
            		}
            }
            XrManager.EVENT_AVAILABLE = 'available';
            XrManager.EVENT_START = 'start';
            XrManager.EVENT_END = 'end';
            XrManager.EVENT_UPDATE = 'update';
            XrManager.EVENT_ERROR = 'error';
            
            class Application extends AppBase {
            		createDevice(canvas, options) {
            				if (!options.graphicsDeviceOptions) {
            						options.graphicsDeviceOptions = {};
            				}
            				if (platform.browser && !!navigator.xr) {
            						options.graphicsDeviceOptions.xrCompatible = true;
            				}
            				options.graphicsDeviceOptions.alpha = options.graphicsDeviceOptions.alpha || false;
            				return new WebglGraphicsDevice(canvas, options.graphicsDeviceOptions);
            		}
            		addComponentSystems(appOptions) {
            				appOptions.componentSystems = [
            						RigidBodyComponentSystem,
            						CollisionComponentSystem,
            						JointComponentSystem,
            						AnimationComponentSystem,
            						AnimComponentSystem,
            						ModelComponentSystem,
            						RenderComponentSystem,
            						CameraComponentSystem,
            						LightComponentSystem,
            						ScriptComponentSystem,
            						SoundComponentSystem,
            						AudioListenerComponentSystem,
            						ParticleSystemComponentSystem,
            						ScreenComponentSystem,
            						ElementComponentSystem,
            						ButtonComponentSystem,
            						ScrollViewComponentSystem,
            						ScrollbarComponentSystem,
            						SpriteComponentSystem,
            						LayoutGroupComponentSystem,
            						LayoutChildComponentSystem,
            						ZoneComponentSystem,
            						GSplatComponentSystem
            				];
            		}
            		addResourceHandles(appOptions) {
            				appOptions.resourceHandlers = [
            						RenderHandler,
            						AnimationHandler,
            						AnimClipHandler,
            						AnimStateGraphHandler,
            						ModelHandler,
            						MaterialHandler,
            						TextureHandler,
            						TextHandler,
            						JsonHandler,
            						AudioHandler,
            						ScriptHandler,
            						SceneHandler,
            						CubemapHandler,
            						HtmlHandler,
            						CssHandler,
            						ShaderHandler,
            						HierarchyHandler,
            						FolderHandler,
            						FontHandler,
            						BinaryHandler,
            						TextureAtlasHandler,
            						SpriteHandler,
            						TemplateHandler,
            						ContainerHandler,
            						GSplatHandler
            				];
            		}
            		constructor(canvas, options = {}){
            				super(canvas);
            				var appOptions = new AppOptions();
            				var _options_graphicsDevice;
            				appOptions.graphicsDevice = (_options_graphicsDevice = options.graphicsDevice) != null ? _options_graphicsDevice : this.createDevice(canvas, options);
            				this.addComponentSystems(appOptions);
            				this.addResourceHandles(appOptions);
            				appOptions.elementInput = options.elementInput;
            				appOptions.keyboard = options.keyboard;
            				appOptions.mouse = options.mouse;
            				appOptions.touch = options.touch;
            				appOptions.gamepads = options.gamepads;
            				appOptions.scriptPrefix = options.scriptPrefix;
            				appOptions.assetPrefix = options.assetPrefix;
            				appOptions.scriptsOrder = options.scriptsOrder;
            				appOptions.soundManager = new SoundManager();
            				appOptions.lightmapper = Lightmapper;
            				appOptions.batchManager = BatchManager;
            				appOptions.xr = XrManager;
            				this.init(appOptions);
            		}
            }
            
            var tempMeshInstances = [];
            var lights = [
            		[],
            		[],
            		[]
            ];
            class RenderPassPicker extends RenderPass {
            		destroy() {
            				this.viewBindGroups.forEach((bg)=>{
            						bg.defaultUniformBuffer.destroy();
            						bg.destroy();
            				});
            				this.viewBindGroups.length = 0;
            		}
            		update(camera, scene, layers, mapping) {
            				this.camera = camera;
            				this.scene = scene;
            				this.layers = layers;
            				this.mapping = mapping;
            		}
            		execute() {
            				var device = this.device;
            				var { renderer, camera, scene, layers, mapping, renderTarget } = this;
            				var srcLayers = scene.layers.layerList;
            				var subLayerEnabled = scene.layers.subLayerEnabled;
            				var isTransparent = scene.layers.subLayerList;
            				for(var i = 0; i < srcLayers.length; i++){
            						var srcLayer = srcLayers[i];
            						if (layers && layers.indexOf(srcLayer) < 0) {
            								continue;
            						}
            						if (srcLayer.enabled && subLayerEnabled[i]) {
            								if (srcLayer.camerasSet.has(camera.camera)) {
            										var transparent = isTransparent[i];
            										if (srcLayer._clearDepthBuffer) {
            												renderer.clear(camera.camera, false, true, false);
            										}
            										var meshInstances = srcLayer.meshInstances;
            										for(var j = 0; j < meshInstances.length; j++){
            												var meshInstance = meshInstances[j];
            												if (meshInstance.pick && meshInstance.transparent === transparent) {
            														tempMeshInstances.push(meshInstance);
            														mapping.set(meshInstance.id, meshInstance);
            												}
            										}
            										if (tempMeshInstances.length > 0) {
            												var clusteredLightingEnabled = scene.clusteredLightingEnabled;
            												if (clusteredLightingEnabled) {
            														var lightClusters = renderer.worldClustersAllocator.empty;
            														lightClusters.activate();
            												}
            												renderer.setCameraUniforms(camera.camera, renderTarget);
            												if (device.supportsUniformBuffers) {
            														renderer.setupViewUniformBuffers(this.viewBindGroups, renderer.viewUniformFormat, renderer.viewBindGroupFormat, 1);
            												}
            												renderer.renderForward(camera.camera, renderTarget, tempMeshInstances, lights, SHADER_PICK, (meshInstance)=>{
            														device.setBlendState(BlendState.NOBLEND);
            												});
            												tempMeshInstances.length = 0;
            										}
            								}
            						}
            				}
            		}
            		constructor(device, renderer){
            				super(device), this.viewBindGroups = [];
            				this.renderer = renderer;
            		}
            }
            
            var tempSet = new Set();
            var _rect = new Vec4();
            let Picker$1 = class Picker {
            		getSelection(x, y, width, height) {
            				if (width === void 0) width = 1;
            				if (height === void 0) height = 1;
            				var device = this.device;
            				if (device.isWebGPU) {
            						return [];
            				}
            				y = this.renderTarget.height - (y + height);
            				var rect = this.sanitizeRect(x, y, width, height);
            				device.setRenderTarget(this.renderTarget);
            				device.updateBegin();
            				var pixels = new Uint8Array(4 * rect.z * rect.w);
            				device.readPixels(rect.x, rect.y, rect.z, rect.w, pixels);
            				device.updateEnd();
            				return this.decodePixels(pixels, this.mapping);
            		}
            		getSelectionAsync(x, y, width, height) {
            				if (width === void 0) width = 1;
            				if (height === void 0) height = 1;
            				var _this_device;
            				if ((_this_device = this.device) == null ? void 0 : _this_device.isWebGL2) {
            						y = this.renderTarget.height - (y + height);
            				}
            				var rect = this.sanitizeRect(x, y, width, height);
            				return this.renderTarget.colorBuffer.read(rect.x, rect.y, rect.z, rect.w, {
            						renderTarget: this.renderTarget,
            						immediate: true
            				}).then((pixels)=>{
            						return this.decodePixels(pixels, this.mapping);
            				});
            		}
            		sanitizeRect(x, y, width, height) {
            				var maxWidth = this.renderTarget.width;
            				var maxHeight = this.renderTarget.height;
            				x = math.clamp(Math.floor(x), 0, maxWidth - 1);
            				y = math.clamp(Math.floor(y), 0, maxHeight - 1);
            				width = Math.floor(Math.max(width, 1));
            				width = Math.min(width, maxWidth - x);
            				height = Math.floor(Math.max(height, 1));
            				height = Math.min(height, maxHeight - y);
            				return _rect.set(x, y, width, height);
            		}
            		decodePixels(pixels, mapping) {
            				var selection = [];
            				if (this.deviceValid) {
            						var count = pixels.length;
            						for(var i = 0; i < count; i += 4){
            								var r = pixels[i + 0];
            								var g = pixels[i + 1];
            								var b = pixels[i + 2];
            								var a = pixels[i + 3];
            								var index = (a << 24 | r << 16 | g << 8 | b) >>> 0;
            								if (index !== 0xFFFFFFFF) {
            										tempSet.add(mapping.get(index));
            								}
            						}
            						tempSet.forEach((meshInstance)=>{
            								if (meshInstance) {
            										selection.push(meshInstance);
            								}
            						});
            						tempSet.clear();
            				}
            				return selection;
            		}
            		allocateRenderTarget() {
            				var colorBuffer = new Texture(this.device, {
            						format: PIXELFORMAT_RGBA8,
            						width: this.width,
            						height: this.height,
            						mipmaps: false,
            						minFilter: FILTER_NEAREST,
            						magFilter: FILTER_NEAREST,
            						addressU: ADDRESS_CLAMP_TO_EDGE,
            						addressV: ADDRESS_CLAMP_TO_EDGE,
            						name: 'pick'
            				});
            				this.renderTarget = new RenderTarget({
            						colorBuffer: colorBuffer,
            						depth: true
            				});
            		}
            		releaseRenderTarget() {
            				if (this.renderTarget) {
            						this.renderTarget.destroyTextureBuffers();
            						this.renderTarget.destroy();
            						this.renderTarget = null;
            				}
            		}
            		prepare(camera, scene, layers) {
            				if (layers instanceof Layer) {
            						layers = [
            								layers
            						];
            				}
            				if (!this.renderTarget || this.width !== this.renderTarget.width || this.height !== this.renderTarget.height) {
            						this.releaseRenderTarget();
            						this.allocateRenderTarget();
            				}
            				this.mapping.clear();
            				var renderPass = this.renderPass;
            				renderPass.init(this.renderTarget);
            				renderPass.colorOps.clearValue = Color.WHITE;
            				renderPass.colorOps.clear = true;
            				renderPass.depthStencilOps.clearDepth = true;
            				renderPass.update(camera, scene, layers, this.mapping);
            				renderPass.render();
            		}
            		resize(width, height) {
            				this.width = Math.floor(width);
            				this.height = Math.floor(height);
            		}
            		constructor(app, width, height){
            				this.renderTarget = null;
            				this.mapping = new Map();
            				this.deviceValid = true;
            				this.renderer = app.renderer;
            				this.device = app.graphicsDevice;
            				this.renderPass = new RenderPassPicker(this.device, app.renderer);
            				this.width = 0;
            				this.height = 0;
            				this.resize(width, height);
            				this.device.on('destroy', ()=>{
            						this.deviceValid = false;
            				});
            		}
            };
            
            class CpuTimer {
            		begin(name) {
            				if (!this.enabled) {
            						return;
            				}
            				if (this._frameIndex < this._frameTimings.length) {
            						this._frameTimings.splice(this._frameIndex);
            				}
            				var tmp = this._prevTimings;
            				this._prevTimings = this._timings;
            				this._timings = this._frameTimings;
            				this._frameTimings = tmp;
            				this._frameIndex = 0;
            				this.mark(name);
            		}
            		mark(name) {
            				if (!this.enabled) {
            						return;
            				}
            				var timestamp = now();
            				if (this._frameIndex > 0) {
            						var prev = this._frameTimings[this._frameIndex - 1];
            						prev[1] = timestamp - prev[1];
            				} else if (this._timings.length > 0) {
            						var prev1 = this._timings[this._timings.length - 1];
            						prev1[1] = timestamp - prev1[1];
            				}
            				if (this._frameIndex >= this._frameTimings.length) {
            						this._frameTimings.push([
            								name,
            								timestamp
            						]);
            				} else {
            						var timing = this._frameTimings[this._frameIndex];
            						timing[0] = name;
            						timing[1] = timestamp;
            				}
            				this._frameIndex++;
            		}
            		get timings() {
            				return this._timings.slice(0, -1).map((v)=>v[1]);
            		}
            		constructor(app){
            				this._frameIndex = 0;
            				this._frameTimings = [];
            				this._timings = [];
            				this._prevTimings = [];
            				this.unitsName = 'ms';
            				this.decimalPlaces = 1;
            				this.enabled = true;
            				app.on('frameupdate', this.begin.bind(this, 'update'));
            				app.on('framerender', this.mark.bind(this, 'render'));
            				app.on('frameend', this.mark.bind(this, 'other'));
            		}
            }
            
            class GpuTimer {
            		get timings() {
            				this._timings[0] = this.device.gpuProfiler._frameTime;
            				return this._timings;
            		}
            		constructor(device){
            				this.device = device;
            				device.gpuProfiler.enabled = true;
            				this.enabled = true;
            				this.unitsName = 'ms';
            				this.decimalPlaces = 1;
            				this._timings = [];
            		}
            }
            
            class StatsTimer {
            		get timings() {
            				return this.values;
            		}
            		constructor(app, statNames, decimalPlaces, unitsName, multiplier){
            				this.app = app;
            				this.values = [];
            				this.statNames = statNames;
            				if (this.statNames.length > 3) {
            						this.statNames.length = 3;
            				}
            				this.unitsName = unitsName;
            				this.decimalPlaces = decimalPlaces;
            				this.multiplier = multiplier || 1;
            				var resolve = (path, obj)=>{
            						return path.split('.').reduce((prev, curr)=>{
            								return prev ? prev[curr] : null;
            						}, obj || this);
            				};
            				app.on('frameupdate', (ms)=>{
            						for(var i = 0; i < this.statNames.length; i++){
            								this.values[i] = resolve(this.statNames[i], this.app.stats) * this.multiplier;
            						}
            				});
            		}
            }
            
            class Graph {
            		destroy() {
            				this.app.off('frameupdate', this.update, this);
            		}
            		loseContext() {
            				if (this.timer && typeof this.timer.loseContext === 'function') {
            						this.timer.loseContext();
            				}
            		}
            		update(ms) {
            				var timings = this.timer.timings;
            				var total = timings.reduce((a, v)=>a + v, 0);
            				this.avgTotal += total;
            				this.avgTimer += ms;
            				this.avgCount++;
            				if (this.avgTimer > this.textRefreshRate) {
            						this.timingText = (this.avgTotal / this.avgCount).toFixed(this.timer.decimalPlaces);
            						this.avgTimer = 0;
            						this.avgTotal = 0;
            						this.avgCount = 0;
            				}
            				if (this.enabled) {
            						var value = 0;
            						var range = 1.5 * this.watermark;
            						for(var i = 0; i < timings.length; ++i){
            								value += Math.floor(timings[i] / range * 255);
            								this.sample[i] = value;
            						}
            						this.sample[3] = this.watermark / range * 255;
            						var data = this.texture.lock();
            						data.set(this.sample, (this.cursor + this.yOffset * this.texture.width) * 4);
            						this.texture.unlock();
            						this.cursor++;
            						if (this.cursor === this.texture.width) {
            								this.cursor = 0;
            						}
            				}
            		}
            		render(render2d, x, y, w, h) {
            				render2d.quad(x + w, y, -w, h, this.enabled ? this.cursor : 0, this.enabled ? 0.5 + this.yOffset : this.texture.height - 1, -w, 0, this.texture, 0);
            		}
            		constructor(name, app, watermark, textRefreshRate, timer){
            				this.app = app;
            				this.name = name;
            				this.device = app.graphicsDevice;
            				this.timer = timer;
            				this.watermark = watermark;
            				this.enabled = false;
            				this.textRefreshRate = textRefreshRate;
            				this.avgTotal = 0;
            				this.avgTimer = 0;
            				this.avgCount = 0;
            				this.timingText = '';
            				this.texture = null;
            				this.yOffset = 0;
            				this.cursor = 0;
            				this.sample = new Uint8ClampedArray(4);
            				this.sample.set([
            						0,
            						0,
            						0,
            						255
            				]);
            				this.counter = 0;
            				this.app.on('frameupdate', this.update, this);
            		}
            }
            
            class WordAtlas {
            		destroy() {
            				this.texture.destroy();
            				this.texture = null;
            		}
            		render(render2d, word, x, y) {
            				var p = this.placements.get(word);
            				if (p) {
            						var padding = 1;
            						render2d.quad(x + p.l - padding, y - p.d + padding, p.w + padding * 2, p.h + padding * 2, p.x - padding, this.texture.height - p.y - p.h - padding, undefined, undefined, this.texture, 1);
            						return p.w;
            				}
            				return 0;
            		}
            		constructor(device, words){
            				var initContext = (context)=>{
            						context.font = '10px "Lucida Console", Monaco, monospace';
            						context.textAlign = 'left';
            						context.textBaseline = 'alphabetic';
            				};
            				var isNumber = (word)=>{
            						return word === '.' || word.length === 1 && word.charCodeAt(0) >= 48 && word.charCodeAt(0) <= 57;
            				};
            				var canvas = document.createElement('canvas');
            				var context = canvas.getContext('2d', {
            						alpha: true
            				});
            				initContext(context);
            				var placements = new Map();
            				var padding = 5;
            				var width = 512;
            				var x = padding;
            				var y = padding;
            				words.forEach((word)=>{
            						var measurement = context.measureText(word);
            						var l = Math.ceil(-measurement.actualBoundingBoxLeft);
            						var r = Math.ceil(measurement.actualBoundingBoxRight);
            						var a = Math.ceil(measurement.actualBoundingBoxAscent);
            						var d = Math.ceil(measurement.actualBoundingBoxDescent);
            						var w = l + r;
            						var h = a + d;
            						if (x + w + padding >= width) {
            								x = padding;
            								y += 16;
            						}
            						placements.set(word, {
            								l,
            								r,
            								a,
            								d,
            								w,
            								h,
            								x: x,
            								y: y
            						});
            						x += w + padding;
            				});
            				canvas.width = 512;
            				canvas.height = math.nextPowerOfTwo(y + 16 + padding);
            				initContext(context);
            				context.fillStyle = 'rgb(0, 0, 0)';
            				context.fillRect(0, 0, canvas.width, canvas.height);
            				placements.forEach((m, word)=>{
            						context.fillStyle = isNumber(word) ? 'rgb(255, 255, 255)' : 'rgb(170, 170, 170)';
            						context.fillText(word, m.x - m.l, m.y + m.a);
            				});
            				this.placements = placements;
            				var data = context.getImageData(0, 0, canvas.width, canvas.height).data;
            				for(var i = 0; i < data.length; i += 4){
            						data[i + 3] = data[i + 0];
            						data[i + 0] = 255;
            						data[i + 1] = 255;
            						data[i + 2] = 255;
            				}
            				this.texture = new Texture(device, {
            						name: 'mini-stats-word-atlas',
            						width: canvas.width,
            						height: canvas.height,
            						mipmaps: false,
            						minFilter: FILTER_NEAREST,
            						magFilter: FILTER_NEAREST,
            						levels: [
            								data
            						]
            				});
            		}
            }
            
            var vertexShaderGLSL = "\n	attribute vec3 vertex_position;\n	attribute vec4 vertex_texCoord0;\n	varying vec4 uv0;\n	varying float wordFlag;\n	void main(void) {\n		gl_Position = vec4(vertex_position.xy * 2.0 - 1.0, 0.5, 1.0);\n		uv0 = vertex_texCoord0;\n		wordFlag = vertex_position.z;\n	}\n";
            var vertexShaderWGSL = "\n    attribute vertex_position: vec3f;         // unnormalized xy, word flag\n    attribute vertex_texCoord0: vec4f;        // unnormalized texture space uv, normalized uv\n\n    varying uv0: vec4f;\n    varying wordFlag: f32;\n\n    @vertex fn vertexMain(input : VertexInput) -> VertexOutput {\n        var output : VertexOutput;\n        output.position = vec4(input.vertex_position.xy * 2.0 - 1.0, 0.5, 1.0);\n        output.uv0 = input.vertex_texCoord0;\n        output.wordFlag = input.vertex_position.z;\n        return output;\n    }\n";
            var fragmentShaderGLSL = "\n	varying vec4 uv0;\n	varying float wordFlag;\n	uniform vec4 clr;\n	uniform sampler2D graphTex;\n	uniform sampler2D wordsTex;\n	void main (void) {\n		vec4 graphSample = texture2D(graphTex, uv0.xy);\n		vec4 graph;\n		if (uv0.w < graphSample.r)\n			graph = vec4(0.7, 0.2, 0.2, 1.0);\n		else if (uv0.w < graphSample.g)\n			graph = vec4(0.2, 0.7, 0.2, 1.0);\n		else if (uv0.w < graphSample.b)\n			graph = vec4(0.2, 0.2, 0.7, 1.0);\n		else\n			graph = vec4(0.0, 0.0, 0.0, 1.0 - 0.25 * sin(uv0.w * 3.14159));\n		vec4 words = texture2D(wordsTex, vec2(uv0.x, 1.0 - uv0.y));\n		gl_FragColor = mix(graph, words, wordFlag) * clr;\n	}\n";
            var fragmentShaderWGSL = "\n    varying uv0: vec4f;\n    varying wordFlag: f32;\n\n    uniform clr: vec4f;\n\n    var graphTex : texture_2d<f32>;\n    var graphTex_sampler : sampler;\n\n    var wordsTex : texture_2d<f32>;\n    var wordsTex_sampler : sampler;\n\n    @fragment fn fragmentMain(input : FragmentInput) -> FragmentOutput {\n        var uv0: vec4f = input.uv0;\n        var graphSample: vec4f = textureSample(graphTex, graphTex_sampler, uv0.xy);\n\n        var graph: vec4f;\n        if (uv0.w < graphSample.r) {\n            graph = vec4f(0.7, 0.2, 0.2, 1.0);\n        } else if (uv0.w < graphSample.g) {\n            graph = vec4f(0.2, 0.7, 0.2, 1.0);\n        } else if (uv0.w < graphSample.b) {\n            graph = vec4f(0.2, 0.2, 0.7, 1.0);\n        } else {\n            graph = vec4f(0.0, 0.0, 0.0, 1.0 - 0.25 * sin(uv0.w * 3.14159));\n        }\n\n        var words: vec4f = textureSample(wordsTex, wordsTex_sampler, vec2f(uv0.x, 1.0 - uv0.y));\n\n        var output: FragmentOutput;\n        output.color = mix(graph, words, input.wordFlag) * uniform.clr;\n        return output;\n    }\n";
            class Render2d {
            		quad(x, y, w, h, u, v, uw, uh, texture, wordFlag) {
            				if (wordFlag === void 0) wordFlag = 0;
            				var rw = this.targetSize.width;
            				var rh = this.targetSize.height;
            				var x0 = x / rw;
            				var y0 = y / rh;
            				var x1 = (x + w) / rw;
            				var y1 = (y + h) / rh;
            				var tw = texture.width;
            				var th = texture.height;
            				var u0 = u / tw;
            				var v0 = v / th;
            				var u1 = (u + (uw != null ? uw : w)) / tw;
            				var v1 = (v + (uh != null ? uh : h)) / th;
            				this.data.set([
            						x0,
            						y0,
            						wordFlag,
            						u0,
            						v0,
            						0,
            						0,
            						x1,
            						y0,
            						wordFlag,
            						u1,
            						v0,
            						1,
            						0,
            						x1,
            						y1,
            						wordFlag,
            						u1,
            						v1,
            						1,
            						1,
            						x0,
            						y1,
            						wordFlag,
            						u0,
            						v1,
            						0,
            						1
            				], 4 * 7 * this.quads);
            				this.quads++;
            				this.prim.count += 6;
            		}
            		startFrame() {
            				this.quads = 0;
            				this.prim.count = 0;
            				this.targetSize.width = this.device.canvas.scrollWidth;
            				this.targetSize.height = this.device.canvas.scrollHeight;
            		}
            		render(app, layer, graphTexture, wordsTexture, clr, height) {
            				this.buffer.setData(this.data.buffer);
            				this.uniforms.clr.set(clr, 0);
            				this.material.setParameter('clr', this.uniforms.clr);
            				this.material.setParameter('graphTex', graphTexture);
            				this.material.setParameter('wordsTex', wordsTexture);
            				app.drawMeshInstance(this.meshInstance, layer);
            		}
            		constructor(device, maxQuads = 512){
            				var format = new VertexFormat(device, [
            						{
            								semantic: SEMANTIC_POSITION,
            								components: 3,
            								type: TYPE_FLOAT32
            						},
            						{
            								semantic: SEMANTIC_TEXCOORD0,
            								components: 4,
            								type: TYPE_FLOAT32
            						}
            				]);
            				var indices = new Uint16Array(maxQuads * 6);
            				for(var i = 0; i < maxQuads; ++i){
            						indices[i * 6 + 0] = i * 4;
            						indices[i * 6 + 1] = i * 4 + 1;
            						indices[i * 6 + 2] = i * 4 + 2;
            						indices[i * 6 + 3] = i * 4;
            						indices[i * 6 + 4] = i * 4 + 2;
            						indices[i * 6 + 5] = i * 4 + 3;
            				}
            				this.device = device;
            				this.buffer = new VertexBuffer(device, format, maxQuads * 4, {
            						usage: BUFFER_STREAM
            				});
            				this.data = new Float32Array(this.buffer.numBytes / 4);
            				this.indexBuffer = new IndexBuffer(device, INDEXFORMAT_UINT16, maxQuads * 6, BUFFER_STATIC, indices);
            				this.prim = {
            						type: PRIMITIVE_TRIANGLES,
            						indexed: true,
            						base: 0,
            						count: 0
            				};
            				this.quads = 0;
            				this.mesh = new Mesh(device);
            				this.mesh.vertexBuffer = this.buffer;
            				this.mesh.indexBuffer[0] = this.indexBuffer;
            				this.mesh.primitive = [
            						this.prim
            				];
            				var material = new ShaderMaterial({
            						uniqueName: 'MiniStats',
            						vertexGLSL: vertexShaderGLSL,
            						fragmentGLSL: fragmentShaderGLSL,
            						vertexWGSL: vertexShaderWGSL,
            						fragmentWGSL: fragmentShaderWGSL,
            						attributes: {
            								vertex_position: SEMANTIC_POSITION,
            								vertex_texCoord0: SEMANTIC_TEXCOORD0
            						}
            				});
            				this.material = material;
            				material.cull = CULLFACE_NONE;
            				material.depthState = DepthState.NODEPTH;
            				material.blendState = new BlendState(true, BLENDEQUATION_ADD, BLENDMODE_SRC_ALPHA, BLENDMODE_ONE_MINUS_SRC_ALPHA, BLENDEQUATION_ADD, BLENDMODE_ONE, BLENDMODE_ONE);
            				material.update();
            				this.meshInstance = new MeshInstance(this.mesh, material, new GraphNode('MiniStatsMesh'));
            				this.uniforms = {
            						clr: new Float32Array(4)
            				};
            				this.targetSize = {
            						width: device.width,
            						height: device.height
            				};
            		}
            }
            
            class MiniStats {
            		destroy() {
            				this.device.off('resizecanvas', this.updateDiv, this);
            				this.device.off('losecontext', this.loseContext, this);
            				this.app.off('postrender', this.postRender, this);
            				this.graphs.forEach((graph)=>graph.destroy());
            				this.wordAtlas.destroy();
            				this.texture.destroy();
            		}
            		static getDefaultOptions() {
            				return {
            						sizes: [
            								{
            										width: 100,
            										height: 16,
            										spacing: 0,
            										graphs: false
            								},
            								{
            										width: 128,
            										height: 32,
            										spacing: 2,
            										graphs: true
            								},
            								{
            										width: 256,
            										height: 64,
            										spacing: 2,
            										graphs: true
            								}
            						],
            						startSizeIndex: 0,
            						textRefreshRate: 500,
            						cpu: {
            								enabled: true,
            								watermark: 33
            						},
            						gpu: {
            								enabled: true,
            								watermark: 33
            						},
            						stats: [
            								{
            										name: 'Frame',
            										stats: [
            												'frame.ms'
            										],
            										decimalPlaces: 1,
            										unitsName: 'ms',
            										watermark: 33
            								},
            								{
            										name: 'DrawCalls',
            										stats: [
            												'drawCalls.total'
            										],
            										watermark: 1000
            								}
            						]
            				};
            		}
            		set activeSizeIndex(value) {
            				this._activeSizeIndex = value;
            				this.gspacing = this.sizes[value].spacing;
            				this.resize(this.sizes[value].width, this.sizes[value].height, this.sizes[value].graphs);
            		}
            		get activeSizeIndex() {
            				return this._activeSizeIndex;
            		}
            		set opacity(value) {
            				this.clr[3] = value;
            		}
            		get opacity() {
            				return this.clr[3];
            		}
            		get overallHeight() {
            				var graphs = this.graphs;
            				var spacing = this.gspacing;
            				return this.height * graphs.length + spacing * (graphs.length - 1);
            		}
            		set enabled(value) {
            				if (value !== this._enabled) {
            						this._enabled = value;
            						for(var i = 0; i < this.graphs.length; ++i){
            								this.graphs[i].enabled = value;
            								this.graphs[i].timer.enabled = value;
            						}
            				}
            		}
            		get enabled() {
            				return this._enabled;
            		}
            		initGraphs(app, device, options) {
            				this.graphs = [];
            				if (options.cpu.enabled) {
            						var timer = new CpuTimer(app);
            						var graph = new Graph('CPU', app, options.cpu.watermark, options.textRefreshRate, timer);
            						this.graphs.push(graph);
            				}
            				if (options.gpu.enabled) {
            						var timer1 = new GpuTimer(device);
            						var graph1 = new Graph('GPU', app, options.gpu.watermark, options.textRefreshRate, timer1);
            						this.graphs.push(graph1);
            				}
            				if (options.stats) {
            						options.stats.forEach((entry)=>{
            								var timer = new StatsTimer(app, entry.stats, entry.decimalPlaces, entry.unitsName, entry.multiplier);
            								var graph = new Graph(entry.name, app, entry.watermark, options.textRefreshRate, timer);
            								this.graphs.push(graph);
            						});
            				}
            				var maxWidth = options.sizes.reduce((max, v)=>{
            						return v.width > max ? v.width : max;
            				}, 0);
            				this.texture = new Texture(device, {
            						name: 'mini-stats-graph-texture',
            						width: math.nextPowerOfTwo(maxWidth),
            						height: math.nextPowerOfTwo(this.graphs.length),
            						mipmaps: false,
            						minFilter: FILTER_NEAREST,
            						magFilter: FILTER_NEAREST,
            						addressU: ADDRESS_REPEAT,
            						addressV: ADDRESS_REPEAT
            				});
            				this.graphs.forEach((graph, i)=>{
            						graph.texture = this.texture;
            						graph.yOffset = i;
            				});
            		}
            		render() {
            				var graphs = this.graphs;
            				var wordAtlas = this.wordAtlas;
            				var render2d = this.render2d;
            				var width = this.width;
            				var height = this.height;
            				var gspacing = this.gspacing;
            				render2d.startFrame();
            				for(var i = 0; i < graphs.length; ++i){
            						var graph = graphs[i];
            						var y = i * (height + gspacing);
            						graph.render(render2d, 0, y, width, height);
            						var x = 1;
            						y += height - 13;
            						x += wordAtlas.render(render2d, graph.name, x, y) + 10;
            						var timingText = graph.timingText;
            						for(var j = 0; j < timingText.length; ++j){
            								x += wordAtlas.render(render2d, timingText[j], x, y);
            						}
            						if (graph.timer.unitsName) {
            								x += 3;
            								wordAtlas.render(render2d, graph.timer.unitsName, x, y);
            						}
            				}
            				render2d.render(this.app, this.drawLayer, this.texture, this.wordAtlas.texture, this.clr, height);
            		}
            		resize(width, height, showGraphs) {
            				var graphs = this.graphs;
            				for(var i = 0; i < graphs.length; ++i){
            						graphs[i].enabled = showGraphs;
            				}
            				this.width = width;
            				this.height = height;
            				this.updateDiv();
            		}
            		updateDiv() {
            				var rect = this.device.canvas.getBoundingClientRect();
            				this.div.style.left = "" + rect.left + "px";
            				this.div.style.bottom = "" + (window.innerHeight - rect.bottom) + "px";
            				this.div.style.width = "" + this.width + "px";
            				this.div.style.height = "" + this.overallHeight + "px";
            		}
            		loseContext() {
            				this.graphs.forEach((graph)=>graph.loseContext());
            		}
            		postRender() {
            				if (this._enabled) {
            						this.render();
            				}
            		}
            		constructor(app, options){
            				var device = app.graphicsDevice;
            				options = options || MiniStats.getDefaultOptions();
            				this.initGraphs(app, device, options);
            				var words = new Set([
            						'',
            						'ms',
            						'0',
            						'1',
            						'2',
            						'3',
            						'4',
            						'5',
            						'6',
            						'7',
            						'8',
            						'9',
            						'.'
            				].concat(this.graphs.map((graph)=>graph.name)).concat(options.stats ? options.stats.map((stat)=>stat.unitsName) : []).filter((item)=>!!item));
            				this.wordAtlas = new WordAtlas(device, words);
            				this.sizes = options.sizes;
            				this._activeSizeIndex = options.startSizeIndex;
            				var div = document.createElement('div');
            				div.setAttribute('id', 'mini-stats');
            				div.style.cssText = 'position:fixed;bottom:0;left:0;background:transparent;';
            				document.body.appendChild(div);
            				div.addEventListener('mouseenter', (event)=>{
            						this.opacity = 1.0;
            				});
            				div.addEventListener('mouseleave', (event)=>{
            						this.opacity = 0.7;
            				});
            				div.addEventListener('click', (event)=>{
            						event.preventDefault();
            						if (this._enabled) {
            								this.activeSizeIndex = (this.activeSizeIndex + 1) % this.sizes.length;
            								this.resize(this.sizes[this.activeSizeIndex].width, this.sizes[this.activeSizeIndex].height, this.sizes[this.activeSizeIndex].graphs);
            						}
            				});
            				device.on('resizecanvas', this.updateDiv, this);
            				device.on('losecontext', this.loseContext, this);
            				app.on('postrender', this.postRender, this);
            				this.app = app;
            				this.drawLayer = app.scene.layers.getLayerById(LAYERID_UI);
            				this.device = device;
            				this.render2d = new Render2d(device);
            				this.div = div;
            				this.width = 0;
            				this.height = 0;
            				this.gspacing = 2;
            				this.clr = [
            						1,
            						1,
            						1,
            						0.5
            				];
            				this._enabled = true;
            				this.activeSizeIndex = this._activeSizeIndex;
            		}
            }
            
            /**
             * Base class for all PlayCanvas Web Components that initialize asynchronously.
             */
            class AsyncElement extends HTMLElement {
                /** @ignore */
                constructor() {
                    super();
                    this._readyPromise = new Promise((resolve) => {
                        this._readyResolve = resolve;
                    });
                }
                get closestApp() {
                    var _a;
                    return (_a = this.parentElement) === null || _a === void 0 ? void 0 : _a.closest('pc-app');
                }
                get closestEntity() {
                    var _a;
                    return (_a = this.parentElement) === null || _a === void 0 ? void 0 : _a.closest('pc-entity');
                }
                /**
                 * Called when the element is fully initialized and ready.
                 * Subclasses should call this when they're ready.
                 */
                _onReady() {
                    this._readyResolve();
                    this.dispatchEvent(new CustomEvent('ready'));
                }
                /**
                 * Returns a promise that resolves with this element when it's ready.
                 * @returns A promise that resolves with this element when it's ready.
                 */
                ready() {
                    return this._readyPromise.then(() => this);
                }
            }
            
            /**
             * The ModuleElement interface provides properties and methods for manipulating
             * {@link https://developer.playcanvas.com/user-manual/engine/web-components/tags/pc-module/ | `<pc-module>`} elements.
             * The ModuleElement interface also inherits the properties and methods of the
             * {@link HTMLElement} interface.
             */
            class ModuleElement extends HTMLElement {
                /** @ignore */
                constructor() {
                    super();
                    this.loadPromise = this.loadModule();
                }
                async loadModule() {
                    const name = this.getAttribute('name');
                    const glueUrl = this.getAttribute('glue');
                    const wasmUrl = this.getAttribute('wasm');
                    const fallbackUrl = this.getAttribute('fallback');
                    const config = { glueUrl, wasmUrl, fallbackUrl };
                    if (name === 'Basis') {
                        basisInitialize(config);
                    }
                    else {
                        WasmModule.setConfig(name, config);
                        await new Promise((resolve) => {
                            WasmModule.getInstance(name, () => resolve());
                        });
                    }
                }
                getLoadPromise() {
                    return this.loadPromise;
                }
            }
            customElements.define('pc-module', ModuleElement);
            
            /**
             * The AppElement interface provides properties and methods for manipulating
             * {@link https://developer.playcanvas.com/user-manual/engine/web-components/tags/pc-app/ | `<pc-app>`} elements.
             * The AppElement interface also inherits the properties and methods of the
             * {@link HTMLElement} interface.
             */
            class AppElement extends AsyncElement {
                /**
                 * Creates a new AppElement instance.
                 *
                 * @ignore
                 */
                constructor() {
                    super();
                    /**
                     * The canvas element.
                     */
                    this._canvas = null;
                    this._alpha = true;
                    this._antialias = true;
                    this._depth = true;
                    this._stencil = true;
                    this._highResolution = true;
                    this._hierarchyReady = false;
                    this._picker = null;
                    this._hasPointerListeners = {
                        pointerenter: false,
                        pointerleave: false,
                        pointerdown: false,
                        pointerup: false,
                        pointermove: false
                    };
                    this._hoveredEntity = null;
                    this._pointerHandlers = {
                        pointermove: null,
                        pointerdown: null,
                        pointerup: null
                    };
                    /**
                     * The PlayCanvas application instance.
                     */
                    this.app = null;
                    // Bind methods to maintain 'this' context
                    this._onWindowResize = this._onWindowResize.bind(this);
                }
                async connectedCallback() {
                    // Get all pc-module elements that are direct children of the pc-app element
                    const moduleElements = this.querySelectorAll(':scope > pc-module');
                    // Wait for all modules to load
                    await Promise.all(Array.from(moduleElements).map(module => module.getLoadPromise()));
                    // Create and append the canvas to the element
                    this._canvas = document.createElement('canvas');
                    this.appendChild(this._canvas);
                    // Initialize the PlayCanvas application
                    this.app = new Application(this._canvas, {
                        graphicsDeviceOptions: {
                            alpha: this._alpha,
                            antialias: this._antialias,
                            depth: this._depth,
                            stencil: this._stencil
                        },
                        keyboard: new Keyboard(window),
                        mouse: new Mouse(this._canvas)
                    });
                    this.app.graphicsDevice.maxPixelRatio = this._highResolution ? window.devicePixelRatio : 1;
                    this.app.setCanvasFillMode(FILLMODE_FILL_WINDOW);
                    this.app.setCanvasResolution(RESOLUTION_AUTO);
                    this._pickerCreate();
                    // Get all pc-asset elements that are direct children of the pc-app element
                    const assetElements = this.querySelectorAll(':scope > pc-asset');
                    Array.from(assetElements).forEach((assetElement) => {
                        assetElement.createAsset();
                        const asset = assetElement.asset;
                        if (asset) {
                            this.app.assets.add(asset);
                        }
                    });
                    // Get all pc-material elements that are direct children of the pc-app element
                    const materialElements = this.querySelectorAll(':scope > pc-material');
                    Array.from(materialElements).forEach((materialElement) => {
                        materialElement.createMaterial();
                    });
                    // Create all entities
                    const entityElements = this.querySelectorAll('pc-entity');
                    Array.from(entityElements).forEach((entityElement) => {
                        entityElement.createEntity(this.app);
                    });
                    // Build hierarchy
                    entityElements.forEach((entityElement) => {
                        entityElement.buildHierarchy(this.app);
                    });
                    this._hierarchyReady = true;
                    // Load assets before starting the application
                    this.app.preload(() => {
                        // Start the application
                        this.app.start();
                        // Handle window resize to keep the canvas responsive
                        window.addEventListener('resize', this._onWindowResize);
                        this._onReady();
                    });
                }
                disconnectedCallback() {
                    this._pickerDestroy();
                    // Clean up the application
                    if (this.app) {
                        this.app.destroy();
                        this.app = null;
                    }
                    // Remove event listeners
                    window.removeEventListener('resize', this._onWindowResize);
                    // Remove the canvas
                    if (this._canvas && this.contains(this._canvas)) {
                        this.removeChild(this._canvas);
                        this._canvas = null;
                    }
                }
                _onWindowResize() {
                    if (this.app) {
                        this.app.resizeCanvas();
                    }
                }
                _pickerCreate() {
                    const { width, height } = this.app.graphicsDevice;
                    this._picker = new Picker$1(this.app, width, height);
                    // Create bound handlers but don't attach them yet
                    this._pointerHandlers.pointermove = this._onPointerMove.bind(this);
                    this._pointerHandlers.pointerdown = this._onPointerDown.bind(this);
                    this._pointerHandlers.pointerup = this._onPointerUp.bind(this);
                    // Listen for pointer listeners being added/removed
                    ['pointermove', 'pointerdown', 'pointerup', 'pointerenter', 'pointerleave'].forEach((type) => {
                        this.addEventListener(`${type}:connect`, () => this._onPointerListenerAdded(type));
                        this.addEventListener(`${type}:disconnect`, () => this._onPointerListenerRemoved(type));
                    });
                }
                _pickerDestroy() {
                    if (this._canvas) {
                        Object.entries(this._pointerHandlers).forEach(([type, handler]) => {
                            if (handler) {
                                this._canvas.removeEventListener(type, handler);
                            }
                        });
                    }
                    this._picker = null;
                    this._pointerHandlers = {
                        pointermove: null,
                        pointerdown: null,
                        pointerup: null
                    };
                }
                // New helper to convert CSS coordinates to canvas (picker) coordinates
                _getPickerCoordinates(event) {
                    // Get the canvas' bounding rectangle in CSS pixels.
                    const canvasRect = this._canvas.getBoundingClientRect();
                    // Compute scale factors based on canvas actual resolution vs. its CSS display size.
                    const scaleX = this._canvas.width / canvasRect.width;
                    const scaleY = this._canvas.height / canvasRect.height;
                    // Convert the client coordinates accordingly.
                    const x = (event.clientX - canvasRect.left) * scaleX;
                    const y = (event.clientY - canvasRect.top) * scaleY;
                    return { x, y };
                }
                _onPointerMove(event) {
                    if (!this._picker || !this.app)
                        return;
                    const camera = this.app.root.findComponent('camera');
                    if (!camera)
                        return;
                    // Use the helper to convert event coordinates into canvas/picker coordinates.
                    const { x, y } = this._getPickerCoordinates(event);
                    this._picker.prepare(camera, this.app.scene);
                    const selection = this._picker.getSelection(x, y);
                    // Get the currently hovered entity by walking up the hierarchy
                    let newHoverEntity = null;
                    if (selection.length > 0) {
                        let currentNode = selection[0].node;
                        while (currentNode !== null) {
                            const entityElement = this.querySelector(`pc-entity[name="${currentNode.name}"]`);
                            if (entityElement) {
                                newHoverEntity = entityElement;
                                break;
                            }
                            currentNode = currentNode.parent;
                        }
                    }
                    // Handle enter/leave events
                    if (this._hoveredEntity !== newHoverEntity) {
                        if (this._hoveredEntity && this._hoveredEntity.hasListeners('pointerleave')) {
                            this._hoveredEntity.dispatchEvent(new PointerEvent('pointerleave', event));
                        }
                        if (newHoverEntity && newHoverEntity.hasListeners('pointerenter')) {
                            newHoverEntity.dispatchEvent(new PointerEvent('pointerenter', event));
                        }
                    }
                    // Update hover state
                    this._hoveredEntity = newHoverEntity;
                    // Handle pointermove event
                    if (newHoverEntity && newHoverEntity.hasListeners('pointermove')) {
                        newHoverEntity.dispatchEvent(new PointerEvent('pointermove', event));
                    }
                }
                _onPointerDown(event) {
                    if (!this._picker || !this.app)
                        return;
                    const camera = this.app.root.findComponent('camera');
                    if (!camera)
                        return;
                    // Convert the event's pointer coordinates
                    const { x, y } = this._getPickerCoordinates(event);
                    this._picker.prepare(camera, this.app.scene);
                    const selection = this._picker.getSelection(x, y);
                    if (selection.length > 0) {
                        let currentNode = selection[0].node;
                        while (currentNode !== null) {
                            const entityElement = this.querySelector(`pc-entity[name="${currentNode.name}"]`);
                            if (entityElement && entityElement.hasListeners('pointerdown')) {
                                entityElement.dispatchEvent(new PointerEvent('pointerdown', event));
                                break;
                            }
                            currentNode = currentNode.parent;
                        }
                    }
                }
                _onPointerUp(event) {
                    if (!this._picker || !this.app)
                        return;
                    const camera = this.app.root.findComponent('camera');
                    if (!camera)
                        return;
                    // Convert CSS coordinates to picker coordinates
                    const { x, y } = this._getPickerCoordinates(event);
                    this._picker.prepare(camera, this.app.scene);
                    const selection = this._picker.getSelection(x, y);
                    if (selection.length > 0) {
                        const entityElement = this.querySelector(`pc-entity[name="${selection[0].node.name}"]`);
                        if (entityElement && entityElement.hasListeners('pointerup')) {
                            entityElement.dispatchEvent(new PointerEvent('pointerup', event));
                        }
                    }
                }
                _onPointerListenerAdded(type) {
                    if (!this._hasPointerListeners[type] && this._canvas) {
                        this._hasPointerListeners[type] = true;
                        // For enter/leave events, we need the move handler
                        const handler = (type === 'pointerenter' || type === 'pointerleave') ?
                            this._pointerHandlers.pointermove :
                            this._pointerHandlers[type];
                        if (handler) {
                            this._canvas.addEventListener(type === 'pointerenter' || type === 'pointerleave' ? 'pointermove' : type, handler);
                        }
                    }
                }
                _onPointerListenerRemoved(type) {
                    const hasListeners = Array.from(this.querySelectorAll('pc-entity'))
                        .some(entity => entity.hasListeners(type));
                    if (!hasListeners && this._canvas) {
                        this._hasPointerListeners[type] = false;
                        const handler = (type === 'pointerenter' || type === 'pointerleave') ?
                            this._pointerHandlers.pointermove :
                            this._pointerHandlers[type];
                        if (handler) {
                            this._canvas.removeEventListener(type === 'pointerenter' || type === 'pointerleave' ? 'pointermove' : type, handler);
                        }
                    }
                }
                /**
                 * Sets the alpha flag.
                 * @param value - The alpha flag.
                 */
                set alpha(value) {
                    this._alpha = value;
                }
                /**
                 * Gets the alpha flag.
                 * @returns The alpha flag.
                 */
                get alpha() {
                    return this._alpha;
                }
                /**
                 * Sets the antialias flag.
                 * @param value - The antialias flag.
                 */
                set antialias(value) {
                    this._antialias = value;
                }
                /**
                 * Gets the antialias flag.
                 * @returns The antialias flag.
                 */
                get antialias() {
                    return this._antialias;
                }
                /**
                 * Sets the depth flag.
                 * @param value - The depth flag.
                 */
                set depth(value) {
                    this._depth = value;
                }
                /**
                 * Gets the depth flag.
                 * @returns The depth flag.
                 */
                get depth() {
                    return this._depth;
                }
                /**
                 * Gets the hierarchy ready flag.
                 * @returns The hierarchy ready flag.
                 * @ignore
                 */
                get hierarchyReady() {
                    return this._hierarchyReady;
                }
                /**
                 * Sets the high resolution flag. When true, the application will render at the device's
                 * physical resolution. When false, the application will render at CSS resolution.
                 * @param value - The high resolution flag.
                 */
                set highResolution(value) {
                    this._highResolution = value;
                    if (this.app) {
                        this.app.graphicsDevice.maxPixelRatio = value ? window.devicePixelRatio : 1;
                    }
                }
                /**
                 * Gets the high resolution flag.
                 * @returns The high resolution flag.
                 */
                get highResolution() {
                    return this._highResolution;
                }
                /**
                 * Sets the stencil flag.
                 * @param value - The stencil flag.
                 */
                set stencil(value) {
                    this._stencil = value;
                }
                /**
                 * Gets the stencil flag.
                 * @returns The stencil flag.
                 */
                get stencil() {
                    return this._stencil;
                }
                static get observedAttributes() {
                    return ['alpha', 'antialias', 'depth', 'stencil', 'high-resolution'];
                }
                attributeChangedCallback(name, _oldValue, newValue) {
                    switch (name) {
                        case 'alpha':
                            this.alpha = newValue !== 'false';
                            break;
                        case 'antialias':
                            this.antialias = newValue !== 'false';
                            break;
                        case 'depth':
                            this.depth = newValue !== 'false';
                            break;
                        case 'high-resolution':
                            this.highResolution = newValue !== 'false';
                            break;
                        case 'stencil':
                            this.stencil = newValue !== 'false';
                            break;
                    }
                }
            }
            customElements.define('pc-app', AppElement);
            
            const CSS_COLORS = {
                aliceblue: '#f0f8ff',
                antiquewhite: '#faebd7',
                aqua: '#00ffff',
                aquamarine: '#7fffd4',
                azure: '#f0ffff',
                beige: '#f5f5dc',
                bisque: '#ffe4c4',
                black: '#000000',
                blanchedalmond: '#ffebcd',
                blue: '#0000ff',
                blueviolet: '#8a2be2',
                brown: '#a52a2a',
                burlywood: '#deb887',
                cadetblue: '#5f9ea0',
                chartreuse: '#7fff00',
                chocolate: '#d2691e',
                coral: '#ff7f50',
                cornflowerblue: '#6495ed',
                cornsilk: '#fff8dc',
                crimson: '#dc143c',
                cyan: '#00ffff',
                darkblue: '#00008b',
                darkcyan: '#008b8b',
                darkgoldenrod: '#b8860b',
                darkgray: '#a9a9a9',
                darkgreen: '#006400',
                darkgrey: '#a9a9a9',
                darkkhaki: '#bdb76b',
                darkmagenta: '#8b008b',
                darkolivegreen: '#556b2f',
                darkorange: '#ff8c00',
                darkorchid: '#9932cc',
                darkred: '#8b0000',
                darksalmon: '#e9967a',
                darkseagreen: '#8fbc8f',
                darkslateblue: '#483d8b',
                darkslategray: '#2f4f4f',
                darkslategrey: '#2f4f4f',
                darkturquoise: '#00ced1',
                darkviolet: '#9400d3',
                deeppink: '#ff1493',
                deepskyblue: '#00bfff',
                dimgray: '#696969',
                dimgrey: '#696969',
                dodgerblue: '#1e90ff',
                firebrick: '#b22222',
                floralwhite: '#fffaf0',
                forestgreen: '#228b22',
                fuchsia: '#ff00ff',
                gainsboro: '#dcdcdc',
                ghostwhite: '#f8f8ff',
                gold: '#ffd700',
                goldenrod: '#daa520',
                gray: '#808080',
                green: '#008000',
                greenyellow: '#adff2f',
                grey: '#808080',
                honeydew: '#f0fff0',
                hotpink: '#ff69b4',
                indianred: '#cd5c5c',
                indigo: '#4b0082',
                ivory: '#fffff0',
                khaki: '#f0e68c',
                lavender: '#e6e6fa',
                lavenderblush: '#fff0f5',
                lawngreen: '#7cfc00',
                lemonchiffon: '#fffacd',
                lightblue: '#add8e6',
                lightcoral: '#f08080',
                lightcyan: '#e0ffff',
                lightgoldenrodyellow: '#fafad2',
                lightgray: '#d3d3d3',
                lightgreen: '#90ee90',
                lightgrey: '#d3d3d3',
                lightpink: '#ffb6c1',
                lightsalmon: '#ffa07a',
                lightseagreen: '#20b2aa',
                lightskyblue: '#87cefa',
                lightslategray: '#778899',
                lightslategrey: '#778899',
                lightsteelblue: '#b0c4de',
                lightyellow: '#ffffe0',
                lime: '#00ff00',
                limegreen: '#32cd32',
                linen: '#faf0e6',
                magenta: '#ff00ff',
                maroon: '#800000',
                mediumaquamarine: '#66cdaa',
                mediumblue: '#0000cd',
                mediumorchid: '#ba55d3',
                mediumpurple: '#9370db',
                mediumseagreen: '#3cb371',
                mediumslateblue: '#7b68ee',
                mediumspringgreen: '#00fa9a',
                mediumturquoise: '#48d1cc',
                mediumvioletred: '#c71585',
                midnightblue: '#191970',
                mintcream: '#f5fffa',
                mistyrose: '#ffe4e1',
                moccasin: '#ffe4b5',
                navajowhite: '#ffdead',
                navy: '#000080',
                oldlace: '#fdf5e6',
                olive: '#808000',
                olivedrab: '#6b8e23',
                orange: '#ffa500',
                orangered: '#ff4500',
                orchid: '#da70d6',
                palegoldenrod: '#eee8aa',
                palegreen: '#98fb98',
                paleturquoise: '#afeeee',
                palevioletred: '#db7093',
                papayawhip: '#ffefd5',
                peachpuff: '#ffdab9',
                peru: '#cd853f',
                pink: '#ffc0cb',
                plum: '#dda0dd',
                powderblue: '#b0e0e6',
                purple: '#800080',
                rebeccapurple: '#663399',
                red: '#ff0000',
                rosybrown: '#bc8f8f',
                royalblue: '#4169e1',
                saddlebrown: '#8b4513',
                salmon: '#fa8072',
                sandybrown: '#f4a460',
                seagreen: '#2e8b57',
                seashell: '#fff5ee',
                sienna: '#a0522d',
                silver: '#c0c0c0',
                skyblue: '#87ceeb',
                slateblue: '#6a5acd',
                slategray: '#708090',
                slategrey: '#708090',
                snow: '#fffafa',
                springgreen: '#00ff7f',
                steelblue: '#4682b4',
                tan: '#d2b48c',
                teal: '#008080',
                thistle: '#d8bfd8',
                tomato: '#ff6347',
                turquoise: '#40e0d0',
                violet: '#ee82ee',
                wheat: '#f5deb3',
                white: '#ffffff',
                whitesmoke: '#f5f5f5',
                yellow: '#ffff00',
                yellowgreen: '#9acd32'
            };
            
            /**
             * Parse a color string into a Color object. String can be in the format of '#rgb', '#rgba',
             * '#rrggbb', '#rrggbbaa', or a string of 3 or 4 comma-delimited numbers.
             *
             * @param value - The color string to parse.
             * @returns The parsed Color object.
             */
            const parseColor = (value) => {
                // Check if it's a CSS color name first
                const hexColor = CSS_COLORS[value.toLowerCase()];
                if (hexColor) {
                    return new Color().fromString(hexColor);
                }
                if (value.startsWith('#')) {
                    return new Color().fromString(value);
                }
                const components = value.split(' ').map(Number);
                return new Color(components);
            };
            /**
             * Parse an Euler angles string into a Quat object. String can be in the format of 'x,y,z'.
             *
             * @param value - The Euler angles string to parse.
             * @returns The parsed Quat object.
             */
            const parseQuat = (value) => {
                const [x, y, z] = value.split(' ').map(Number);
                const q = new Quat();
                q.setFromEulerAngles(x, y, z);
                return q;
            };
            /**
             * Parse a Vec2 string into a Vec2 object. String can be in the format of 'x,y'.
             *
             * @param value - The Vec2 string to parse.
             * @returns The parsed Vec2 object.
             */
            const parseVec2 = (value) => {
                const components = value.split(' ').map(Number);
                return new Vec2(components);
            };
            /**
             * Parse a Vec3 string into a Vec3 object. String can be in the format of 'x,y,z'.
             *
             * @param value - The Vec3 string to parse.
             * @returns The parsed Vec3 object.
             */
            const parseVec3 = (value) => {
                const components = value.split(' ').map(Number);
                return new Vec3(components);
            };
            /**
             * Parse a Vec4 string into a Vec4 object. String can be in the format of 'x,y,z,w'.
             *
             * @param value - The Vec4 string to parse.
             * @returns The parsed Vec4 object.
             */
            const parseVec4 = (value) => {
                const components = value.split(' ').map(Number);
                return new Vec4(components);
            };
            
            /**
             * The EntityElement interface provides properties and methods for manipulating
             * {@link https://developer.playcanvas.com/user-manual/engine/web-components/tags/pc-entity/ | `<pc-entity>`} elements.
             * The EntityElement interface also inherits the properties and methods of the
             * {@link HTMLElement} interface.
             */
            class EntityElement extends AsyncElement {
                constructor() {
                    super(...arguments);
                    /**
                     * Whether the entity is enabled.
                     */
                    this._enabled = true;
                    /**
                     * The name of the entity.
                     */
                    this._name = 'Untitled';
                    /**
                     * The position of the entity.
                     */
                    this._position = new Vec3();
                    /**
                     * The rotation of the entity.
                     */
                    this._rotation = new Vec3();
                    /**
                     * The scale of the entity.
                     */
                    this._scale = new Vec3(1, 1, 1);
                    /**
                     * The tags of the entity.
                     */
                    this._tags = [];
                    /**
                     * The pointer event listeners for the entity.
                     */
                    this._listeners = {};
                    /**
                     * The PlayCanvas entity instance.
                     */
                    this.entity = null;
                }
                createEntity(app) {
                    // Create a new entity
                    this.entity = new Entity(this.getAttribute('name') || this._name, app);
                    const enabled = this.getAttribute('enabled');
                    if (enabled) {
                        this.entity.enabled = enabled !== 'false';
                    }
                    const position = this.getAttribute('position');
                    if (position) {
                        this.entity.setLocalPosition(parseVec3(position));
                    }
                    const rotation = this.getAttribute('rotation');
                    if (rotation) {
                        this.entity.setLocalEulerAngles(parseVec3(rotation));
                    }
                    const scale = this.getAttribute('scale');
                    if (scale) {
                        this.entity.setLocalScale(parseVec3(scale));
                    }
                    const tags = this.getAttribute('tags');
                    if (tags) {
                        this.entity.tags.add(tags.split(',').map(tag => tag.trim()));
                    }
                    // Handle pointer events
                    const pointerEvents = [
                        'onpointerenter',
                        'onpointerleave',
                        'onpointerdown',
                        'onpointerup',
                        'onpointermove'
                    ];
                    pointerEvents.forEach((eventName) => {
                        const handler = this.getAttribute(eventName);
                        if (handler) {
                            const eventType = eventName.substring(2); // remove 'on' prefix
                            const eventHandler = (event) => {
                                try {
                                    /* eslint-disable-next-line no-new-func */
                                    new Function('event', handler).call(this, event);
                                }
                                catch (e) {
                                    console.error('Error in event handler:', e);
                                }
                            };
                            this.addEventListener(eventType, eventHandler);
                        }
                    });
                }
                buildHierarchy(app) {
                    if (!this.entity)
                        return;
                    const closestEntity = this.closestEntity;
                    if (closestEntity === null || closestEntity === void 0 ? void 0 : closestEntity.entity) {
                        closestEntity.entity.addChild(this.entity);
                    }
                    else {
                        app.root.addChild(this.entity);
                    }
                    this._onReady();
                }
                connectedCallback() {
                    // Wait for app to be ready
                    const closestApp = this.closestApp;
                    if (!closestApp)
                        return;
                    // If app is already running, create entity immediately
                    if (closestApp.hierarchyReady) {
                        const app = closestApp.app;
                        this.createEntity(app);
                        this.buildHierarchy(app);
                        // Handle any child entities that might exist
                        const childEntities = this.querySelectorAll('pc-entity');
                        childEntities.forEach((child) => {
                            child.createEntity(app);
                        });
                        childEntities.forEach((child) => {
                            child.buildHierarchy(app);
                        });
                    }
                }
                disconnectedCallback() {
                    if (this.entity) {
                        // Notify all children that their entities are about to become invalid
                        const children = this.querySelectorAll('pc-entity');
                        children.forEach((child) => {
                            child.entity = null;
                        });
                        // Destroy the entity
                        this.entity.destroy();
                        this.entity = null;
                    }
                }
                /**
                 * Sets the enabled state of the entity.
                 * @param value - Whether the entity is enabled.
                 */
                set enabled(value) {
                    this._enabled = value;
                    if (this.entity) {
                        this.entity.enabled = value;
                    }
                }
                /**
                 * Gets the enabled state of the entity.
                 * @returns Whether the entity is enabled.
                 */
                get enabled() {
                    return this._enabled;
                }
                /**
                 * Sets the name of the entity.
                 * @param value - The name of the entity.
                 */
                set name(value) {
                    this._name = value;
                    if (this.entity) {
                        this.entity.name = value;
                    }
                }
                /**
                 * Gets the name of the entity.
                 * @returns The name of the entity.
                 */
                get name() {
                    return this._name;
                }
                /**
                 * Sets the position of the entity.
                 * @param value - The position of the entity.
                 */
                set position(value) {
                    this._position = value;
                    if (this.entity) {
                        this.entity.setLocalPosition(this._position);
                    }
                }
                /**
                 * Gets the position of the entity.
                 * @returns The position of the entity.
                 */
                get position() {
                    return this._position;
                }
                /**
                 * Sets the rotation of the entity.
                 * @param value - The rotation of the entity.
                 */
                set rotation(value) {
                    this._rotation = value;
                    if (this.entity) {
                        this.entity.setLocalEulerAngles(this._rotation);
                    }
                }
                /**
                 * Gets the rotation of the entity.
                 * @returns The rotation of the entity.
                 */
                get rotation() {
                    return this._rotation;
                }
                /**
                 * Sets the scale of the entity.
                 * @param value - The scale of the entity.
                 */
                set scale(value) {
                    this._scale = value;
                    if (this.entity) {
                        this.entity.setLocalScale(this._scale);
                    }
                }
                /**
                 * Gets the scale of the entity.
                 * @returns The scale of the entity.
                 */
                get scale() {
                    return this._scale;
                }
                /**
                 * Sets the tags of the entity.
                 * @param value - The tags of the entity.
                 */
                set tags(value) {
                    this._tags = value;
                    if (this.entity) {
                        this.entity.tags.clear();
                        this.entity.tags.add(this._tags);
                    }
                }
                /**
                 * Gets the tags of the entity.
                 * @returns The tags of the entity.
                 */
                get tags() {
                    return this._tags;
                }
                static get observedAttributes() {
                    return [
                        'enabled',
                        'name',
                        'position',
                        'rotation',
                        'scale',
                        'tags',
                        'onpointerenter',
                        'onpointerleave',
                        'onpointerdown',
                        'onpointerup',
                        'onpointermove'
                    ];
                }
                attributeChangedCallback(name, _oldValue, newValue) {
                    switch (name) {
                        case 'enabled':
                            this.enabled = newValue !== 'false';
                            break;
                        case 'name':
                            this.name = newValue;
                            break;
                        case 'position':
                            this.position = parseVec3(newValue);
                            break;
                        case 'rotation':
                            this.rotation = parseVec3(newValue);
                            break;
                        case 'scale':
                            this.scale = parseVec3(newValue);
                            break;
                        case 'tags':
                            this.tags = newValue.split(',').map(tag => tag.trim());
                            break;
                        case 'onpointerenter':
                        case 'onpointerleave':
                        case 'onpointerdown':
                        case 'onpointerup':
                        case 'onpointermove':
                            if (newValue) {
                                const eventName = name.substring(2);
                                // Use Function.prototype.bind to avoid new Function
                                const handler = (event) => {
                                    try {
                                        const handlerStr = this.getAttribute(eventName) || '';
                                        /* eslint-disable-next-line no-new-func */
                                        new Function('event', handlerStr).call(this, event);
                                    }
                                    catch (e) {
                                        console.error('Error in event handler:', e);
                                    }
                                };
                                this.addEventListener(eventName, handler);
                            }
                            break;
                    }
                }
                addEventListener(type, listener, options) {
                    if (!this._listeners[type]) {
                        this._listeners[type] = [];
                    }
                    this._listeners[type].push(listener);
                    super.addEventListener(type, listener, options);
                    if (type.startsWith('pointer')) {
                        this.dispatchEvent(new CustomEvent(`${type}:connect`, { bubbles: true }));
                    }
                }
                removeEventListener(type, listener, options) {
                    if (this._listeners[type]) {
                        this._listeners[type] = this._listeners[type].filter(l => l !== listener);
                    }
                    super.removeEventListener(type, listener, options);
                    if (type.startsWith('pointer')) {
                        this.dispatchEvent(new CustomEvent(`${type}:disconnect`, { bubbles: true }));
                    }
                }
                hasListeners(type) {
                    var _a;
                    return Boolean((_a = this._listeners[type]) === null || _a === void 0 ? void 0 : _a.length);
                }
            }
            customElements.define('pc-entity', EntityElement);
            
            // This file is part of meshoptimizer library and is distributed under the terms of MIT License.
            // Copyright (C) 2016-2022, by Arseny Kapoulkine (arseny.kapoulkine@gmail.com)
            var MeshoptDecoder = (function() {
            
            	// Built with clang version 14.0.4
            	// Built from meshoptimizer 0.18
            	var wasm_base = "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb";
            	var wasm_simd = "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb";
            
            	var detector = new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,3,2,0,0,5,3,1,0,1,12,1,0,10,22,2,12,0,65,0,65,0,65,0,252,10,0,0,11,7,0,65,0,253,15,26,11]);
            	var wasmpack = new Uint8Array([32,0,65,2,1,106,34,33,3,128,11,4,13,64,6,253,10,7,15,116,127,5,8,12,40,16,19,54,20,9,27,255,113,17,42,67,24,23,146,148,18,14,22,45,70,69,56,114,101,21,25,63,75,136,108,28,118,29,73,115]);
            
            	if (typeof WebAssembly !== 'object') {
            		return {
            			supported: false,
            		};
            	}
            
            	var wasm = WebAssembly.validate(detector) ? wasm_simd : wasm_base;
            
            	var instance;
            
            	var ready =
            		WebAssembly.instantiate(unpack(wasm), {})
            		.then(function(result) {
            			instance = result.instance;
            			instance.exports.__wasm_call_ctors();
            		});
            
            	function unpack(data) {
            		var result = new Uint8Array(data.length);
            		for (var i = 0; i < data.length; ++i) {
            			var ch = data.charCodeAt(i);
            			result[i] = ch > 96 ? ch - 97 : ch > 64 ? ch - 39 : ch + 4;
            		}
            		var write = 0;
            		for (var i = 0; i < data.length; ++i) {
            			result[write++] = (result[i] < 60) ? wasmpack[result[i]] : (result[i] - 60) * 64 + result[++i];
            		}
            		return result.buffer.slice(0, write);
            	}
            
            	function decode(fun, target, count, size, source, filter) {
            		var sbrk = instance.exports.sbrk;
            		var count4 = (count + 3) & -4;
            		var tp = sbrk(count4 * size);
            		var sp = sbrk(source.length);
            		var heap = new Uint8Array(instance.exports.memory.buffer);
            		heap.set(source, sp);
            		var res = fun(tp, count, size, sp, source.length);
            		if (res == 0 && filter) {
            			filter(tp, count4, size);
            		}
            		target.set(heap.subarray(tp, tp + count * size));
            		sbrk(tp - sbrk(0));
            		if (res != 0) {
            			throw new Error("Malformed buffer data: " + res);
            		}
            	}
            
            	var filters = {
            		NONE: "",
            		OCTAHEDRAL: "meshopt_decodeFilterOct",
            		QUATERNION: "meshopt_decodeFilterQuat",
            		EXPONENTIAL: "meshopt_decodeFilterExp",
            	};
            
            	var decoders = {
            		ATTRIBUTES: "meshopt_decodeVertexBuffer",
            		TRIANGLES: "meshopt_decodeIndexBuffer",
            		INDICES: "meshopt_decodeIndexSequence",
            	};
            
            	var workers = [];
            	var requestId = 0;
            
            	function createWorker(url) {
            		var worker = {
            			object: new Worker(url),
            			pending: 0,
            			requests: {}
            		};
            
            		worker.object.onmessage = function(event) {
            			var data = event.data;
            
            			worker.pending -= data.count;
            			worker.requests[data.id][data.action](data.value);
            
            			delete worker.requests[data.id];
            		};
            
            		return worker;
            	}
            
            	function initWorkers(count) {
            		var source =
            			"var instance; var ready = WebAssembly.instantiate(new Uint8Array([" + new Uint8Array(unpack(wasm)) + "]), {})" +
            			".then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });" +
            			"self.onmessage = workerProcess;" +
            			decode.toString() + workerProcess.toString();
            
            		var blob = new Blob([source], {type: 'text/javascript'});
            		var url = URL.createObjectURL(blob);
            
            		for (var i = 0; i < count; ++i) {
            			workers[i] = createWorker(url);
            		}
            
            		URL.revokeObjectURL(url);
            	}
            
            	function decodeWorker(count, size, source, mode, filter) {
            		var worker = workers[0];
            
            		for (var i = 1; i < workers.length; ++i) {
            			if (workers[i].pending < worker.pending) {
            				worker = workers[i];
            			}
            		}
            
            		return new Promise(function (resolve, reject) {
            			var data = new Uint8Array(source);
            			var id = requestId++;
            
            			worker.pending += count;
            			worker.requests[id] = { resolve: resolve, reject: reject };
            			worker.object.postMessage({ id: id, count: count, size: size, source: data, mode: mode, filter: filter }, [ data.buffer ]);
            		});
            	}
            
            	function workerProcess(event) {
            		ready.then(function() {
            			var data = event.data;
            			try {
            				var target = new Uint8Array(data.count * data.size);
            				decode(instance.exports[data.mode], target, data.count, data.size, data.source, instance.exports[data.filter]);
            				self.postMessage({ id: data.id, count: data.count, action: "resolve", value: target }, [ target.buffer ]);
            			} catch (error) {
            				self.postMessage({ id: data.id, count: data.count, action: "reject", value: error });
            			}
            		});
            	}
            
            	return {
            		ready: ready,
            		supported: true,
            		useWorkers: function(count) {
            			initWorkers(count);
            		},
            		decodeVertexBuffer: function(target, count, size, source, filter) {
            			decode(instance.exports.meshopt_decodeVertexBuffer, target, count, size, source, instance.exports[filters[filter]]);
            		},
            		decodeIndexBuffer: function(target, count, size, source) {
            			decode(instance.exports.meshopt_decodeIndexBuffer, target, count, size, source);
            		},
            		decodeIndexSequence: function(target, count, size, source) {
            			decode(instance.exports.meshopt_decodeIndexSequence, target, count, size, source);
            		},
            		decodeGltfBuffer: function(target, count, size, source, mode, filter) {
            			decode(instance.exports[decoders[mode]], target, count, size, source, instance.exports[filters[filter]]);
            		},
            		decodeGltfBufferAsync: function(count, size, source, mode, filter) {
            			if (workers.length > 0) {
            				return decodeWorker(count, size, source, decoders[mode], filters[filter]);
            			}
            
            			return ready.then(function() {
            				var target = new Uint8Array(count * size);
            				decode(instance.exports[decoders[mode]], target, count, size, source, instance.exports[filters[filter]]);
            				return target;
            			});
            		}
            	};
            })();
            
            const extToType = new Map([
                ['bin', 'binary'],
                ['css', 'css'],
                ['frag', 'shader'],
                ['glb', 'container'],
                ['glsl', 'shader'],
                ['hdr', 'texture'],
                ['html', 'html'],
                ['jpg', 'texture'],
                ['js', 'script'],
                ['json', 'json'],
                ['mp3', 'audio'],
                ['mjs', 'script'],
                ['ply', 'gsplat'],
                ['png', 'texture'],
                ['txt', 'text'],
                ['vert', 'shader'],
                ['webp', 'texture']
            ]);
            // provide buffer view callback so we can handle models compressed with MeshOptimizer
            // https://github.com/zeux/meshoptimizer
            const processBufferView = (gltfBuffer, buffers, continuation) => {
                if (gltfBuffer.extensions && gltfBuffer.extensions.EXT_meshopt_compression) {
                    const extensionDef = gltfBuffer.extensions.EXT_meshopt_compression;
                    Promise.all([MeshoptDecoder.ready, buffers[extensionDef.buffer]]).then((promiseResult) => {
                        const buffer = promiseResult[1];
                        const byteOffset = extensionDef.byteOffset || 0;
                        const byteLength = extensionDef.byteLength || 0;
                        const count = extensionDef.count;
                        const stride = extensionDef.byteStride;
                        const result = new Uint8Array(count * stride);
                        const source = new Uint8Array(buffer.buffer, buffer.byteOffset + byteOffset, byteLength);
                        MeshoptDecoder.decodeGltfBuffer(result, count, stride, source, extensionDef.mode, extensionDef.filter);
                        continuation(null, result);
                    });
                }
                else {
                    continuation(null, null);
                }
            };
            /**
             * The AssetElement interface provides properties and methods for manipulating
             * {@link https://developer.playcanvas.com/user-manual/engine/web-components/tags/pc-asset/ | `<pc-asset>`} elements.
             * The AssetElement interface also inherits the properties and methods of the
             * {@link HTMLElement} interface.
             */
            class AssetElement extends HTMLElement {
                constructor() {
                    super(...arguments);
                    this._lazy = false;
                    /**
                     * The asset that is loaded.
                     */
                    this.asset = null;
                }
                disconnectedCallback() {
                    this.destroyAsset();
                }
                createAsset() {
                    var _a;
                    const id = this.getAttribute('id') || '';
                    const src = this.getAttribute('src') || '';
                    let type = this.getAttribute('type');
                    // If no type is specified, try to infer it from the file extension.
                    if (!type) {
                        const ext = src.split('.').pop();
                        type = (_a = extToType.get(ext || '')) !== null && _a !== void 0 ? _a : null;
                    }
                    if (!type) {
                        console.warn(`Unsupported asset type: ${src}`);
                        return;
                    }
                    if (type === 'container') {
                        this.asset = new Asset(id, type, { url: src }, undefined, {
                            // @ts-ignore TODO no definition in pc
                            bufferView: {
                                processAsync: processBufferView.bind(this)
                            }
                        });
                    }
                    else {
                        // @ts-ignore
                        this.asset = new Asset(id, type, { url: src });
                    }
                    this.asset.preload = !this._lazy;
                }
                destroyAsset() {
                    if (this.asset) {
                        this.asset.unload();
                        this.asset = null;
                    }
                }
                /**
                 * Sets whether the asset should be loaded lazily.
                 * @param value - The lazy loading flag.
                 */
                set lazy(value) {
                    this._lazy = value;
                    if (this.asset) {
                        this.asset.preload = !value;
                    }
                }
                /**
                 * Gets whether the asset should be loaded lazily.
                 * @returns The lazy loading flag.
                 */
                get lazy() {
                    return this._lazy;
                }
                static get(id) {
                    const assetElement = document.querySelector(`pc-asset[id="${id}"]`);
                    return assetElement === null || assetElement === void 0 ? void 0 : assetElement.asset;
                }
                static get observedAttributes() {
                    return ['lazy'];
                }
                attributeChangedCallback(name, _oldValue, _newValue) {
                    if (name === 'lazy') {
                        this.lazy = this.hasAttribute('lazy');
                    }
                }
            }
            customElements.define('pc-asset', AssetElement);
            
            /**
             * Represents a component in the PlayCanvas engine.
             *
             * @category Components
             */
            class ComponentElement extends AsyncElement {
                /**
                 * Creates a new ComponentElement instance.
                 *
                 * @param componentName - The name of the component.
                 * @ignore
                 */
                constructor(componentName) {
                    super();
                    this._enabled = true;
                    this._component = null;
                    this._componentName = componentName;
                }
                // Method to be overridden by subclasses to provide initial component data
                getInitialComponentData() {
                    return {};
                }
                async addComponent() {
                    const entityElement = this.closestEntity;
                    if (entityElement) {
                        await entityElement.ready();
                        // Add the component to the entity
                        const data = this.getInitialComponentData();
                        this._component = entityElement.entity.addComponent(this._componentName, data);
                    }
                }
                initComponent() { }
                async connectedCallback() {
                    var _a;
                    await ((_a = this.closestApp) === null || _a === void 0 ? void 0 : _a.ready());
                    await this.addComponent();
                    this.initComponent();
                    this._onReady();
                }
                disconnectedCallback() {
                    // Remove the component when the element is disconnected
                    if (this.component && this.component.entity) {
                        this._component.entity.removeComponent(this._componentName);
                        this._component = null;
                    }
                }
                get component() {
                    return this._component;
                }
                /**
                 * Sets the enabled state of the component.
                 * @param value - The enabled state of the component.
                 */
                set enabled(value) {
                    this._enabled = value;
                    if (this.component) {
                        this.component.enabled = value;
                    }
                }
                /**
                 * Gets the enabled state of the component.
                 * @returns The enabled state of the component.
                 */
                get enabled() {
                    return this._enabled;
                }
                static get observedAttributes() {
                    return ['enabled'];
                }
                attributeChangedCallback(name, _oldValue, newValue) {
                    switch (name) {
                        case 'enabled':
                            this.enabled = newValue !== 'false';
                            break;
                    }
                }
            }
            
            /**
             * The ListenerComponentElement interface provides properties and methods for manipulating
             * {@link https://developer.playcanvas.com/user-manual/engine/web-components/tags/pc-listener/ | `<pc-listener>`} elements.
             * The ListenerComponentElement interface also inherits the properties and methods of the
             * {@link HTMLElement} interface.
             *
             * @category Components
             */
            class ListenerComponentElement extends ComponentElement {
                /** @ignore */
                constructor() {
                    super('audiolistener');
                }
                /**
                 * Gets the underlying PlayCanvas audio listener component.
                 * @returns The audio listener component.
                 */
                get component() {
                    return super.component;
                }
            }
            customElements.define('pc-listener', ListenerComponentElement);
            
            const tonemaps = new Map([
                ['none', TONEMAP_NONE],
                ['linear', TONEMAP_LINEAR],
                ['filmic', TONEMAP_FILMIC],
                ['hejl', TONEMAP_HEJL],
                ['aces', TONEMAP_ACES],
                ['aces2', TONEMAP_ACES2],
                ['neutral', TONEMAP_NEUTRAL]
            ]);
            /**
             * The CameraComponentElement interface provides properties and methods for manipulating
             * {@link https://developer.playcanvas.com/user-manual/engine/web-components/tags/pc-camera/ | `<pc-camera>`} elements.
             * The CameraComponentElement interface also inherits the properties and methods of the
             * {@link HTMLElement} interface.
             *
             * @category Components
             */
            class CameraComponentElement extends ComponentElement {
                /** @ignore */
                constructor() {
                    super('camera');
                    this._clearColor = new Color(0.75, 0.75, 0.75, 1);
                    this._clearColorBuffer = true;
                    this._clearDepthBuffer = true;
                    this._clearStencilBuffer = false;
                    this._cullFaces = true;
                    this._farClip = 1000;
                    this._flipFaces = false;
                    this._fov = 45;
                    this._frustumCulling = true;
                    this._gamma = 'srgb';
                    this._horizontalFov = false;
                    this._nearClip = 0.1;
                    this._orthographic = false;
                    this._orthoHeight = 10;
                    this._priority = 0;
                    this._rect = new Vec4(0, 0, 1, 1);
                    this._scissorRect = new Vec4(0, 0, 1, 1);
                    this._tonemap = 'none';
                }
                getInitialComponentData() {
                    return {
                        clearColor: this._clearColor,
                        clearColorBuffer: this._clearColorBuffer,
                        clearDepthBuffer: this._clearDepthBuffer,
                        clearStencilBuffer: this._clearStencilBuffer,
                        cullFaces: this._cullFaces,
                        farClip: this._farClip,
                        flipFaces: this._flipFaces,
                        fov: this._fov,
                        frustumCulling: this._frustumCulling,
                        gammaCorrection: this._gamma === 'srgb' ? GAMMA_SRGB : GAMMA_NONE,
                        horizontalFov: this._horizontalFov,
                        nearClip: this._nearClip,
                        orthographic: this._orthographic,
                        orthoHeight: this._orthoHeight,
                        priority: this._priority,
                        rect: this._rect,
                        scissorRect: this._scissorRect,
                        toneMapping: tonemaps.get(this._tonemap)
                    };
                }
                get xrAvailable() {
                    var _a;
                    const xrManager = (_a = this.component) === null || _a === void 0 ? void 0 : _a.system.app.xr;
                    return xrManager && xrManager.supported && xrManager.isAvailable(XRTYPE_VR);
                }
                /**
                 * Starts the camera in XR mode.
                 * @param type - The type of XR mode to start.
                 * @param space - The space to start the camera in.
                 */
                startXr(type, space) {
                    if (this.component && this.xrAvailable) {
                        this.component.startXr(type, space, {
                            callback: (err) => {
                                if (err)
                                    console.error(`WebXR Immersive VR failed to start: ${err.message}`);
                            }
                        });
                    }
                }
                /**
                 * Ends the camera's XR mode.
                 */
                endXr() {
                    if (this.component) {
                        this.component.endXr();
                    }
                }
                /**
                 * Gets the underlying PlayCanvas camera component.
                 * @returns The camera component.
                 */
                get component() {
                    return super.component;
                }
                /**
                 * Sets the clear color of the camera.
                 * @param value - The clear color.
                 */
                set clearColor(value) {
                    this._clearColor = value;
                    if (this.component) {
                        this.component.clearColor = value;
                    }
                }
                /**
                 * Gets the clear color of the camera.
                 * @returns The clear color.
                 */
                get clearColor() {
                    return this._clearColor;
                }
                /**
                 * Sets the clear color buffer of the camera.
                 * @param value - The clear color buffer.
                 */
                set clearColorBuffer(value) {
                    this._clearColorBuffer = value;
                    if (this.component) {
                        this.component.clearColorBuffer = value;
                    }
                }
                /**
                 * Gets the clear color buffer of the camera.
                 * @returns The clear color buffer.
                 */
                get clearColorBuffer() {
                    return this._clearColorBuffer;
                }
                /**
                 * Sets the clear depth buffer of the camera.
                 * @param value - The clear depth buffer.
                 */
                set clearDepthBuffer(value) {
                    this._clearDepthBuffer = value;
                    if (this.component) {
                        this.component.clearDepthBuffer = value;
                    }
                }
                /**
                 * Gets the clear depth buffer of the camera.
                 * @returns The clear depth buffer.
                 */
                get clearDepthBuffer() {
                    return this._clearDepthBuffer;
                }
                /**
                 * Sets the clear stencil buffer of the camera.
                 * @param value - The clear stencil buffer.
                 */
                set clearStencilBuffer(value) {
                    this._clearStencilBuffer = value;
                    if (this.component) {
                        this.component.clearStencilBuffer = value;
                    }
                }
                /**
                 * Gets the clear stencil buffer of the camera.
                 * @returns The clear stencil buffer.
                 */
                get clearStencilBuffer() {
                    return this._clearStencilBuffer;
                }
                /**
                 * Sets the cull faces of the camera.
                 * @param value - The cull faces.
                 */
                set cullFaces(value) {
                    this._cullFaces = value;
                    if (this.component) {
                        this.component.cullFaces = value;
                    }
                }
                /**
                 * Gets the cull faces of the camera.
                 * @returns The cull faces.
                 */
                get cullFaces() {
                    return this._cullFaces;
                }
                /**
                 * Sets the far clip distance of the camera.
                 * @param value - The far clip distance.
                 */
                set farClip(value) {
                    this._farClip = value;
                    if (this.component) {
                        this.component.farClip = value;
                    }
                }
                /**
                 * Gets the far clip distance of the camera.
                 * @returns The far clip distance.
                 */
                get farClip() {
                    return this._farClip;
                }
                /**
                 * Sets the flip faces of the camera.
                 * @param value - The flip faces.
                 */
                set flipFaces(value) {
                    this._flipFaces = value;
                    if (this.component) {
                        this.component.flipFaces = value;
                    }
                }
                /**
                 * Gets the flip faces of the camera.
                 * @returns The flip faces.
                 */
                get flipFaces() {
                    return this._flipFaces;
                }
                /**
                 * Sets the field of view of the camera.
                 * @param value - The field of view.
                 */
                set fov(value) {
                    this._fov = value;
                    if (this.component) {
                        this.component.fov = value;
                    }
                }
                /**
                 * Gets the field of view of the camera.
                 * @returns The field of view.
                 */
                get fov() {
                    return this._fov;
                }
                /**
                 * Sets the frustum culling of the camera.
                 * @param value - The frustum culling.
                 */
                set frustumCulling(value) {
                    this._frustumCulling = value;
                    if (this.component) {
                        this.component.frustumCulling = value;
                    }
                }
                /**
                 * Gets the frustum culling of the camera.
                 * @returns The frustum culling.
                 */
                get frustumCulling() {
                    return this._frustumCulling;
                }
                /**
                 * Sets the gamma correction of the camera.
                 * @param value - The gamma correction.
                 */
                set gamma(value) {
                    this._gamma = value;
                    if (this.component) {
                        this.component.gammaCorrection = value === 'srgb' ? GAMMA_SRGB : GAMMA_NONE;
                    }
                }
                /**
                 * Gets the gamma correction of the camera.
                 * @returns The gamma correction.
                 */
                get gamma() {
                    return this._gamma;
                }
                /**
                 * Sets whether the camera's field of view (fov) is horizontal or vertical. Defaults to false
                 * (meaning it is vertical be default).
                 * @param value - Whether the camera's field of view is horizontal.
                 */
                set horizontalFov(value) {
                    this._horizontalFov = value;
                    if (this.component) {
                        this.component.horizontalFov = value;
                    }
                }
                /**
                 * Gets whether the camera's field of view (fov) is horizontal or vertical.
                 * @returns Whether the camera's field of view is horizontal.
                 */
                get horizontalFov() {
                    return this._horizontalFov;
                }
                /**
                 * Sets the near clip distance of the camera.
                 * @param value - The near clip distance.
                 */
                set nearClip(value) {
                    this._nearClip = value;
                    if (this.component) {
                        this.component.nearClip = value;
                    }
                }
                /**
                 * Gets the near clip distance of the camera.
                 * @returns The near clip distance.
                 */
                get nearClip() {
                    return this._nearClip;
                }
                /**
                 * Sets the orthographic projection of the camera.
                 * @param value - The orthographic projection.
                 */
                set orthographic(value) {
                    this._orthographic = value;
                    if (this.component) {
                        this.component.projection = value ? PROJECTION_ORTHOGRAPHIC : PROJECTION_PERSPECTIVE;
                    }
                }
                /**
                 * Gets the orthographic projection of the camera.
                 * @returns The orthographic projection.
                 */
                get orthographic() {
                    return this._orthographic;
                }
                /**
                 * Sets the orthographic height of the camera.
                 * @param value - The orthographic height.
                 */
                set orthoHeight(value) {
                    this._orthoHeight = value;
                    if (this.component) {
                        this.component.orthoHeight = value;
                    }
                }
                /**
                 * Gets the orthographic height of the camera.
                 * @returns The orthographic height.
                 */
                get orthoHeight() {
                    return this._orthoHeight;
                }
                /**
                 * Sets the priority of the camera.
                 * @param value - The priority.
                 */
                set priority(value) {
                    this._priority = value;
                    if (this.component) {
                        this.component.priority = value;
                    }
                }
                /**
                 * Gets the priority of the camera.
                 * @returns The priority.
                 */
                get priority() {
                    return this._priority;
                }
                /**
                 * Sets the rect of the camera.
                 * @param value - The rect.
                 */
                set rect(value) {
                    this._rect = value;
                    if (this.component) {
                        this.component.rect = value;
                    }
                }
                /**
                 * Gets the rect of the camera.
                 * @returns The rect.
                 */
                get rect() {
                    return this._rect;
                }
                /**
                 * Sets the scissor rect of the camera.
                 * @param value - The scissor rect.
                 */
                set scissorRect(value) {
                    this._scissorRect = value;
                    if (this.component) {
                        this.component.scissorRect = value;
                    }
                }
                /**
                 * Gets the scissor rect of the camera.
                 * @returns The scissor rect.
                 */
                get scissorRect() {
                    return this._scissorRect;
                }
                /**
                 * Sets the tone mapping of the camera.
                 * @param value - The tone mapping.
                 */
                set tonemap(value) {
                    var _a;
                    this._tonemap = value;
                    if (this.component) {
                        this.component.toneMapping = (_a = tonemaps.get(value)) !== null && _a !== void 0 ? _a : TONEMAP_NONE;
                    }
                }
                /**
                 * Gets the tone mapping of the camera.
                 * @returns The tone mapping.
                 */
                get tonemap() {
                    return this._tonemap;
                }
                static get observedAttributes() {
                    return [
                        ...super.observedAttributes,
                        'clear-color',
                        'clear-color-buffer',
                        'clear-depth-buffer',
                        'clear-stencil-buffer',
                        'cull-faces',
                        'far-clip',
                        'flip-faces',
                        'fov',
                        'frustum-culling',
                        'gamma',
                        'horizontal-fov',
                        'near-clip',
                        'orthographic',
                        'ortho-height',
                        'priority',
                        'rect',
                        'scissor-rect',
                        'tonemap'
                    ];
                }
                attributeChangedCallback(name, _oldValue, newValue) {
                    super.attributeChangedCallback(name, _oldValue, newValue);
                    switch (name) {
                        case 'clear-color':
                            this.clearColor = parseColor(newValue);
                            break;
                        case 'clear-color-buffer':
                            this.clearColorBuffer = newValue !== 'false';
                            break;
                        case 'clear-depth-buffer':
                            this.clearDepthBuffer = newValue !== 'false';
                            break;
                        case 'clear-stencil-buffer':
                            this.clearStencilBuffer = newValue !== 'false';
                            break;
                        case 'cull-faces':
                            this.cullFaces = newValue !== 'false';
                            break;
                        case 'far-clip':
                            this.farClip = parseFloat(newValue);
                            break;
                        case 'flip-faces':
                            this.flipFaces = newValue !== 'true';
                            break;
                        case 'fov':
                            this.fov = parseFloat(newValue);
                            break;
                        case 'frustum-culling':
                            this.frustumCulling = newValue !== 'false';
                            break;
                        case 'gamma':
                            this.gamma = newValue;
                            break;
                        case 'horizontal-fov':
                            this.horizontalFov = this.hasAttribute('horizontal-fov');
                            break;
                        case 'near-clip':
                            this.nearClip = parseFloat(newValue);
                            break;
                        case 'orthographic':
                            this.orthographic = this.hasAttribute('orthographic');
                            break;
                        case 'ortho-height':
                            this.orthoHeight = parseFloat(newValue);
                            break;
                        case 'priority':
                            this.priority = parseFloat(newValue);
                            break;
                        case 'rect':
                            this.rect = parseVec4(newValue);
                            break;
                        case 'scissor-rect':
                            this.scissorRect = parseVec4(newValue);
                            break;
                        case 'tonemap':
                            this.tonemap = newValue;
                            break;
                    }
                }
            }
            customElements.define('pc-camera', CameraComponentElement);
            
            /**
             * The CollisionComponentElement interface provides properties and methods for manipulating
             * {@link https://developer.playcanvas.com/user-manual/engine/web-components/tags/pc-collision/ | `<pc-collision>`} elements.
             * The CollisionComponentElement interface also inherits the properties and methods of the
             * {@link HTMLElement} interface.
             *
             * @category Components
             */
            class CollisionComponentElement extends ComponentElement {
                /** @ignore */
                constructor() {
                    super('collision');
                    this._angularOffset = new Quat();
                    this._axis = 1;
                    this._convexHull = false;
                    this._halfExtents = new Vec3(0.5, 0.5, 0.5);
                    this._height = 2;
                    this._linearOffset = new Vec3();
                    this._radius = 0.5;
                    this._type = 'box';
                }
                getInitialComponentData() {
                    return {
                        axis: this._axis,
                        angularOffset: this._angularOffset,
                        convexHull: this._convexHull,
                        halfExtents: this._halfExtents,
                        height: this._height,
                        linearOffset: this._linearOffset,
                        radius: this._radius,
                        type: this._type
                    };
                }
                /**
                 * Gets the underlying PlayCanvas collision component.
                 * @returns The collision component.
                 */
                get component() {
                    return super.component;
                }
                set angularOffset(value) {
                    this._angularOffset = value;
                    if (this.component) {
                        this.component.angularOffset = value;
                    }
                }
                get angularOffset() {
                    return this._angularOffset;
                }
                set axis(value) {
                    this._axis = value;
                    if (this.component) {
                        this.component.axis = value;
                    }
                }
                get axis() {
                    return this._axis;
                }
                set convexHull(value) {
                    this._convexHull = value;
                    if (this.component) {
                        this.component.convexHull = value;
                    }
                }
                get convexHull() {
                    return this._convexHull;
                }
                set halfExtents(value) {
                    this._halfExtents = value;
                    if (this.component) {
                        this.component.halfExtents = value;
                    }
                }
                get halfExtents() {
                    return this._halfExtents;
                }
                set height(value) {
                    this._height = value;
                    if (this.component) {
                        this.component.height = value;
                    }
                }
                get height() {
                    return this._height;
                }
                set linearOffset(value) {
                    this._linearOffset = value;
                    if (this.component) {
                        this.component.linearOffset = value;
                    }
                }
                get linearOffset() {
                    return this._linearOffset;
                }
                set radius(value) {
                    this._radius = value;
                    if (this.component) {
                        this.component.radius = value;
                    }
                }
                get radius() {
                    return this._radius;
                }
                set type(value) {
                    this._type = value;
                    if (this.component) {
                        this.component.type = value;
                    }
                }
                get type() {
                    return this._type;
                }
                static get observedAttributes() {
                    return [...super.observedAttributes, 'angular-offset', 'axis', 'convex-hull', 'half-extents', 'height', 'linear-offset', 'radius', 'type'];
                }
                attributeChangedCallback(name, _oldValue, newValue) {
                    super.attributeChangedCallback(name, _oldValue, newValue);
                    switch (name) {
                        case 'angular-offset':
                            this.angularOffset = parseQuat(newValue);
                            break;
                        case 'axis':
                            this.axis = parseInt(newValue, 10);
                            break;
                        case 'convex-hull':
                            this.convexHull = this.hasAttribute('convex-hull');
                            break;
                        case 'half-extents':
                            this.halfExtents = parseVec3(newValue);
                            break;
                        case 'height':
                            this.height = parseFloat(newValue);
                            break;
                        case 'linear-offset':
                            this.linearOffset = parseVec3(newValue);
                            break;
                        case 'radius':
                            this.radius = parseFloat(newValue);
                            break;
                        case 'type':
                            this.type = newValue;
                            break;
                    }
                }
            }
            customElements.define('pc-collision', CollisionComponentElement);
            
            /**
             * The ElementComponentElement interface provides properties and methods for manipulating
             * {@link https://developer.playcanvas.com/user-manual/engine/web-components/tags/pc-element/ | `<pc-element>`} elements.
             * The ElementComponentElement interface also inherits the properties and methods of the
             * {@link HTMLElement} interface.
             *
             * @category Components
             */
            class ElementComponentElement extends ComponentElement {
                /** @ignore */
                constructor() {
                    super('element');
                    this._anchor = new Vec4(0.5, 0.5, 0.5, 0.5);
                    this._asset = '';
                    this._autoWidth = true;
                    this._color = new Color(1, 1, 1, 1);
                    this._fontSize = 32;
                    this._lineHeight = 32;
                    this._pivot = new Vec2(0.5, 0.5);
                    this._text = '';
                    this._type = 'group';
                    this._width = 0;
                    this._wrapLines = false;
                }
                initComponent() {
                    this.component._text._material.useFog = true;
                }
                getInitialComponentData() {
                    return {
                        anchor: this._anchor,
                        autoWidth: this._autoWidth,
                        color: this._color,
                        fontAsset: AssetElement.get(this._asset).id,
                        fontSize: this._fontSize,
                        lineHeight: this._lineHeight,
                        pivot: this._pivot,
                        type: this._type,
                        text: this._text,
                        width: this._width,
                        wrapLines: this._wrapLines
                    };
                }
                /**
                 * Gets the underlying PlayCanvas element component.
                 * @returns The element component.
                 */
                get component() {
                    return super.component;
                }
                /**
                 * Sets the anchor of the element component.
                 * @param value - The anchor.
                 */
                set anchor(value) {
                    this._anchor = value;
                    if (this.component) {
                        this.component.anchor = value;
                    }
                }
                /**
                 * Gets the anchor of the element component.
                 * @returns The anchor.
                 */
                get anchor() {
                    return this._anchor;
                }
                /**
                 * Sets the id of the `pc-asset` to use for the font.
                 * @param value - The asset ID.
                 */
                set asset(value) {
                    this._asset = value;
                    const asset = AssetElement.get(value);
                    if (this.component && asset) {
                        this.component.fontAsset = asset.id;
                    }
                }
                /**
                 * Gets the id of the `pc-asset` to use for the font.
                 * @returns The asset ID.
                 */
                get asset() {
                    return this._asset;
                }
                /**
                 * Sets whether the element component should automatically adjust its width.
                 * @param value - Whether to automatically adjust the width.
                 */
                set autoWidth(value) {
                    this._autoWidth = value;
                    if (this.component) {
                        this.component.autoWidth = value;
                    }
                }
                /**
                 * Gets whether the element component should automatically adjust its width.
                 * @returns Whether to automatically adjust the width.
                 */
                get autoWidth() {
                    return this._autoWidth;
                }
                /**
                 * Sets the color of the element component.
                 * @param value - The color.
                 */
                set color(value) {
                    this._color = value;
                    if (this.component) {
                        this.component.color = value;
                    }
                }
                /**
                 * Gets the color of the element component.
                 * @returns The color.
                 */
                get color() {
                    return this._color;
                }
                /**
                 * Sets the font size of the element component.
                 * @param value - The font size.
                 */
                set fontSize(value) {
                    this._fontSize = value;
                    if (this.component) {
                        this.component.fontSize = value;
                    }
                }
                /**
                 * Gets the font size of the element component.
                 * @returns The font size.
                 */
                get fontSize() {
                    return this._fontSize;
                }
                /**
                 * Sets the line height of the element component.
                 * @param value - The line height.
                 */
                set lineHeight(value) {
                    this._lineHeight = value;
                    if (this.component) {
                        this.component.lineHeight = value;
                    }
                }
                /**
                 * Gets the line height of the element component.
                 * @returns The line height.
                 */
                get lineHeight() {
                    return this._lineHeight;
                }
                /**
                 * Sets the pivot of the element component.
                 * @param value - The pivot.
                 */
                set pivot(value) {
                    this._pivot = value;
                    if (this.component) {
                        this.component.pivot = value;
                    }
                }
                /**
                 * Gets the pivot of the element component.
                 * @returns The pivot.
                 */
                get pivot() {
                    return this._pivot;
                }
                /**
                 * Sets the text of the element component.
                 * @param value - The text.
                 */
                set text(value) {
                    this._text = value;
                    if (this.component) {
                        this.component.text = value;
                    }
                }
                /**
                 * Gets the text of the element component.
                 * @returns The text.
                 */
                get text() {
                    return this._text;
                }
                /**
                 * Sets the type of the element component.
                 * @param value - The type.
                 */
                set type(value) {
                    this._type = value;
                    if (this.component) {
                        this.component.type = value;
                    }
                }
                /**
                 * Gets the type of the element component.
                 * @returns The type.
                 */
                get type() {
                    return this._type;
                }
                /**
                 * Sets the width of the element component.
                 * @param value - The width.
                 */
                set width(value) {
                    this._width = value;
                    if (this.component) {
                        this.component.width = value;
                    }
                }
                /**
                 * Gets the width of the element component.
                 * @returns The width.
                 */
                get width() {
                    return this._width;
                }
                /**
                 * Sets whether the element component should wrap lines.
                 * @param value - Whether to wrap lines.
                 */
                set wrapLines(value) {
                    this._wrapLines = value;
                    if (this.component) {
                        this.component.wrapLines = value;
                    }
                }
                /**
                 * Gets whether the element component should wrap lines.
                 * @returns Whether to wrap lines.
                 */
                get wrapLines() {
                    return this._wrapLines;
                }
                static get observedAttributes() {
                    return [
                        ...super.observedAttributes,
                        'anchor',
                        'asset',
                        'auto-width',
                        'color',
                        'font-size',
                        'line-height',
                        'pivot',
                        'text',
                        'type',
                        'width',
                        'wrap-lines'
                    ];
                }
                attributeChangedCallback(name, _oldValue, newValue) {
                    super.attributeChangedCallback(name, _oldValue, newValue);
                    switch (name) {
                        case 'anchor':
                            this.anchor = parseVec4(newValue);
                            break;
                        case 'asset':
                            this.asset = newValue;
                            break;
                        case 'auto-width':
                            this.autoWidth = newValue !== 'false';
                            break;
                        case 'color':
                            this.color = parseColor(newValue);
                            break;
                        case 'font-size':
                            this.fontSize = Number(newValue);
                            break;
                        case 'line-height':
                            this.lineHeight = Number(newValue);
                            break;
                        case 'pivot':
                            this.pivot = parseVec2(newValue);
                            break;
                        case 'text':
                            this.text = newValue;
                            break;
                        case 'type':
                            this.type = newValue;
                            break;
                        case 'width':
                            this.width = Number(newValue);
                            break;
                        case 'wrap-lines':
                            this.wrapLines = this.hasAttribute(name);
                            break;
                    }
                }
            }
            customElements.define('pc-element', ElementComponentElement);
            
            const shadowTypes = new Map([
                ['pcf1-16f', SHADOW_PCF1_16F],
                ['pcf1-32f', SHADOW_PCF1_32F],
                ['pcf3-16f', SHADOW_PCF3_16F],
                ['pcf3-32f', SHADOW_PCF3_32F],
                ['pcf5-16f', SHADOW_PCF5_16F],
                ['pcf5-32f', SHADOW_PCF5_32F],
                ['vsm-16f', SHADOW_VSM_16F],
                ['vsm-32f', SHADOW_VSM_32F],
                ['pcss-32f', SHADOW_PCSS_32F]
            ]);
            /**
             * The LightComponentElement interface provides properties and methods for manipulating
             * {@link https://developer.playcanvas.com/user-manual/engine/web-components/tags/pc-light/ | `<pc-light>`} elements.
             * The LightComponentElement interface also inherits the properties and methods of the
             * {@link HTMLElement} interface.
             *
             * @category Components
             */
            class LightComponentElement extends ComponentElement {
                /** @ignore */
                constructor() {
                    super('light');
                    this._castShadows = false;
                    this._color = new Color(1, 1, 1);
                    this._innerConeAngle = 40;
                    this._intensity = 1;
                    this._normalOffsetBias = 0.05;
                    this._outerConeAngle = 45;
                    this._range = 10;
                    this._shadowBias = 0.2;
                    this._shadowDistance = 16;
                    this._shadowIntensity = 1;
                    this._shadowResolution = 1024;
                    this._shadowType = 'pcf3-32f';
                    this._type = 'directional';
                    this._vsmBias = 0.01;
                    this._vsmBlurSize = 11;
                }
                getInitialComponentData() {
                    return {
                        castShadows: this._castShadows,
                        color: this._color,
                        innerConeAngle: this._innerConeAngle,
                        intensity: this._intensity,
                        normalOffsetBias: this._normalOffsetBias,
                        outerConeAngle: this._outerConeAngle,
                        range: this._range,
                        shadowBias: this._shadowBias,
                        shadowDistance: this._shadowDistance,
                        shadowIntensity: this._shadowIntensity,
                        shadowResolution: this._shadowResolution,
                        shadowType: shadowTypes.get(this._shadowType),
                        type: this._type,
                        vsmBias: this._vsmBias,
                        vsmBlurSize: this._vsmBlurSize
                    };
                }
                /**
                 * Gets the underlying PlayCanvas light component.
                 * @returns The light component.
                 */
                get component() {
                    return super.component;
                }
                /**
                 * Sets the cast shadows flag of the light.
                 * @param value - The cast shadows flag.
                 */
                set castShadows(value) {
                    this._castShadows = value;
                    if (this.component) {
                        this.component.castShadows = value;
                    }
                }
                /**
                 * Gets the cast shadows flag of the light.
                 * @returns The cast shadows flag.
                 */
                get castShadows() {
                    return this._castShadows;
                }
                /**
                 * Sets the color of the light.
                 * @param value - The color.
                 */
                set color(value) {
                    this._color = value;
                    if (this.component) {
                        this.component.color = value;
                    }
                }
                /**
                 * Gets the color of the light.
                 * @returns The color.
                 */
                get color() {
                    return this._color;
                }
                /**
                 * Sets the inner cone angle of the light.
                 * @param value - The inner cone angle.
                 */
                set innerConeAngle(value) {
                    this._innerConeAngle = value;
                    if (this.component) {
                        this.component.innerConeAngle = value;
                    }
                }
                /**
                 * Gets the inner cone angle of the light.
                 * @returns The inner cone angle.
                 */
                get innerConeAngle() {
                    return this._innerConeAngle;
                }
                /**
                 * Sets the intensity of the light.
                 * @param value - The intensity.
                 */
                set intensity(value) {
                    this._intensity = value;
                    if (this.component) {
                        this.component.intensity = value;
                    }
                }
                /**
                 * Gets the intensity of the light.
                 * @returns The intensity.
                 */
                get intensity() {
                    return this._intensity;
                }
                /**
                 * Sets the normal offset bias of the light.
                 * @param value - The normal offset bias.
                 */
                set normalOffsetBias(value) {
                    this._normalOffsetBias = value;
                    if (this.component) {
                        this.component.normalOffsetBias = value;
                    }
                }
                /**
                 * Gets the normal offset bias of the light.
                 * @returns The normal offset bias.
                 */
                get normalOffsetBias() {
                    return this._normalOffsetBias;
                }
                /**
                 * Sets the outer cone angle of the light.
                 * @param value - The outer cone angle.
                 */
                set outerConeAngle(value) {
                    this._outerConeAngle = value;
                    if (this.component) {
                        this.component.outerConeAngle = value;
                    }
                }
                /**
                 * Gets the outer cone angle of the light.
                 * @returns The outer cone angle.
                 */
                get outerConeAngle() {
                    return this._outerConeAngle;
                }
                /**
                 * Sets the range of the light.
                 * @param value - The range.
                 */
                set range(value) {
                    this._range = value;
                    if (this.component) {
                        this.component.range = value;
                    }
                }
                /**
                 * Gets the range of the light.
                 * @returns The range.
                 */
                get range() {
                    return this._range;
                }
                /**
                 * Sets the shadow bias of the light.
                 * @param value - The shadow bias.
                 */
                set shadowBias(value) {
                    this._shadowBias = value;
                    if (this.component) {
                        this.component.shadowBias = value;
                    }
                }
                /**
                 * Gets the shadow bias of the light.
                 * @returns The shadow bias.
                 */
                get shadowBias() {
                    return this._shadowBias;
                }
                /**
                 * Sets the shadow distance of the light.
                 * @param value - The shadow distance.
                 */
                set shadowDistance(value) {
                    this._shadowDistance = value;
                    if (this.component) {
                        this.component.shadowDistance = value;
                    }
                }
                /**
                 * Gets the shadow distance of the light.
                 * @returns The shadow distance.
                 */
                get shadowDistance() {
                    return this._shadowDistance;
                }
                /**
                 * Sets the shadow intensity of the light.
                 * @param value - The shadow intensity.
                 */
                set shadowIntensity(value) {
                    this._shadowIntensity = value;
                    if (this.component) {
                        this.component.shadowIntensity = value;
                    }
                }
                /**
                 * Gets the shadow intensity of the light.
                 * @returns The shadow intensity.
                 */
                get shadowIntensity() {
                    return this._shadowIntensity;
                }
                /**
                 * Sets the shadow resolution of the light.
                 * @param value - The shadow resolution.
                 */
                set shadowResolution(value) {
                    this._shadowResolution = value;
                    if (this.component) {
                        this.component.shadowResolution = value;
                    }
                }
                /**
                 * Gets the shadow resolution of the light.
                 * @returns The shadow resolution.
                 */
                get shadowResolution() {
                    return this._shadowResolution;
                }
                /**
                 * Sets the shadow type of the light.
                 * @param value - The shadow type. Can be:
                 *
                 * - `pcf1-16f` - 1-tap percentage-closer filtered shadow map with 16-bit depth.
                 * - `pcf1-32f` - 1-tap percentage-closer filtered shadow map with 32-bit depth.
                 * - `pcf3-16f` - 3-tap percentage-closer filtered shadow map with 16-bit depth.
                 * - `pcf3-32f` - 3-tap percentage-closer filtered shadow map with 32-bit depth.
                 * - `pcf5-16f` - 5-tap percentage-closer filtered shadow map with 16-bit depth.
                 * - `pcf5-32f` - 5-tap percentage-closer filtered shadow map with 32-bit depth.
                 * - `vsm-16f` - Variance shadow map with 16-bit depth.
                 * - `vsm-32f` - Variance shadow map with 32-bit depth.
                 * - `pcss-32f` - Percentage-closer soft shadow with 32-bit depth.
                 */
                set shadowType(value) {
                    var _a;
                    this._shadowType = value;
                    if (this.component) {
                        this.component.shadowType = (_a = shadowTypes.get(value)) !== null && _a !== void 0 ? _a : SHADOW_PCF3_32F;
                    }
                }
                /**
                 * Gets the shadow type of the light.
                 * @returns The shadow type.
                 */
                get shadowType() {
                    return this._shadowType;
                }
                /**
                 * Sets the type of the light.
                 * @param value - The type.
                 */
                set type(value) {
                    if (!['directional', 'omni', 'spot'].includes(value)) {
                        console.warn(`Invalid light type '${value}', using default type '${this._type}'.`);
                        return;
                    }
                    this._type = value;
                    if (this.component) {
                        this.component.type = value;
                    }
                }
                /**
                 * Gets the type of the light.
                 * @returns The type.
                 */
                get type() {
                    return this._type;
                }
                /**
                 * Sets the VSM bias of the light.
                 * @param value - The VSM bias.
                 */
                set vsmBias(value) {
                    this._vsmBias = value;
                    if (this.component) {
                        this.component.vsmBias = value;
                    }
                }
                /**
                 * Gets the VSM bias of the light.
                 * @returns The VSM bias.
                 */
                get vsmBias() {
                    return this._vsmBias;
                }
                /**
                 * Sets the VSM blur size of the light. Minimum is 1, maximum is 25. Default is 11.
                 * @param value - The VSM blur size.
                 */
                set vsmBlurSize(value) {
                    this._vsmBlurSize = value;
                    if (this.component) {
                        this.component.vsmBlurSize = value;
                    }
                }
                /**
                 * Gets the VSM blur size of the light.
                 * @returns The VSM blur size.
                 */
                get vsmBlurSize() {
                    return this._vsmBlurSize;
                }
                static get observedAttributes() {
                    return [
                        ...super.observedAttributes,
                        'color',
                        'cast-shadows',
                        'intensity',
                        'inner-cone-angle',
                        'normal-offset-bias',
                        'outer-cone-angle',
                        'range',
                        'shadow-bias',
                        'shadow-distance',
                        'shadow-intensity',
                        'shadow-resolution',
                        'shadow-type',
                        'type',
                        'vsm-bias',
                        'vsm-blur-size'
                    ];
                }
                attributeChangedCallback(name, _oldValue, newValue) {
                    super.attributeChangedCallback(name, _oldValue, newValue);
                    switch (name) {
                        case 'color':
                            this.color = parseColor(newValue);
                            break;
                        case 'cast-shadows':
                            this.castShadows = this.hasAttribute('cast-shadows');
                            break;
                        case 'inner-cone-angle':
                            this.innerConeAngle = Number(newValue);
                            break;
                        case 'intensity':
                            this.intensity = Number(newValue);
                            break;
                        case 'normal-offset-bias':
                            this.normalOffsetBias = Number(newValue);
                            break;
                        case 'outer-cone-angle':
                            this.outerConeAngle = Number(newValue);
                            break;
                        case 'range':
                            this.range = Number(newValue);
                            break;
                        case 'shadow-bias':
                            this.shadowBias = Number(newValue);
                            break;
                        case 'shadow-distance':
                            this.shadowDistance = Number(newValue);
                            break;
                        case 'shadow-resolution':
                            this.shadowResolution = Number(newValue);
                            break;
                        case 'shadow-intensity':
                            this.shadowIntensity = Number(newValue);
                            break;
                        case 'shadow-type':
                            this.shadowType = newValue;
                            break;
                        case 'type':
                            this.type = newValue;
                            break;
                        case 'vsm-bias':
                            this.vsmBias = Number(newValue);
                            break;
                        case 'vsm-blur-size':
                            this.vsmBlurSize = Number(newValue);
                            break;
                    }
                }
            }
            customElements.define('pc-light', LightComponentElement);
            
            /**
             * The ParticleSystemComponentElement interface provides properties and methods for manipulating
             * {@link https://developer.playcanvas.com/user-manual/engine/web-components/tags/pc-particles/ | `<pc-particles>`} elements.
             * The ParticleSystemComponentElement interface also inherits the properties and methods of the
             * {@link HTMLElement} interface.
             *
             * @category Components
             */
            class ParticleSystemComponentElement extends ComponentElement {
                /** @ignore */
                constructor() {
                    super('particlesystem');
                    this._asset = '';
                }
                getInitialComponentData() {
                    var _a;
                    const asset = AssetElement.get(this._asset);
                    if (!asset) {
                        return {};
                    }
                    if (asset.resource.colorMapAsset) {
                        const id = asset.resource.colorMapAsset;
                        const colorMapAsset = (_a = AssetElement.get(id)) === null || _a === void 0 ? void 0 : _a.id;
                        if (colorMapAsset) {
                            asset.resource.colorMapAsset = colorMapAsset;
                        }
                    }
                    return asset.resource;
                }
                /**
                 * Gets the underlying PlayCanvas particle system component.
                 * @returns The particle system component.
                 */
                get component() {
                    return super.component;
                }
                applyConfig(resource) {
                    if (!this.component) {
                        return;
                    }
                    // Set all the config properties on the component
                    for (const key in resource) {
                        if (resource.hasOwnProperty(key)) {
                            this.component[key] = resource[key];
                        }
                    }
                }
                async _loadAsset() {
                    var _a;
                    const appElement = await ((_a = this.closestApp) === null || _a === void 0 ? void 0 : _a.ready());
                    const app = appElement === null || appElement === void 0 ? void 0 : appElement.app;
                    const asset = AssetElement.get(this._asset);
                    if (!asset) {
                        return;
                    }
                    if (asset.loaded) {
                        this.applyConfig(asset.resource);
                    }
                    else {
                        asset.once('load', () => {
                            this.applyConfig(asset.resource);
                        });
                        app.assets.load(asset);
                    }
                }
                /**
                 * Sets the id of the `pc-asset` to use for the model.
                 * @param value - The asset ID.
                 */
                set asset(value) {
                    this._asset = value;
                    if (this.isConnected) {
                        this._loadAsset();
                    }
                }
                /**
                 * Gets the id of the `pc-asset` to use for the model.
                 * @returns The asset ID.
                 */
                get asset() {
                    return this._asset;
                }
                // Control methods
                /**
                 * Starts playing the particle system
                 */
                play() {
                    if (this.component) {
                        this.component.play();
                    }
                }
                /**
                 * Pauses the particle system
                 */
                pause() {
                    if (this.component) {
                        this.component.pause();
                    }
                }
                /**
                 * Resets the particle system
                 */
                reset() {
                    if (this.component) {
                        this.component.reset();
                    }
                }
                /**
                 * Stops the particle system
                 */
                stop() {
                    if (this.component) {
                        this.component.stop();
                    }
                }
                static get observedAttributes() {
                    return [
                        ...super.observedAttributes,
                        'asset'
                    ];
                }
                attributeChangedCallback(name, _oldValue, newValue) {
                    super.attributeChangedCallback(name, _oldValue, newValue);
                    switch (name) {
                        case 'asset':
                            this.asset = newValue;
                            break;
                    }
                }
            }
            customElements.define('pc-particles', ParticleSystemComponentElement);
            
            /**
             * The MaterialElement interface provides properties and methods for manipulating
             * {@link https://developer.playcanvas.com/user-manual/engine/web-components/tags/pc-material/ | `<pc-material>`} elements.
             * The MaterialElement interface also inherits the properties and methods of the
             * {@link HTMLElement} interface.
             */
            class MaterialElement extends HTMLElement {
                constructor() {
                    super(...arguments);
                    this._diffuse = new Color(1, 1, 1);
                    this._diffuseMap = '';
                    this._metalnessMap = '';
                    this._normalMap = '';
                    this._roughnessMap = '';
                    this.material = null;
                }
                createMaterial() {
                    this.material = new StandardMaterial();
                    this.material.glossInvert = false;
                    this.material.useMetalness = false;
                    this.material.diffuse = this._diffuse;
                    this.diffuseMap = this._diffuseMap;
                    this.metalnessMap = this._metalnessMap;
                    this.normalMap = this._normalMap;
                    this.roughnessMap = this._roughnessMap;
                    this.material.update();
                }
                disconnectedCallback() {
                    if (this.material) {
                        this.material.destroy();
                        this.material = null;
                    }
                }
                setMap(map, property) {
                    if (this.material) {
                        const asset = AssetElement.get(map);
                        if (asset) {
                            if (asset.loaded) {
                                this.material[property] = asset.resource;
                                this.material[property].anisotropy = 4;
                            }
                            else {
                                asset.once('load', () => {
                                    this.material[property] = asset.resource;
                                    this.material[property].anisotropy = 4;
                                    this.material.update();
                                });
                            }
                        }
                    }
                }
                set diffuse(value) {
                    this._diffuse = value;
                    if (this.material) {
                        this.material.diffuse = value;
                    }
                }
                get diffuse() {
                    return this._diffuse;
                }
                set diffuseMap(value) {
                    this._diffuseMap = value;
                    this.setMap(value, 'diffuseMap');
                }
                get diffuseMap() {
                    return this._diffuseMap;
                }
                set metalnessMap(value) {
                    this._metalnessMap = value;
                    this.setMap(value, 'metalnessMap');
                }
                get metalnessMap() {
                    return this._metalnessMap;
                }
                set normalMap(value) {
                    this._normalMap = value;
                    this.setMap(value, 'normalMap');
                }
                get normalMap() {
                    return this._normalMap;
                }
                set roughnessMap(value) {
                    this._roughnessMap = value;
                    this.setMap(value, 'glossMap');
                }
                get roughnessMap() {
                    return this._roughnessMap;
                }
                static get(id) {
                    const materialElement = document.querySelector(`pc-material[id="${id}"]`);
                    return materialElement === null || materialElement === void 0 ? void 0 : materialElement.material;
                }
                static get observedAttributes() {
                    return ['diffuse', 'diffuse-map', 'metalness-map', 'normal-map', 'roughness-map'];
                }
                attributeChangedCallback(name, _oldValue, newValue) {
                    switch (name) {
                        case 'diffuse':
                            this.diffuse = parseColor(newValue);
                            break;
                        case 'diffuse-map':
                            this.diffuseMap = newValue;
                            break;
                        case 'metalness-map':
                            this.metalnessMap = newValue;
                            break;
                        case 'normal-map':
                            this.normalMap = newValue;
                            break;
                        case 'roughness-map':
                            this.roughnessMap = newValue;
                            break;
                    }
                }
            }
            customElements.define('pc-material', MaterialElement);
            
            /**
             * The RenderComponentElement interface provides properties and methods for manipulating
             * {@link https://developer.playcanvas.com/user-manual/engine/web-components/tags/pc-render/ | `<pc-render>`} elements.
             * The RenderComponentElement interface also inherits the properties and methods of the
             * {@link HTMLElement} interface.
             *
             * @category Components
             */
            class RenderComponentElement extends ComponentElement {
                /** @ignore */
                constructor() {
                    super('render');
                    this._castShadows = true;
                    this._material = '';
                    this._receiveShadows = true;
                    this._type = 'asset';
                }
                getInitialComponentData() {
                    return {
                        type: this._type,
                        castShadows: this._castShadows,
                        material: MaterialElement.get(this._material),
                        receiveShadows: this._receiveShadows
                    };
                }
                /**
                 * Gets the underlying PlayCanvas render component.
                 * @returns The render component.
                 */
                get component() {
                    return super.component;
                }
                /**
                 * Sets the type of the render component.
                 * @param value - The type.
                 */
                set type(value) {
                    this._type = value;
                    if (this.component) {
                        this.component.type = value;
                    }
                }
                /**
                 * Gets the type of the render component.
                 * @returns The type.
                 */
                get type() {
                    return this._type;
                }
                /**
                 * Sets the cast shadows flag of the render component.
                 * @param value - The cast shadows flag.
                 */
                set castShadows(value) {
                    this._castShadows = value;
                    if (this.component) {
                        this.component.castShadows = value;
                    }
                }
                /**
                 * Gets the cast shadows flag of the render component.
                 * @returns The cast shadows flag.
                 */
                get castShadows() {
                    return this._castShadows;
                }
                /**
                 * Sets the material of the render component.
                 * @param value - The id of the material asset to use.
                 */
                set material(value) {
                    this._material = value;
                    if (this.component) {
                        this.component.material = MaterialElement.get(value);
                    }
                }
                /**
                 * Gets the id of the material asset used by the render component.
                 * @returns The id of the material asset.
                 */
                get material() {
                    return this._material;
                }
                /**
                 * Sets the receive shadows flag of the render component.
                 * @param value - The receive shadows flag.
                 */
                set receiveShadows(value) {
                    this._receiveShadows = value;
                    if (this.component) {
                        this.component.receiveShadows = value;
                    }
                }
                /**
                 * Gets the receive shadows flag of the render component.
                 * @returns The receive shadows flag.
                 */
                get receiveShadows() {
                    return this._receiveShadows;
                }
                static get observedAttributes() {
                    return [...super.observedAttributes, 'cast-shadows', 'material', 'receive-shadows', 'type'];
                }
                attributeChangedCallback(name, _oldValue, newValue) {
                    super.attributeChangedCallback(name, _oldValue, newValue);
                    switch (name) {
                        case 'cast-shadows':
                            this.castShadows = newValue !== 'false';
                            break;
                        case 'material':
                            this.material = newValue;
                            break;
                        case 'receive-shadows':
                            this.receiveShadows = newValue !== 'false';
                            break;
                        case 'type':
                            this.type = newValue;
                            break;
                    }
                }
            }
            customElements.define('pc-render', RenderComponentElement);
            
            /**
             * The RigidBodyComponentElement interface provides properties and methods for manipulating
             * {@link https://developer.playcanvas.com/user-manual/engine/web-components/tags/pc-rigidbody/ | `<pc-rigidbody>`} elements.
             * The RigidBodyComponentElement interface also inherits the properties and methods of the
             * {@link HTMLElement} interface.
             *
             * @category Components
             */
            class RigidBodyComponentElement extends ComponentElement {
                /** @ignore */
                constructor() {
                    super('rigidbody');
                    /**
                     * The angular damping of the rigidbody.
                     */
                    this._angularDamping = 0;
                    /**
                     * The angular factor of the rigidbody.
                     */
                    this._angularFactor = new Vec3(1, 1, 1);
                    /**
                     * The friction of the rigidbody.
                     */
                    this._friction = 0.5;
                    /**
                     * The linear damping of the rigidbody.
                     */
                    this._linearDamping = 0;
                    /**
                     * The linear factor of the rigidbody.
                     */
                    this._linearFactor = new Vec3(1, 1, 1);
                    /**
                     * The mass of the rigidbody.
                     */
                    this._mass = 1;
                    /**
                     * The restitution of the rigidbody.
                     */
                    this._restitution = 0;
                    /**
                     * The rolling friction of the rigidbody.
                     */
                    this._rollingFriction = 0;
                    /**
                     * The type of the rigidbody.
                     */
                    this._type = 'static';
                }
                getInitialComponentData() {
                    return {
                        angularDamping: this._angularDamping,
                        angularFactor: this._angularFactor,
                        friction: this._friction,
                        linearDamping: this._linearDamping,
                        linearFactor: this._linearFactor,
                        mass: this._mass,
                        restitution: this._restitution,
                        rollingFriction: this._rollingFriction,
                        type: this._type
                    };
                }
                /**
                 * Gets the underlying PlayCanvas rigidbody component.
                 * @returns The rigidbody component.
                 */
                get component() {
                    return super.component;
                }
                set angularDamping(value) {
                    this._angularDamping = value;
                    if (this.component) {
                        this.component.angularDamping = value;
                    }
                }
                get angularDamping() {
                    return this._angularDamping;
                }
                set angularFactor(value) {
                    this._angularFactor = value;
                    if (this.component) {
                        this.component.angularFactor = value;
                    }
                }
                get angularFactor() {
                    return this._angularFactor;
                }
                set friction(value) {
                    this._friction = value;
                    if (this.component) {
                        this.component.friction = value;
                    }
                }
                get friction() {
                    return this._friction;
                }
                set linearDamping(value) {
                    this._linearDamping = value;
                    if (this.component) {
                        this.component.linearDamping = value;
                    }
                }
                get linearDamping() {
                    return this._linearDamping;
                }
                set linearFactor(value) {
                    this._linearFactor = value;
                    if (this.component) {
                        this.component.linearFactor = value;
                    }
                }
                get linearFactor() {
                    return this._linearFactor;
                }
                set mass(value) {
                    this._mass = value;
                    if (this.component) {
                        this.component.mass = value;
                    }
                }
                get mass() {
                    return this._mass;
                }
                set restitution(value) {
                    this._restitution = value;
                    if (this.component) {
                        this.component.restitution = value;
                    }
                }
                get restitution() {
                    return this._restitution;
                }
                set rollingFriction(value) {
                    this._rollingFriction = value;
                    if (this.component) {
                        this.component.rollingFriction = value;
                    }
                }
                get rollingFriction() {
                    return this._rollingFriction;
                }
                set type(value) {
                    this._type = value;
                    if (this.component) {
                        this.component.type = value;
                    }
                }
                get type() {
                    return this._type;
                }
                static get observedAttributes() {
                    return [...super.observedAttributes, 'angular-damping', 'angular-factor', 'friction', 'linear-damping', 'linear-factor', 'mass', 'restitution', 'rolling-friction', 'type'];
                }
                attributeChangedCallback(name, _oldValue, newValue) {
                    super.attributeChangedCallback(name, _oldValue, newValue);
                    switch (name) {
                        case 'angular-damping':
                            this.angularDamping = parseFloat(newValue);
                            break;
                        case 'angular-factor':
                            this.angularFactor = parseVec3(newValue);
                            break;
                        case 'friction':
                            this.friction = parseFloat(newValue);
                            break;
                        case 'linear-damping':
                            this.linearDamping = parseFloat(newValue);
                            break;
                        case 'linear-factor':
                            this.linearFactor = parseVec3(newValue);
                            break;
                        case 'mass':
                            this.mass = parseFloat(newValue);
                            break;
                        case 'restitution':
                            this.restitution = parseFloat(newValue);
                            break;
                        case 'rolling-friction':
                            this.rollingFriction = parseFloat(newValue);
                            break;
                        case 'type':
                            this.type = newValue;
                            break;
                    }
                }
            }
            customElements.define('pc-rigidbody', RigidBodyComponentElement);
            
            /**
             * The ScreenComponentElement interface provides properties and methods for manipulating
             * {@link https://developer.playcanvas.com/user-manual/engine/web-components/tags/pc-screen/ | `<pc-screen>`} elements.
             * The ScreenComponentElement interface also inherits the properties and methods of the
             * {@link HTMLElement} interface.
             *
             * @category Components
             */
            class ScreenComponentElement extends ComponentElement {
                /** @ignore */
                constructor() {
                    super('screen');
                    this._screenSpace = false;
                    this._resolution = new Vec2(640, 320);
                    this._referenceResolution = new Vec2(640, 320);
                    this._priority = 0;
                    this._blend = false;
                    this._scaleBlend = 0.5;
                }
                getInitialComponentData() {
                    return {
                        priority: this._priority,
                        referenceResolution: this._referenceResolution,
                        resolution: this._resolution,
                        scaleBlend: this._scaleBlend,
                        scaleMode: this._blend ? SCALEMODE_BLEND : SCALEMODE_NONE,
                        screenSpace: this._screenSpace
                    };
                }
                /**
                 * Gets the underlying PlayCanvas screen component.
                 * @returns The screen component.
                 */
                get component() {
                    return super.component;
                }
                set priority(value) {
                    this._priority = value;
                    if (this.component) {
                        this.component.priority = this._priority;
                    }
                }
                get priority() {
                    return this._priority;
                }
                set referenceResolution(value) {
                    this._referenceResolution = value;
                    if (this.component) {
                        this.component.referenceResolution = this._referenceResolution;
                    }
                }
                get referenceResolution() {
                    return this._referenceResolution;
                }
                set resolution(value) {
                    this._resolution = value;
                    if (this.component) {
                        this.component.resolution = this._resolution;
                    }
                }
                get resolution() {
                    return this._resolution;
                }
                set scaleBlend(value) {
                    this._scaleBlend = value;
                    if (this.component) {
                        this.component.scaleBlend = this._scaleBlend;
                    }
                }
                get scaleBlend() {
                    return this._scaleBlend;
                }
                set blend(value) {
                    this._blend = value;
                    if (this.component) {
                        this.component.scaleMode = this._blend ? SCALEMODE_BLEND : SCALEMODE_NONE;
                    }
                }
                get blend() {
                    return this._blend;
                }
                set screenSpace(value) {
                    this._screenSpace = value;
                    if (this.component) {
                        this.component.screenSpace = this._screenSpace;
                    }
                }
                get screenSpace() {
                    return this._screenSpace;
                }
                static get observedAttributes() {
                    return [
                        ...super.observedAttributes,
                        'blend',
                        'screen-space',
                        'resolution',
                        'reference-resolution',
                        'priority',
                        'scale-blend'
                    ];
                }
                attributeChangedCallback(name, _oldValue, newValue) {
                    super.attributeChangedCallback(name, _oldValue, newValue);
                    switch (name) {
                        case 'priority':
                            this.priority = parseInt(newValue, 10);
                            break;
                        case 'reference-resolution':
                            this.referenceResolution = parseVec2(newValue);
                            break;
                        case 'resolution':
                            this.resolution = parseVec2(newValue);
                            break;
                        case 'scale-blend':
                            this.scaleBlend = parseFloat(newValue);
                            break;
                        case 'blend':
                            this.blend = this.hasAttribute('blend');
                            break;
                        case 'screen-space':
                            this.screenSpace = this.hasAttribute('screen-space');
                            break;
                    }
                }
            }
            customElements.define('pc-screen', ScreenComponentElement);
            
            /**
             * The ScriptComponentElement interface provides properties and methods for manipulating
             * {@link https://developer.playcanvas.com/user-manual/engine/web-components/tags/pc-scripts/ | `<pc-scripts>`} elements.
             * The ScriptComponentElement interface also inherits the properties and methods of the
             * {@link HTMLElement} interface.
             *
             * @category Components
             */
            class ScriptComponentElement extends ComponentElement {
                /** @ignore */
                constructor() {
                    super('script');
                    // Create mutation observer to watch for child script elements
                    this.observer = new MutationObserver(this.handleMutations.bind(this));
                    this.observer.observe(this, {
                        childList: true
                    });
                    // Listen for script attribute and enable changes
                    this.addEventListener('scriptattributeschange', this.handleScriptAttributesChange.bind(this));
                    this.addEventListener('scriptenablechange', this.handleScriptEnableChange.bind(this));
                }
                initComponent() {
                    // Handle initial script elements
                    this.querySelectorAll(':scope > pc-script').forEach((scriptElement) => {
                        const scriptName = scriptElement.getAttribute('name');
                        const attributes = scriptElement.getAttribute('attributes');
                        if (scriptName) {
                            this.createScript(scriptName, attributes);
                        }
                    });
                }
                /**
                 * Recursively converts raw attribute data into proper PlayCanvas types. Supported conversions:
                 * - "asset:assetId"  resolves to an Asset instance
                 * - "entity:entityId"  resolves to an Entity instance
                 * - "vec2:1,2"  new Vec2(1,2)
                 * - "vec3:1,2,3"  new Vec3(1,2,3)
                 * - "vec4:1,2,3,4"  new Vec4(1,2,3,4)
                 * - "color:1,0.5,0.5,1"  new Color(1,0.5,0.5,1)
                 * @param item - The item to convert.
                 * @returns The converted item.
                 */
                convertAttributes(item) {
                    if (typeof item === 'string') {
                        if (item.startsWith('asset:')) {
                            const assetId = item.slice(6);
                            const assetElement = document.querySelector(`pc-asset#${assetId}`);
                            if (assetElement) {
                                return assetElement.asset;
                            }
                        }
                        if (item.startsWith('entity:')) {
                            const entityId = item.slice(7);
                            const entityElement = document.querySelector(`pc-entity[name="${entityId}"]`);
                            if (entityElement) {
                                return entityElement.entity;
                            }
                        }
                        if (item.startsWith('vec2:')) {
                            const parts = item.slice(5).split(',').map(Number);
                            if (parts.length === 2 && parts.every(v => !isNaN(v))) {
                                return new Vec2(parts[0], parts[1]);
                            }
                        }
                        if (item.startsWith('vec3:')) {
                            const parts = item.slice(5).split(',').map(Number);
                            if (parts.length === 3 && parts.every(v => !isNaN(v))) {
                                return new Vec3(parts[0], parts[1], parts[2]);
                            }
                        }
                        if (item.startsWith('vec4:')) {
                            const parts = item.slice(5).split(',').map(Number);
                            if (parts.length === 4 && parts.every(v => !isNaN(v))) {
                                return new Vec4(parts[0], parts[1], parts[2], parts[3]);
                            }
                        }
                        if (item.startsWith('color:')) {
                            const parts = item.slice(6).split(',').map(Number);
                            if (parts.length === 4 && parts.every(v => !isNaN(v))) {
                                return new Color(parts[0], parts[1], parts[2], parts[3]);
                            }
                        }
                        return item;
                    }
                    if (Array.isArray(item)) {
                        // If it's an array of objects, convert each element individually.
                        if (item.length > 0 && typeof item[0] === 'object') {
                            return item.map((el) => this.convertAttributes(el));
                        }
                        // Otherwise, leave the numeric array unchanged but process each element.
                        return item.map((el) => this.convertAttributes(el));
                    }
                    if (item && typeof item === 'object') {
                        const result = {};
                        for (const key in item) {
                            result[key] = this.convertAttributes(item[key]);
                        }
                        return result;
                    }
                    return item;
                }
                /**
                 * Preprocess the attributes object by converting its values.
                 * @param attrs - The attributes object to preprocess.
                 * @returns The preprocessed attributes object.
                 */
                preprocessAttributes(attrs) {
                    return this.convertAttributes(attrs);
                }
                /**
                 * Recursively merge properties from source into target.
                 * @param target - The target object to merge into.
                 * @param source - The source object to merge from.
                 * @returns The merged object.
                 */
                mergeDeep(target, source) {
                    for (const key in source) {
                        if (source[key] &&
                            typeof source[key] === 'object' &&
                            !Array.isArray(source[key])) {
                            if (!target[key] || typeof target[key] !== 'object') {
                                target[key] = {};
                            }
                            this.mergeDeep(target[key], source[key]);
                        }
                        else {
                            target[key] = source[key];
                        }
                    }
                    return target;
                }
                /**
                 * Update script attributes by merging preprocessed values into the script.
                 * @param script - The script to update.
                 * @param attributes - The attributes to merge into the script.
                 */
                applyAttributes(script, attributes) {
                    try {
                        const attributesObject = attributes ? JSON.parse(attributes) : {};
                        const converted = this.convertAttributes(attributesObject);
                        this.mergeDeep(script, converted);
                    }
                    catch (error) {
                        console.error(`Error parsing attributes JSON string ${attributes}:`, error);
                    }
                }
                handleScriptAttributesChange(event) {
                    const scriptElement = event.target;
                    const scriptName = scriptElement.getAttribute('name');
                    if (!scriptName || !this.component)
                        return;
                    const script = this.component.get(scriptName);
                    if (script) {
                        this.applyAttributes(script, event.detail.attributes);
                    }
                }
                handleScriptEnableChange(event) {
                    const scriptElement = event.target;
                    const scriptName = scriptElement.getAttribute('name');
                    if (!scriptName || !this.component)
                        return;
                    const script = this.component.get(scriptName);
                    if (script) {
                        script.enabled = event.detail.enabled;
                    }
                }
                createScript(name, attributes) {
                    if (!this.component)
                        return null;
                    let attributesObject = {};
                    if (attributes) {
                        try {
                            attributesObject = JSON.parse(attributes);
                            // Preprocess attributes: convert arrays or strings into vectors, colors, asset references, etc.
                            attributesObject = this.preprocessAttributes(attributesObject);
                        }
                        catch (error) {
                            console.error(`Error parsing attributes JSON string ${attributes}:`, error);
                        }
                    }
                    return this.component.create(name, {
                        properties: attributesObject
                    });
                }
                destroyScript(name) {
                    if (!this.component)
                        return;
                    this.component.destroy(name);
                }
                handleMutations(mutations) {
                    for (const mutation of mutations) {
                        // Handle added nodes
                        mutation.addedNodes.forEach((node) => {
                            if (node instanceof HTMLElement && node.tagName.toLowerCase() === 'pc-script') {
                                const scriptName = node.getAttribute('name');
                                const attributes = node.getAttribute('attributes');
                                if (scriptName) {
                                    this.createScript(scriptName, attributes);
                                }
                            }
                        });
                        // Handle removed nodes
                        mutation.removedNodes.forEach((node) => {
                            if (node instanceof HTMLElement && node.tagName.toLowerCase() === 'pc-script') {
                                const scriptName = node.getAttribute('name');
                                if (scriptName) {
                                    this.destroyScript(scriptName);
                                }
                            }
                        });
                    }
                }
                disconnectedCallback() {
                    var _a;
                    this.observer.disconnect();
                    (_a = super.disconnectedCallback) === null || _a === void 0 ? void 0 : _a.call(this);
                }
                /**
                 * Gets the underlying PlayCanvas script component.
                 * @returns The script component.
                 */
                get component() {
                    return super.component;
                }
            }
            customElements.define('pc-scripts', ScriptComponentElement);
            
            /**
             * The ScriptElement interface provides properties and methods for manipulating
             * `<pc-script>` elements. The ScriptElement interface also inherits the properties and
             * methods of the {@link HTMLElement} interface.
             */
            class ScriptElement extends HTMLElement {
                constructor() {
                    super(...arguments);
                    this._attributes = '{}';
                    this._enabled = true;
                    this._name = '';
                }
                /**
                 * Sets the attributes of the script.
                 * @param value - The attributes of the script.
                 */
                set scriptAttributes(value) {
                    this._attributes = value;
                    this.dispatchEvent(new CustomEvent('scriptattributeschange', {
                        detail: { attributes: value },
                        bubbles: true
                    }));
                }
                /**
                 * Gets the attributes of the script.
                 * @returns The attributes of the script.
                 */
                get scriptAttributes() {
                    return this._attributes;
                }
                /**
                 * Sets the enabled state of the script.
                 * @param value - The enabled state of the script.
                 */
                set enabled(value) {
                    this._enabled = value;
                    this.dispatchEvent(new CustomEvent('scriptenablechange', {
                        detail: { enabled: value },
                        bubbles: true
                    }));
                }
                /**
                 * Gets the enabled state of the script.
                 * @returns The enabled state of the script.
                 */
                get enabled() {
                    return this._enabled;
                }
                /**
                 * Sets the name of the script to create.
                 * @param value - The name.
                 */
                set name(value) {
                    this._name = value;
                }
                /**
                 * Gets the name of the script.
                 * @returns The name.
                 */
                get name() {
                    return this._name;
                }
                static get observedAttributes() {
                    return ['attributes', 'enabled', 'name'];
                }
                attributeChangedCallback(name, _oldValue, newValue) {
                    switch (name) {
                        case 'attributes':
                            this.scriptAttributes = newValue;
                            break;
                        case 'enabled':
                            this.enabled = newValue !== 'false';
                            break;
                        case 'name':
                            this.name = newValue;
                            break;
                    }
                }
            }
            customElements.define('pc-script', ScriptElement);
            
            /**
             * The SoundComponentElement interface provides properties and methods for manipulating
             * {@link https://developer.playcanvas.com/user-manual/engine/web-components/tags/pc-sounds/ | `<pc-sounds>`} elements.
             * The SoundComponentElement interface also inherits the properties and methods of the
             * {@link HTMLElement} interface.
             *
             * @category Components
             */
            class SoundComponentElement extends ComponentElement {
                /** @ignore */
                constructor() {
                    super('sound');
                    this._distanceModel = 'linear';
                    this._maxDistance = 10000;
                    this._pitch = 1;
                    this._positional = false;
                    this._refDistance = 1;
                    this._rollOffFactor = 1;
                    this._volume = 1;
                }
                getInitialComponentData() {
                    return {
                        distanceModel: this._distanceModel,
                        maxDistance: this._maxDistance,
                        pitch: this._pitch,
                        positional: this._positional,
                        refDistance: this._refDistance,
                        rollOffFactor: this._rollOffFactor,
                        volume: this._volume
                    };
                }
                /**
                 * Gets the underlying PlayCanvas sound component.
                 * @returns The sound component.
                 */
                get component() {
                    return super.component;
                }
                /**
                 * Sets which algorithm to use to reduce the volume of the sound as it moves away from the listener.
                 * @param value - The distance model.
                 */
                set distanceModel(value) {
                    this._distanceModel = value;
                    if (this.component) {
                        this.component.distanceModel = value;
                    }
                }
                /**
                 * Gets which algorithm to use to reduce the volume of the sound as it moves away from the listener.
                 * @returns The distance model.
                 */
                get distanceModel() {
                    return this._distanceModel;
                }
                /**
                 * Sets the maximum distance from the listener at which audio falloff stops.
                 * @param value - The max distance.
                 */
                set maxDistance(value) {
                    this._maxDistance = value;
                    if (this.component) {
                        this.component.maxDistance = value;
                    }
                }
                /**
                 * Gets the maximum distance from the listener at which audio falloff stops.
                 * @returns The max distance.
                 */
                get maxDistance() {
                    return this._maxDistance;
                }
                /**
                 * Sets the pitch of the sound.
                 * @param value - The pitch.
                 */
                set pitch(value) {
                    this._pitch = value;
                    if (this.component) {
                        this.component.pitch = value;
                    }
                }
                /**
                 * Gets the pitch of the sound.
                 * @returns The pitch.
                 */
                get pitch() {
                    return this._pitch;
                }
                /**
                 * Sets the positional flag of the sound.
                 * @param value - The positional flag.
                 */
                set positional(value) {
                    this._positional = value;
                    if (this.component) {
                        this.component.positional = value;
                    }
                }
                /**
                 * Gets the positional flag of the sound.
                 * @returns The positional flag.
                 */
                get positional() {
                    return this._positional;
                }
                /**
                 * Sets the reference distance for reducing volume as the sound source moves further from the listener. Defaults to 1.
                 * @param value - The ref distance.
                 */
                set refDistance(value) {
                    this._refDistance = value;
                    if (this.component) {
                        this.component.refDistance = value;
                    }
                }
                /**
                 * Gets the reference distance for reducing volume as the sound source moves further from the listener.
                 * @returns The ref distance.
                 */
                get refDistance() {
                    return this._refDistance;
                }
                /**
                 * Sets the factor used in the falloff equation. Defaults to 1.
                 * @param value - The roll-off factor.
                 */
                set rollOffFactor(value) {
                    this._rollOffFactor = value;
                    if (this.component) {
                        this.component.rollOffFactor = value;
                    }
                }
                /**
                 * Gets the factor used in the falloff equation.
                 * @returns The roll-off factor.
                 */
                get rollOffFactor() {
                    return this._rollOffFactor;
                }
                /**
                 * Sets the volume of the sound.
                 * @param value - The volume.
                 */
                set volume(value) {
                    this._volume = value;
                    if (this.component) {
                        this.component.volume = value;
                    }
                }
                /**
                 * Gets the volume of the sound.
                 * @returns The volume.
                 */
                get volume() {
                    return this._volume;
                }
                static get observedAttributes() {
                    return [
                        ...super.observedAttributes,
                        'distance-model',
                        'max-distance',
                        'pitch',
                        'positional',
                        'ref-distance',
                        'roll-off-factor',
                        'volume'
                    ];
                }
                attributeChangedCallback(name, _oldValue, newValue) {
                    super.attributeChangedCallback(name, _oldValue, newValue);
                    switch (name) {
                        case 'distance-model':
                            this.distanceModel = newValue;
                            break;
                        case 'max-distance':
                            this.maxDistance = parseFloat(newValue);
                            break;
                        case 'pitch':
                            this.pitch = parseFloat(newValue);
                            break;
                        case 'positional':
                            this.positional = this.hasAttribute('positional');
                            break;
                        case 'ref-distance':
                            this.refDistance = parseFloat(newValue);
                            break;
                        case 'roll-off-factor':
                            this.rollOffFactor = parseFloat(newValue);
                            break;
                        case 'volume':
                            this.volume = parseFloat(newValue);
                            break;
                    }
                }
            }
            customElements.define('pc-sounds', SoundComponentElement);
            
            /**
             * The SoundSlotElement interface provides properties and methods for manipulating
             * `<pc-sound>` elements. The SoundSlotElement interface also inherits the properties and
             * methods of the {@link AsyncElement} interface.
             */
            class SoundSlotElement extends AsyncElement {
                constructor() {
                    super(...arguments);
                    this._asset = '';
                    this._autoPlay = false;
                    this._duration = null;
                    this._loop = false;
                    this._name = '';
                    this._overlap = false;
                    this._pitch = 1;
                    this._startTime = 0;
                    this._volume = 1;
                    /**
                     * The sound slot.
                     */
                    this.soundSlot = null;
                }
                async connectedCallback() {
                    var _a;
                    await ((_a = this.soundElement) === null || _a === void 0 ? void 0 : _a.ready());
                    const options = {
                        autoPlay: this._autoPlay,
                        loop: this._loop,
                        overlap: this._overlap,
                        pitch: this._pitch,
                        startTime: this._startTime,
                        volume: this._volume
                    };
                    if (this._duration) {
                        options.duration = this._duration;
                    }
                    this.soundSlot = this.soundElement.component.addSlot(this._name, options);
                    this.asset = this._asset;
                    this._onReady();
                }
                disconnectedCallback() {
                    this.soundElement.component.removeSlot(this._name);
                }
                get soundElement() {
                    const soundElement = this.parentElement;
                    if (!(soundElement instanceof SoundComponentElement)) {
                        console.warn('pc-sound-slot must be a direct child of a pc-sound element');
                        return null;
                    }
                    return soundElement;
                }
                /**
                 * Sets the id of the `pc-asset` to use for the sound slot.
                 * @param value - The asset.
                 */
                set asset(value) {
                    var _a;
                    this._asset = value;
                    if (this.soundSlot) {
                        const id = (_a = AssetElement.get(value)) === null || _a === void 0 ? void 0 : _a.id;
                        if (id) {
                            this.soundSlot.asset = id;
                        }
                    }
                }
                /**
                 * Gets the id of the `pc-asset` to use for the sound slot.
                 * @returns The asset.
                 */
                get asset() {
                    return this._asset;
                }
                /**
                 * Sets the auto play flag of the sound slot.
                 * @param value - The auto play flag.
                 */
                set autoPlay(value) {
                    this._autoPlay = value;
                    if (this.soundSlot) {
                        this.soundSlot.autoPlay = value;
                    }
                }
                /**
                 * Gets the auto play flag of the sound slot.
                 * @returns The auto play flag.
                 */
                get autoPlay() {
                    return this._autoPlay;
                }
                /**
                 * Sets the duration of the sound slot.
                 * @param value - The duration.
                 */
                set duration(value) {
                    this._duration = value;
                    if (this.soundSlot) {
                        this.soundSlot.duration = value;
                    }
                }
                /**
                 * Gets the duration of the sound slot.
                 * @returns The duration.
                 */
                get duration() {
                    return this._duration;
                }
                /**
                 * Sets the loop flag of the sound slot.
                 * @param value - The loop flag.
                 */
                set loop(value) {
                    this._loop = value;
                    if (this.soundSlot) {
                        this.soundSlot.loop = value;
                    }
                }
                /**
                 * Gets the loop flag of the sound slot.
                 * @returns The loop flag.
                 */
                get loop() {
                    return this._loop;
                }
                /**
                 * Sets the name of the sound slot.
                 * @param value - The name.
                 */
                set name(value) {
                    this._name = value;
                    if (this.soundSlot) {
                        this.soundSlot.name = value;
                    }
                }
                /**
                 * Gets the name of the sound slot.
                 * @returns The name.
                 */
                get name() {
                    return this._name;
                }
                /**
                 * Sets the overlap flag of the sound slot.
                 * @param value - The overlap flag.
                 */
                set overlap(value) {
                    this._overlap = value;
                    if (this.soundSlot) {
                        this.soundSlot.overlap = value;
                    }
                }
                /**
                 * Gets the overlap flag of the sound slot.
                 * @returns The overlap flag.
                 */
                get overlap() {
                    return this._overlap;
                }
                /**
                 * Sets the pitch of the sound slot.
                 * @param value - The pitch.
                 */
                set pitch(value) {
                    this._pitch = value;
                    if (this.soundSlot) {
                        this.soundSlot.pitch = value;
                    }
                }
                /**
                 * Gets the pitch of the sound slot.
                 * @returns The pitch.
                 */
                get pitch() {
                    return this._pitch;
                }
                /**
                 * Sets the start time of the sound slot.
                 * @param value - The start time.
                 */
                set startTime(value) {
                    this._startTime = value;
                    if (this.soundSlot) {
                        this.soundSlot.startTime = value;
                    }
                }
                /**
                 * Gets the start time of the sound slot.
                 * @returns The start time.
                 */
                get startTime() {
                    return this._startTime;
                }
                /**
                 * Sets the volume of the sound slot.
                 * @param value - The volume.
                 */
                set volume(value) {
                    this._volume = value;
                    if (this.soundSlot) {
                        this.soundSlot.volume = value;
                    }
                }
                /**
                 * Gets the volume of the sound slot.
                 * @returns The volume.
                 */
                get volume() {
                    return this._volume;
                }
                static get observedAttributes() {
                    return ['asset', 'auto-play', 'duration', 'loop', 'name', 'overlap', 'pitch', 'start-time', 'volume'];
                }
                attributeChangedCallback(name, _oldValue, newValue) {
                    switch (name) {
                        case 'asset':
                            this.asset = newValue;
                            break;
                        case 'auto-play':
                            this.autoPlay = this.hasAttribute('auto-play');
                            break;
                        case 'duration':
                            this.duration = parseFloat(newValue);
                            break;
                        case 'loop':
                            this.loop = this.hasAttribute('loop');
                            break;
                        case 'name':
                            this.name = newValue;
                            break;
                        case 'overlap':
                            this.overlap = this.hasAttribute('overlap');
                            break;
                        case 'pitch':
                            this.pitch = parseFloat(newValue);
                            break;
                        case 'start-time':
                            this.startTime = parseFloat(newValue);
                            break;
                        case 'volume':
                            this.volume = parseFloat(newValue);
                            break;
                    }
                }
            }
            customElements.define('pc-sound', SoundSlotElement);
            
            /**
             * The SplatComponentElement interface provides properties and methods for manipulating
             * {@link https://developer.playcanvas.com/user-manual/engine/web-components/tags/pc-splat/ | `<pc-splat>`} elements.
             * The SplatComponentElement interface also inherits the properties and methods of the
             * {@link HTMLElement} interface.
             *
             * @category Components
             */
            class SplatComponentElement extends ComponentElement {
                /** @ignore */
                constructor() {
                    super('gsplat');
                    this._asset = '';
                    this._castShadows = false;
                }
                getInitialComponentData() {
                    return {
                        asset: AssetElement.get(this._asset),
                        castShadows: this._castShadows
                    };
                }
                /**
                 * Gets the underlying PlayCanvas splat component.
                 * @returns The splat component.
                 */
                get component() {
                    return super.component;
                }
                /**
                 * Sets id of the `pc-asset` to use for the splat.
                 * @param value - The asset ID.
                 */
                set asset(value) {
                    this._asset = value;
                    const asset = AssetElement.get(value);
                    if (this.component && asset) {
                        this.component.asset = asset;
                    }
                }
                /**
                 * Gets the id of the `pc-asset` to use for the splat.
                 * @returns The asset ID.
                 */
                get asset() {
                    return this._asset;
                }
                /**
                 * Sets whether the splat casts shadows.
                 * @param value - Whether the splat casts shadows.
                 */
                set castShadows(value) {
                    this._castShadows = value;
                    if (this.component) {
                        this.component.castShadows = value;
                    }
                }
                /**
                 * Gets whether the splat casts shadows.
                 * @returns Whether the splat casts shadows.
                 */
                get castShadows() {
                    return this._castShadows;
                }
                static get observedAttributes() {
                    return [
                        ...super.observedAttributes,
                        'asset',
                        'cast-shadows'
                    ];
                }
                attributeChangedCallback(name, _oldValue, newValue) {
                    super.attributeChangedCallback(name, _oldValue, newValue);
                    switch (name) {
                        case 'asset':
                            this.asset = newValue;
                            break;
                        case 'cast-shadows':
                            this.castShadows = this.hasAttribute('cast-shadows');
                            break;
                    }
                }
            }
            customElements.define('pc-splat', SplatComponentElement);
            
            /**
             * The ModelElement interface provides properties and methods for manipulating
             * {@link https://developer.playcanvas.com/user-manual/engine/web-components/tags/pc-model/ | `<pc-model>`} elements.
             * The ModelElement interface also inherits the properties and methods of the
             * {@link HTMLElement} interface.
             */
            class ModelElement extends AsyncElement {
                constructor() {
                    super(...arguments);
                    this._asset = '';
                    this._entity = null;
                }
                connectedCallback() {
                    this._loadModel();
                    this._onReady();
                }
                disconnectedCallback() {
                    this._unloadModel();
                }
                _instantiate(container) {
                    this._entity = container.instantiateRenderEntity();
                    // @ts-ignore
                    if (container.animations.length > 0) {
                        this._entity.addComponent('anim');
                        // @ts-ignore
                        this._entity.anim.assignAnimation('animation', container.animations[0].resource);
                    }
                    const parentEntityElement = this.closestEntity;
                    if (parentEntityElement) {
                        parentEntityElement.ready().then(() => {
                            parentEntityElement.entity.addChild(this._entity);
                        });
                    }
                    else {
                        const appElement = this.closestApp;
                        if (appElement) {
                            appElement.ready().then(() => {
                                appElement.app.root.addChild(this._entity);
                            });
                        }
                    }
                }
                async _loadModel() {
                    var _a;
                    this._unloadModel();
                    const appElement = await ((_a = this.closestApp) === null || _a === void 0 ? void 0 : _a.ready());
                    const app = appElement === null || appElement === void 0 ? void 0 : appElement.app;
                    const asset = AssetElement.get(this._asset);
                    if (!asset) {
                        return;
                    }
                    if (asset.loaded) {
                        this._instantiate(asset.resource);
                    }
                    else {
                        asset.once('load', () => {
                            this._instantiate(asset.resource);
                        });
                        app.assets.load(asset);
                    }
                }
                _unloadModel() {
                    var _a;
                    (_a = this._entity) === null || _a === void 0 ? void 0 : _a.destroy();
                    this._entity = null;
                }
                /**
                 * Sets the id of the `pc-asset` to use for the model.
                 * @param value - The asset ID.
                 */
                set asset(value) {
                    this._asset = value;
                    if (this.isConnected) {
                        this._loadModel();
                    }
                }
                /**
                 * Gets the id of the `pc-asset` to use for the model.
                 * @returns The asset ID.
                 */
                get asset() {
                    return this._asset;
                }
                static get observedAttributes() {
                    return ['asset'];
                }
                attributeChangedCallback(name, _oldValue, newValue) {
                    switch (name) {
                        case 'asset':
                            this.asset = newValue;
                            break;
                    }
                }
            }
            customElements.define('pc-model', ModelElement);
            
            /**
             * The SceneElement interface provides properties and methods for manipulating
             * {@link https://developer.playcanvas.com/user-manual/engine/web-components/tags/pc-scene/ | `<pc-scene>`} elements.
             * The SceneElement interface also inherits the properties and methods of the
             * {@link HTMLElement} interface.
             */
            class SceneElement extends AsyncElement {
                constructor() {
                    super(...arguments);
                    /**
                     * The fog type of the scene.
                     */
                    this._fog = 'none'; // possible values: 'none', 'linear', 'exp', 'exp2'
                    /**
                     * The color of the fog.
                     */
                    this._fogColor = new Color(1, 1, 1);
                    /**
                     * The density of the fog.
                     */
                    this._fogDensity = 0;
                    /**
                     * The start distance of the fog.
                     */
                    this._fogStart = 0;
                    /**
                     * The end distance of the fog.
                     */
                    this._fogEnd = 1000;
                    /**
                     * The gravity of the scene.
                     */
                    this._gravity = new Vec3(0, -9.81, 0);
                    /**
                     * The PlayCanvas scene instance.
                     */
                    this.scene = null;
                }
                async connectedCallback() {
                    var _a;
                    await ((_a = this.closestApp) === null || _a === void 0 ? void 0 : _a.ready());
                    this.scene = this.closestApp.app.scene;
                    this.updateSceneSettings();
                    this._onReady();
                }
                updateSceneSettings() {
                    if (this.scene) {
                        this.scene.fog.type = this._fog;
                        this.scene.fog.color = this._fogColor;
                        this.scene.fog.density = this._fogDensity;
                        this.scene.fog.start = this._fogStart;
                        this.scene.fog.end = this._fogEnd;
                        const appElement = this.parentElement;
                        appElement.app.systems.rigidbody.gravity.copy(this._gravity);
                    }
                }
                /**
                 * Sets the fog type of the scene.
                 * @param value - The fog type.
                 */
                set fog(value) {
                    this._fog = value;
                    if (this.scene) {
                        this.scene.fog.type = value;
                    }
                }
                /**
                 * Gets the fog type of the scene.
                 * @returns The fog type.
                 */
                get fog() {
                    return this._fog;
                }
                /**
                 * Sets the fog color of the scene.
                 * @param value - The fog color.
                 */
                set fogColor(value) {
                    this._fogColor = value;
                    if (this.scene) {
                        this.scene.fog.color = value;
                    }
                }
                /**
                 * Gets the fog color of the scene.
                 * @returns The fog color.
                 */
                get fogColor() {
                    return this._fogColor;
                }
                /**
                 * Sets the fog density of the scene.
                 * @param value - The fog density.
                 */
                set fogDensity(value) {
                    this._fogDensity = value;
                    if (this.scene) {
                        this.scene.fog.density = value;
                    }
                }
                /**
                 * Gets the fog density of the scene.
                 * @returns The fog density.
                 */
                get fogDensity() {
                    return this._fogDensity;
                }
                /**
                 * Sets the fog start distance of the scene.
                 * @param value - The fog start distance.
                 */
                set fogStart(value) {
                    this._fogStart = value;
                    if (this.scene) {
                        this.scene.fog.start = value;
                    }
                }
                /**
                 * Gets the fog start distance of the scene.
                 * @returns The fog start distance.
                 */
                get fogStart() {
                    return this._fogStart;
                }
                /**
                 * Sets the fog end distance of the scene.
                 * @param value - The fog end distance.
                 */
                set fogEnd(value) {
                    this._fogEnd = value;
                    if (this.scene) {
                        this.scene.fog.end = value;
                    }
                }
                /**
                 * Gets the fog end distance of the scene.
                 * @returns The fog end distance.
                 */
                get fogEnd() {
                    return this._fogEnd;
                }
                /**
                 * Sets the gravity of the scene.
                 * @param value - The gravity.
                 */
                set gravity(value) {
                    this._gravity = value;
                    if (this.scene) {
                        const appElement = this.parentElement;
                        appElement.app.systems.rigidbody.gravity.copy(value);
                    }
                }
                /**
                 * Gets the gravity of the scene.
                 * @returns The gravity.
                 */
                get gravity() {
                    return this._gravity;
                }
                static get observedAttributes() {
                    return ['fog', 'fog-color', 'fog-density', 'fog-start', 'fog-end', 'gravity'];
                }
                attributeChangedCallback(name, _oldValue, newValue) {
                    switch (name) {
                        case 'fog':
                            this.fog = newValue;
                            break;
                        case 'fog-color':
                            this.fogColor = parseColor(newValue);
                            break;
                        case 'fog-density':
                            this.fogDensity = parseFloat(newValue);
                            break;
                        case 'fog-start':
                            this.fogStart = parseFloat(newValue);
                            break;
                        case 'fog-end':
                            this.fogEnd = parseFloat(newValue);
                            break;
                        case 'gravity':
                            this.gravity = parseVec3(newValue);
                            break;
                        // ... handle other attributes as well
                    }
                }
            }
            customElements.define('pc-scene', SceneElement);
            
            /**
             * The SkyElement interface provides properties and methods for manipulating
             * `<pc-sky>` elements. The SkyElement interface also inherits the properties and
             * methods of the {@link HTMLElement} interface.
             */
            class SkyElement extends AsyncElement {
                constructor() {
                    super(...arguments);
                    this._asset = '';
                    this._center = new Vec3(0, 0.01, 0);
                    this._intensity = 1;
                    this._rotation = new Vec3();
                    this._level = 0;
                    this._lighting = false;
                    this._scale = new Vec3(100, 100, 100);
                    this._type = 'infinite';
                    this._scene = null;
                }
                connectedCallback() {
                    this._loadSkybox();
                    this._onReady();
                }
                disconnectedCallback() {
                    this._unloadSkybox();
                }
                _generateSkybox(asset) {
                    if (!this._scene)
                        return;
                    const source = asset.resource;
                    const skybox = EnvLighting.generateSkyboxCubemap(source);
                    skybox.anisotropy = 4;
                    this._scene.skybox = skybox;
                    if (this._lighting) {
                        const lighting = EnvLighting.generateLightingSource(source);
                        const envAtlas = EnvLighting.generateAtlas(lighting);
                        this._scene.envAtlas = envAtlas;
                    }
                    const layer = this._scene.layers.getLayerById(LAYERID_SKYBOX);
                    if (layer) {
                        layer.enabled = this._type !== 'none';
                    }
                    this._scene.sky.type = this._type;
                    this._scene.sky.node.setLocalScale(this._scale);
                    this._scene.sky.center = this._center;
                    this._scene.skyboxIntensity = this._intensity;
                    this._scene.skyboxMip = this._level;
                }
                async _loadSkybox() {
                    var _a;
                    const appElement = await ((_a = this.closestApp) === null || _a === void 0 ? void 0 : _a.ready());
                    const app = appElement === null || appElement === void 0 ? void 0 : appElement.app;
                    if (!app) {
                        return;
                    }
                    const asset = AssetElement.get(this._asset);
                    if (!asset) {
                        return;
                    }
                    this._scene = app.scene;
                    if (asset.loaded) {
                        this._generateSkybox(asset);
                    }
                    else {
                        asset.once('load', () => {
                            this._generateSkybox(asset);
                        });
                        app.assets.load(asset);
                    }
                }
                _unloadSkybox() {
                    var _a, _b;
                    if (!this._scene)
                        return;
                    (_a = this._scene.skybox) === null || _a === void 0 ? void 0 : _a.destroy();
                    // @ts-ignore
                    this._scene.skybox = null;
                    (_b = this._scene.envAtlas) === null || _b === void 0 ? void 0 : _b.destroy();
                    // @ts-ignore
                    this._scene.envAtlas = null;
                    this._scene = null;
                }
                /**
                 * Sets the id of the `pc-asset` to use for the skybox.
                 * @param value - The asset ID.
                 */
                set asset(value) {
                    this._asset = value;
                    if (this.isConnected) {
                        this._loadSkybox();
                    }
                }
                /**
                 * Gets the id of the `pc-asset` to use for the skybox.
                 * @returns The asset ID.
                 */
                get asset() {
                    return this._asset;
                }
                /**
                 * Sets the center of the skybox.
                 * @param value - The center.
                 */
                set center(value) {
                    this._center = value;
                    if (this._scene) {
                        this._scene.sky.center = this._center;
                    }
                }
                /**
                 * Gets the center of the skybox.
                 * @returns The center.
                 */
                get center() {
                    return this._center;
                }
                /**
                 * Sets the intensity of the skybox.
                 * @param value - The intensity.
                 */
                set intensity(value) {
                    this._intensity = value;
                    if (this._scene) {
                        this._scene.skyboxIntensity = this._intensity;
                    }
                }
                /**
                 * Gets the intensity of the skybox.
                 * @returns The intensity.
                 */
                get intensity() {
                    return this._intensity;
                }
                /**
                 * Sets the mip level of the skybox.
                 * @param value - The mip level.
                 */
                set level(value) {
                    this._level = value;
                    if (this._scene) {
                        this._scene.skyboxMip = this._level;
                    }
                }
                /**
                 * Gets the mip level of the skybox.
                 * @returns The mip level.
                 */
                get level() {
                    return this._level;
                }
                /**
                 * Sets whether the skybox is used as a light source.
                 * @param value - Whether to use lighting.
                 */
                set lighting(value) {
                    this._lighting = value;
                }
                /**
                 * Gets whether the skybox is used as a light source.
                 * @returns Whether to use lighting.
                 */
                get lighting() {
                    return this._lighting;
                }
                /**
                 * Sets the Euler rotation of the skybox.
                 * @param value - The rotation.
                 */
                set rotation(value) {
                    this._rotation = value;
                    if (this._scene) {
                        this._scene.skyboxRotation = new Quat().setFromEulerAngles(value);
                    }
                }
                /**
                 * Gets the Euler rotation of the skybox.
                 * @returns The rotation.
                 */
                get rotation() {
                    return this._rotation;
                }
                /**
                 * Sets the scale of the skybox.
                 * @param value - The scale.
                 */
                set scale(value) {
                    this._scale = value;
                    if (this._scene) {
                        this._scene.sky.node.setLocalScale(this._scale);
                    }
                }
                /**
                 * Gets the scale of the skybox.
                 * @returns The scale.
                 */
                get scale() {
                    return this._scale;
                }
                /**
                 * Sets the type of the skybox.
                 * @param value - The type.
                 */
                set type(value) {
                    this._type = value;
                    if (this._scene) {
                        this._scene.sky.type = this._type;
                        const layer = this._scene.layers.getLayerById(LAYERID_SKYBOX);
                        if (layer) {
                            layer.enabled = this._type !== 'none';
                        }
                    }
                }
                /**
                 * Gets the type of the skybox.
                 * @returns The type.
                 */
                get type() {
                    return this._type;
                }
                static get observedAttributes() {
                    return ['asset', 'center', 'intensity', 'level', 'lighting', 'rotation', 'scale', 'type'];
                }
                attributeChangedCallback(name, _oldValue, newValue) {
                    switch (name) {
                        case 'asset':
                            this.asset = newValue;
                            break;
                        case 'center':
                            this.center = parseVec3(newValue);
                            break;
                        case 'intensity':
                            this.intensity = parseFloat(newValue);
                            break;
                        case 'level':
                            this.level = parseInt(newValue, 10);
                            break;
                        case 'lighting':
                            this.lighting = this.hasAttribute(name);
                            break;
                        case 'rotation':
                            this.rotation = parseVec3(newValue);
                            break;
                        case 'scale':
                            this.scale = parseVec3(newValue);
                            break;
                        case 'type':
                            this.type = newValue;
                            break;
                    }
                }
            }
            customElements.define('pc-sky', SkyElement);
            
            class XrControllers extends Script {
                /**
                 * The base URL for fetching the WebXR input profiles.
                 *
                 * @attribute
                 * @type {string}
                 */
                basePath = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets/dist/profiles';
            
                controllers = new Map();
            
                initialize() {
                    if (!this.app.xr) {
                        console.error('XrControllers script requires XR to be enabled on the application');
                        return;
                    }
            
                    this.app.xr.input.on('add', async (inputSource) => {
                        if (!inputSource.profiles?.length) {
                            console.warn('No profiles available for input source');
                            return;
                        }
            
                        // Process all profiles concurrently
                        const profilePromises = inputSource.profiles.map(async (profileId) => {
                            const profileUrl = `${this.basePath}/${profileId}/profile.json`;
            
                            try {
                                const response = await fetch(profileUrl);
                                if (!response.ok) {
                                    return null;
                                }
            
                                const profile = await response.json();
                                const layoutPath = profile.layouts[inputSource.handedness]?.assetPath || '';
                                const assetPath = `${this.basePath}/${profile.profileId}/${inputSource.handedness}${layoutPath.replace(/^\/?(left|right)/, '')}`;
            
                                // Load the model
                                const asset = await new Promise((resolve, reject) => {
                                    this.app.assets.loadFromUrl(assetPath, 'container', (err, asset) => {
                                        if (err) reject(err);
                                        else resolve(asset);
                                    });
                                });
            
                                return { profileId, asset };
                            } catch (error) {
                                console.warn(`Failed to process profile ${profileId}`);
                                return null;
                            }
                        });
            
                        // Wait for all profile attempts to complete
                        const results = await Promise.all(profilePromises);
                        const successfulResult = results.find(result => result !== null);
            
                        if (successfulResult) {
                            const { asset } = successfulResult;
                            const container = asset.resource;
                            const entity = container.instantiateRenderEntity();
                            this.app.root.addChild(entity);
            
                            const jointMap = new Map();
                            if (inputSource.hand) {
                                for (const joint of inputSource.hand.joints) {
                                    const jointEntity = entity.findByName(joint.id);
                                    if (jointEntity) {
                                        jointMap.set(joint, jointEntity);
                                    }
                                }
                            }
            
                            this.controllers.set(inputSource, { entity, jointMap });
                        } else {
                            console.warn('No compatible profiles found');
                        }
                    });
            
                    this.app.xr.input.on('remove', (inputSource) => {
                        const controller = this.controllers.get(inputSource);
                        if (controller) {
                            controller.entity.destroy();
                            this.controllers.delete(inputSource);
                        }
                    });
                }
            
                update(dt) {
                    if (this.app.xr?.active) {
                        for (const [inputSource, { entity, jointMap }] of this.controllers) {
                            if (inputSource.hand) {
                                for (const [joint, jointEntity] of jointMap) {
                                    jointEntity.setPosition(joint.getPosition());
                                    jointEntity.setRotation(joint.getRotation());
                                }
                            } else {
                                entity.setPosition(inputSource.getPosition());
                                entity.setRotation(inputSource.getRotation());
                            }
                        }
                    }
                }
            }
            
            /** @import { XrInputSource } from 'playcanvas' */
            
            /**
             * Handles VR teleportation navigation by allowing users to point and teleport using either
             * hands or tracked controllers. Shows a visual ray and target indicator when the user holds
             * the select button (trigger) or makes a pinch gesture with hand tracking, and teleports to
             * the target location when released.
             *
             * This script should be attached to a parent entity of the camera entity used for the XR
             * session. Use it in conjunction with the `XrControllers` script to handle the rendering of
             * the controllers.
             */
            class XrNavigation extends Script {
                /** @type {Set<XrInputSource>} */
                inputSources = new Set();
            
                /** @type {Map<XrInputSource, boolean>} */
                activePointers = new Map();
            
                validColor = new Color(0, 1, 0);    // Green for valid teleport
            
                invalidColor = new Color(1, 0, 0);   // Red for invalid teleport
            
                /** @type {Map<XrInputSource, { handleSelectStart: Function, handleSelectEnd: Function }>} */
                inputHandlers = new Map();
            
                initialize() {
                    if (!this.app.xr) {
                        console.error('XrNavigation script requires XR to be enabled on the application');
                        return;
                    }
            
                    this.app.xr.input.on('add', (inputSource) => {
                        const handleSelectStart = () => {
                            this.activePointers.set(inputSource, true);
                        };
            
                        const handleSelectEnd = () => {
                            this.activePointers.set(inputSource, false);
                            this.tryTeleport(inputSource);
                        };
            
                        // Attach the handlers
                        inputSource.on('selectstart', handleSelectStart);
                        inputSource.on('selectend', handleSelectEnd);
            
                        // Store the handlers in the map
                        this.inputHandlers.set(inputSource, { handleSelectStart, handleSelectEnd });
                        this.inputSources.add(inputSource);
                    });
            
                    this.app.xr.input.on('remove', (inputSource) => {
                        const handlers = this.inputHandlers.get(inputSource);
                        if (handlers) {
                            inputSource.off('selectstart', handlers.handleSelectStart);
                            inputSource.off('selectend', handlers.handleSelectEnd);
                            this.inputHandlers.delete(inputSource);
                        }
                        this.activePointers.delete(inputSource);
                        this.inputSources.delete(inputSource);
                    });
                }
            
                findPlaneIntersection(origin, direction) {
                    // Find intersection with y=0 plane
                    if (Math.abs(direction.y) < 0.00001) return null;  // Ray is parallel to plane
            
                    const t = -origin.y / direction.y;
                    if (t < 0) return null;  // Intersection is behind the ray
            
                    return new Vec3(
                        origin.x + direction.x * t,
                        0,
                        origin.z + direction.z * t
                    );
                }
            
                tryTeleport(inputSource) {
                    const origin = inputSource.getOrigin();
                    const direction = inputSource.getDirection();
            
                    const hitPoint = this.findPlaneIntersection(origin, direction);
                    if (hitPoint) {
                        const cameraY = this.entity.getPosition().y;
                        hitPoint.y = cameraY;
                        this.entity.setPosition(hitPoint);
                    }
                }
            
                update() {
                    for (const inputSource of this.inputSources) {
                        // Only show ray when trigger is pressed
                        if (!this.activePointers.get(inputSource)) continue;
            
                        const start = inputSource.getOrigin();
                        const direction = inputSource.getDirection();
            
                        const hitPoint = this.findPlaneIntersection(start, direction);
            
                        if (hitPoint) {
                            // Draw line to intersection point
                            this.app.drawLine(start, hitPoint, this.validColor);
                            this.drawTeleportIndicator(hitPoint);
                        } else {
                            // Draw full length ray if no intersection
                            const end = start.clone().add(
                                direction.clone().mulScalar(100)
                            );
                            this.app.drawLine(start, end, this.invalidColor);
                        }
                    }
                }
            
                drawTeleportIndicator(point) {
                    // Draw a circle at the teleport point
                    const segments = 32;
                    const radius = 0.2;
            
                    for (let i = 0; i < segments; i++) {
                        const angle1 = (i / segments) * Math.PI * 2;
                        const angle2 = ((i + 1) / segments) * Math.PI * 2;
            
                        const x1 = point.x + Math.cos(angle1) * radius;
                        const z1 = point.z + Math.sin(angle1) * radius;
                        const x2 = point.x + Math.cos(angle2) * radius;
                        const z2 = point.z + Math.sin(angle2) * radius;
            
                        this.app.drawLine(
                            new Vec3(x1, 0.01, z1),  // Slightly above ground to avoid z-fighting
                            new Vec3(x2, 0.01, z2),
                            this.validColor
                        );
                    }
                }
            }
            
            const lerp = (a, b, t) => a * (1 - t) + b * t;
            
            const damp = (damping, dt) => 1 - Math.pow(damping, dt * 1000);
            
            // modulo including negative numbers
            const mod = (n, m) => ((n % m) + m) % m;
            
            const x = new Vec3();
            const y = new Vec3();
            const z = new Vec3();
            
            class MyQuat extends Quat {
                dot(other) {
                    return this.x * other.x + this.y * other.y + this.z * other.z + this.w * other.w;
                }
            
                lerp(a, b, t) {
                    const omt = (1 - t) * (a.dot(b) < 0 ? -1 : 1);
                    this.x = a.x * omt + b.x * t;
                    this.y = a.y * omt + b.y * t;
                    this.z = a.z * omt + b.z * t;
                    this.w = a.w * omt + b.w * t;
                    return this.normalize();
                }
            
                // set a quaternion given an orthonormal basis
                fromBasis(x, y, z) {
                    const m00 = x.x;
                    const m01 = x.y;
                    const m02 = x.z;
                    const m10 = y.x;
                    const m11 = y.y;
                    const m12 = y.z;
                    const m20 = z.x;
                    const m21 = z.y;
                    const m22 = z.z;
            
                    if (m22 < 0) {
                        if (m00 > m11) {
                            this.set(1 + m00 - m11 - m22, m01 + m10, m20 + m02, m12 - m21);
                        } else {
                            this.set(m01 + m10, 1 - m00 + m11 - m22, m12 + m21, m20 - m02);
                        }
                    } else {
                        if (m00 < -m11) {
                            this.set(m20 + m02, m12 + m21, 1 - m00 - m11 + m22, m01 - m10);
                        } else {
                            this.set(m12 - m21, m20 - m02, m01 - m10, 1 + m00 + m11 + m22);
                        }
                    }
            
                    this.mulScalar(1.0 / this.length());
            
                    return this;
                }
            
                // set this quaternion to the rotation defined by a viewer
                // placed at position looking at target
                fromLookAt(position, target) {
                    z.sub2(position, target).normalize();
                    if (Math.abs(z.dot(Vec3.UP)) > 0.9999) {
                        x.cross(Vec3.RIGHT, z).normalize();
                    } else {
                        x.cross(Vec3.UP, z).normalize();
                    }
                    y.cross(z, x);
                    return this.fromBasis(x, y, z);
                }
            
                fromArray(array, offset = 0) {
                    this.x = array[offset];
                    this.y = array[offset + 1];
                    this.z = array[offset + 2];
                    return this;
                }
            
                toArray(array, offset = 0) {
                    array[offset] = this.x;
                    array[offset + 1] = this.y;
                    array[offset + 2] = this.z;
                    return array;
                }
            }
            
            class SmoothDamp {
                constructor(value, smoothTime = 0.05) {
                    this.dims = value.length;
                    this.value = value;
                    this.target = value.slice();
                    this.velocity = value.slice().fill(0);
                    this.smoothTime = smoothTime;
                }
            
                reset(newValue) {
                    const { dims, value, velocity } = this;
                    for (let i = 0; i < dims; i++) {
                        value[i] = newValue[i];
                        velocity[i] = 0;
                    }
                }
            
                update(dt) {
                    const { dims, value, target, velocity, smoothTime } = this;
            
                    const omega = 2 / smoothTime;
                    const x = omega * dt;
                    const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
            
                    for (let i = 0; i < dims; i++) {
                        const change = value[i] - target[i];
                        const temp = (velocity[i] + omega * change) * dt;
                        velocity[i] = (velocity[i] - omega * temp) * exp;
                        value[i] = target[i] + (change + temp) * exp;
                    }
                }
            }
            
            class CubicSpline {
                // control times
                times;
            
                // control data: in-tangent, point, out-tangent
                knots;
            
                // dimension of the knot points
                dim;
            
                constructor(times, knots) {
                    this.times = times;
                    this.knots = knots;
                    this.dim = knots.length / times.length / 3;
                }
            
                evaluate(time, result) {
                    const { times } = this;
                    const last = times.length - 1;
            
                    if (time <= times[0]) {
                        this.getKnot(0, result);
                    } else if (time >= times[last]) {
                        this.getKnot(last, result);
                    } else {
                        let seg = 0;
                        while (time >= times[seg + 1]) {
                            seg++;
                        }
                        return this.evaluateSegment(seg, (time - times[seg]) / (times[seg + 1] - times[seg]), result);
                    }
                }
            
                getKnot(index, result) {
                    const { knots, dim } = this;
                    const idx = index * 3 * dim;
                    for (let i = 0; i < dim; ++i) {
                        result[i] = knots[idx + i * 3 + 1];
                    }
                }
            
                // evaluate the spline segment at the given normalized time t
                evaluateSegment(segment, t, result) {
                    const { knots, dim } = this;
            
                    const t2 = t * t;
                    const twot = t + t;
                    const omt = 1 - t;
                    const omt2 = omt * omt;
            
                    let idx = segment * dim * 3;
                    for (let i = 0; i < dim; ++i) {
                        const p0 = knots[idx + 1];
                        const m0 = knots[idx + 2];
                        const m1 = knots[idx + dim * 3];
                        const p1 = knots[idx + dim * 3 + 1];
                        idx += 3;
            
                        result[i] =
                            p0 * ((1 + twot) * omt2) +
                            m0 * (t * omt2) +
                            p1 * (t2 * (3 - twot)) +
                            m1 * (t2 * (t - 1));
                    }
                }
            
                // create cubic spline data from a set of control points to be interpolated
                // times: time values for each control point
                // points: control point values to be interpolated (n dimensional)
                // tension: level of smoothness, 0 = smooth, 1 = linear interpolation
                static fromPoints(times, points, tension = 0) {
                    const dim = points.length / times.length;
                    const knots = new Array(times.length * dim * 3);
            
                    for (let i = 0; i < times.length; i++) {
                        const t = times[i];
            
                        for (let j = 0; j < dim; j++) {
                            const idx = i * dim + j;
                            const p = points[idx];
            
                            let tangent;
                            if (i === 0) {
                                tangent = (points[idx + dim] - p) / (times[i + 1] - t);
                            } else if (i === times.length - 1) {
                                tangent = (p - points[idx - dim]) / (t - times[i - 1]);
                            } else {
                                // finite difference tangents
                                tangent = 0.5 * ((points[idx + dim] - p) / (times[i + 1] - t) + (p - points[idx - dim]) / (t - times[i - 1]));
            
                                // cardinal spline tangents
                                // tangent = (points[idx + dim] - points[idx - dim]) / (times[i + 1] - times[i - 1]);
                            }
            
                            // apply tension
                            tangent *= (1.0 - tension);
            
                            knots[idx * 3] = tangent;
                            knots[idx * 3 + 1] = p;
                            knots[idx * 3 + 2] = tangent;
                        }
                    }
            
                    return new CubicSpline(times, knots);
                }
            
                // create a looping spline by duplicating animation points at the end and beginning
                static fromPointsLooping(length, times, points, tension) {
                    if (times.length < 2) {
                        return CubicSpline.fromPoints(times, points, tension);
                    }
            
                    const dim = points.length / times.length;
                    const newTimes = times.slice();
                    const newPoints = points.slice();
            
                    // append first two points
                    newTimes.push(length + times[0], length + times[1]);
                    newPoints.push(...points.slice(0, dim * 2));
            
                    // prepend last two points
                    newTimes.splice(0, 0, times[times.length - 2] - length, times[times.length - 1] - length);
                    newPoints.splice(0, 0, ...points.slice(points.length - dim * 2));
            
                    return CubicSpline.fromPoints(newTimes, newPoints, tension);
                }
            }
            
            const q$2 = new MyQuat();
            
            // track an animation cursor with support for looping and ping-pong modes
            class AnimCursor {
                duration = 0;
            
                loopMode = 'none';
            
                timer = 0;
            
                cursor = 0;
            
                constructor(duration, loopMode) {
                    this.reset(duration, loopMode);
                }
            
                update(deltaTime) {
                    // update animation timer
                    this.timer += deltaTime;
            
                    // update the track cursor
                    this.cursor += deltaTime;
            
                    if (this.cursor >= this.duration) {
                        switch (this.loopMode) {
                            case 'none': this.cursor = this.duration; break;
                            case 'repeat': this.cursor %= this.duration; break;
                            case 'pingpong': this.cursor %= (this.duration * 2); break;
                        }
                    }
                }
            
                reset(duration, loopMode) {
                    this.duration = duration;
                    this.loopMode = loopMode;
                    this.timer = 0;
                    this.cursor = 0;
                }
            
                set value(value) {
                    this.cursor = mod(value, this.duration);
                }
            
                get value() {
                    return this.cursor > this.duration ? this.duration - this.cursor : this.cursor;
                }
            }
            
            // Manage the state of a camera animation track
            class AnimCamera {
                spline;
            
                cursor = new AnimCursor();
            
                frameRate;
            
                result = [];
            
                position = new Vec3();
            
                target = new Vec3();
            
                rotateSpeed = 0.2;
            
                rotation = new Vec3();
            
                constructor(spline, duration, loopMode, frameRate) {
                    this.spline = spline;
                    this.cursor.reset(duration, loopMode);
                    this.frameRate = frameRate;
            
                    // initialize the camera to the start frame
                    this.update(0, null);
                }
            
                update(deltaTime, input) {
                    const { cursor, result, spline, frameRate, position, target, rotateSpeed, rotation } = this;
            
                    // update the animation cursor
                    cursor.update(deltaTime);
            
                    // evaluate the spline
                    spline.evaluate(cursor.value * frameRate, result);
            
                    if (result.every(isFinite)) {
                        position.set(result[0], result[1], result[2]);
                        target.set(result[3], result[4], result[5]);
                    }
            
                    // rotate
                    if (input?.rotate) {
                        if (input.rotate.events.indexOf('up') !== -1) {
                            // reset on up event`
                            rotation.set(0, 0, 0);
                        } else {
                            rotation.x = Math.max(-90, Math.min(90, rotation.x - input.rotate.value[1] * rotateSpeed));
                            rotation.y = Math.max(-180, Math.min(180, rotation.y - input.rotate.value[0] * rotateSpeed));
                        }
                    }
                }
            
                getPose(pose) {
                    const { position, target, rotation } = this;
            
                    pose.fromLookAt(position, target);
            
                    q$2.setFromAxisAngle(Vec3.RIGHT, rotation.x);
                    pose.rotation.mul2(pose.rotation, q$2);
            
                    q$2.setFromAxisAngle(Vec3.UP, rotation.y);
                    pose.rotation.mul2(q$2, pose.rotation);
                }
            
                // construct an animation from a settings track
                static fromTrack(track) {
                    const { keyframes, duration, frameRate, loopMode } = track;
                    const { times, values } = keyframes;
                    const { position, target } = values;
            
                    // construct the points array containing position and target
                    const points = [];
                    for (let i = 0; i < times.length; i++) {
                        points.push(position[i * 3], position[i * 3 + 1], position[i * 3 + 2]);
                        points.push(target[i * 3], target[i * 3 + 1], target[i * 3 + 2]);
                    }
            
                    const extra = (duration === times[times.length - 1] / frameRate) ? 1 : 0;
            
                    const spline = CubicSpline.fromPointsLooping((duration + extra) * frameRate, times, points, -1);
            
                    return new AnimCamera(spline, duration, loopMode, frameRate);
                }
            }
            
            const migrateAnimTrack = (track) => {
                if (!track.frameRate) {
                    const defaultFrameRate = 30;
            
                    track.frameRate = defaultFrameRate;
                    const times = track.keyframes.times;
                    for (let i = 0; i < times.length; i++) {
                        times[i] *= defaultFrameRate;
                    }
                }
            };
            
            const migrateSettings = (settings) => {
                settings.animTracks?.forEach((track) => {
                    migrateAnimTrack(track);
                });
                return settings;
            };
            
            const forward$1 = new Vec3();
            const right$1 = new Vec3();
            const up$1 = new Vec3();
            const v$3 = new Vec3();
            const q$1 = new MyQuat();
            
            class FlyCamera {
                position = new Vec3();
            
                rotation = new MyQuat();
            
                distance = 1;
            
                smoothPosition = new Vec3();
            
                smoothRotation = new MyQuat();
            
                moveSpeed = 0.1;
            
                rotateSpeed = 0.2;
            
                reset(pose, snap = true) {
                    this.position.copy(pose.position);
                    this.rotation.copy(pose.rotation);
                    this.distance = pose.distance;
                    if (snap) {
                        this.smoothPosition.copy(pose.position);
                        this.smoothRotation.copy(pose.rotation);
                    }
                }
            
                update(dt, input) {
                    if (input) {
                        this.move(input);
                    }
                    this.smooth(dt);
                }
            
                move(input) {
                    const { position, rotation, moveSpeed, rotateSpeed } = this;
            
                    // get camera vectors
                    rotation.transformVector(Vec3.FORWARD, forward$1);
                    rotation.transformVector(Vec3.RIGHT, right$1);
                    rotation.transformVector(Vec3.UP, up$1);
            
                    // move
                    v$3.copy(right$1).mulScalar(input.move.value[0] * moveSpeed);
                    position.add(v$3);
            
                    v$3.copy(up$1).mulScalar(input.move.value[2] * -moveSpeed);
                    position.add(v$3);
            
                    v$3.copy(forward$1).mulScalar(input.move.value[1] * -moveSpeed);
                    position.add(v$3);
            
                    // rotate
                    q$1.setFromAxisAngle(right$1, -input.rotate.value[1] * rotateSpeed);
                    rotation.mul2(q$1, rotation);
            
                    q$1.setFromAxisAngle(Vec3.UP, -input.rotate.value[0] * rotateSpeed);
                    rotation.mul2(q$1, rotation);
            
                    q$1.setFromAxisAngle(forward$1, -input.rotate.value[2] * rotateSpeed);
                    rotation.mul(q$1, rotation);
            
                    rotation.normalize();
                }
            
                smooth(dt) {
                    const weight = damp(0.98, dt);
                    this.smoothPosition.lerp(this.smoothPosition, this.position, weight);
                    this.smoothRotation.lerp(this.smoothRotation, this.rotation, weight);
                }
            
                getPose(pose) {
                    const { smoothPosition, smoothRotation, distance } = this;
                    pose.position.copy(smoothPosition);
                    pose.rotation.copy(smoothRotation);
                    pose.distance = distance;
                }
            }
            
            // stores the input deltas for 3 axes (x, y, z)
            class Input {
                constructor() {
                    this.value = [0, 0, 0];
                    this.events = [];
                }
            
                // helper to add to the input value
                add(x, y, z) {
                    this.value[0] += x;
                    this.value[1] += y;
                    this.value[2] += z;
                }
            
                update(dt) {
            
                }
            
                clear() {
                    this.value.fill(0);
                    this.events.splice(0);
                }
            }
            
            // additive input sums child inputs
            class AdditiveInput extends Input {
                constructor(...args) {
                    super();
                    this.inputs = args;
                }
            
                update(dt) {
                    const { inputs, value, events } = this;
                    inputs.forEach((input) => {
                        input.update?.(dt);
                        value[0] += input.value[0];
                        value[1] += input.value[1];
                        value[2] += input.value[2];
            
                        // sum events
                        events.push(...input.events);
                    });
                }
            
                clear() {
                    super.clear();
            
                    this.inputs.forEach(input => input.clear());
                }
            }
            
            // joystick sums input deltas based on stick position
            class Joystick extends Input {
                constructor() {
                    super();
                    this.stick = [0, 0, 0];
                }
            
                update(dt) {
                    const { value, stick } = this;
                    for (let i = 0; i < 3; ++i) {
                        value[i] += stick[i] * dt;
                    }
                }
            }
            
            // dampens a target value (usually a toggle value based on buttons) and maps it to a joystick axis
            class DampedJoystick extends Joystick {
                constructor() {
                    super();
                    this.target = [0, 0, 0];
                }
            
                update(dt) {
                    const { stick, target } = this;
                    const t = damp(0.98, dt);
                    for (let i = 0; i < 3; ++i) {
                        stick[i] = lerp(stick[i], target[i], t);
                        if (Math.abs(stick[i]) < 1e-3) {
                            stick[i] = 0;
                        }
                    }
                    super.update(dt);
                }
            }
            
            // tracks a touch input and adds to the input value
            class TouchInput extends Input {
                constructor() {
                    super();
                    this.id = null;
                    this.prev = [0, 0, 0];
                }
            
                down(id, x, y, z = 0) {
                    const { prev } = this;
                    this.id = id;
                    prev[0] = x;
                    prev[1] = y;
                    prev[2] = z;
                }
            
                move(x, y, z = 0) {
                    const { value, prev } = this;
                    value[0] += x - prev[0];
                    value[1] += y - prev[1];
                    value[2] += z - prev[2];
                    prev[0] = x;
                    prev[1] = y;
                    prev[2] = z;
                }
            
                up() {
                    this.id = null;
                }
            }
            
            // tracks a touch input and converts it to a joystick input
            class TouchJoystick extends Joystick {
                constructor() {
                    super();
                    this.id = null;
                    this.base = [0, 0, 0];
                }
            
                down(id, x, y, z = 0) {
                    const { base } = this;
                    this.id = id;
                    base[0] = x;
                    base[1] = y;
                    base[2] = z;
                }
            
                move(x, y, z = 0) {
                    const { base, stick } = this;
                    stick[0] = x - base[0];
                    stick[1] = y - base[1];
                    stick[2] = z - base[2];
                }
            
                up() {
                    const { stick } = this;
                    this.id = null;
                    stick[0] = 0;
                    stick[1] = 0;
                    stick[2] = 0;
                }
            }
            
            // track two touch inputs and convert them into 2 inputs
            class TouchController {
                constructor() {
                    const left = new TouchJoystick();
                    const right = new TouchInput();
            
                    const get = (id) => {
                        return id === left.id ? left : (id === right.id ? right : null);
                    };
            
                    this.pointerDown = (event, element) => {
                        const isLeft = event.clientX < element.getBoundingClientRect().width / 2;
                        const joy = isLeft ? (left.id === null && left) : (right.id === null && right);
            
                        if (joy) {
                            joy.down(event.pointerId, event.clientX, event.clientY);
                        }
            
                        if (isLeft) {
                            element.setPointerCapture(event.pointerId);
                        }
                    };
            
                    this.pointerMove = (event) => {
                        const joy = get(event.pointerId);
                        if (joy) {
                            joy.move(event.clientX, event.clientY);
                        }
                    };
            
                    this.pointerUp = (event, element) => {
                        const joy = get(event.pointerId);
                        if (joy) {
                            joy.up();
                            if (joy === left) {
                                element.releasePointerCapture(event.pointerId);
                            }
                        }
                    };
            
                    // public interface
                    this.left = left;
                    this.right = right;
                }
            }
            
            // track two touch inputs and convert into 3d input when both are active
            // x and y axis is two-touch translation
            // z axis is two-touch distance
            class TwoTouchInput extends Input {
                constructor(a, b) {
                    super();
            
                    this.a = a;
                    this.b = b;
            
                    this.active = false;
                    this.prev = [0, 0, 0];
                }
            
                update(dt) {
                    const { a, b } = this;
            
                    a.update(dt);
                    b.update(dt);
            
                    if (a.id && b.id) {
                        const { value, prev } = this;
                        const aprev = a.prev;
                        const bprev = b.prev;
            
                        const curX = (aprev[0] + bprev[0]) * 0.5;
                        const curY = (aprev[1] + bprev[1]) * 0.5;
                        const curZ = Math.sqrt(((aprev[0] - bprev[0]) ** 2) + ((aprev[1] - bprev[1]) ** 2));
            
                        if (!this.active) {
                            this.active = true;
                            prev[0] = curX;
                            prev[1] = curY;
                            prev[2] = curZ;
                        }
            
                        value[0] = curX - prev[0];
                        value[1] = curY - prev[1];
                        value[2] = -(curZ - prev[2]);
            
                        prev[0] = curX;
                        prev[1] = curY;
                        prev[2] = curZ;
            
                        // we've consumed the invividual inputs so clear them
                        a.clear();
                        b.clear();
                    } else {
                        this.active = false;
                    }
                }
            
                clear() {
                    super.clear();
            
                    const { a, b } = this;
                    a.clear();
                    b.clear();
                }
            }
            
            class OrbitTouchController {
                constructor() {
                    const first = new TouchInput();
                    const second = new TouchInput();
                    const twoTouch = new TwoTouchInput(first, second);
            
                    this.pointerDown = (event, element) => {
                        if (first.id === null) {
                            first.down(event.pointerId, event.clientX, event.clientY);
                            element.setPointerCapture(event.pointerId);
                        } else if (second.id === null) {
                            second.down(event.pointerId, event.clientX, event.clientY);
                            element.setPointerCapture(event.pointerId);
                        }
                    };
            
                    this.pointerMove = (event) => {
                        if (event.pointerId === first.id) {
                            first.move(event.clientX, event.clientY);
                        } else if (event.pointerId === second.id) {
                            second.move(event.clientX, event.clientY);
                        }
                    };
            
                    this.pointerUp = (event, element) => {
                        if (event.pointerId === first.id) {
                            first.up();
                            element.releasePointerCapture(event.pointerId);
                        } else if (event.pointerId === second.id) {
                            second.up();
                            element.releasePointerCapture(event.pointerId);
                        }
                    };
            
                    this.pointerCancel = this.pointerUp;
            
                    // public interface
                    this.left = twoTouch;
                    this.right = first;
                }
            }
            
            class MouseInput {
                constructor() {
                    this.prev = [0, 0, 0];
                    this.left = new Input();
                    this.middle = new Input();
                    this.right = new Input();
                }
            
                down(x, y, z = 0) {
                    const { prev } = this;
                    prev[0] = x;
                    prev[1] = y;
                    prev[2] = z;
                }
            
                move(buttons, x, y, z = 0) {
                    const { prev } = this;
                    const dx = x - prev[0];
                    const dy = y - prev[1];
                    const dz = z - prev[2];
                    prev[0] = x;
                    prev[1] = y;
                    prev[2] = z;
            
                    if (buttons === 1) this.left.add(dx, dy, dz);
                    else if (buttons === 2) this.right.add(dx, dy, dz);
                    else if (buttons === 4) this.middle.add(dx, dy, dz);
                }
            
                up() {
                    this.left.events.push('up');
                }
            
                clear() {
                    const { left, right, middle } = this;
                    left.clear();
                    right.clear();
                    middle.clear();
                }
            }
            
            // keyboard and mouse controller
            class DesktopController {
                constructor() {
                    const controls = {
                        left: false,
                        right: false,
                        forward: false,
                        backward: false,
                        up: false,
                        down: false,
                        lookleft: false,
                        lookright: false,
                        lookup: false,
                        lookdown: false
                    };
            
                    const keys = {
                        keyw: 'forward',
                        keya: 'left',
                        keys: 'backward',
                        keyd: 'right',
                        keyq: 'up',
                        keye: 'down',
                        arrowleft: 'lookleft',
                        arrowright: 'lookright',
                        arrowup: 'lookup',
                        arrowdown: 'lookdown'
                    };
            
                    const mouseInput = new MouseInput();
                    const leftKeys = new DampedJoystick();
                    const rightKeys = new DampedJoystick();
                    const left = new AdditiveInput(mouseInput.right, leftKeys);
                    const right = new AdditiveInput(mouseInput.left, rightKeys);
            
                    this.wheel = (event) => {
                        mouseInput.right.value[2] += event.deltaY * 0.1;
                        mouseInput.left.value[0] += event.deltaX;
                        event.preventDefault();
                    };
            
                    this.pointerDown = (event, element) => {
                        mouseInput.down(event.clientX, event.clientY);
                        element.setPointerCapture(event.pointerId);
                    };
            
                    this.pointerMove = (event) => {
                        mouseInput.move(event.buttons, event.clientX, event.clientY);
                    };
            
                    this.pointerUp = (event, element) => {
                        mouseInput.up();
                        element.releasePointerCapture(event.pointerId);
                    };
            
                    this.contextMenu = event => event.preventDefault();
            
                    const handleKey = (event, state) => {
            
                        // ignore all keys in combination with meta
                        if (event.metaKey && state) {
                            return;
                        }
            
                        const key = event.code.toLowerCase();
                        if (keys.hasOwnProperty(key)) {
                            event.stopPropagation();
                            event.preventDefault();
            
                            controls[keys[key]] = state;
            
                            const s = 300;
            
                            switch (keys[key]) {
                                case 'left':
                                case 'right':
                                    leftKeys.target[0] = (controls.left ? -300 : 0) + (controls.right ? s : 0);
                                    break;
                                case 'forward':
                                case 'backward':
                                    leftKeys.target[1] = (controls.forward ? -300 : 0) + (controls.backward ? s : 0);
                                    break;
                                case 'up':
                                case 'down':
                                    leftKeys.target[2] = (controls.up ? s : 0) + (controls.down ? -300 : 0);
                                    break;
                                case 'lookleft':
                                case 'lookright':
                                    rightKeys.target[0] = (controls.lookleft ? -300 : 0) + (controls.lookright ? s : 0);
                                    break;
                                case 'lookup':
                                case 'lookdown':
                                    rightKeys.target[1] = (controls.lookup ? -300 : 0) + (controls.lookdown ? s : 0);
                                    break;
                            }
                        }
                    };
            
                    this.keyDown = event => handleKey(event, true);
                    this.keyUp = event => handleKey(event, false);
            
                    this.left = left;
                    this.right = right;
                }
            }
            
            class AppController {
                constructor() {
                    this.touch = new TouchController();
                    this.orbit = new OrbitTouchController();
                    this.desktop = new DesktopController();
            
                    // final left and right inputs are the sum of supported possible inputs
                    this.left = new AdditiveInput(this.touch.left, this.orbit.left, this.desktop.left);
                    this.right = new AdditiveInput(this.touch.right, this.orbit.right, this.desktop.right);
            
                    this.update = (dt) => {
                        this.left.update(dt);
                        this.right.update(dt);
                    };
            
                    this.clear = () => {
                        this.left.clear();
                        this.right.clear();
                    };
                }
            }
            
            // creates an observer proxy object to wrap some target object. fires events when properties change.
            const observe = (events, target) => {
                const members = new Set(Object.keys(target));
            
                return new Proxy(target, {
                    set(target, property, value, receiver) {
                        // not allowed to set a new value on target
                        if (!members.has(property)) {
                            console.log('err');
                            return false;
                        }
            
                        // set and fire event if value changed
                        if (target[property] !== value) {
                            const prev = target[property];
                            target[property] = value;
                            events.fire(`${property}:changed`, value, prev);
                        }
            
                        return true;
                    }
                });
            };
            
            const forward = new Vec3();
            const right = new Vec3();
            const up = new Vec3();
            const v$2 = new Vec3();
            const q = new MyQuat();
            
            const radToDeg = 180 / Math.PI;
            
            class OrbitCamera {
                focus = new Vec3();
            
                rotation = new Vec3();
            
                distance = 1;
            
                smoothDamp = new SmoothDamp([0, 0, 0, 0, 0, 0, 1]);
            
                moveSpeed = 0.001;
            
                rotateSpeed = 0.16;
            
                distanceSpeed = 0.01;
            
                reset(pose, snap = true) {
                    pose.rotation.transformVector(Vec3.FORWARD, v$2);
                    v$2.normalize();
            
                    this.focus.copy(v$2).mulScalar(pose.distance).add(pose.position);
            
                    this.rotation.x = Math.asin(v$2.y) * radToDeg;
                    this.rotation.y = mod(Math.atan2(-v$2.x, -v$2.z) * radToDeg, 360);
                    this.rotation.z = 0;
            
                    this.distance = pose.distance;
            
                    if (snap) {
                        this.focus.toArray(this.smoothDamp.value, 0);
                        this.rotation.toArray(this.smoothDamp.value, 3);
                        this.smoothDamp.value[6] = pose.distance;
                    }
                }
            
                update(dt, input) {
                    if (input) {
                        this.move(input);
                    }
                    this.smooth(dt);
                }
            
                move(input) {
                    const { focus, rotation, moveSpeed, distanceSpeed, rotateSpeed } = this;
            
                    q.setFromEulerAngles(rotation);
            
                    // get camera vectors
                    q.transformVector(Vec3.FORWARD, forward);
                    q.transformVector(Vec3.RIGHT, right);
                    q.transformVector(Vec3.UP, up);
            
                    // focus point
                    v$2.copy(right).mulScalar(input.move.value[0] * -moveSpeed * this.distance);
                    focus.add(v$2);
            
                    v$2.copy(up).mulScalar(input.move.value[1] * moveSpeed * this.distance);
                    focus.add(v$2);
            
                    // distance
                    this.distance = Math.max(0.01, this.distance * (1 + input.move.value[2] * distanceSpeed));
            
                    // rotate
                    rotation.x = Math.max(-90, Math.min(90, rotation.x - input.rotate.value[1] * rotateSpeed));
                    rotation.y = mod(rotation.y - input.rotate.value[0] * rotateSpeed, 360);
                }
            
                smooth(dt) {
                    const { focus, rotation, smoothDamp } = this;
                    const { value, target } = smoothDamp;
            
                    // package latest target values
                    focus.toArray(target, 0);
                    rotation.toArray(target, 3);
                    target[6] = this.distance;
            
                    // ensure rotations wrap around correctly
                    value[3] = target[3] + mod((value[3] - target[3]) + 90, 180) - 90;
                    value[4] = target[4] + mod((value[4] - target[4]) + 180, 360) - 180;
            
                    // update
                    smoothDamp.update(dt);
                }
            
                getPose(pose) {
                    const { smoothDamp } = this;
                    const { value } = smoothDamp;
            
                    v$2.fromArray(value, 3);
                    pose.rotation.setFromEulerAngles(v$2);
                    pose.rotation.transformVector(Vec3.FORWARD, v$2);
                    pose.distance = value[6];
                    v$2.mulScalar(-pose.distance);
                    pose.position.fromArray(value).add(v$2);
                }
            }
            
            const float32 = new Float32Array(1);
            const uint8 = new Uint8Array(float32.buffer);
            const two = new Vec4(2, 2, 2, 1);
            const one = new Vec4(1, 1, 1, 0);
            
            class Picker {
                constructor(app, camera) {
                    this.app = app;
                    this.camera = camera;
                    this.picker = null;
                }
            
                async pick(x, y) {
                    const { app, camera } = this;
                    const { graphicsDevice } = app;
                    const { canvas } = graphicsDevice;
                    const width = canvas.clientWidth;
                    const height = canvas.clientHeight;
            
                    y = height - y - 1;
            
                    // construct picker on demand
                    if (!this.picker) {
                        this.picker = new Picker$1(this.app, width, height);
                    }
            
                    // render scene, read depth
                    const { picker } = this;
                    picker.resize(width, height);
                    picker.prepare(camera.camera, app.scene, [app.scene.layers.getLayerByName('World')]);
                    const pixels = await picker.renderTarget.colorBuffer.read(x, y, 1, 1, {
                        renderTarget: picker.renderTarget
                    });
            
                    for (let i = 0; i < 4; ++i) {
                        uint8[i] = pixels[i];
                    }
                    const depth = float32[0];
            
                    // 255, 255, 255, 255 === NaN
                    if (!isFinite(depth)) {
                        return null;
                    }
            
                    // clip space
                    const pos = new Vec4(x / width, y / height, depth, 1).mul(two).sub(one);
            
                    // homogeneous view space
                    camera.camera.projectionMatrix.clone().invert().transformVec4(pos, pos);
            
                    // perform perspective divide
                    pos.mulScalar(1.0 / pos.w);
            
                    // view to world space
                    const pos3 = new Vec3(pos.x, pos.y, pos.z);
                    camera.getWorldTransform().transformPoint(pos3, pos3);
            
                    return pos3;
                }
            }
            
            class PointerDevice {
                constructor(element) {
                    this.target = null;
            
                    element.addEventListener('wheel', (event) => {
                        this.target?.wheel?.(event, element);
                    }, { passive: false });
            
                    element.addEventListener('pointerdown', (event) => {
                        this.target?.pointerDown?.(event, element);
                    });
            
                    element.addEventListener('pointermove', (event) => {
                        this.target?.pointerMove?.(event, element);
                    });
            
                    element.addEventListener('pointerup', (event) => {
                        this.target?.pointerUp?.(event, element);
                    });
            
                    element.addEventListener('pointercancel', (event) => {
                        this.target?.pointerCancel?.(event, element);
                    });
            
                    element.addEventListener('contextmenu', (event) => {
                        this.target?.contextMenu?.(event, element);
                    });
            
                    window.addEventListener('keydown', (event) => {
                        this.target?.keyDown?.(event, window);
                    });
            
                    window.addEventListener('keyup', (event) => {
                        this.target?.keyUp?.(event, window);
                    });
                }
            }
            
            const v$1 = new Vec3();
            
            // stores a camera pose
            class Pose {
                constructor(other) {
                    this.position = new Vec3();
                    this.rotation = new MyQuat();
                    this.distance = 1;
                    if (other) {
                        this.copy(other);
                    }
                }
            
                copy(pose) {
                    this.position.copy(pose.position);
                    this.rotation.copy(pose.rotation);
                    this.distance = pose.distance;
                    return this;
                }
            
                lerp(a, b, t) {
                    this.position.lerp(a.position, b.position, t);
                    this.rotation.lerp(a.rotation, b.rotation, t);
                    this.distance = lerp(a.distance, b.distance, t);
                    return this;
                }
            
                fromLookAt(position, target) {
                    this.position.copy(position);
                    this.rotation.fromLookAt(position, target);
                    this.distance = position.distance(target);
                    return this;
                }
            
                calcTarget(target) {
                    this.rotation.transformVector(Vec3.FORWARD, v$1);
                    target.copy(v$1).mulScalar(this.distance).add(this.position);
                }
            }
            
            const url = new URL(location.href);
            
            // support overriding parameters by query param
            const paramOverrides = {};
            if (url.searchParams.has('noui')) paramOverrides.noui = true;
            if (url.searchParams.has('noanim')) paramOverrides.noanim = true;
            if (url.searchParams.has('poster')) paramOverrides.posterUrl = url.searchParams.get('poster');
            if (url.searchParams.has('skybox')) paramOverrides.skyboxUrl = url.searchParams.get('skybox');
            if (url.searchParams.has('ministats')) paramOverrides.ministats = true;
            
            // get experience parameters
            const params = {
                ...(window.sse?.params ?? {}),
                ...paramOverrides
            };
            
            const gsplatFS = /* glsl */ `
            
            #ifdef PICK_PASS
            vec4 packFloat(float depth) {
                uvec4 u = (uvec4(floatBitsToUint(depth)) >> uvec4(0u, 8u, 16u, 24u)) & 0xffu;
                return vec4(u) / 255.0;
            }
            #endif
            
            varying mediump vec2 gaussianUV;
            varying mediump vec4 gaussianColor;
            
            void main(void) {
                mediump float A = dot(gaussianUV, gaussianUV);
                if (A > 1.0) {
                    discard;
                }
            
                // evaluate alpha
                mediump float alpha = exp(-A * 4.0) * gaussianColor.a;
            
                #ifdef PICK_PASS
                    if (alpha < 0.1) {
                        discard;
                    }
                    gl_FragColor = packFloat(gl_FragCoord.z);
                #else
                    if (alpha < 1.0 / 255.0) {
                        discard;
                    }
            
                    #ifndef DITHER_NONE
                        opacityDither(alpha, id * 0.013);
                    #endif
            
                    gl_FragColor = vec4(gaussianColor.xyz * alpha, alpha);
                #endif
            }
            `;
            
            // render skybox as plain equirect
            shaderChunks.skyboxPS = shaderChunks.skyboxPS.replace('mapRoughnessUv(uv, mipLevel)', 'uv');
            
            const v = new Vec3();
            const pose = new Pose();
            
            class Viewer {
                constructor(app, entity, events, state, settings) {
                    const { background, camera } = settings;
                    const { graphicsDevice } = app;
            
                    this.app = app;
                    this.entity = entity;
                    this.events = events;
                    this.state = state;
                    this.settings = settings;
            
                    // disable auto render, we'll render only when camera changes
                    app.autoRender = false;
            
                    // apply camera animation settings
                    entity.camera.clearColor = new Color(background.color);
                    entity.camera.fov = camera.fov;
            
                    // handle horizontal fov on canvas resize
                    const updateHorizontalFov = () => {
                        this.entity.camera.horizontalFov = graphicsDevice.width > graphicsDevice.height;
                    };
                    graphicsDevice.on('resizecanvas', () => {
                        updateHorizontalFov();
                        app.renderNextFrame = true;
                    });
                    updateHorizontalFov();
            
                    // track camera changes
                    const prevProj = new Mat4();
                    const prevWorld = new Mat4();
            
                    app.on('framerender', () => {
                        const world = this.entity.getWorldTransform();
                        const proj = this.entity.camera.projectionMatrix;
                        const nearlyEquals = (a, b, epsilon = 1e-4) => {
                            return !a.some((v, i) => Math.abs(v - b[i]) >= epsilon);
                        };
            
                        if (params.ministats) {
                            app.renderNextFrame = true;
                        }
            
                        if (!app.autoRender && !app.renderNextFrame) {
                            if (!nearlyEquals(world.data, prevWorld.data) ||
                                !nearlyEquals(proj.data, prevProj.data)) {
                                app.renderNextFrame = true;
                            }
                        }
            
                        if (app.renderNextFrame) {
                            prevWorld.copy(world);
                            prevProj.copy(proj);
                        }
            
                        // suppress rendering till we're ready
                        if (!state.readyToRender) {
                            app.renderNextFrame = false;
                        }
                    });
            
                    events.on('hqMode:changed', (value) => {
                        graphicsDevice.maxPixelRatio = value ? window.devicePixelRatio : 1;
                        app.renderNextFrame = true;
                    });
                    graphicsDevice.maxPixelRatio = state.hqMode ? window.devicePixelRatio : 1;
            
                    // initialize the viewer after assets have finished loading
                    events.on('loaded', () => this.initialize());
                }
            
                // initialize the viewer once gsplat asset is finished loading (so we know its bound etc)
                initialize() {
                    const { app, entity, events, state, settings } = this;
            
                    // get the gsplat
                    const gsplat = app.root.findComponent('gsplat');
            
                    // calculate scene bounding box
                    const bbox = gsplat?.instance?.meshInstance?.aabb ?? new BoundingBox();
            
                    // override gsplat shader for picking
                    const { instance } = gsplat;
                    instance.createMaterial({
                        fragment: gsplatFS
                    });
            
                    // create an anim camera
                    const createAnimCamera = (initial, isObjectExperience) => {
                        const { animTracks, camera } = settings;
            
                        // extract the camera animation track from settings
                        if (animTracks?.length > 0 && camera.startAnim === 'animTrack') {
                            const track = animTracks.find(track => track.name === camera.animTrack);
                            if (track) {
                                return AnimCamera.fromTrack(track);
                            }
                        } else if (isObjectExperience) {
                            // create a slowly rotating animation around it
                            const keys = 12;
                            const duration = 20;
                            const times = new Array(keys).fill(0).map((_, i) => i / keys * duration);
                            const position = [];
                            const target = [];
            
                            const initialTarget = new Vec3();
                            initial.calcTarget(initialTarget);
            
                            const mat = new Mat4();
                            const vec = new Vec3();
                            const dif = new Vec3(
                                initial.position.x - initialTarget.x,
                                initial.position.y - initialTarget.y,
                                initial.position.z - initialTarget.z
                            );
            
                            for (let i = 0; i < keys; ++i) {
                                mat.setFromEulerAngles(0, -i / keys * 360, 0);
                                mat.transformPoint(dif, vec);
            
                                position.push(initialTarget.x + vec.x);
                                position.push(initialTarget.y + vec.y);
                                position.push(initialTarget.z + vec.z);
            
                                target.push(initialTarget.x);
                                target.push(initialTarget.y);
                                target.push(initialTarget.z);
                            }
            
                            // construct a simple rotation animation around an object
                            return AnimCamera.fromTrack({
                                name: 'rotate',
                                duration,
                                frameRate: 1,
                                target: 'camera',
                                loopMode: 'repeat',
                                interpolation: 'spline',
                                keyframes: {
                                    times,
                                    values: {
                                        position,
                                        target
                                    }
                                }
                            });
                        }
            
                        return null;
                    };
            
                    // calculate the orbit camera frame position
                    const framePose = (() => {
                        const sceneSize = bbox.halfExtents.length();
                        const distance = sceneSize / Math.sin(entity.camera.fov / 180 * Math.PI * 0.5);
                        return new Pose().fromLookAt(
                            new Vec3(2, 1, 2).normalize().mulScalar(distance).add(bbox.center),
                            bbox.center
                        );
                    })();
            
                    // calculate the orbit camera reset position
                    const resetPose = (() => {
                        const { position, target } = this.settings.camera;
                        return new Pose().fromLookAt(
                            new Vec3(position ?? [2, 1, 2]),
                            new Vec3(target ?? [0, 0, 0])
                        );
                    })();
            
                    // calculate the user camera start position (the pose we'll use if there is no animation)
                    const useReset = settings.camera.position || settings.camera.target || bbox.halfExtents.length() > 100;
                    const userStart = new Pose(useReset ? resetPose : framePose);
            
                    // if camera doesn't intersect the scene, assume it's an object we're
                    // viewing
                    const isObjectExperience = !bbox.containsPoint(userStart.position);
            
                    // create the cameras
                    const animCamera = createAnimCamera(userStart, isObjectExperience);
                    const orbitCamera = new OrbitCamera();
                    const flyCamera = new FlyCamera();
            
                    const getCamera = (cameraMode) => {
                        switch (cameraMode) {
                            case 'orbit': return orbitCamera;
                            case 'anim': return animCamera;
                            case 'fly': return flyCamera;
                        }
                    };
            
                    // set fly speed based on scene size, within reason
                    flyCamera.moveSpeed = Math.max(0.05, Math.min(1, bbox.halfExtents.length() * 0.0001));
            
                    // set the global animation flag
                    state.hasAnimation = !!animCamera;
                    state.animationDuration = animCamera ? animCamera.cursor.duration : 0;
                    state.cameraMode = animCamera ? 'anim' : 'orbit';
            
                    // this pose stores the current camera position. it will be blended/smoothed
                    // toward the current active camera
                    const activePose = new Pose();
            
                    // calculate the initial camera position, either userStart or animated
                    // camera start position
                    if (state.cameraMode === 'anim') {
                        animCamera.getPose(activePose);
                    } else {
                        activePose.copy(userStart);
                    }
            
                    // place all user cameras at the start position
                    orbitCamera.reset(activePose);
                    flyCamera.reset(activePose);
            
                    // create the pointer device
                    const pointerDevice = new PointerDevice(app.graphicsDevice.canvas);
                    const controller = new AppController();
            
                    // transition time between cameras
                    let transitionTimer = 0;
            
                    // the previous camera we're transitioning away from
                    const prevPose = new Pose();
                    let prevCamera = null;
                    let prevCameraMode = 'orbit';
            
                    // update the currently active controller
                    const assignController = () => {
                        switch (state.cameraMode) {
                            case 'orbit':
                                pointerDevice.target = state.inputMode === 'touch' ? controller.orbit : controller.desktop;
                                break;
                            case 'anim':
                                // for animated camera with lookaround, use the following:
                                // pointerDevice.target = state.inputMode === 'touch' ? controller.orbit : controller.desktop;
            
                                // no input to anim camera means no lookaround
                                pointerDevice.target = null;
                                break;
                            case 'fly':
                                pointerDevice.target = state.inputMode === 'touch' ? controller.touch : controller.desktop;
                                break;
                        }
                    };
            
                    assignController();
            
                    // handle input mode changing (once user interacts with the app input
                    // mode can switch to touch device)
                    events.on('inputMode:changed', (value, prev) => {
                        assignController();
                    });
            
                    // handle input events
                    events.on('inputEvent', (eventName, event) => {
                        const doReset = (pose) => {
                            if (state.cameraMode === 'anim') {
                                state.cameraMode = prevCameraMode;
                            }
            
                            if (state.cameraMode === 'orbit') {
                                orbitCamera.reset(pose, false);
                            } else if (state.cameraMode === 'fly') {
                                flyCamera.reset(pose, false);
                            }
                        };
            
                        switch (eventName) {
                            case 'frame':
                                doReset(framePose);
                                break;
                            case 'reset':
                                doReset(resetPose);
                                break;
                            case 'cancel':
                            case 'interrupt':
                                if (state.cameraMode === 'anim') {
                                    state.cameraMode = prevCameraMode;
                                }
                                break;
                        }
                    });
            
                    // application update
                    app.on('update', (deltaTime) => {
            
                        // in xr mode we leave the camera alone
                        if (app.xr.active) {
                            return;
                        }
            
                        // update input controller
                        controller.update(deltaTime);
            
                        // remap some desktop inputs based on camera mode
                        if (state.cameraMode === 'orbit') {
                            const { value } = controller.desktop.left.inputs[1];
                            controller.left.value[0] -= value[0] * 2;
                            controller.left.value[1] -= value[1] * 2;
                        } else if (state.cameraMode === 'fly') {
                            const { value } = controller.desktop.left.inputs[0];
                            controller.left.value[1] -= value[1];
                            controller.left.value[2] += value[1];
                        }
            
                        // update touch joystick UI
                        const touchJoystick = controller.touch.left;
                        if (touchJoystick.stick.every(v => v === 0)) {
                            events.fire('touchJoystickUpdate', null);
                        } else {
                            events.fire('touchJoystickUpdate', touchJoystick.base, touchJoystick.stick);
                        }
            
                        // update the active camera
                        const input = {
                            move: controller.left,
                            rotate: controller.right
                        };
            
                        // use dt of 0 if animation is paused
                        const dt = state.cameraMode === 'anim' ?
                            (state.animationPaused ? 0 : deltaTime * transitionTimer) :
                            deltaTime;
            
                        const activeCamera = getCamera(state.cameraMode);
                        activeCamera.update(dt, state.cameraMode !== 'anim' && input);
                        activeCamera.getPose(pose);
            
                        // controls have been consumed
                        controller.clear();
            
                        if (state.cameraMode === 'anim') {
                            state.animationTime = animCamera.cursor.value;
                        }
            
                        // blend camera smoothly during transitions
                        if (transitionTimer < 1) {
                            transitionTimer = Math.min(1, transitionTimer + deltaTime);
            
                            if (transitionTimer < 1 && prevCamera) {
                                const x = transitionTimer;
                                // ease out exponential
                                const norm = 1 - (2 ** -10);
                                const weight = (1 - (2 ** (-10 * x))) / norm;
                                pose.lerp(prevPose, pose, weight);
                            }
                        }
            
                        // snap camera
                        activePose.copy(pose);
            
                        // apply to camera
                        entity.setPosition(activePose.position);
                        entity.setRotation(activePose.rotation);
                    });
            
                    // handle camera mode switching
                    events.on('cameraMode:changed', (value, prev) => {
                        prevCameraMode = prev;
                        prevCamera = getCamera(prev);
                        prevCamera.getPose(prevPose);
            
                        switch (value) {
                            case 'orbit':
                            case 'fly':
                                getCamera(value).reset(pose);
                                break;
                        }
            
                        // reset camera transition timer
                        transitionTimer = 0;
            
                        // reassign controller
                        assignController();
                    });
            
                    events.on('setAnimationTime', (time) => {
                        if (animCamera) {
                            animCamera.cursor.value = time;
            
                            // switch to animation camera if we're not already there
                            if (state.cameraMode !== 'anim') {
                                state.cameraMode = 'anim';
                            }
                        }
                    });
            
                    // pick orbit camera focus point on double click
                    let picker = null;
                    events.on('inputEvent', async (eventName, event) => {
                        if (state.cameraMode === 'orbit' && eventName === 'dblclick') {
                            if (!picker) {
                                picker = new Picker(app, entity);
                            }
                            const result = await picker.pick(event.clientX, event.clientY);
                            if (result) {
                                // get the current pose
                                orbitCamera.getPose(pose);
                                pose.fromLookAt(pose.position, result);
                                orbitCamera.reset(pose, false);
                            }
                        }
                    });
            
                    // initialize the camera entity to initial position and kick off the
                    // first scene sort (which usually happens during render)
                    entity.setPosition(activePose.position);
                    entity.setRotation(activePose.rotation);
                    gsplat?.instance?.sort(entity);
            
                    // handle gsplat sort updates
                    gsplat?.instance?.sorter?.on('updated', () => {
                        // request frame render when sorting changes
                        app.renderNextFrame = true;
            
                        if (!state.readyToRender) {
                            // we're ready to render once the first sort has completed
                            state.readyToRender = true;
            
                            // wait for the first valid frame to complete rendering
                            const frameHandle = app.on('frameend', () => {
                                frameHandle.off();
            
                                events.fire('firstFrame');
            
                                // emit first frame event on window
                                window.firstFrame?.();
                            });
                        }
                    });
                }
            }
            
            // displays a blurry poster image which resolves to sharp during loading
            const initPoster = (url, events) => {
                const blur = progress => `blur(${Math.floor((100 - progress) * 0.4)}px)`;
            
                const element = document.getElementById('poster');
                element.style.backgroundImage = `url(${url})`;
                element.style.display = 'block';
                element.style.filter = blur(0);
            
                events.on('progress:changed', (progress) => {
                    element.style.filter = blur(progress);
                });
            
                events.on('firstFrame', () => {
                    element.style.display = 'none';
                });
            };
            
            // On entering/exiting AR, we need to set the camera clear color to transparent black
            const initXr = (app, cameraElement, state, events) => {
            
                // initialize ar/vr
                app.xr.on('available:immersive-ar', (available) => {
                    state.hasAR = available;
                });
                app.xr.on('available:immersive-vr', (available) => {
                    state.hasVR = available;
                });
            
                const parent = cameraElement.parentElement.entity;
                const camera = cameraElement.entity;
                const clearColor = new Color();
            
                const parentPosition = new Vec3();
                const parentRotation = new Quat();
                const cameraPosition = new Vec3();
                const cameraRotation = new Quat();
                const angles = new Vec3();
            
                parent.script.create(XrControllers);
                parent.script.create(XrNavigation);
            
                app.xr.on('start', () => {
                    app.autoRender = true;
            
                    // cache original camera rig positions and rotations
                    parentPosition.copy(parent.getPosition());
                    parentRotation.copy(parent.getRotation());
                    cameraPosition.copy(camera.getPosition());
                    cameraRotation.copy(camera.getRotation());
            
                    cameraRotation.getEulerAngles(angles);
            
                    // copy transform to parent to XR/VR mode starts in the right place
                    parent.setPosition(cameraPosition.x, 0, cameraPosition.z);
                    parent.setEulerAngles(0, angles.y, 0);
            
                    if (app.xr.type === 'immersive-ar') {
                        clearColor.copy(camera.camera.clearColor);
                        camera.camera.clearColor = new Color(0, 0, 0, 0);
                    }
                });
            
                app.xr.on('end', () => {
                    app.autoRender = false;
            
                    // restore camera to pre-XR state
                    parent.setPosition(parentPosition);
                    parent.setRotation(parentRotation);
                    camera.setPosition(cameraPosition);
                    camera.setRotation(cameraRotation);
            
                    if (app.xr.type === 'immersive-ar') {
                        camera.camera.clearColor = clearColor;
                    }
                });
            
                events.on('startAR', () => {
                    app.xr.start(app.root.findComponent('camera'), 'immersive-ar', 'local-floor');
                });
            
                events.on('startVR', () => {
                    app.xr.start(app.root.findComponent('camera'), 'immersive-vr', 'local-floor');
                });
            
                events.on('inputEvent', (event) => {
                    if (event === 'cancel' && app.xr.active) {
                        app.xr.end();
                    }
                });
            };
            
            const loadContent = (app) => {
                const { contentUrl, contents } = window.sse;
            
                const asset = new Asset('scene.compressed.ply', 'gsplat', {
                    url: contentUrl,
                    filename: 'scene.compressed.ply',
                    contents
                });
            
                asset.on('load', () => {
                    const entity = asset.resource.instantiate();
                    app.root.addChild(entity);
                });
            
                asset.on('error', (err) => {
                    console.log(err);
                });
            
                app.assets.add(asset);
                app.assets.load(asset);
            };
            
            document.addEventListener('DOMContentLoaded', async () => {
                const appElement = document.querySelector('pc-app');
                const app = (await appElement.ready()).app;
            
                loadContent(app);
            
                const cameraElement = await document.querySelector('pc-entity[name="camera"]').ready();
                const camera = cameraElement.entity;
                const settings = migrateSettings(await window.sse?.settings);
                const events = new EventHandler();
                const state = observe(events, {
                    readyToRender: false,       // don't render till this is set
                    hqMode: true,
                    progress: 0,
                    inputMode: 'desktop',       // desktop, touch
                    cameraMode: 'orbit',        // orbit, anim, fly
                    hasAnimation: false,
                    animationDuration: 0,
                    animationTime: 0,
                    animationPaused: params.noanim,
                    hasAR: app.xr.isAvailable('immersive-ar'),
                    hasVR: app.xr.isAvailable('immersive-vr'),
                    isFullscreen: false,
                    uiVisible: true
                });
            
                // Initialize the load-time poster
                if (params.posterUrl) {
                    initPoster(params.posterUrl, events);
                }
            
                // Initialize skybox
                if (params.skyboxUrl) {
                    const skyAsset = new Asset('skybox', 'texture', {
                        url: params.skyboxUrl
                    }, {
                        type: 'rgbp',
                        mipmaps: false,
                        addressu: 'repeat',
                        addressv: 'clamp'
                    });
            
                    skyAsset.on('load', () => {
                        app.scene.envAtlas = skyAsset.resource;
                    });
            
                    app.assets.add(skyAsset);
                    app.assets.load(skyAsset);
                }
            
                // construct ministats
                if (params.ministats) {
                    const miniStats = new MiniStats(app);
                    miniStats.position = 'topright';
                }
            
                // Initialize XR support
                initXr(app, cameraElement, state, events);
            
                // eslint-disable-next-line no-unused-vars
                new Viewer(app, camera, events, state, settings);
            
                // wait for gsplat asset to load before initializing the rest
                const assets = app.assets.filter(asset => asset.type === 'gsplat');
                if (assets.length > 0) {
                    const asset = assets[0];
            
                    asset.on('progress', (received, length) => {
                        state.progress = (Math.min(1, received / length) * 100).toFixed(0);
                    });
            
                    if (asset.loaded) {
                        events.fire('loaded', asset);
                    } else {
                        asset.on('load', () => {
                            events.fire('loaded', asset);
                        });
                    }
                }
            
                // Get button and info panel elements
                const dom = [
                    'ui',
                    'controlsWrap',
                    'arMode', 'vrMode',
                    'enterFullscreen', 'exitFullscreen',
                    'info', 'infoPanel', 'desktopTab', 'touchTab', 'desktopInfoPanel', 'touchInfoPanel',
                    'timelineContainer', 'handle', 'time',
                    'buttonContainer',
                    'play', 'pause',
                    'settings', 'settingsPanel',
                    'fly', 'orbit', 'cameraToggleHighlight',
                    'high', 'low', 'qualityToggleHighlight',
                    'reset', 'frame',
                    'loadingText', 'loadingBar',
                    'joystickBase', 'joystick'
                ].reduce((acc, id) => {
                    acc[id] = document.getElementById(id);
                    return acc;
                }, {});
            
                // Handle loading progress updates
                events.on('progress:changed', (progress) => {
                    dom.loadingText.textContent = `${progress}%`;
                    if (progress < 100) {
                        dom.loadingBar.style.backgroundImage = `linear-gradient(90deg, #F60 0%, #F60 ${progress}%, white ${progress}%, white 100%)`;
                    } else {
                        dom.loadingBar.style.backgroundImage = 'linear-gradient(90deg, #F60 0%, #F60 100%)';
                    }
                });
            
                // Hide loading bar once first frame is rendered
                events.on('firstFrame', () => {
                    document.getElementById('loadingWrap').classList.add('hidden');
                });
            
                // Fullscreen support
                const docRoot = document.documentElement;
                const hasFullscreenAPI = docRoot.requestFullscreen && document.exitFullscreen;
            
                const requestFullscreen = () => {
                    if (hasFullscreenAPI) {
                        docRoot.requestFullscreen();
                    } else {
                        window.parent.postMessage('requestFullscreen', '*');
                        state.isFullscreen = true;
                    }
                };
            
                const exitFullscreen = () => {
                    if (hasFullscreenAPI) {
                        document.exitFullscreen();
                    } else {
                        window.parent.postMessage('exitFullscreen', '*');
                        state.isFullscreen = false;
                    }
                };
            
                if (hasFullscreenAPI) {
                    document.addEventListener('fullscreenchange', () => {
                        state.isFullscreen = !!document.fullscreenElement;
                    });
                }
            
                dom.enterFullscreen.addEventListener('click', requestFullscreen);
                dom.exitFullscreen.addEventListener('click', exitFullscreen);
            
                // toggle fullscreen when user switches between landscape portrait
                // orientation
                screen?.orientation?.addEventListener('change', (event) => {
                    if (['landscape-primary', 'landscape-secondary'].includes(screen.orientation.type)) {
                        requestFullscreen();
                    } else {
                        exitFullscreen();
                    }
                });
            
                // update UI when fullscreen state changes
                events.on('isFullscreen:changed', (value) => {
                    dom.enterFullscreen.classList[value ? 'add' : 'remove']('hidden');
                    dom.exitFullscreen.classList[value ? 'remove' : 'add']('hidden');
                });
            
                // HQ mode
                dom.high.addEventListener('click', () => {
                    state.hqMode = true;
                });
                dom.low.addEventListener('click', () => {
                    state.hqMode = false;
                });
            
                const updateHQ = () => {
                    dom.qualityToggleHighlight.classList[state.hqMode ? 'add' : 'remove']('right');
                };
                events.on('hqMode:changed', (value) => {
                    updateHQ();
                });
                updateHQ();
            
                // AR/VR
                const arChanged = () => dom.arMode.classList[state.hasAR ? 'remove' : 'add']('hidden');
                const vrChanged = () => dom.vrMode.classList[state.hasVR ? 'remove' : 'add']('hidden');
            
                dom.arMode.addEventListener('click', () => events.fire('startAR'));
                dom.vrMode.addEventListener('click', () => events.fire('startVR'));
            
                events.on('hasAR:changed', arChanged);
                events.on('hasVR:changed', vrChanged);
            
                arChanged();
                vrChanged();
            
                // Info panel
                const updateInfoTab = (tab) => {
                    if (tab === 'desktop') {
                        dom.desktopTab.classList.add('active');
                        dom.touchTab.classList.remove('active');
                        dom.desktopInfoPanel.classList.remove('hidden');
                        dom.touchInfoPanel.classList.add('hidden');
                    } else {
                        dom.desktopTab.classList.remove('active');
                        dom.touchTab.classList.add('active');
                        dom.desktopInfoPanel.classList.add('hidden');
                        dom.touchInfoPanel.classList.remove('hidden');
                    }
                };
            
                dom.desktopTab.addEventListener('click', () => {
                    updateInfoTab('desktop');
                });
            
                dom.touchTab.addEventListener('click', () => {
                    updateInfoTab('touch');
                });
            
                dom.info.addEventListener('pointerup', () => {
                    updateInfoTab(state.inputMode);
                    dom.infoPanel.classList.toggle('hidden');
                });
            
                dom.infoPanel.addEventListener('pointerdown', () => {
                    dom.infoPanel.classList.add('hidden');
                });
            
                events.on('inputEvent', (event) => {
                    if (event === 'cancel') {
                        // close info panel on cancel
                        dom.infoPanel.classList.add('hidden');
                        dom.settingsPanel.classList.add('hidden');
            
                        // close fullscreen on cancel
                        if (state.isFullscreen) {
                            exitFullscreen();
                        }
                    } else if (event === 'interrupt') {
                        dom.settingsPanel.classList.add('hidden');
                    }
                });
            
                // fade ui controls after 5 seconds of inactivity
                events.on('uiVisible:changed', (value) => {
                    dom.controlsWrap.className = value ? 'faded-in' : 'faded-out';
                });
            
                // show the ui and start a timer to hide it again
                let uiTimeout = null;
                const showUI = () => {
                    if (uiTimeout) {
                        clearTimeout(uiTimeout);
                    }
                    state.uiVisible = true;
                    uiTimeout = setTimeout(() => {
                        uiTimeout = null;
                        state.uiVisible = false;
                    }, 4000);
                };
                showUI();
            
                events.on('inputEvent', showUI);
            
                // Animation controls
                events.on('hasAnimation:changed', (value, prev) => {
                    // Start and Stop animation
                    dom.play.addEventListener('click', () => {
                        state.cameraMode = 'anim';
                        state.animationPaused = false;
                    });
            
                    dom.pause.addEventListener('click', () => {
                        state.cameraMode = 'anim';
                        state.animationPaused = true;
                    });
            
                    const updatePlayPause = () => {
                        if (state.cameraMode !== 'anim' || state.animationPaused) {
                            dom.play.classList.remove('hidden');
                            dom.pause.classList.add('hidden');
                        } else {
                            dom.play.classList.add('hidden');
                            dom.pause.classList.remove('hidden');
                        }
            
                        if (state.cameraMode === 'anim') {
                            dom.timelineContainer.classList.remove('hidden');
                        } else {
                            dom.timelineContainer.classList.add('hidden');
                        }
                    };
            
                    // Update UI on animation changes
                    events.on('cameraMode:changed', updatePlayPause);
                    events.on('animationPaused:changed', updatePlayPause);
            
                    // Spacebar to play/pause
                    events.on('inputEvent', (eventName) => {
                        if (eventName === 'playPause') {
                            state.cameraMode = 'anim';
                            state.animationPaused = !state.animationPaused;
                        }
                    });
            
                    const updateSlider = () => {
                        dom.handle.style.left = `${state.animationTime / state.animationDuration * 100}%`;
                        dom.time.style.left = `${state.animationTime / state.animationDuration * 100}%`;
                        dom.time.innerText = `${state.animationTime.toFixed(1)}s`;
                    };
            
                    events.on('animationTime:changed', updateSlider);
                    events.on('animationLength:changed', updateSlider);
            
                    const handleScrub = (event) => {
                        const rect = dom.timelineContainer.getBoundingClientRect();
                        const t = Math.max(0, Math.min(rect.width - 1, event.clientX - rect.left)) / rect.width;
                        events.fire('setAnimationTime', state.animationDuration * t);
                    };
            
                    let paused = false;
                    let captured = false;
            
                    dom.timelineContainer.addEventListener('pointerdown', (event) => {
                        if (!captured) {
                            handleScrub(event);
                            dom.timelineContainer.setPointerCapture(event.pointerId);
                            dom.time.classList.remove('hidden');
                            paused = state.animationPaused;
                            state.animationPaused = true;
                            captured = true;
                        }
                    });
            
                    dom.timelineContainer.addEventListener('pointermove', (event) => {
                        if (captured) {
                            handleScrub(event);
                        }
                    });
            
                    dom.timelineContainer.addEventListener('pointerup', (event) => {
                        if (captured) {
                            dom.timelineContainer.releasePointerCapture(event.pointerId);
                            dom.time.classList.add('hidden');
                            state.animationPaused = paused;
                            captured = false;
                        }
                    });
                });
            
                // Camera mode UI
                const updateCameraMode = () => {
                    if (state.cameraMode === 'fly') {
                        dom.cameraToggleHighlight.classList.add('right');
                    } else {
                        dom.cameraToggleHighlight.classList.remove('right');
                    }
                };
                events.on('cameraMode:changed', updateCameraMode);
            
                dom.settings.addEventListener('click', () => {
                    dom.settingsPanel.classList.toggle('hidden');
                });
            
                dom.fly.addEventListener('click', () => {
                    state.cameraMode = 'fly';
                });
            
                dom.orbit.addEventListener('click', () => {
                    state.cameraMode = 'orbit';
                });
            
                dom.reset.addEventListener('click', (event) => {
                    events.fire('inputEvent', 'reset', event);
                });
            
                dom.frame.addEventListener('click', (event) => {
                    events.fire('inputEvent', 'frame', event);
                });
            
                // update UI based on touch joystick updates
                events.on('touchJoystickUpdate', (base, stick) => {
                    if (base === null) {
                        dom.joystickBase.classList.add('hidden');
                    } else {
                        v.set(stick[0], stick[1], 0).mulScalar(1 / 48);
                        if (v.length() > 1) {
                            v.normalize();
                        }
                        v.mulScalar(48);
            
                        dom.joystickBase.classList.remove('hidden');
                        dom.joystickBase.style.left = `${base[0]}px`;
                        dom.joystickBase.style.top = `${base[1]}px`;
                        dom.joystick.style.left = `${48 + v.x}px`;
                        dom.joystick.style.top = `${48 + v.y}px`;
                    }
                });
            
                // Hide UI
                if (params.noui) {
                    dom.ui.classList.add('hidden');
                }
            
                // Generate input events
            
                ['wheel', 'pointerdown', 'contextmenu', 'keydown'].forEach((eventName) => {
                    app.graphicsDevice.canvas.addEventListener(eventName, (event) => {
                        events.fire('inputEvent', 'interrupt', event);
                    });
                });
            
                app.graphicsDevice.canvas.addEventListener('pointermove', (event) => {
                    events.fire('inputEvent', 'interact', event);
                });
            
                // we must detect double taps manually because ios doesn't send dblclick events
                const lastTap = { time: 0, x: 0, y: 0 };
                app.graphicsDevice.canvas.addEventListener('pointerdown', (event) => {
                    const curTap = new Date().getTime();
                    const delay = Math.max(0, curTap - lastTap.time);
                    if (delay < 300 &&
                        Math.abs(event.clientX - lastTap.x) < 8 &&
                        Math.abs(event.clientY - lastTap.y) < 8) {
                        events.fire('inputEvent', 'dblclick', event);
                        lastTap.time = 0;
                    } else {
                        lastTap.time = curTap;
                        lastTap.x = event.clientX;
                        lastTap.y = event.clientY;
                    }
                });
            
                // update input mode based on pointer event
                ['pointerdown', 'pointermove'].forEach((eventName) => {
                    window.addEventListener(eventName, (event) => {
                        state.inputMode = event.pointerType === 'touch' ? 'touch' : 'desktop';
                    });
                });
            
                window.addEventListener('keydown', (event) => {
                    if (event.key === 'Escape') {
                        events.fire('inputEvent', 'cancel', event);
                    } else if (!event.ctrlKey && !event.altKey && !event.metaKey) {
                        switch (event.key) {
                            case 'f':
                                events.fire('inputEvent', 'frame', event);
                                break;
                            case 'r':
                                events.fire('inputEvent', 'reset', event);
                                break;
                            case ' ':
                                events.fire('inputEvent', 'playPause', event);
                                break;
                        }
                    }
                });
            });
            //# sourceMappingURL=index.js.map
            
        </script>
    </head>
    <body>
        <pc-app antialias="false" depth="false" high-resolution="true" stencil="false">
            <pc-scene>
                <!-- Camera (with XR support) -->
                <pc-entity name="camera root">
                    <pc-entity name="camera">
                        <pc-camera near-clip="0.001" far-clip="5000" horizontal-fov="true" tonemap="none"></pc-camera>
                    </pc-entity>
                    <!-- XR controllers will be added here -->
                    <pc-scripts>
                    </pc-scripts>
                </pc-entity>
                <!-- Light (for XR controllers) -->
                <pc-entity name="light" rotation="35 45 0">
                    <pc-light color="white" intensity="1.5"></pc-light>
                </pc-entity>
                <!-- Splat -->
                <pc-entity name="splat" rotation="0 0 180">
                </pc-entity>
            </pc-scene>
        </pc-app>

        <div id="ui">
            <div id="poster"></div>

            <!-- Loading Indicator -->
            <div id="loadingWrap">
                <div id="loadingText"></div>
                <div id="loadingBar"></div>
            </div>

            <div id="controlsWrap" class="faded-in">

                <!-- Timeline Panel -->
                <div id="timelineContainer" class="hidden">
                    <div id="line"></div>
                    <div id="handle"></div>
                    <div id="time" class="hidden">0:00</div>
                </div>

                <!-- Buttons Panel -->
                <div id="buttonContainer">
                    <button id="play" class="button hidden">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24px" height="24px" viewBox="4 4 16 16" fill="currentColor"><path d="M15 12.3301L9 16.6603L9 8L15 12.3301Z"/></svg>
                    </button>
                    <button id="pause" class="button hidden">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24px" height="24px" viewBox="0 0 20 20" fill="currentColor"><path d="M5 16V4h3v12H5zm7-12h3v12h-3V4z"/></svg>
                    </button>
                    <div class="spacer"></div>
                    <button id="arMode" class="button hidden">
                        <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M440-181 240-296q-19-11-29.5-29T200-365v-230q0-22 10.5-40t29.5-29l200-115q19-11 40-11t40 11l200 115q19 11 29.5 29t10.5 40v230q0 22-10.5 40T720-296L520-181q-19 11-40 11t-40-11Zm0-92v-184l-160-93v185l160 92Zm80 0 160-92v-185l-160 93v184ZM80-680v-120q0-33 23.5-56.5T160-880h120v80H160v120H80ZM280-80H160q-33 0-56.5-23.5T80-160v-120h80v120h120v80Zm400 0v-80h120v-120h80v120q0 33-23.5 56.5T800-80H680Zm120-600v-120H680v-80h120q33 0 56.5 23.5T880-800v120h-80ZM480-526l158-93-158-91-158 91 158 93Zm0 45Zm0-45Zm40 69Zm-80 0Z"/></svg>
                    </button>
                    <button id="vrMode" class="button hidden">
                        <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M300-240q-66 0-113-47t-47-113v-163q0-51 32-89.5t82-47.5q57-11 113-15.5t113-4.5q57 0 113.5 4.5T706-700q50 10 82 48t32 89v163q0 66-47 113t-113 47h-40q-13 0-26-1.5t-25-6.5l-64-22q-12-5-25-5t-25 5l-64 22q-12 5-25 6.5t-26 1.5h-40Zm0-80h40q7 0 13.5-1t12.5-3q29-9 56.5-19t57.5-10q30 0 58 9.5t56 19.5q6 2 12.5 3t13.5 1h40q33 0 56.5-23.5T740-400v-163q0-22-14-38t-35-21q-52-11-104.5-14.5T480-640q-54 0-106 4t-105 14q-21 4-35 20.5T220-563v163q0 33 23.5 56.5T300-320ZM40-400v-160h60v160H40Zm820 0v-160h60v160h-60Zm-380-80Z"/></svg>
                    </button>
                    <button id="info" class="button">
                        <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M440-280h80v-240h-80v240Zm40-320q17 0 28.5-11.5T520-640q0-17-11.5-28.5T480-680q-17 0-28.5 11.5T440-640q0 17 11.5 28.5T480-600Zm0 520q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z"/></svg>
                    </button>
                    <button id="settings" class="button">
                        <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M160-160q-33 0-56.5-23.5T80-240v-480q0-33 23.5-56.5T160-800h480q33 0 56.5 23.5T720-720v180l160-160v440L720-420v180q0 33-23.5 56.5T640-160H160Zm0-80h480v-480H160v480Zm0 0v-480 480Z"/></svg>
                    </button>
                    <button id="enterFullscreen" class="button">
                        <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M120-120v-200h80v120h120v80H120Zm520 0v-80h120v-120h80v200H640ZM120-640v-200h200v80H200v120h-80Zm640 0v-120H640v-80h200v200h-80Z"/></svg>
                    </button>
                    <button id="exitFullscreen" class="button hidden">
                        <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="currentColor"><path d="M240-120v-120H120v-80h200v200h-80Zm400 0v-200h200v80H720v120h-80ZM120-640v-80h120v-120h80v200H120Zm520 0v-200h80v120h120v80H640Z"/></svg>
                    </button>
                </div>
            </div>

            <!-- Settings Panel -->
            <div id="settingsPanel" class="hidden">
                <div>Camera Mode</div>
                <div id="cameraToggle" class="toggleWrap">
                    <div id="cameraToggleHighlight" class="toggleHighlight"></div>
                    <button id="orbit" class="left">Orbit</button>
                    <button id="fly" class="right">Fly</button>
                </div>
                <div>Render Quality</div>
                <div id="qualityToggle" class="toggleWrap">
                    <div id="qualityToggleHighlight" class="toggleHighlight"></div>
                    <button id="low" class="left">Low</button>
                    <button id="high" class="right">High</button>
                </div>
                <div>View</div>
                <div class="settingsRow">
                    <button id="frame" class="button">Frame</button>
                    <button id="reset" class="button">Reset</button>
                </div>
            </div>

            <!-- Info Panel -->
            <div id="infoPanel" class="hidden">
                <div id="infoPanelContent" onpointerdown="event.stopPropagation()">
                    <div id="header">Controls</div>
                    <div id="tabs">
                        <div id="desktopTab" class="tab active">Desktop</div>
                        <div id="touchTab" class="tab">Touch</div>
                    </div>
                    <div id="infoPanels">
                        <div id="desktopInfoPanel">
                            <div class="control-spacer"></div>
                            <h1>Orbit Mode</h1>
                            <div class="control-item">
                                <span class="control-action">Orbit</span>
                                <span class="control-key">Left Mouse</span>
                            </div>
                            <div class="control-item">
                                <span class="control-action">Pan</span>
                                <span class="control-key">Right Mouse</span>
                            </div>
                            <div class="control-item">
                                <span class="control-action">Zoom</span>
                                <span class="control-key">Mouse Wheel</span>
                            </div>
                            <div class="control-item">
                                <span class="control-action">Set Focus</span>
                                <span class="control-key">Double Click</span>
                            </div>
                            <div class="control-spacer"></div>
                            <h1>Fly Mode</h1>
                            <div class="control-item">
                                <span class="control-action">Look Around</span>
                                <span class="control-key">Left Mouse</span>
                            </div>
                            <div class="control-item">
                                <span class="control-action">Fly</span>
                                <span class="control-key">W,S,A,D</span>
                            </div>
                            <div class="control-spacer"></div>
                            <div class="control-item">
                                <span class="control-action">Frame Scene</span>
                                <span class="control-key">F</span>
                            </div>
                            <div class="control-item">
                                <span class="control-action">Reset Camera</span>
                                <span class="control-key">R</span>
                            </div>
                        </div>
                        <div id="touchInfoPanel" class="hidden">
                            <div class="control-spacer"></div>
                            <h1>Orbit Mode</h1>
                            <div class="control-item">
                                <span class="control-action">Orbit</span>
                                <span class="control-key">One Finger Drag</span>
                            </div>
                            <div class="control-item">
                                <span class="control-action">Pan</span>
                                <span class="control-key">Two Finger Drag</span>
                            </div>
                            <div class="control-item">
                                <span class="control-action">Zoom</span>
                                <span class="control-key">Pinch</span>
                            </div>
                            <div class="control-item">
                                <span class="control-action">Set Focus</span>
                                <span class="control-key">Double Tap</span>
                            </div>
                            <div class="control-spacer"></div>
                            <h1>Fly Mode</h1>
                            <div class="control-item">
                                <span class="control-action">Look Around</span>
                                <span class="control-key">Touch on Right</span>
                            </div>
                            <div class="control-item">
                                <span class="control-action">Fly</span>
                                <span class="control-key">Touch on Left</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Touch Joystick -->
            <div id="joystickBase" class="hidden">
                <div id="joystick"></div>
            </div>
        </div>
    </body>
</html>
